/*! jQuery v1.7.2 jquery.com | jquery.org/license */
(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f("<"+a+">").appendTo(b),e=d.css("display");d.remove();if(e==="none"||e===""){ck||(ck=c.createElement("iframe"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?"<!doctype html>":"")+"<html><body>"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,"display"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h=="string"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k==="*")k=l;else if(l!=="*"&&l!==k){m=l+" "+k,n=e[m]||e["* "+k];if(!n){p=b;for(o in e){j=o.split(" ");if(j[0]===l||j[0]==="*"){p=e[j[1]+" "+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error("No conversion from "+m.replace(" "," to ")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function ca(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]==="*")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader("content-type"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+" "+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function b_(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bD.test(a)?d(a,e):b_(a+"["+(typeof e=="object"?b:"")+"]",e,c,d)});else if(!c&&f.type(b)==="object")for(var e in b)b_(a+"["+e+"]",b[e],c,d);else d(a,b)}function b$(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bZ(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bS,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l=="string"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bZ(a,c,d,e,l,g)));(k||!l)&&!g["*"]&&(l=bZ(a,c,d,e,"*",g));return l}function bY(a){return function(b,c){typeof b!="string"&&(c=b,b="*");if(f.isFunction(c)){var d=b.toLowerCase().split(bO),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\+/.test(h),j&&(h=h.substr(1)||"*"),i=a[h]=a[h]||[],i[j?"unshift":"push"](c)}}}function bB(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=b==="width"?1:0,g=4;if(d>0){if(c!=="border")for(;e<g;e+=2)c||(d-=parseFloat(f.css(a,"padding"+bx[e]))||0),c==="margin"?d+=parseFloat(f.css(a,c+bx[e]))||0:d-=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0;return d+"px"}d=by(a,b);if(d<0||d==null)d=a.style[b];if(bt.test(d))return d;d=parseFloat(d)||0;if(c)for(;e<g;e+=2)d+=parseFloat(f.css(a,"padding"+bx[e]))||0,c!=="padding"&&(d+=parseFloat(f.css(a,"border"+bx[e]+"Width"))||0),c==="margin"&&(d+=parseFloat(f.css(a,c+bx[e]))||0);return d+"px"}function bo(a){var b=c.createElement("div");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||"").toLowerCase();b==="input"?bm(a):b!=="script"&&typeof a.getElementsByTagName!="undefined"&&f.grep(a.getElementsByTagName("input"),bm)}function bm(a){if(a.type==="checkbox"||a.type==="radio")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bk(a,b){var c;b.nodeType===1&&(b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c==="object"?b.outerHTML=a.outerHTML:c!=="input"||a.type!=="checkbox"&&a.type!=="radio"?c==="option"?b.selected=a.defaultSelected:c==="input"||c==="textarea"?b.defaultValue=a.defaultValue:c==="script"&&b.text!==a.text&&(b.text=a.text):(a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value)),b.removeAttribute(f.expando),b.removeAttribute("_submit_attached"),b.removeAttribute("_change_attached"))}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c,i[c][d])}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,"table")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function U(a){var b=V.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+"defer",e=b+"queue",g=b+"mark",h=f._data(a,d);h&&(c==="queue"||!f._data(a,e))&&(c==="mark"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b==="data"&&f.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(k,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:f.isNumeric(d)?+d:j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll("left")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.jQuery,g=a.$,h,i=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,j=/\S/,k=/^\s+/,l=/\s+$/,m=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,n=/^[\],:{}\s]*$/,o=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,q=/(?:^|:|,)(?:\s*\[)+/g,r=/(webkit)[ \/]([\w.]+)/,s=/(opera)(?:.*version)?[ \/]([\w.]+)/,t=/(msie) ([\w.]+)/,u=/(mozilla)(?:.*? rv:([\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+"").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a==="body"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a=="string"){a.charAt(0)!=="<"||a.charAt(a.length-1)!==">"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.jquery?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:"",jquery:"1.7.2",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),"slice",F.call(arguments).join(","))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i=="boolean"&&(l=i,i=arguments[1]||{},j=2),typeof i!="object"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.jQuery===e&&(a.jQuery=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger("ready").off("ready")}},bindReady:function(){if(!A){A=e.Callbacks("once memory");if(c.readyState==="complete")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener("DOMContentLoaded",B,!1),a.addEventListener("load",e.ready,!1);else if(c.attachEvent){c.attachEvent("onreadystatechange",B),a.attachEvent("onload",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)==="function"},isArray:Array.isArray||function(a){return e.type(a)==="array"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||"object"},isPlainObject:function(a){if(!a||e.type(a)!=="object"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,"constructor")&&!D.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!="string"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,"@").replace(p,"]").replace(q,"")))return(new Function("return "+b))();e.error("Invalid JSON: "+b)},parseXML:function(c){if(typeof c!="string"||!c)return null;var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&e.error("Invalid XML: "+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,"ms-").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?"":G.call(a)}:function(a){return a==null?"":(a+"").replace(k,"").replace(l,"")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d==="string"||d==="function"||d==="regexp"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length=="number")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j=="number"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c=="string"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h,i){var j,k=d==null,l=0,m=a.length;if(d&&typeof d=="object"){for(l in d)e.access(a,c,l,d[l],1,h,f);g=1}else if(f!==b){j=i===b&&e.isFunction(f),k&&(j?(j=c,c=function(a,b,c){return j.call(e(a),c)}):(c.call(a,f),c=null));if(c)for(;l<m;l++)c(a[l],d,j?f.call(a[l],l,c(a[l],d)):f,i);g=1}return g?a:k?c.call(a):m?c(a[0],d):h},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf("compatible")<0&&u.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){I["[object "+b+"]"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(" ")&&(k=/^[\s\xA0]+/,l=/[\s\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener("DOMContentLoaded",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState==="complete"&&(c.detachEvent("onreadystatechange",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m,n=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h==="array"?n(g):h==="function"&&(!a.unique||!p.has(g))&&c.push(g)},o=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,j=!0,m=k||0,k=0,l=c.length;for(;c&&m<l;m++)if(c[m].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}j=!1,c&&(a.once?e===!0?p.disable():c=[]:d&&d.length&&(e=d.shift(),p.fireWith(e[0],e[1])))},p={add:function(){if(c){var a=c.length;n(arguments),j?l=c.length:e&&e!==!0&&(k=a,o(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){j&&f<=l&&(l--,f<=m&&m--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&p.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(j?a.once||d.push([b,c]):(!a.once||!e)&&o(b,c));return this},fire:function(){p.fireWith(this,arguments);return this},fired:function(){return!!i}};return p};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks("once memory"),c=f.Callbacks("once memory"),d=f.Callbacks("memory"),e="pending",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,"resolve"],fail:[b,"reject"],progress:[c,"notify"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+"With"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+"With"]=g[j].fireWith;i.done(function(){e="resolved"},c.disable,d.lock).fail(function(){e="rejected"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p=c.createElement("div"),q=c.documentElement;p.setAttribute("className","t"),p.innerHTML="   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>",d=p.getElementsByTagName("*"),e=p.getElementsByTagName("a")[0];if(!d||!d.length||!e)return{};g=c.createElement("select"),h=g.appendChild(c.createElement("option")),i=p.getElementsByTagName("input")[0],b={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(e.getAttribute("style")),hrefNormalized:e.getAttribute("href")==="/a",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value==="on",optSelected:h.selected,getSetAttribute:p.className!=="t",enctype:!!c.createElement("form").enctype,html5Clone:c.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,pixelMargin:!0},f.boxModel=b.boxModel=c.compatMode==="CSS1Compat",i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete p.test}catch(r){b.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",function(){b.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick")),i=c.createElement("input"),i.value="t",i.setAttribute("type","radio"),b.radioValue=i.value==="t",i.setAttribute("checked","checked"),i.setAttribute("name","t"),p.appendChild(i),j=c.createDocumentFragment(),j.appendChild(p.lastChild),b.checkClone=j.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,j.removeChild(i),j.appendChild(p);if(p.attachEvent)for(n in{submit:1,change:1,focusin:1})m="on"+n,o=m in p,o||(p.setAttribute(m,"return;"),o=typeof p[m]=="function"),b[n+"Bubbles"]=o;j.removeChild(p),j=g=h=p=i=null,f(function(){var d,e,g,h,i,j,l,m,n,q,r,s,t,u=c.getElementsByTagName("body")[0];!u||(m=1,t="padding:0;margin:0;border:",r="position:absolute;top:0;left:0;width:1px;height:1px;",s=t+"0;visibility:hidden;",n="style='"+r+t+"5px solid #000;",q="<div "+n+"display:block;'><div style='"+t+"0;display:block;overflow:hidden;'></div></div>"+"<table "+n+"' cellpadding='0' cellspacing='0'>"+"<tr><td></td></tr></table>",d=c.createElement("div"),d.style.cssText=s+"width:0;height:0;position:static;top:0;margin-top:"+m+"px",u.insertBefore(d,u.firstChild),p=c.createElement("div"),d.appendChild(p),p.innerHTML="<table><tr><td style='"+t+"0;display:none'></td><td>t</td></tr></table>",k=p.getElementsByTagName("td"),o=k[0].offsetHeight===0,k[0].style.display="",k[1].style.display="none",b.reliableHiddenOffsets=o&&k[0].offsetHeight===0,a.getComputedStyle&&(p.innerHTML="",l=c.createElement("div"),l.style.width="0",l.style.marginRight="0",p.style.width="2px",p.appendChild(l),b.reliableMarginRight=(parseInt((a.getComputedStyle(l,null)||{marginRight:0}).marginRight,10)||0)===0),typeof p.style.zoom!="undefined"&&(p.innerHTML="",p.style.width=p.style.padding="1px",p.style.border=0,p.style.overflow="hidden",p.style.display="inline",p.style.zoom=1,b.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display="block",p.style.overflow="visible",p.innerHTML="<div style='width:5px;'></div>",b.shrinkWrapBlocks=p.offsetWidth!==3),p.style.cssText=r+s,p.innerHTML=q,e=p.firstChild,g=e.firstChild,i=e.nextSibling.firstChild.firstChild,j={doesNotAddBorder:g.offsetTop!==5,doesAddBorderForTableAndCells:i.offsetTop===5},g.style.position="fixed",g.style.top="20px",j.fixedPosition=g.offsetTop===20||g.offsetTop===15,g.style.position=g.style.top="",e.style.overflow="hidden",e.style.position="relative",j.subtractsBorderForOverflowNotVisible=g.offsetTop===-5,j.doesNotIncludeMarginInBodyOffset=u.offsetTop!==m,a.getComputedStyle&&(p.style.marginTop="1%",b.pixelMargin=(a.getComputedStyle(p,null)||{marginTop:0}).marginTop!=="1%"),typeof d.style.zoom!="undefined"&&(d.style.zoom=1),u.removeChild(d),l=p=d=null,f.extend(b,j))});return b}();var j=/^(?:\{.*\}|\[.*\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:"jQuery"+(f.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c=="string",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c==="events";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c=="object"||typeof c=="function")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute("classid")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h,i,j=this[0],k=0,m=null;if(a===b){if(this.length){m=f.data(j);if(j.nodeType===1&&!f._data(j,"parsedAttrs")){g=j.attributes;for(i=g.length;k<i;k++)h=g[k].name,h.indexOf("data-")===0&&(h=f.camelCase(h.substring(5)),l(j,h,m[h]));f._data(j,"parsedAttrs",!0)}}return m}if(typeof a=="object")return this.each(function(){f.data(this,a)});d=a.split(".",2),d[1]=d[1]?"."+d[1]:"",e=d[1]+"!";return f.access(this,function(c){if(c===b){m=this.triggerHandler("getData"+e,[d[0]]),m===b&&j&&(m=f.data(j,a),m=l(j,a,m));return m===b&&d[1]?this.data(d[0]):m}d[1]=c,this.each(function(){var b=f(this);b.triggerHandler("setData"+e,d),f.data(this,a,c),b.triggerHandler("changeData"+e,d)})},null,c,arguments.length>1,null,!1)},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||"fx")+"mark",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||"fx";var d=c+"mark",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,"mark"))}},queue:function(a,b,c){var d;if(a){b=(b||"fx")+"queue",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||"fx";var c=f.queue(a,b),d=c.shift(),e={};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),f._data(a,b+".run",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+"queue "+b+".run",!0),n(a,b,"queue"))}}),f.fn.extend({queue:function(a,c){var d=2;typeof a!="string"&&(c=a,a="fx",d--);if(arguments.length<d)return f.queue(this[0],a);return c===b?this:this.each(function(){var b=f.queue(this,a,c);a==="fx"&&b[0]!=="inprogress"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||"fx";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!="string"&&(c=a,a=b),a=a||"fx";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+"defer",j=a+"queue",k=a+"mark",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks("once memory"),!0))h++,l.add(m);m();return d.promise(c)}});var o=/[\n\t\r]/g,p=/\s+/,q=/\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,f.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,f.prop,a,b,arguments.length>1)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=" "+e.className+" ";for(h=0,i=b.length;h<i;h++)~g.indexOf(" "+b[h]+" ")||(g+=b[h]+" ");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(" "+g.className+" ").replace(o," ");for(i=0,j=c.length;i<j;i++)h=h.replace(" "+c[i]+" "," ");g.className=f.trim(h)}else g.className=""}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c==="string"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&f._data(this,"__className__",this.className),this.className=this.className||a===!1?"":f._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(o," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h="":typeof h=="number"?h+="":f.isArray(h)&&(h=f.map(h,function(a){return a==null?"":a+""})),c=f.valHooks[this.type]||f.valHooks[this.nodeName.toLowerCase()];if(!c||!("set"in c)||c.set(this,h,"value")===b)this.value=h}})}if(g){c=f.valHooks[g.type]||f.valHooks[g.nodeName.toLowerCase()];if(c&&"get"in c&&(d=c.get(g,"value"))!==b)return d;d=g.value;return typeof d=="string"?d.replace(q,""):d==null?"":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type==="select-one";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,"optgroup"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find("option").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute=="undefined")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&"set"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,""+d);return d}if(h&&"get"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h,i=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;i<g;i++)e=d[i],e&&(c=f.propFix[e]||e,h=u.test(e),h||f.attr(a,e,""),a.removeAttribute(v?e:c),h&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error("type property can't be changed");else if(!f.support.radioValue&&b==="radio"&&f.nodeName(a,"input")){var c=a.value;a.setAttribute("type",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,"button"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,"button"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&"set"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&"get"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0,coords:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!=="":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+""}},f.attrHooks.tabindex.set=w.set,f.each(["width","height"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===""){a.setAttribute(b,"auto");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===""&&(b="false"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each(["href","src","width","height"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype="encoding"),f.support.checkOn||f.each(["radio","checkbox"],function(){f.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),f.each(["radio","checkbox"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\.]*)?(?:\.(.+))?$/,B=/(?:^|\s)hover(\.\S+)?\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,G=function(
a){var b=F.exec(a);b&&(b[1]=(b[1]||"").toLowerCase(),b[3]=b[3]&&new RegExp("(?:^|\\s)"+b[3]+"(?:\\s|$)"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c["class"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,"mouseenter$1 mouseleave$1")};f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler,g=p.selector),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!="undefined"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(" ");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||"").split(".").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:g&&G(g),namespace:n.join(".")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent("on"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||"")).split(" ");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp("(^|\\.)"+l.split(".").sort().join("\\.(?:.*\\.)?")+"(\\.|$)"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d==="**"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,["events","handle"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf("!")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(".")>=0&&(i=h.split("."),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c=="object"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+i.join("\\.(?:.*\\.)?")+"(\\.|$)"):null,o=h.indexOf(":")<0?"on"+h:"";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,"events")||{})[c.type]&&f._data(m,"handle"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!=="click"||!f.nodeName(e,"a"))&&f.acceptData(e)&&o&&e[h]&&(h!=="focus"&&h!=="blur"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,"events")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=f.event.special[c.type]||{},j=[],k,l,m,n,o,p,q,r,s,t,u;g[0]=c,c.delegateTarget=this;if(!i.preDispatch||i.preDispatch.call(this,c)!==!1){if(e&&(!c.button||c.type!=="click")){n=f(this),n.context=this.ownerDocument||this;for(m=c.target;m!=this;m=m.parentNode||this)if(m.disabled!==!0){p={},r=[],n[0]=m;for(k=0;k<e;k++)s=d[k],t=s.selector,p[t]===b&&(p[t]=s.quick?H(m,s.quick):n.is(t)),p[t]&&r.push(s);r.length&&j.push({elem:m,matches:r})}}d.length>e&&j.push({elem:this,matches:d.slice(e)});for(k=0;k<j.length&&!c.isPropagationStopped();k++){q=j[k],c.currentTarget=q.elem;for(l=0;l<q.matches.length&&!c.isImmediatePropagationStopped();l++){s=q.matches[l];if(h||!c.namespace&&!s.namespace||c.namespace_re&&c.namespace_re.test(s.namespace))c.data=s.data,c.handleObj=s,o=((f.event.special[s.origType]||{}).handle||s.handler).apply(q.elem,g),o!==b&&(c.result=o,o===!1&&(c.preventDefault(),c.stopPropagation()))}}i.postDispatch&&i.postDispatch.call(this,c);return c.result}},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent("on"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,"form"))return!1;f.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=f.nodeName(c,"input")||f.nodeName(c,"button")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,"submit._submit",function(a){a._submit_bubble=!0}),d._submit_attached=!0)})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&f.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){if(f.nodeName(this,"form"))return!1;f.event.remove(this,"._submit")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")f.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),f.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate("change",this,a,!0))});return!1}f.event.add(this,"beforeactivate._change",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate("change",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,"._change");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:"focusin",blur:"focusout"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a=="object"){typeof c!="string"&&(d=d||c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.origType+"."+e.namespace:e.origType,e.selector,e.handler);return this}if(typeof a=="object"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c=="function")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||"**",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,"lastToggle"+a.guid)||0)%d;f._data(this,"lastToggle"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!="string"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,d="sizcache"+(Math.random()+"").replace(".",""),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\/g,k=/\r\n/g,l=/\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!="string")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(""),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]==="~"||w[0]==="+")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q="",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)==="[object Array]")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!=="\\"){g[1]=(g[1]||"").replace(j,""),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],"");break}}}}d||(d=typeof b.getElementsByTagName!="undefined"?b.getElementsByTagName("*"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)==="\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],"");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e="";if(d){if(d===1||d===9||d===11){if(typeof a.textContent=="string")return a.textContent;if(typeof a.innerText=="string")return a.innerText.replace(k,"");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(a){return a.getAttribute("href")},type:function(a){return a.getAttribute("type")}},relative:{"+":function(a,b){var c=typeof b=="string",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},">":function(a,b){var c,d=typeof b=="string",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},"":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("parentNode",b,f,a,d,c)},"~":function(a,b,c){var d,f=e++,g=x;typeof b=="string"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g("previousSibling",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!="undefined"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!="undefined"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute("name")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!="undefined")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=" "+a[1].replace(j,"")+" ";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(" "+h.className+" ").replace(/[\t\n\r]/g," ").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,"")},TAG:function(a,b){return a[1].replace(j,"").toLowerCase()},CHILD:function(a){if(a[1]==="nth"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\+|\s*/g,"");var b=/(-?)(\d*)(?:n([+\-]?\d*))?/.exec(a[2]==="even"&&"2n"||a[2]==="odd"&&"2n+1"||!/\D/.test(a[2])&&"0n+"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,"");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||"").replace(j,""),a[2]==="~="&&(a[4]=" "+a[4]+" ");return a},PSEUDO:function(b,c,d,e,f){if(b[1]==="not")if((a.exec(b[3])||"").length>1||/^\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!=="hidden"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute("type"),c=a.type;return a.nodeName.toLowerCase()==="input"&&"text"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()==="input"&&"radio"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()==="input"&&"checkbox"===a.type},file:function(a){return a.nodeName.toLowerCase()==="input"&&"file"===a.type},password:function(a){return a.nodeName.toLowerCase()==="input"&&"password"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"submit"===a.type},image:function(a){return a.nodeName.toLowerCase()==="input"&&"image"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b==="input"||b==="button")&&"reset"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&"button"===a.type||b==="button"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e==="contains")return(a.textContent||a.innerText||n([a])||"").indexOf(b[3])>=0;if(e==="not"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case"only":case"first":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k==="first")return!0;l=a;case"last":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case"nth":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute("id")===b},TAG:function(a,b){return b==="*"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(" "+(a.className||a.getAttribute("class"))+" ").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+"",f=b[2],g=b[4];return d==null?f==="!=":!f&&m.attr?d!=null:f==="="?e===g:f==="*="?e.indexOf(g)>=0:f==="~="?(" "+e+" ").indexOf(g)>=0:g?f==="!="?e!==g:f==="^="?e.indexOf(g)===0:f==="$="?e.substr(e.length-g.length)===g:f==="|="?e===g||e.substr(0,g.length+1)===g+"-":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return"\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\[]*\])(?![^\(]*\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[r].source.replace(/\\(\d+)/g,q));o.match.globalPOS=p;var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)==="[object Array]")Array.prototype.push.apply(d,a);else if(typeof a.length=="number")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement("div"),d="script"+(new Date).getTime(),e=c.documentElement;a.innerHTML="<a name='"+d+"'/>",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!="undefined"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!="undefined"&&e.getAttributeNode("id").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!="undefined"&&a.getAttributeNode("id");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement("div");a.appendChild(c.createComment("")),a.getElementsByTagName("*").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]==="*"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!="undefined"&&a.firstChild.getAttribute("href")!=="#"&&(o.attrHandle.href=function(a){return a.getAttribute("href",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement("div"),d="__sizzle__";b.innerHTML="<p class='TEST'></p>";if(!b.querySelectorAll||b.querySelectorAll(".TEST").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b==="body"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!=="object"){var k=e,l=e.getAttribute("id"),n=l||d,p=e.parentNode,q=/^\s*[+~]/.test(b);l?n=n.replace(/'/g,"\\$&"):e.setAttribute("id",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll("[id='"+n+"'] "+b),f)}catch(r){}finally{l||k.removeAttribute("id")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement("div"),"div"),e=!1;try{b.call(c.documentElement,"[test!='']:sizzle")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement("div");a.innerHTML="<div class='test e'></div><div class='test'></div>";if(!!a.getElementsByClassName&&a.getElementsByClassName("e").length!==0){a.lastChild.className="e";if(a.getElementsByClassName("e").length===1)return;o.order.splice(1,0,"CLASS"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!="undefined"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!=="HTML":!1};var y=function(a,b,c){var d,e=[],f="",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,"");a=o.relative[a]?a+"*":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[":"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\[\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.globalPOS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!="string")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack("","find",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),"not",a)},filter:function(a){return this.pushStack(T(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!="string"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,"closest",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a=="string")return f.inArray(this[0],f(a));return f.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var c=typeof a=="string"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,"parentNode")},parentsUntil:function(a,b,c){return f.dir(a,"parentNode",c)},next:function(a){return f.nth(a,2,"nextSibling")},prev:function(a){return f.nth(a,2,"previousSibling")},nextAll:function(a){return f.dir(a,"nextSibling")},prevAll:function(a){return f.dir(a,"previousSibling")},nextUntil:function(a,b,c){return f.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return f.dir(a,"previousSibling",c)},siblings:function(a){return f.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d=="string"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(","))}}),f.extend({filter:function(a,b,c){c&&(a=":not("+a+")");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",W=/ jQuery\d+="(?:\d+|null)"/g,X=/^\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Z=/<([\w:]+)/,$=/<tbody/i,_=/<|&#?\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp("<(?:"+V+")[\\s/>]","i"),bd=/checked\s*(?:[^=]|=\s*.checked.)/i,be=/\/(java|ecma)script/i,bf=/^\s*<!(?:\[CDATA\[|\-\-)/,bg={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,"div<div>","</div>"]),f.fn.extend({text:function(a){return f.access(this,function(a){return a===b?f.text(this):this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,"body")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f
.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName("*")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName("*"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){return f.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(W,""):null;if(typeof a=="string"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Y,"<$1></$2>");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(f.cleanData(c.getElementsByTagName("*")),c.innerHTML=a);c=0}catch(g){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!="string"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),"replaceWith",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j=="string"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,"tr");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,function(a,b){b.src?f.ajax({type:"GET",global:!1,url:b.src,async:!1,dataType:"script"}):f.globalEval((b.text||b.textContent||b.innerHTML||"").replace(bf,"/*$0*/")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j=="string"&&j.length<512&&i===c&&j.charAt(0)==="<"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||f.isXMLDoc(a)||!bc.test("<"+a.nodeName+">")?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g,h,i,j=[];b=b||c,typeof b.createElement=="undefined"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);for(var k=0,l;(l=a[k])!=null;k++){typeof l=="number"&&(l+="");if(!l)continue;if(typeof l=="string")if(!_.test(l))l=b.createTextNode(l);else{l=l.replace(Y,"<$1></$2>");var m=(Z.exec(l)||["",""])[1].toLowerCase(),n=bg[m]||bg._default,o=n[0],p=b.createElement("div"),q=bh.childNodes,r;b===c?bh.appendChild(p):U(b).appendChild(p),p.innerHTML=n[1]+l+n[2];while(o--)p=p.lastChild;if(!f.support.tbody){var s=$.test(l),t=m==="table"&&!s?p.firstChild&&p.firstChild.childNodes:n[1]==="<table>"&&!s?p.childNodes:[];for(i=t.length-1;i>=0;--i)f.nodeName(t[i],"tbody")&&!t[i].childNodes.length&&t[i].parentNode.removeChild(t[i])}!f.support.leadingWhitespace&&X.test(l)&&p.insertBefore(b.createTextNode(X.exec(l)[0]),p.firstChild),l=p.childNodes,p&&(p.parentNode.removeChild(p),q.length>0&&(r=q[q.length-1],r&&r.parentNode&&r.parentNode.removeChild(r)))}var u;if(!f.support.appendChecked)if(l[0]&&typeof (u=l.length)=="number")for(i=0;i<u;i++)bn(l[i]);else bn(l);l.nodeType?j.push(l):j=f.merge(j,l)}if(d){g=function(a){return!a.type||be.test(a.type)};for(k=0;j[k];k++){h=j[k];if(e&&f.nodeName(h,"script")&&(!h.type||be.test(h.type)))e.push(h.parentNode?h.parentNode.removeChild(h):h);else{if(h.nodeType===1){var v=f.grep(h.getElementsByTagName("script"),g);j.splice.apply(j,[k+1,0].concat(v))}d.appendChild(h)}}}return j},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bp=/alpha\([^)]*\)/i,bq=/opacity=([^)]*)/,br=/([A-Z]|^ms)/g,bs=/^[\-+]?(?:\d*\.)?\d+$/i,bt=/^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,bu=/^([\-+])=([\-+.\de]+)/,bv=/^margin/,bw={position:"absolute",visibility:"hidden",display:"block"},bx=["Top","Right","Bottom","Left"],by,bz,bA;f.fn.css=function(a,c){return f.access(this,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)},a,c,arguments.length>1)},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=by(a,"opacity");return c===""?"1":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":f.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&"get"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h==="string"&&(g=bu.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h="number");if(d==null||h==="number"&&isNaN(d))return;h==="number"&&!f.cssNumber[i]&&(d+="px");if(!k||!("set"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c==="cssFloat"&&(c="float");if(g&&"get"in g&&(e=g.get(a,!0,d))!==b)return e;if(by)return by(a,c)},swap:function(a,b,c){var d={},e,f;for(f in b)d[f]=a.style[f],a.style[f]=b[f];e=c.call(a);for(f in b)a.style[f]=d[f];return e}}),f.curCSS=f.css,c.defaultView&&c.defaultView.getComputedStyle&&(bz=function(a,b){var c,d,e,g,h=a.style;b=b.replace(br,"-$1").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===""&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b))),!f.support.pixelMargin&&e&&bv.test(b)&&bt.test(c)&&(g=h.width,h.width=c,c=e.width,h.width=g);return c}),c.documentElement.currentStyle&&(bA=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f==null&&g&&(e=g[b])&&(f=e),bt.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b==="fontSize"?"1em":f,f=g.pixelLeft+"px",g.left=c,d&&(a.runtimeStyle.left=d));return f===""?"auto":f}),by=bz||bA,f.each(["height","width"],function(a,b){f.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0?bB(a,b,d):f.swap(a,bw,function(){return bB(a,b,d)})},set:function(a,b){return bs.test(b)?b+"px":b}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bq.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?"alpha(opacity="+b*100+")":"",g=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&f.trim(g.replace(bp,""))===""){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bp.test(g)?g.replace(bp,e):g+" "+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){return f.swap(a,{display:"inline-block"},function(){return b?by(a,"margin-right"):a.style.marginRight})}})}),f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,"display"))==="none"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)}),f.each({margin:"",padding:"",border:"Width"},function(a,b){f.cssHooks[a+b]={expand:function(c){var d,e=typeof c=="string"?c.split(" "):[c],f={};for(d=0;d<4;d++)f[a+bx[d]+b]=e[d]||e[d-2]||e[0];return f}}});var bC=/%20/g,bD=/\[\]$/,bE=/\r?\n/g,bF=/#.*$/,bG=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,bH=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bI=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,bJ=/^(?:GET|HEAD)$/,bK=/^\/\//,bL=/\?/,bM=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bN=/^(?:select|textarea)/i,bO=/\s+/,bP=/([?&])_=[^&]*/,bQ=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,bR=f.fn.load,bS={},bT={},bU,bV,bW=["*/"]+["*"];try{bU=e.href}catch(bX){bU=c.createElement("a"),bU.href="",bU=bU.href}bV=bQ.exec(bU.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!="string"&&bR)return bR.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h="GET";c&&(f.isFunction(c)?(d=c,c=b):typeof c=="object"&&(c=f.param(c,f.ajaxSettings.traditional),h="POST"));var i=this;f.ajax({url:a,type:h,dataType:"html",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f("<div>").append(c.replace(bM,"")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bN.test(this.nodeName)||bH.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bE,"\r\n")}}):{name:b.name,value:c.replace(bE,"\r\n")}}).get()}}),f.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each(["get","post"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,"script")},getJSON:function(a,b,c){return f.get(a,b,c,"json")},ajaxSetup:function(a,b){b?b$(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b$(a,b);return a},ajaxSettings:{url:bU,isLocal:bI.test(bV[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":bW},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":f.parseJSON,"text xml":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bY(bS),ajaxTransport:bY(bT),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||"",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?ca(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader("Last-Modified"))f.lastModified[k]=y;if(z=v.getResponseHeader("Etag"))f.etag[k]=z}if(a===304)w="notmodified",o=!0;else try{r=cb(d,x),w="success",o=!0}catch(A){w="parsererror",u=A}}else{u=w;if(!w||a)w="error",a<0&&(a=0)}v.status=a,v.statusText=""+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger("ajax"+(o?"Success":"Error"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger("ajaxComplete",[v,d]),--f.active||f.event.trigger("ajaxStop"))}}typeof a=="object"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks("once memory"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bG.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||"abort",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+"").replace(bF,"").replace(bK,bV[1]+"//"),d.dataTypes=f.trim(d.dataType||"*").toLowerCase().split(bO),d.crossDomain==null&&(r=bQ.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bV[1]&&r[2]==bV[2]&&(r[3]||(r[1]==="http:"?80:443))==(bV[3]||(bV[1]==="http:"?80:443)))),d.data&&d.processData&&typeof d.data!="string"&&(d.data=f.param(d.data,d.traditional)),bZ(bS,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bJ.test(d.type),t&&f.active++===0&&f.event.trigger("ajaxStart");if(!d.hasContent){d.data&&(d.url+=(bL.test(d.url)?"&":"?")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bP,"$1_="+x);d.url=y+(y===d.url?(bL.test(d.url)?"&":"?")+"_="+x:"")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader("Content-Type",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader("If-Modified-Since",f.lastModified[k]),f.etag[k]&&v.setRequestHeader("If-None-Match",f.etag[k])),v.setRequestHeader("Accept",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!=="*"?", "+bW+"; q=0.01":""):d.accepts["*"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bZ(bT,d,c,v);if(!p)w(-1,"No Transport");else{v.readyState=1,t&&g.trigger("ajaxSend",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort("timeout")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.jquery&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)b_(g,a[g],c,e);return d.join("&").replace(bC,"+")}}),f.extend({active:0,lastModified:{},etag:{}});var cc=f.now(),cd=/(\=)\?(&|$)|\?\?/i;f.ajaxSetup({jsonp:"callback",jsonpCallback:function(){return f.expando+"_"+cc++}}),f.ajaxPrefilter("json jsonp",function(b,c,d){var e=typeof b.data=="string"&&/^application\/x\-www\-form\-urlencoded/.test(b.contentType);if(b.dataTypes[0]==="jsonp"||b.jsonp!==!1&&(cd.test(b.url)||e&&cd.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l="$1"+h+"$2";b.jsonp!==!1&&(j=j.replace(cd,l),b.url===j&&(e&&(k=k.replace(cd,l)),b.data===k&&(j+=(/\?/.test(j)?"&":"?")+b.jsonp+"="+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters["script json"]=function(){g||f.error(h+" was not called");return g[0]},b.dataTypes[0]="json";return"script"}}),f.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),f.ajaxTransport("script",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName("head")[0]||c.documentElement;return{send:function(f,g){d=c.createElement("script"),d.async="async",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,"success")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var ce=a.ActiveXObject?function(){for(var a in cg)cg[a](0,1)}:!1,cf=0,cg;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ch()||ci()}:ch,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,ce&&delete cg[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n);try{m.text=h.responseText}catch(a){}try{k=h.statusText}catch(o){k=""}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cf,ce&&(cg||(cg={},f(a).unload(ce)),cg[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cj={},ck,cl,cm=/^(?:toggle|show|hide)$/,cn=/^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,co,cp=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]],cq;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(ct("show",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,"olddisplay")&&e==="none"&&(e=d.style.display=""),(e===""&&f.css(d,"display")==="none"||!f.contains(d.ownerDocument.documentElement,d))&&f._data(d,"olddisplay",cu(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===""||e==="none")d.style.display=f._data(d,"olddisplay")||""}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(ct("hide",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,"display"),e!=="none"&&!f._data(d,"olddisplay")&&f._data(d,"olddisplay",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display="none");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a=="boolean";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(":hidden");f(this)[b?"show":"hide"]()}):this.animate(ct("toggle",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(":hidden"),g,h,i,j,k,l,m,n,o,p,q;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]);if((k=f.cssHooks[g])&&"expand"in k){l=k.expand(a[g]),delete a[g];for(i in l)i in a||(a[i]=l[i])}}for(g in a){h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||"swing";if(h==="hide"&&d||h==="show"&&!d)return b.complete.call(this);c&&(g==="height"||g==="width")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,"display")==="inline"&&f.css(this,"float")==="none"&&(!f.support.inlineBlockNeedsLayout||cu(this.nodeName)==="inline"?this.style.display="inline-block":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow="hidden");for(i in a)j=new f.fx(this,b,i),h=a[i],cm.test(h)?(q=f._data(this,"toggle"+i)||(h==="toggle"?d?"show":"hide":0),q?(f._data(this,"toggle"+i,q==="show"?"hide":"show"),j[q]()):j[h]()):(m=cn.exec(h),n=j.cur(),m?(o=parseFloat(m[2]),p=m[3]||(f.cssNumber[i]?"":"px"),p!=="px"&&(f.style(this,i,(o||1)+p),n=(o||1)/j.cur()*n,f.style(this,i,n+p)),m[1]&&(o=(m[1]==="-="?-1:1)*o+n),j.custom(n,o,p)):j.custom(n,h,""));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(".run")===b.length-4&&h(this,g,b);else g[b=a+".run"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:ct("show",1),slideUp:ct("hide",1),slideToggle:ct("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a=="object"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a){return a},swing:function(a){return-Math.cos(a*Math.PI)/2+.5}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b==="auto"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cq||cr(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?"":"px"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){f._data(e.elem,"fxshow"+e.prop)===b&&(e.options.hide?f._data(e.elem,"fxshow"+e.prop,e.start):e.options.show&&f._data(e.elem,"fxshow"+e.prop,e.end))},h()&&f.timers.push(h)&&!co&&(co=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,"fxshow"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,"fxshow"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cq||cr(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each(["","X","Y"],function(a,b){h.style["overflow"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,"fxshow"+b,!0),f.removeData(h,"toggle"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(co),co=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,"opacity",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(cp.concat.apply([],cp),function(a,b){b.indexOf("margin")&&(f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)})}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cv,cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;"getBoundingClientRect"in c.documentElement?cv=function(a,b,c,d){try{d=a.getBoundingClientRect()}catch(e){}if(!d||!f.contains(c,a))return d?{top:d.top,left:d.left}:{top:0,left:0};var g=b.body,h=cy(b),i=c.clientTop||g.clientTop||0,j=c.clientLeft||g.clientLeft||0,k=h.pageYOffset||f.support.boxModel&&c.scrollTop||g.scrollTop,l=h.pageXOffset||f.support.boxModel&&c.scrollLeft||g.scrollLeft,m=d.top+k-i,n=d.left+l-j;return{top:m,left:n}}:cv=function(a,b,c){var d,e=a.offsetParent,g=a,h=b.body,i=b.defaultView,j=i?i.getComputedStyle(a,null):a.currentStyle,k=a.offsetTop,l=a.offsetLeft;while((a=a.parentNode)&&a!==h&&a!==c){if(f.support.fixedPosition&&j.position==="fixed")break;d=i?i.getComputedStyle(a,null):a.currentStyle,k-=a.scrollTop,l-=a.scrollLeft,a===e&&(k+=a.offsetTop,l+=a.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(a.nodeName))&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),g=e,e=a.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),j=d}if(j.position==="relative"||j.position==="static")k+=h.offsetTop,l+=h.offsetLeft;f.support.fixedPosition&&j.position==="fixed"&&(k+=Math.max(c.scrollTop,h.scrollTop),l+=Math.max(c.scrollLeft,h.scrollLeft));return{top:k,left:l}},f.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){f.offset.setOffset(this,a,b)});var c=this[0],d=c&&c.ownerDocument;if(!d)return null;if(c===d.body)return f.offset.bodyOffset(c);return cv(c,d,d.documentElement)},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,"marginTop"))||0,c+=parseFloat(f.css(a,"marginLeft"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,"position");d==="static"&&(a.style.position="relative");var e=f(a),g=e.offset(),h=f.css(a,"top"),i=f.css(a,"left"),j=(d==="absolute"||d==="fixed")&&f.inArray("auto",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),"using"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,"marginTop"))||0,c.left-=parseFloat(f.css(a,"marginLeft"))||0,d.top+=parseFloat(f.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(f.css(b[0],"borderLeftWidth"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,"position")==="static")a=a.offsetParent;return a})}}),f.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,c){var d=/Y/.test(c);f.fn[a]=function(e){return f.access(this,function(a,e,g){var h=cy(a);if(g===b)return h?c in h?h[c]:f.support.boxModel&&h.document.documentElement[e]||h.document.body[e]:a[e];h?h.scrollTo(d?f(h).scrollLeft():g,d?g:f(h).scrollTop()):a[e]=g},a,e,arguments.length,null)}}),f.each({Height:"height",Width:"width"},function(a,c){var d="client"+a,e="scroll"+a,g="offset"+a;f.fn["inner"+a]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,c,"padding")):this[c]():null},f.fn["outer"+a]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,c,a?"margin":"border")):this[c]():null},f.fn[c]=function(a){return f.access(this,function(a,c,h){var i,j,k,l;if(f.isWindow(a)){i=a.document,j=i.documentElement[d];return f.support.boxModel&&j||i.body&&i.body[d]||j}if(a.nodeType===9){i=a.documentElement;if(i[d]>=i[e])return i[d];return Math.max(a.body[e],i[e],a.body[g],i[g])}if(h===b){k=f.css(a,c),l=parseFloat(k);return f.isNumeric(l)?l:k}f(a).css(c,h)},c,a,arguments.length,null)}}),a.jQuery=a.$=f,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return f})})(window);

/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.core.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
jQuery.effects||function(a,b){function c(b){var c;return b&&b.constructor==Array&&b.length==3?b:(c=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(b))?[parseInt(c[1],10),parseInt(c[2],10),parseInt(c[3],10)]:(c=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(b))?[parseFloat(c[1])*2.55,parseFloat(c[2])*2.55,parseFloat(c[3])*2.55]:(c=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(b))?[parseInt(c[1],16),parseInt(c[2],16),parseInt(c[3],16)]:(c=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(b))?[parseInt(c[1]+c[1],16),parseInt(c[2]+c[2],16),parseInt(c[3]+c[3],16)]:(c=/rgba\(0, 0, 0, 0\)/.exec(b))?e.transparent:e[a.trim(b).toLowerCase()]}function d(b,d){var e;do{e=a.curCSS(b,d);if(e!=""&&e!="transparent"||a.nodeName(b,"body"))break;d="backgroundColor"}while(b=b.parentNode);return c(e)}function h(){var a=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,b={},c,d;if(a&&a.length&&a[0]&&a[a[0]]){var e=a.length;while(e--)c=a[e],typeof a[c]=="string"&&(d=c.replace(/\-(\w)/g,function(a,b){return b.toUpperCase()}),b[d]=a[c])}else for(c in a)typeof a[c]=="string"&&(b[c]=a[c]);return b}function i(b){var c,d;for(c in b)d=b[c],(d==null||a.isFunction(d)||c in g||/scrollbar/.test(c)||!/color/i.test(c)&&isNaN(parseFloat(d)))&&delete b[c];return b}function j(a,b){var c={_:0},d;for(d in b)a[d]!=b[d]&&(c[d]=b[d]);return c}function k(b,c,d,e){typeof b=="object"&&(e=c,d=null,c=b,b=c.effect),a.isFunction(c)&&(e=c,d=null,c={});if(typeof c=="number"||a.fx.speeds[c])e=d,d=c,c={};return a.isFunction(d)&&(e=d,d=null),c=c||{},d=d||c.duration,d=a.fx.off?0:typeof d=="number"?d:d in a.fx.speeds?a.fx.speeds[d]:a.fx.speeds._default,e=e||c.complete,[b,c,d,e]}function l(b){return!b||typeof b=="number"||a.fx.speeds[b]?!0:typeof b=="string"&&!a.effects[b]?!0:!1}a.effects={},a.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor","borderTopColor","borderColor","color","outlineColor"],function(b,e){a.fx.step[e]=function(a){a.colorInit||(a.start=d(a.elem,e),a.end=c(a.end),a.colorInit=!0),a.elem.style[e]="rgb("+Math.max(Math.min(parseInt(a.pos*(a.end[0]-a.start[0])+a.start[0],10),255),0)+","+Math.max(Math.min(parseInt(a.pos*(a.end[1]-a.start[1])+a.start[1],10),255),0)+","+Math.max(Math.min(parseInt(a.pos*(a.end[2]-a.start[2])+a.start[2],10),255),0)+")"}});var e={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},f=["add","remove","toggle"],g={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};a.effects.animateClass=function(b,c,d,e){return a.isFunction(d)&&(e=d,d=null),this.queue(function(){var g=a(this),k=g.attr("style")||" ",l=i(h.call(this)),m,n=g.attr("class")||"";a.each(f,function(a,c){b[c]&&g[c+"Class"](b[c])}),m=i(h.call(this)),g.attr("class",n),g.animate(j(l,m),{queue:!1,duration:c,easing:d,complete:function(){a.each(f,function(a,c){b[c]&&g[c+"Class"](b[c])}),typeof g.attr("style")=="object"?(g.attr("style").cssText="",g.attr("style").cssText=k):g.attr("style",k),e&&e.apply(this,arguments),a.dequeue(this)}})})},a.fn.extend({_addClass:a.fn.addClass,addClass:function(b,c,d,e){return c?a.effects.animateClass.apply(this,[{add:b},c,d,e]):this._addClass(b)},_removeClass:a.fn.removeClass,removeClass:function(b,c,d,e){return c?a.effects.animateClass.apply(this,[{remove:b},c,d,e]):this._removeClass(b)},_toggleClass:a.fn.toggleClass,toggleClass:function(c,d,e,f,g){return typeof d=="boolean"||d===b?e?a.effects.animateClass.apply(this,[d?{add:c}:{remove:c},e,f,g]):this._toggleClass(c,d):a.effects.animateClass.apply(this,[{toggle:c},d,e,f])},switchClass:function(b,c,d,e,f){return a.effects.animateClass.apply(this,[{add:c,remove:b},d,e,f])}}),a.extend(a.effects,{version:"1.8.21",save:function(a,b){for(var c=0;c<b.length;c++)b[c]!==null&&a.data("ec.storage."+b[c],a[0].style[b[c]])},restore:function(a,b){for(var c=0;c<b.length;c++)b[c]!==null&&a.css(b[c],a.data("ec.storage."+b[c]))},setMode:function(a,b){return b=="toggle"&&(b=a.is(":hidden")?"show":"hide"),b},getBaseline:function(a,b){var c,d;switch(a[0]){case"top":c=0;break;case"middle":c=.5;break;case"bottom":c=1;break;default:c=a[0]/b.height}switch(a[1]){case"left":d=0;break;case"center":d=.5;break;case"right":d=1;break;default:d=a[1]/b.width}return{x:d,y:c}},createWrapper:function(b){if(b.parent().is(".ui-effects-wrapper"))return b.parent();var c={width:b.outerWidth(!0),height:b.outerHeight(!0),"float":b.css("float")},d=a("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),e=document.activeElement;try{e.id}catch(f){e=document.body}return b.wrap(d),(b[0]===e||a.contains(b[0],e))&&a(e).focus(),d=b.parent(),b.css("position")=="static"?(d.css({position:"relative"}),b.css({position:"relative"})):(a.extend(c,{position:b.css("position"),zIndex:b.css("z-index")}),a.each(["top","left","bottom","right"],function(a,d){c[d]=b.css(d),isNaN(parseInt(c[d],10))&&(c[d]="auto")}),b.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),d.css(c).show()},removeWrapper:function(b){var c,d=document.activeElement;return b.parent().is(".ui-effects-wrapper")?(c=b.parent().replaceWith(b),(b[0]===d||a.contains(b[0],d))&&a(d).focus(),c):b},setTransition:function(b,c,d,e){return e=e||{},a.each(c,function(a,c){var f=b.cssUnit(c);f[0]>0&&(e[c]=f[0]*d+f[1])}),e}}),a.fn.extend({effect:function(b,c,d,e){var f=k.apply(this,arguments),g={options:f[1],duration:f[2],callback:f[3]},h=g.options.mode,i=a.effects[b];return a.fx.off||!i?h?this[h](g.duration,g.callback):this.each(function(){g.callback&&g.callback.call(this)}):i.call(this,g)},_show:a.fn.show,show:function(a){if(l(a))return this._show.apply(this,arguments);var b=k.apply(this,arguments);return b[1].mode="show",this.effect.apply(this,b)},_hide:a.fn.hide,hide:function(a){if(l(a))return this._hide.apply(this,arguments);var b=k.apply(this,arguments);return b[1].mode="hide",this.effect.apply(this,b)},__toggle:a.fn.toggle,toggle:function(b){if(l(b)||typeof b=="boolean"||a.isFunction(b))return this.__toggle.apply(this,arguments);var c=k.apply(this,arguments);return c[1].mode="toggle",this.effect.apply(this,c)},cssUnit:function(b){var c=this.css(b),d=[];return a.each(["em","px","%","pt"],function(a,b){c.indexOf(b)>0&&(d=[parseFloat(c),b])}),d}}),a.easing.jswing=a.easing.swing,a.extend(a.easing,{def:"easeOutQuad",swing:function(b,c,d,e,f){return a.easing[a.easing.def](b,c,d,e,f)},easeInQuad:function(a,b,c,d,e){return d*(b/=e)*b+c},easeOutQuad:function(a,b,c,d,e){return-d*(b/=e)*(b-2)+c},easeInOutQuad:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b+c:-d/2*(--b*(b-2)-1)+c},easeInCubic:function(a,b,c,d,e){return d*(b/=e)*b*b+c},easeOutCubic:function(a,b,c,d,e){return d*((b=b/e-1)*b*b+1)+c},easeInOutCubic:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b+c:d/2*((b-=2)*b*b+2)+c},easeInQuart:function(a,b,c,d,e){return d*(b/=e)*b*b*b+c},easeOutQuart:function(a,b,c,d,e){return-d*((b=b/e-1)*b*b*b-1)+c},easeInOutQuart:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b*b+c:-d/2*((b-=2)*b*b*b-2)+c},easeInQuint:function(a,b,c,d,e){return d*(b/=e)*b*b*b*b+c},easeOutQuint:function(a,b,c,d,e){return d*((b=b/e-1)*b*b*b*b+1)+c},easeInOutQuint:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b*b*b+c:d/2*((b-=2)*b*b*b*b+2)+c},easeInSine:function(a,b,c,d,e){return-d*Math.cos(b/e*(Math.PI/2))+d+c},easeOutSine:function(a,b,c,d,e){return d*Math.sin(b/e*(Math.PI/2))+c},easeInOutSine:function(a,b,c,d,e){return-d/2*(Math.cos(Math.PI*b/e)-1)+c},easeInExpo:function(a,b,c,d,e){return b==0?c:d*Math.pow(2,10*(b/e-1))+c},easeOutExpo:function(a,b,c,d,e){return b==e?c+d:d*(-Math.pow(2,-10*b/e)+1)+c},easeInOutExpo:function(a,b,c,d,e){return b==0?c:b==e?c+d:(b/=e/2)<1?d/2*Math.pow(2,10*(b-1))+c:d/2*(-Math.pow(2,-10*--b)+2)+c},easeInCirc:function(a,b,c,d,e){return-d*(Math.sqrt(1-(b/=e)*b)-1)+c},easeOutCirc:function(a,b,c,d,e){return d*Math.sqrt(1-(b=b/e-1)*b)+c},easeInOutCirc:function(a,b,c,d,e){return(b/=e/2)<1?-d/2*(Math.sqrt(1-b*b)-1)+c:d/2*(Math.sqrt(1-(b-=2)*b)+1)+c},easeInElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e)==1)return c+d;g||(g=e*.3);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return-(h*Math.pow(2,10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g))+c},easeOutElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e)==1)return c+d;g||(g=e*.3);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*b)*Math.sin((b*e-f)*2*Math.PI/g)+d+c},easeInOutElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e/2)==2)return c+d;g||(g=e*.3*1.5);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return b<1?-0.5*h*Math.pow(2,10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g)+c:h*Math.pow(2,-10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g)*.5+d+c},easeInBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),e*(c/=f)*c*((g+1)*c-g)+d},easeOutBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),e*((c=c/f-1)*c*((g+1)*c+g)+1)+d},easeInOutBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),(c/=f/2)<1?e/2*c*c*(((g*=1.525)+1)*c-g)+d:e/2*((c-=2)*c*(((g*=1.525)+1)*c+g)+2)+d},easeInBounce:function(b,c,d,e,f){return e-a.easing.easeOutBounce(b,f-c,0,e,f)+d},easeOutBounce:function(a,b,c,d,e){return(b/=e)<1/2.75?d*7.5625*b*b+c:b<2/2.75?d*(7.5625*(b-=1.5/2.75)*b+.75)+c:b<2.5/2.75?d*(7.5625*(b-=2.25/2.75)*b+.9375)+c:d*(7.5625*(b-=2.625/2.75)*b+.984375)+c},easeInOutBounce:function(b,c,d,e,f){return c<f/2?a.easing.easeInBounce(b,c*2,0,e,f)*.5+d:a.easing.easeOutBounce(b,c*2-f,0,e,f)*.5+e*.5+d}})}(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.core.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){function c(b,c){var e=b.nodeName.toLowerCase();if("area"===e){var f=b.parentNode,g=f.name,h;return!b.href||!g||f.nodeName.toLowerCase()!=="map"?!1:(h=a("img[usemap=#"+g+"]")[0],!!h&&d(h))}return(/input|select|textarea|button|object/.test(e)?!b.disabled:"a"==e?b.href||c:c)&&d(b)}function d(b){return!a(b).parents().andSelf().filter(function(){return a.curCSS(this,"visibility")==="hidden"||a.expr.filters.hidden(this)}).length}a.ui=a.ui||{};if(a.ui.version)return;a.extend(a.ui,{version:"1.8.21",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}}),a.fn.extend({propAttr:a.fn.prop||a.fn.attr,_focus:a.fn.focus,focus:function(b,c){return typeof b=="number"?this.each(function(){var d=this;setTimeout(function(){a(d).focus(),c&&c.call(d)},b)}):this._focus.apply(this,arguments)},scrollParent:function(){var b;return a.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?b=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(a.curCSS(this,"position",1))&&/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0):b=this.parents().filter(function(){return/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0),/fixed/.test(this.css("position"))||!b.length?a(document):b},zIndex:function(c){if(c!==b)return this.css("zIndex",c);if(this.length){var d=a(this[0]),e,f;while(d.length&&d[0]!==document){e=d.css("position");if(e==="absolute"||e==="relative"||e==="fixed"){f=parseInt(d.css("zIndex"),10);if(!isNaN(f)&&f!==0)return f}d=d.parent()}}return 0},disableSelection:function(){return this.bind((a.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),a.each(["Width","Height"],function(c,d){function h(b,c,d,f){return a.each(e,function(){c-=parseFloat(a.curCSS(b,"padding"+this,!0))||0,d&&(c-=parseFloat(a.curCSS(b,"border"+this+"Width",!0))||0),f&&(c-=parseFloat(a.curCSS(b,"margin"+this,!0))||0)}),c}var e=d==="Width"?["Left","Right"]:["Top","Bottom"],f=d.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+d]=function(c){return c===b?g["inner"+d].call(this):this.each(function(){a(this).css(f,h(this,c)+"px")})},a.fn["outer"+d]=function(b,c){return typeof b!="number"?g["outer"+d].call(this,b):this.each(function(){a(this).css(f,h(this,b,!0,c)+"px")})}}),a.extend(a.expr[":"],{data:function(b,c,d){return!!a.data(b,d[3])},focusable:function(b){return c(b,!isNaN(a.attr(b,"tabindex")))},tabbable:function(b){var d=a.attr(b,"tabindex"),e=isNaN(d);return(e||d>=0)&&c(b,!e)}}),a(function(){var b=document.body,c=b.appendChild(c=document.createElement("div"));c.offsetHeight,a.extend(c.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),a.support.minHeight=c.offsetHeight===100,a.support.selectstart="onselectstart"in c,b.removeChild(c).style.display="none"}),a.extend(a.ui,{plugin:{add:function(b,c,d){var e=a.ui[b].prototype;for(var f in d)e.plugins[f]=e.plugins[f]||[],e.plugins[f].push([c,d[f]])},call:function(a,b,c){var d=a.plugins[b];if(!d||!a.element[0].parentNode)return;for(var e=0;e<d.length;e++)a.options[d[e][0]]&&d[e][1].apply(a.element,c)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(b,c){if(a(b).css("overflow")==="hidden")return!1;var d=c&&c==="left"?"scrollLeft":"scrollTop",e=!1;return b[d]>0?!0:(b[d]=1,e=b[d]>0,b[d]=0,e)},isOverAxis:function(a,b,c){return a>b&&a<b+c},isOver:function(b,c,d,e,f,g){return a.ui.isOverAxis(b,d,f)&&a.ui.isOverAxis(c,e,g)}})})(jQuery);

if(!this.JSON){JSON={};}
(function(){function f(n){return n<10?'0'+n:n;}
if(typeof Date.prototype.toJSON!=='function'){Date.prototype.toJSON=function(key){return this.getUTCFullYear()+'-'+
f(this.getUTCMonth()+1)+'-'+
f(this.getUTCDate())+'T'+
f(this.getUTCHours())+':'+
f(this.getUTCMinutes())+':'+
f(this.getUTCSeconds())+'Z';};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf();};}
var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'"'+string.replace(escapable,function(a){var c=meta[a];return typeof c==='string'?c:'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4);})+'"':'"'+string+'"';}
function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value==='object'&&typeof value.toJSON==='function'){value=value.toJSON(key);}
if(typeof rep==='function'){value=rep.call(holder,key,value);}
switch(typeof value){case'string':return quote(value);case'number':return isFinite(value)?String(value):'null';case'boolean':case'null':return String(value);case'object':if(!value){return'null';}
gap+=indent;partial=[];if(Object.prototype.toString.apply(value)==='[object Array]'){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||'null';}
v=partial.length===0?'[]':gap?'[\n'+gap+
partial.join(',\n'+gap)+'\n'+
mind+']':'['+partial.join(',')+']';gap=mind;return v;}
if(rep&&typeof rep==='object'){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k==='string'){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v);}}}}else{for(k in value){if(Object.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v);}}}}
v=partial.length===0?'{}':gap?'{\n'+gap+partial.join(',\n'+gap)+'\n'+
mind+'}':'{'+partial.join(',')+'}';gap=mind;return v;}}
if(typeof JSON.stringify!=='function'){JSON.stringify=function(value,replacer,space){var i;gap='';indent='';if(typeof space==='number'){for(i=0;i<space;i+=1){indent+=' ';}}else if(typeof space==='string'){indent=space;}
rep=replacer;if(replacer&&typeof replacer!=='function'&&(typeof replacer!=='object'||typeof replacer.length!=='number')){throw new Error('JSON.stringify');}
return str('',{'':value});};}
if(typeof JSON.parse!=='function'){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value==='object'){for(k in value){if(Object.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v;}else{delete value[k];}}}}
return reviver.call(holder,key,value);}
cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return'\\u'+
('0000'+a.charCodeAt(0).toString(16)).slice(-4);});}
if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,''))){j=eval('('+text+')');return typeof reviver==='function'?walk({'':j},''):j;}
throw new SyntaxError('JSON.parse');};}})();
//     Underscore.js 1.1.3
//     (c) 2010 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var slice            = ArrayProto.slice,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) { return new wrapper(obj); };

  // Export the Underscore object for **CommonJS**, with backwards-compatibility
  // for the old `require()` API. If we're not in CommonJS, add `_` to the
  // global object.
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = _;
    _._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.1.3';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects implementing `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    var value;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (_.isNumber(obj.length)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (hasOwnProperty.call(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = function(obj, iterator, context) {
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    var results = [];
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = memo !== void 0;
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial && index === 0) {
        memo = value;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return memo !== void 0 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();
    return _.reduce(reversed, iterator, memo, context);
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    var results = [];
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    var results = [];
    each(obj, function(value, index, list) {
      if (!iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator = iterator || _.identity;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    var result = true;
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator = iterator || _.identity;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    var result = false;
    each(obj, function(value, index, list) {
      if (result = iterator.call(context, value, index, list)) return breaker;
    });
    return result;
  };

  // Determine if a given value is included in the array or object using `===`.
  // Aliased as `contains`.
  _.include = _.contains = function(obj, target) {
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    var found = false;
    any(obj, function(value) {
      if (found = value === target) return true;
    });
    return found;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (method ? value[method] : value).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Return the maximum element or (element-based computation).
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }), 'value');
  };

  // Use a comparator function to figure out at what index an object should
  // be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator) {
    iterator = iterator || _.identity;
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(iterable) {
    if (!iterable)                return [];
    if (iterable.toArray)         return iterable.toArray();
    if (_.isArray(iterable))      return iterable;
    if (_.isArguments(iterable))  return slice.call(iterable);
    return _.values(iterable);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    return _.toArray(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head`. The **guard** check allows it to work
  // with `_.map`.
  _.first = _.head = function(array, n, guard) {
    return n && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the first entry of the array. Aliased as `tail`.
  // Especially useful on the arguments object. Passing an **index** will return
  // the rest of the values in the array from that index onward. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, _.isUndefined(index) || guard ? 1 : index);
  };

  // Get the last element of an array.
  _.last = function(array) {
    return array[array.length - 1];
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array) {
    return _.reduce(array, function(memo, value) {
      if (_.isArray(value)) return memo.concat(_.flatten(value));
      memo[memo.length] = value;
      return memo;
    }, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    var values = slice.call(arguments, 1);
    return _.filter(array, function(value){ return !_.include(values, value); });
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted) {
    return _.reduce(array, function(memo, el, i) {
      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) memo[memo.length] = el;
      return memo;
    }, []);
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
    return results;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  _.indexOf = function(array, item) {
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
    for (var i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;
    return -1;
  };


  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item) {
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    var args  = slice.call(arguments),
        solo  = args.length <= 1,
        start = solo ? 0 : args[0],
        stop  = solo ? args[0] : args[1],
        step  = args[2] || 1,
        len   = Math.max(Math.ceil((stop - start) / step), 0),
        idx   = 0,
        range = new Array(len);
    while (idx < len) {
      range[idx++] = start;
      start += step;
    }
    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  _.bind = function(func, obj) {
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(obj || {}, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher = hasher || _.identity;
    return function() {
      var key = hasher.apply(this, arguments);
      return key in memo ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(func, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Internal function used to implement `_.throttle` and `_.debounce`.
  var limit = function(func, wait, debounce) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var throttler = function() {
        timeout = null;
        func.apply(context, args);
      };
      if (debounce) clearTimeout(timeout);
      if (debounce || !timeout) timeout = setTimeout(throttler, wait);
    };
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    return limit(func, wait, false);
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds.
  _.debounce = function(func, wait) {
    return limit(func, wait, true);
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments));
      return wrapper.apply(wrapper, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = slice.call(arguments);
    return function() {
      var args = slice.call(arguments);
      for (var i=funcs.length-1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (_.isArray(obj)) return _.range(0, obj.length);
    var keys = [];
    for (var key in obj) if (hasOwnProperty.call(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    return _.map(obj, _.identity);
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    return _.filter(_.keys(obj), function(key){ return _.isFunction(obj[key]); }).sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) obj[prop] = source[prop];
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    // Check object identity.
    if (a === b) return true;
    // Different types?
    var atype = typeof(a), btype = typeof(b);
    if (atype != btype) return false;
    // Basic equality test (watch out for coercions).
    if (a == b) return true;
    // One is falsy and the other truthy.
    if ((!a && b) || (a && !b)) return false;
    // One of them implements an isEqual()?
    if (a.isEqual) return a.isEqual(b);
    // Check dates' integer values.
    if (_.isDate(a) && _.isDate(b)) return a.getTime() === b.getTime();
    // Both are NaN?
    if (_.isNaN(a) && _.isNaN(b)) return false;
    // Compare regular expressions.
    if (_.isRegExp(a) && _.isRegExp(b))
      return a.source     === b.source &&
             a.global     === b.global &&
             a.ignoreCase === b.ignoreCase &&
             a.multiline  === b.multiline;
    // If a is not an object by this point, we can't handle it.
    if (atype !== 'object') return false;
    // Check for different array lengths before comparing contents.
    if (a.length && (a.length !== b.length)) return false;
    // Nothing else worked, deep compare the contents.
    var aKeys = _.keys(a), bKeys = _.keys(b);
    // Different object sizes?
    if (aKeys.length != bKeys.length) return false;
    // Recursive comparison of contents.
    for (var key in a) if (!(key in b) || !_.isEqual(a[key], b[key])) return false;
    return true;
  };

  // Is a given array or object empty?
  _.isEmpty = function(obj) {
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType == 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return !!(obj && obj.concat && obj.unshift && !obj.callee);
  };

  // Is a given variable an arguments object?
  _.isArguments = function(obj) {
    return !!(obj && obj.callee);
  };

  // Is a given value a function?
  _.isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  // Is a given value a string?
  _.isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  // Is a given value a number?
  _.isNumber = function(obj) {
    return !!(obj === 0 || (obj && obj.toExponential && obj.toFixed));
  };

  // Is the given value NaN -- this one is interesting. NaN != NaN, and
  // isNaN(undefined) == true, so we make sure it's a number first.
  _.isNaN = function(obj) {
    return toString.call(obj) === '[object Number]' && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  // Is a given value a date?
  _.isDate = function(obj) {
    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);
  };

  // Is the given value a regular expression?
  _.isRegExp = function(obj) {
    return !!(obj && obj.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function (n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Add your own custom functions to the Underscore object, ensuring that
  // they're correctly added to the OOP wrapper as well.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      addToWrapper(name, _[name] = obj[name]);
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(str, data) {
    var c  = _.templateSettings;
    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +
      'with(obj||{}){__p.push(\'' +
      str.replace(/\\/g, '\\\\')
         .replace(/'/g, "\\'")
         .replace(c.interpolate, function(match, code) {
           return "'," + code.replace(/\\'/g, "'") + ",'";
         })
         .replace(c.evaluate || null, function(match, code) {
           return "');" + code.replace(/\\'/g, "'")
                              .replace(/[\r\n\t]/g, ' ') + "__p.push('";
         })
         .replace(/\r/g, '\\r')
         .replace(/\n/g, '\\n')
         .replace(/\t/g, '\\t')
         + "');}return __p.join('');";
    var func = new Function('obj', tmpl);
    return data ? func(data) : func;
  };

  // The OOP Wrapper
  // ---------------

  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  var wrapper = function(obj) { this._wrapped = obj; };

  // Expose `wrapper.prototype` as `_.prototype`
  _.prototype = wrapper.prototype;

  // Helper function to continue chaining intermediate results.
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj;
  };

  // A method to easily add functions to the OOP wrapper.
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain);
    };
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      method.apply(this._wrapped, arguments);
      return result(this._wrapped, this._chain);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain);
    };
  });

  // Start chaining a wrapped Underscore object.
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this;
  };

  // Extracts the result from a wrapped and chained object.
  wrapper.prototype.value = function() {
    return this._wrapped;
  };

})();

(function(){function diff_match_patch(){this.Diff_Timeout=1;this.Diff_EditCost=4;this.Match_Threshold=0.5;this.Match_Distance=1E3;this.Patch_DeleteThreshold=0.5;this.Patch_Margin=4;this.Match_MaxBits=32}
diff_match_patch.prototype.diff_main=function(a,b,c,d){if(typeof d=="undefined")d=this.Diff_Timeout<=0?Number.MAX_VALUE:(new Date).getTime()+this.Diff_Timeout*1E3;if(a==null||b==null)throw Error("Null input. (diff_main)");if(a==b){if(a)return[[0,a]];return[]}if(typeof c=="undefined")c=true;var e=c,f=this.diff_commonPrefix(a,b);c=a.substring(0,f);a=a.substring(f);b=b.substring(f);f=this.diff_commonSuffix(a,b);var g=a.substring(a.length-f);a=a.substring(0,a.length-f);b=b.substring(0,b.length-f);a=this.diff_compute_(a,
b,e,d);c&&a.unshift([0,c]);g&&a.push([0,g]);this.diff_cleanupMerge(a);return a};
diff_match_patch.prototype.diff_compute_=function(a,b,c,d){if(!a)return[[1,b]];if(!b)return[[-1,a]];var e=a.length>b.length?a:b,f=a.length>b.length?b:a,g=e.indexOf(f);if(g!=-1){c=[[1,e.substring(0,g)],[0,f],[1,e.substring(g+f.length)]];if(a.length>b.length)c[0][0]=c[2][0]=-1;return c}if(f.length==1)return[[-1,a],[1,b]];if(e=this.diff_halfMatch_(a,b)){f=e[0];a=e[1];g=e[2];b=e[3];e=e[4];f=this.diff_main(f,g,c,d);c=this.diff_main(a,b,c,d);return f.concat([[0,e]],c)}if(c&&a.length>100&&b.length>100)return this.diff_lineMode_(a,
b,d);return this.diff_bisect_(a,b,d)};
diff_match_patch.prototype.diff_lineMode_=function(a,b,c){var d=this.diff_linesToChars_(a,b);a=d[0];b=d[1];d=d[2];a=this.diff_bisect_(a,b,c);this.diff_charsToLines_(a,d);this.diff_cleanupSemantic(a);a.push([0,""]);for(var e=b=0,f=0,g=d="";b<a.length;){switch(a[b][0]){case 1:f++;g+=a[b][1];break;case -1:e++;d+=a[b][1];break;case 0:if(e>=1&&f>=1){d=this.diff_main(d,g,false,c);a.splice(b-e-f,e+f);b=b-e-f;for(e=d.length-1;e>=0;e--)a.splice(b,0,d[e]);b+=d.length}e=f=0;g=d=""}b++}a.pop();return a};
diff_match_patch.prototype.diff_bisect_=function(a,b,c){for(var d=a.length,e=b.length,f=Math.ceil((d+e)/2),g=f,h=2*f,j=Array(h),i=Array(h),k=0;k<h;k++){j[k]=-1;i[k]=-1}j[g+1]=0;i[g+1]=0;k=d-e;for(var l=k%2!=0,s=0,p=0,q=0,t=0,r=0;r<f;r++){if((new Date).getTime()>c)break;for(var n=-r+s;n<=r-p;n+=2){var m=g+n,o;o=n==-r||n!=r&&j[m-1]<j[m+1]?j[m+1]:j[m-1]+1;for(var u=o-n;o<d&&u<e&&a.charAt(o)==b.charAt(u);){o++;u++}j[m]=o;if(o>d)p+=2;else if(u>e)s+=2;else if(l){m=g+k-n;if(m>=0&&m<h&&i[m]!=-1){var v=d-
i[m];if(o>=v)return this.diff_bisectSplit_(a,b,o,u,c)}}}for(n=-r+q;n<=r-t;n+=2){m=g+n;v=n==-r||n!=r&&i[m-1]<i[m+1]?i[m+1]:i[m-1]+1;for(o=v-n;v<d&&o<e&&a.charAt(d-v-1)==b.charAt(e-o-1);){v++;o++}i[m]=v;if(v>d)t+=2;else if(o>e)q+=2;else if(!l){m=g+k-n;if(m>=0&&m<h&&j[m]!=-1){o=j[m];u=g+o-m;v=d-v;if(o>=v)return this.diff_bisectSplit_(a,b,o,u,c)}}}}return[[-1,a],[1,b]]};
diff_match_patch.prototype.diff_bisectSplit_=function(a,b,c,d,e){var f=a.substring(0,c),g=b.substring(0,d);a=a.substring(c);b=b.substring(d);f=this.diff_main(f,g,false,e);e=this.diff_main(a,b,false,e);return f.concat(e)};
diff_match_patch.prototype.diff_linesToChars_=function(a,b){function c(h){for(var j="",i=0,k=-1,l=d.length;k<h.length-1;){k=h.indexOf("\n",i);if(k==-1)k=h.length-1;var s=h.substring(i,k+1);i=k+1;if(e.hasOwnProperty?e.hasOwnProperty(s):e[s]!==undefined)j+=String.fromCharCode(e[s]);else{j+=String.fromCharCode(l);e[s]=l;d[l++]=s}}return j}var d=[],e={};d[0]="";var f=c(a),g=c(b);return[f,g,d]};
diff_match_patch.prototype.diff_charsToLines_=function(a,b){for(var c=0;c<a.length;c++){for(var d=a[c][1],e=[],f=0;f<d.length;f++)e[f]=b[d.charCodeAt(f)];a[c][1]=e.join("")}};diff_match_patch.prototype.diff_commonPrefix=function(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;){if(a.substring(f,e)==b.substring(f,e))f=c=e;else d=e;e=Math.floor((d-c)/2+c)}return e};
diff_match_patch.prototype.diff_commonSuffix=function(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;){if(a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f))f=c=e;else d=e;e=Math.floor((d-c)/2+c)}return e};
diff_match_patch.prototype.diff_commonOverlap_=function(a,b){var c=a.length,d=b.length;if(c==0||d==0)return 0;if(c>d)a=a.substring(c-d);else if(c<d)b=b.substring(0,c);c=Math.min(c,d);if(a==b)return c;d=0;for(var e=1;;){var f=a.substring(c-e);f=b.indexOf(f);if(f==-1)return d;e+=f;if(f==0||a.substring(c-e)==b.substring(0,e)){d=e;e++}}};
diff_match_patch.prototype.diff_halfMatch_=function(a,b){function c(i,k,l){for(var s=i.substring(l,l+Math.floor(i.length/4)),p=-1,q="",t,r,n,m;(p=k.indexOf(s,p+1))!=-1;){var o=f.diff_commonPrefix(i.substring(l),k.substring(p)),u=f.diff_commonSuffix(i.substring(0,l),k.substring(0,p));if(q.length<u+o){q=k.substring(p-u,p)+k.substring(p,p+o);t=i.substring(0,l-u);r=i.substring(l+o);n=k.substring(0,p-u);m=k.substring(p+o)}}return q.length*2>=i.length?[t,r,n,m,q]:null}if(this.Diff_Timeout<=0)return null;
var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(d.length<4||e.length*2<d.length)return null;var f=this,g=c(d,e,Math.ceil(d.length/4));d=c(d,e,Math.ceil(d.length/2));var h;if(!g&&!d)return null;else h=d?g?g[4].length>d[4].length?g:d:d:g;var j;if(a.length>b.length){g=h[0];d=h[1];e=h[2];j=h[3]}else{e=h[0];j=h[1];g=h[2];d=h[3]}h=h[4];return[g,d,e,j,h]};
diff_match_patch.prototype.diff_cleanupSemantic=function(a){for(var b=false,c=[],d=0,e=null,f=0,g=0,h=0,j=0,i=0;f<a.length;){if(a[f][0]==0){c[d++]=f;g=j;h=i;i=j=0;e=a[f][1]}else{if(a[f][0]==1)j+=a[f][1].length;else i+=a[f][1].length;if(e!==null&&e.length<=Math.max(g,h)&&e.length<=Math.max(j,i)){a.splice(c[d-1],0,[-1,e]);a[c[d-1]+1][0]=1;d--;d--;f=d>0?c[d-1]:-1;i=j=h=g=0;e=null;b=true}}f++}b&&this.diff_cleanupMerge(a);this.diff_cleanupSemanticLossless(a);for(f=1;f<a.length;){if(a[f-1][0]==-1&&a[f][0]==
1){b=a[f-1][1];c=a[f][1];if(d=this.diff_commonOverlap_(b,c)){a.splice(f,0,[0,c.substring(0,d)]);a[f-1][1]=b.substring(0,b.length-d);a[f+1][1]=c.substring(d);f++}f++}f++}};
diff_match_patch.prototype.diff_cleanupSemanticLossless=function(a){function b(r,n){if(!r||!n)return 5;var m=0;if(r.charAt(r.length-1).match(c)||n.charAt(0).match(c)){m++;if(r.charAt(r.length-1).match(d)||n.charAt(0).match(d)){m++;if(r.charAt(r.length-1).match(e)||n.charAt(0).match(e)){m++;if(r.match(f)||n.match(g))m++}}}return m}for(var c=/[^a-zA-Z0-9]/,d=/\s/,e=/[\r\n]/,f=/\n\r?\n$/,g=/^\r?\n\r?\n/,h=1;h<a.length-1;){if(a[h-1][0]==0&&a[h+1][0]==0){var j=a[h-1][1],i=a[h][1],k=a[h+1][1],l=this.diff_commonSuffix(j,
i);if(l){var s=i.substring(i.length-l);j=j.substring(0,j.length-l);i=s+i.substring(0,i.length-l);k=s+k}l=j;s=i;for(var p=k,q=b(j,i)+b(i,k);i.charAt(0)===k.charAt(0);){j+=i.charAt(0);i=i.substring(1)+k.charAt(0);k=k.substring(1);var t=b(j,i)+b(i,k);if(t>=q){q=t;l=j;s=i;p=k}}if(a[h-1][1]!=l){if(l)a[h-1][1]=l;else{a.splice(h-1,1);h--}a[h][1]=s;if(p)a[h+1][1]=p;else{a.splice(h+1,1);h--}}}h++}};
diff_match_patch.prototype.diff_cleanupEfficiency=function(a){for(var b=false,c=[],d=0,e="",f=0,g=false,h=false,j=false,i=false;f<a.length;){if(a[f][0]==0){if(a[f][1].length<this.Diff_EditCost&&(j||i)){c[d++]=f;g=j;h=i;e=a[f][1]}else{d=0;e=""}j=i=false}else{if(a[f][0]==-1)i=true;else j=true;if(e&&(g&&h&&j&&i||e.length<this.Diff_EditCost/2&&g+h+j+i==3)){a.splice(c[d-1],0,[-1,e]);a[c[d-1]+1][0]=1;d--;e="";if(g&&h){j=i=true;d=0}else{d--;f=d>0?c[d-1]:-1;j=i=false}b=true}}f++}b&&this.diff_cleanupMerge(a)};
diff_match_patch.prototype.diff_cleanupMerge=function(a){a.push([0,""]);for(var b=0,c=0,d=0,e="",f="",g;b<a.length;)switch(a[b][0]){case 1:d++;f+=a[b][1];b++;break;case -1:c++;e+=a[b][1];b++;break;case 0:if(c+d>1){if(c!==0&&d!==0){g=this.diff_commonPrefix(f,e);if(g!==0){if(b-c-d>0&&a[b-c-d-1][0]==0)a[b-c-d-1][1]+=f.substring(0,g);else{a.splice(0,0,[0,f.substring(0,g)]);b++}f=f.substring(g);e=e.substring(g)}g=this.diff_commonSuffix(f,e);if(g!==0){a[b][1]=f.substring(f.length-g)+a[b][1];f=f.substring(0,
f.length-g);e=e.substring(0,e.length-g)}}if(c===0)a.splice(b-c-d,c+d,[1,f]);else d===0?a.splice(b-c-d,c+d,[-1,e]):a.splice(b-c-d,c+d,[-1,e],[1,f]);b=b-c-d+(c?1:0)+(d?1:0)+1}else if(b!==0&&a[b-1][0]==0){a[b-1][1]+=a[b][1];a.splice(b,1)}else b++;c=d=0;f=e=""}a[a.length-1][1]===""&&a.pop();c=false;for(b=1;b<a.length-1;){if(a[b-1][0]==0&&a[b+1][0]==0)if(a[b][1].substring(a[b][1].length-a[b-1][1].length)==a[b-1][1]){a[b][1]=a[b-1][1]+a[b][1].substring(0,a[b][1].length-a[b-1][1].length);a[b+1][1]=a[b-1][1]+
a[b+1][1];a.splice(b-1,1);c=true}else if(a[b][1].substring(0,a[b+1][1].length)==a[b+1][1]){a[b-1][1]+=a[b+1][1];a[b][1]=a[b][1].substring(a[b+1][1].length)+a[b+1][1];a.splice(b+1,1);c=true}b++}c&&this.diff_cleanupMerge(a)};diff_match_patch.prototype.diff_xIndex=function(a,b){var c=0,d=0,e=0,f=0,g;for(g=0;g<a.length;g++){if(a[g][0]!==1)c+=a[g][1].length;if(a[g][0]!==-1)d+=a[g][1].length;if(c>b)break;e=c;f=d}if(a.length!=g&&a[g][0]===-1)return f;return f+(b-e)};
diff_match_patch.prototype.diff_prettyHtml=function(a){for(var b=[],c=0,d=/&/g,e=/</g,f=/>/g,g=/\n/g,h=0;h<a.length;h++){var j=a[h][0],i=a[h][1],k=i.replace(d,"&amp;").replace(e,"&lt;").replace(f,"&gt;").replace(g,"&para;<br>");switch(j){case 1:b[h]='<ins style="background:#e6ffe6;">'+k+"</ins>";break;case -1:b[h]='<del style="background:#ffe6e6;">'+k+"</del>";break;case 0:b[h]="<span>"+k+"</span>"}if(j!==-1)c+=i.length}return b.join("")};
diff_match_patch.prototype.diff_text1=function(a){for(var b=[],c=0;c<a.length;c++)if(a[c][0]!==1)b[c]=a[c][1];return b.join("")};diff_match_patch.prototype.diff_text2=function(a){for(var b=[],c=0;c<a.length;c++)if(a[c][0]!==-1)b[c]=a[c][1];return b.join("")};diff_match_patch.prototype.diff_levenshtein=function(a){for(var b=0,c=0,d=0,e=0;e<a.length;e++){var f=a[e][0],g=a[e][1];switch(f){case 1:c+=g.length;break;case -1:d+=g.length;break;case 0:b+=Math.max(c,d);d=c=0}}b+=Math.max(c,d);return b};
diff_match_patch.prototype.diff_toDelta=function(a){for(var b=[],c=0;c<a.length;c++)switch(a[c][0]){case 1:b[c]="+"+encodeURI(a[c][1]);break;case -1:b[c]="-"+a[c][1].length;break;case 0:b[c]="="+a[c][1].length}return b.join("\t").replace(/%20/g," ")};
diff_match_patch.prototype.diff_fromDelta=function(a,b){for(var c=[],d=0,e=0,f=b.split(/\t/g),g=0;g<f.length;g++){var h=f[g].substring(1);switch(f[g].charAt(0)){case "+":try{c[d++]=[1,decodeURI(h)]}catch(j){throw Error("Illegal escape in diff_fromDelta: "+h);}break;case "-":case "=":var i=parseInt(h,10);if(isNaN(i)||i<0)throw Error("Invalid number in diff_fromDelta: "+h);h=a.substring(e,e+=i);if(f[g].charAt(0)=="=")c[d++]=[0,h];else c[d++]=[-1,h];break;default:if(f[g])throw Error("Invalid diff operation in diff_fromDelta: "+
f[g]);}}if(e!=a.length)throw Error("Delta length ("+e+") does not equal source text length ("+a.length+").");return c};diff_match_patch.prototype.match_main=function(a,b,c){if(a==null||b==null||c==null)throw Error("Null input. (match_main)");c=Math.max(0,Math.min(c,a.length));return a==b?0:a.length?a.substring(c,c+b.length)==b?c:this.match_bitap_(a,b,c):-1};
diff_match_patch.prototype.match_bitap_=function(a,b,c){function d(r,n){var m=r/b.length,o=Math.abs(c-n);if(!f.Match_Distance)return o?1:m;return m+o/f.Match_Distance}if(b.length>this.Match_MaxBits)throw Error("Pattern too long for this browser.");var e=this.match_alphabet_(b),f=this,g=this.Match_Threshold,h=a.indexOf(b,c);if(h!=-1){g=Math.min(d(0,h),g);h=a.lastIndexOf(b,c+b.length);if(h!=-1)g=Math.min(d(0,h),g)}var j=1<<b.length-1;h=-1;for(var i,k,l=b.length+a.length,s,p=0;p<b.length;p++){i=0;for(k=
l;i<k;){if(d(p,c+k)<=g)i=k;else l=k;k=Math.floor((l-i)/2+i)}l=k;i=Math.max(1,c-k+1);var q=Math.min(c+k,a.length)+b.length;k=Array(q+2);for(k[q+1]=(1<<p)-1;q>=i;q--){var t=e[a.charAt(q-1)];k[q]=p===0?(k[q+1]<<1|1)&t:(k[q+1]<<1|1)&t|(s[q+1]|s[q])<<1|1|s[q+1];if(k[q]&j){t=d(p,q-1);if(t<=g){g=t;h=q-1;if(h>c)i=Math.max(1,2*c-h);else break}}}if(d(p+1,c)>g)break;s=k}return h};
diff_match_patch.prototype.match_alphabet_=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=0;for(c=0;c<a.length;c++)b[a.charAt(c)]|=1<<a.length-c-1;return b};
diff_match_patch.prototype.patch_addContext_=function(a,b){if(b.length!=0){for(var c=b.substring(a.start2,a.start2+a.length1),d=0;b.indexOf(c)!=b.lastIndexOf(c)&&c.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;){d+=this.Patch_Margin;c=b.substring(a.start2-d,a.start2+a.length1+d)}d+=this.Patch_Margin;(c=b.substring(a.start2-d,a.start2))&&a.diffs.unshift([0,c]);(d=b.substring(a.start2+a.length1,a.start2+a.length1+d))&&a.diffs.push([0,d]);a.start1-=c.length;a.start2-=c.length;a.length1+=
c.length+d.length;a.length2+=c.length+d.length}};
diff_match_patch.prototype.patch_make=function(a,b,c){var d;if(typeof a=="string"&&typeof b=="string"&&typeof c=="undefined"){d=a;b=this.diff_main(d,b,true);if(b.length>2){this.diff_cleanupSemantic(b);this.diff_cleanupEfficiency(b)}}else if(a&&typeof a=="object"&&typeof b=="undefined"&&typeof c=="undefined"){b=a;d=this.diff_text1(b)}else if(typeof a=="string"&&b&&typeof b=="object"&&typeof c=="undefined")d=a;else if(typeof a=="string"&&typeof b=="string"&&c&&typeof c=="object"){d=a;b=c}else throw Error("Unknown call format to patch_make.");
if(b.length===0)return[];c=[];a=new patch_obj;for(var e=0,f=0,g=0,h=d,j=0;j<b.length;j++){var i=b[j][0],k=b[j][1];if(!e&&i!==0){a.start1=f;a.start2=g}switch(i){case 1:a.diffs[e++]=b[j];a.length2+=k.length;d=d.substring(0,g)+k+d.substring(g);break;case -1:a.length1+=k.length;a.diffs[e++]=b[j];d=d.substring(0,g)+d.substring(g+k.length);break;case 0:if(k.length<=2*this.Patch_Margin&&e&&b.length!=j+1){a.diffs[e++]=b[j];a.length1+=k.length;a.length2+=k.length}else if(k.length>=2*this.Patch_Margin)if(e){this.patch_addContext_(a,
h);c.push(a);a=new patch_obj;e=0;h=d;f=g}}if(i!==1)f+=k.length;if(i!==-1)g+=k.length}if(e){this.patch_addContext_(a,h);c.push(a)}return c};diff_match_patch.prototype.patch_deepCopy=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=new patch_obj;e.diffs=[];for(var f=0;f<d.diffs.length;f++)e.diffs[f]=d.diffs[f].slice();e.start1=d.start1;e.start2=d.start2;e.length1=d.length1;e.length2=d.length2;b[c]=e}return b};
diff_match_patch.prototype.patch_apply=function(a,b){if(a.length==0)return[b,[]];a=this.patch_deepCopy(a);var c=this.patch_addPadding(a);b=c+b+c;this.patch_splitMax(a);for(var d=0,e=[],f=0;f<a.length;f++){var g=a[f].start2+d,h=this.diff_text1(a[f].diffs),j,i=-1;if(h.length>this.Match_MaxBits){j=this.match_main(b,h.substring(0,this.Match_MaxBits),g);if(j!=-1){i=this.match_main(b,h.substring(h.length-this.Match_MaxBits),g+h.length-this.Match_MaxBits);if(i==-1||j>=i)j=-1}}else j=this.match_main(b,h,
g);if(j==-1){e[f]=false;d-=a[f].length2-a[f].length1}else{e[f]=true;d=j-g;g=i==-1?b.substring(j,j+h.length):b.substring(j,i+this.Match_MaxBits);if(h==g)b=b.substring(0,j)+this.diff_text2(a[f].diffs)+b.substring(j+h.length);else{g=this.diff_main(h,g,false);if(h.length>this.Match_MaxBits&&this.diff_levenshtein(g)/h.length>this.Patch_DeleteThreshold)e[f]=false;else{this.diff_cleanupSemanticLossless(g);h=0;var k;for(i=0;i<a[f].diffs.length;i++){var l=a[f].diffs[i];if(l[0]!==0)k=this.diff_xIndex(g,h);
if(l[0]===1)b=b.substring(0,j+k)+l[1]+b.substring(j+k);else if(l[0]===-1)b=b.substring(0,j+k)+b.substring(j+this.diff_xIndex(g,h+l[1].length));if(l[0]!==-1)h+=l[1].length}}}}}b=b.substring(c.length,b.length-c.length);return[b,e]};
diff_match_patch.prototype.patch_addPadding=function(a){for(var b=this.Patch_Margin,c="",d=1;d<=b;d++)c+=String.fromCharCode(d);for(d=0;d<a.length;d++){a[d].start1+=b;a[d].start2+=b}d=a[0];var e=d.diffs;if(e.length==0||e[0][0]!=0){e.unshift([0,c]);d.start1-=b;d.start2-=b;d.length1+=b;d.length2+=b}else if(b>e[0][1].length){var f=b-e[0][1].length;e[0][1]=c.substring(e[0][1].length)+e[0][1];d.start1-=f;d.start2-=f;d.length1+=f;d.length2+=f}d=a[a.length-1];e=d.diffs;if(e.length==0||e[e.length-1][0]!=
0){e.push([0,c]);d.length1+=b;d.length2+=b}else if(b>e[e.length-1][1].length){f=b-e[e.length-1][1].length;e[e.length-1][1]+=c.substring(0,f);d.length1+=f;d.length2+=f}return c};
diff_match_patch.prototype.patch_splitMax=function(a){for(var b=this.Match_MaxBits,c=0;c<a.length;c++)if(a[c].length1>b){var d=a[c];a.splice(c--,1);for(var e=d.start1,f=d.start2,g="";d.diffs.length!==0;){var h=new patch_obj,j=true;h.start1=e-g.length;h.start2=f-g.length;if(g!==""){h.length1=h.length2=g.length;h.diffs.push([0,g])}for(;d.diffs.length!==0&&h.length1<b-this.Patch_Margin;){g=d.diffs[0][0];var i=d.diffs[0][1];if(g===1){h.length2+=i.length;f+=i.length;h.diffs.push(d.diffs.shift());j=false}else if(g===
-1&&h.diffs.length==1&&h.diffs[0][0]==0&&i.length>2*b){h.length1+=i.length;e+=i.length;j=false;h.diffs.push([g,i]);d.diffs.shift()}else{i=i.substring(0,b-h.length1-this.Patch_Margin);h.length1+=i.length;e+=i.length;if(g===0){h.length2+=i.length;f+=i.length}else j=false;h.diffs.push([g,i]);if(i==d.diffs[0][1])d.diffs.shift();else d.diffs[0][1]=d.diffs[0][1].substring(i.length)}}g=this.diff_text2(h.diffs);g=g.substring(g.length-this.Patch_Margin);i=this.diff_text1(d.diffs).substring(0,this.Patch_Margin);
if(i!==""){h.length1+=i.length;h.length2+=i.length;if(h.diffs.length!==0&&h.diffs[h.diffs.length-1][0]===0)h.diffs[h.diffs.length-1][1]+=i;else h.diffs.push([0,i])}j||a.splice(++c,0,h)}}};diff_match_patch.prototype.patch_toText=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=a[c];return b.join("")};
diff_match_patch.prototype.patch_fromText=function(a){var b=[];if(!a)return b;a=a.split("\n");for(var c=0,d=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;c<a.length;){var e=a[c].match(d);if(!e)throw Error("Invalid patch string: "+a[c]);var f=new patch_obj;b.push(f);f.start1=parseInt(e[1],10);if(e[2]===""){f.start1--;f.length1=1}else if(e[2]=="0")f.length1=0;else{f.start1--;f.length1=parseInt(e[2],10)}f.start2=parseInt(e[3],10);if(e[4]===""){f.start2--;f.length2=1}else if(e[4]=="0")f.length2=0;else{f.start2--;
f.length2=parseInt(e[4],10)}for(c++;c<a.length;){e=a[c].charAt(0);try{var g=decodeURI(a[c].substring(1))}catch(h){throw Error("Illegal escape in patch_fromText: "+g);}if(e=="-")f.diffs.push([-1,g]);else if(e=="+")f.diffs.push([1,g]);else if(e==" ")f.diffs.push([0,g]);else if(e=="@")break;else if(e!=="")throw Error('Invalid patch mode "'+e+'" in: '+g);c++}}return b};function patch_obj(){this.diffs=[];this.start2=this.start1=null;this.length2=this.length1=0}
patch_obj.prototype.toString=function(){var a,b;a=this.length1===0?this.start1+",0":this.length1==1?this.start1+1:this.start1+1+","+this.length1;b=this.length2===0?this.start2+",0":this.length2==1?this.start2+1:this.start2+1+","+this.length2;a=["@@ -"+a+" +"+b+" @@\n"];var c;for(b=0;b<this.diffs.length;b++){switch(this.diffs[b][0]){case 1:c="+";break;case -1:c="-";break;case 0:c=" "}a[b+1]=c+encodeURI(this.diffs[b][1])+"\n"}return a.join("").replace(/%20/g," ")};window.diff_match_patch=diff_match_patch;
window.patch_obj=patch_obj;window.DIFF_DELETE=-1;window.DIFF_INSERT=1;window.DIFF_EQUAL=0;})()

/**
 * Copyright 2010 Tim Down.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Hashtable=(function(){var p="function";var n=(typeof Array.prototype.splice==p)?function(s,r){s.splice(r,1)}:function(u,t){var s,v,r;if(t===u.length-1){u.length=t}else{s=u.slice(t+1);u.length=t;for(v=0,r=s.length;v<r;++v){u[t+v]=s[v]}}};function a(t){var r;if(typeof t=="string"){return t}else{if(typeof t.hashCode==p){r=t.hashCode();return(typeof r=="string")?r:a(r)}else{if(typeof t.toString==p){return t.toString()}else{try{return String(t)}catch(s){return Object.prototype.toString.call(t)}}}}}function g(r,s){return r.equals(s)}function e(r,s){return(typeof s.equals==p)?s.equals(r):(r===s)}function c(r){return function(s){if(s===null){throw new Error("null is not a valid "+r)}else{if(typeof s=="undefined"){throw new Error(r+" must not be undefined")}}}}var q=c("key"),l=c("value");function d(u,s,t,r){this[0]=u;this.entries=[];this.addEntry(s,t);if(r!==null){this.getEqualityFunction=function(){return r}}}var h=0,j=1,f=2;function o(r){return function(t){var s=this.entries.length,v,u=this.getEqualityFunction(t);while(s--){v=this.entries[s];if(u(t,v[0])){switch(r){case h:return true;case j:return v;case f:return[s,v[1]]}}}return false}}function k(r){return function(u){var v=u.length;for(var t=0,s=this.entries.length;t<s;++t){u[v+t]=this.entries[t][r]}}}d.prototype={getEqualityFunction:function(r){return(typeof r.equals==p)?g:e},getEntryForKey:o(j),getEntryAndIndexForKey:o(f),removeEntryForKey:function(s){var r=this.getEntryAndIndexForKey(s);if(r){n(this.entries,r[0]);return r[1]}return null},addEntry:function(r,s){this.entries[this.entries.length]=[r,s]},keys:k(0),values:k(1),getEntries:function(s){var u=s.length;for(var t=0,r=this.entries.length;t<r;++t){s[u+t]=this.entries[t].slice(0)}},containsKey:o(h),containsValue:function(s){var r=this.entries.length;while(r--){if(s===this.entries[r][1]){return true}}return false}};function m(s,t){var r=s.length,u;while(r--){u=s[r];if(t===u[0]){return r}}return null}function i(r,s){var t=r[s];return(t&&(t instanceof d))?t:null}function b(t,r){var w=this;var v=[];var u={};var x=(typeof t==p)?t:a;var s=(typeof r==p)?r:null;this.put=function(B,C){q(B);l(C);var D=x(B),E,A,z=null;E=i(u,D);if(E){A=E.getEntryForKey(B);if(A){z=A[1];A[1]=C}else{E.addEntry(B,C)}}else{E=new d(D,B,C,s);v[v.length]=E;u[D]=E}return z};this.get=function(A){q(A);var B=x(A);var C=i(u,B);if(C){var z=C.getEntryForKey(A);if(z){return z[1]}}return null};this.containsKey=function(A){q(A);var z=x(A);var B=i(u,z);return B?B.containsKey(A):false};this.containsValue=function(A){l(A);var z=v.length;while(z--){if(v[z].containsValue(A)){return true}}return false};this.clear=function(){v.length=0;u={}};this.isEmpty=function(){return !v.length};var y=function(z){return function(){var A=[],B=v.length;while(B--){v[B][z](A)}return A}};this.keys=y("keys");this.values=y("values");this.entries=y("getEntries");this.remove=function(B){q(B);var C=x(B),z,A=null;var D=i(u,C);if(D){A=D.removeEntryForKey(B);if(A!==null){if(!D.entries.length){z=m(v,C);n(v,z);delete u[C]}}}return A};this.size=function(){var A=0,z=v.length;while(z--){A+=v[z].entries.length}return A};this.each=function(C){var z=w.entries(),A=z.length,B;while(A--){B=z[A];C(B[0],B[1])}};this.putAll=function(H,C){var B=H.entries();var E,F,D,z,A=B.length;var G=(typeof C==p);while(A--){E=B[A];F=E[0];D=E[1];if(G&&(z=w.get(F))){D=C(F,z,D)}w.put(F,D)}};this.clone=function(){var z=new b(t,r);z.putAll(w);return z}}return b})();
/*  Copyright Mihai Bazon, 2002-2005  |  www.bazon.net/mishoo
 * -----------------------------------------------------------
 *
 * The DHTML Calendar, version 1.0 "It is happening again"
 *
 * Details and latest version at:
 * www.dynarch.com/projects/calendar
 *
 * This script is developed by Dynarch.com.  Visit us at www.dynarch.com.
 *
 * This script is distributed under the GNU Lesser General Public License.
 * Read the entire license text here: http://www.gnu.org/licenses/lgpl.html
 */

// $Id: calendar.js,v 1.51 2005/03/07 16:44:31 mishoo Exp $

/** The Calendar object constructor. */
Calendar = function (firstDayOfWeek, dateStr, onSelected, onClose) {
	// member variables
	this.activeDiv = null;
	this.currentDateEl = null;
	this.getDateStatus = null;
	this.getDateToolTip = null;
	this.getDateText = null;
	this.timeout = null;
	this.onSelected = onSelected || null;
	this.onClose = onClose || null;
	this.dragging = false;
	this.hidden = false;
	this.minYear = 1970;
	this.maxYear = 2050;
	this.dateFormat = Calendar._TT["DEF_DATE_FORMAT"];
	this.ttDateFormat = Calendar._TT["TT_DATE_FORMAT"];
	this.isPopup = true;
	this.weekNumbers = true;
	this.firstDayOfWeek = typeof firstDayOfWeek == "number" ? firstDayOfWeek : Calendar._FD; // 0 for Sunday, 1 for Monday, etc.
	this.showsOtherMonths = false;
	this.dateStr = dateStr;
	this.ar_days = null;
	this.showsTime = false;
	this.time24 = true;
	this.yearStep = 2;
	this.hiliteToday = true;
	this.multiple = null;
	// HTML elements
	this.table = null;
	this.element = null;
	this.tbody = null;
	this.firstdayname = null;
	// Combo boxes
	this.monthsCombo = null;
	this.yearsCombo = null;
	this.hilitedMonth = null;
	this.activeMonth = null;
	this.hilitedYear = null;
	this.activeYear = null;
	// Information
	this.dateClicked = false;

	// one-time initializations
	if (typeof Calendar._SDN == "undefined") {
		// table of short day names
		if (typeof Calendar._SDN_len == "undefined")
			Calendar._SDN_len = 3;
		var ar = new Array();
		for (var i = 8; i > 0;) {
			ar[--i] = Calendar._DN[i].substr(0, Calendar._SDN_len);
		}
		Calendar._SDN = ar;
		// table of short month names
		if (typeof Calendar._SMN_len == "undefined")
			Calendar._SMN_len = 3;
		ar = new Array();
		for (var i = 12; i > 0;) {
			ar[--i] = Calendar._MN[i].substr(0, Calendar._SMN_len);
		}
		Calendar._SMN = ar;
	}
};

// ** constants

/// "static", needed for event handlers.
Calendar._C = null;

/// detect a special case of "web browser"
Calendar.is_ie = ( /msie/i.test(navigator.userAgent) &&
		   !/opera/i.test(navigator.userAgent) );

Calendar.is_ie5 = ( Calendar.is_ie && /msie 5\.0/i.test(navigator.userAgent) );

/// detect Opera browser
Calendar.is_opera = /opera/i.test(navigator.userAgent);

/// detect KHTML-based browsers
Calendar.is_khtml = /Konqueror|Safari|KHTML/i.test(navigator.userAgent);

// BEGIN: UTILITY FUNCTIONS; beware that these might be moved into a separate
//        library, at some point.

Calendar.getAbsolutePos = function(el) {
	var SL = 0, ST = 0;
	var is_div = /^div$/i.test(el.tagName);
	if (is_div && el.scrollLeft)
		SL = el.scrollLeft;
	if (is_div && el.scrollTop)
		ST = el.scrollTop;
	var r = { x: el.offsetLeft - SL, y: el.offsetTop - ST };
	if (el.offsetParent) {
		var tmp = this.getAbsolutePos(el.offsetParent);
		r.x += tmp.x;
		r.y += tmp.y;
	}
	return r;
};

Calendar.isRelated = function (el, evt) {
	var related = evt.relatedTarget;
	if (!related) {
		var type = evt.type;
		if (type == "mouseover") {
			related = evt.fromElement;
		} else if (type == "mouseout") {
			related = evt.toElement;
		}
	}
	while (related) {
		if (related == el) {
			return true;
		}
		related = related.parentNode;
	}
	return false;
};

Calendar.removeClass = function(el, className) {
	if (!(el && el.className)) {
		return;
	}
	var cls = el.className.split(" ");
	var ar = new Array();
	for (var i = cls.length; i > 0;) {
		if (cls[--i] != className) {
			ar[ar.length] = cls[i];
		}
	}
	el.className = ar.join(" ");
};

Calendar.addClass = function(el, className) {
	Calendar.removeClass(el, className);
	el.className += " " + className;
};

// FIXME: the following 2 functions totally suck, are useless and should be replaced immediately.
Calendar.getElement = function(ev) {
	var f = Calendar.is_ie ? window.event.srcElement : ev.currentTarget;
	while (f.nodeType != 1 || /^div$/i.test(f.tagName))
		f = f.parentNode;
	return f;
};

Calendar.getTargetElement = function(ev) {
	var f = Calendar.is_ie ? window.event.srcElement : ev.target;
	while (f.nodeType != 1)
		f = f.parentNode;
	return f;
};

Calendar.stopEvent = function(ev) {
	ev || (ev = window.event);
	if (Calendar.is_ie) {
		ev.cancelBubble = true;
		ev.returnValue = false;
	} else {
		ev.preventDefault();
		ev.stopPropagation();
	}
	return false;
};

Calendar.addEvent = function(el, evname, func) {
	if (el.attachEvent) { // IE
		el.attachEvent("on" + evname, func);
	} else if (el.addEventListener) { // Gecko / W3C
		el.addEventListener(evname, func, true);
	} else {
		el["on" + evname] = func;
	}
};

Calendar.removeEvent = function(el, evname, func) {
	if (el.detachEvent) { // IE
		el.detachEvent("on" + evname, func);
	} else if (el.removeEventListener) { // Gecko / W3C
		el.removeEventListener(evname, func, true);
	} else {
		el["on" + evname] = null;
	}
};

Calendar.createElement = function(type, parent) {
	var el = null;
	if (document.createElementNS) {
		// use the XHTML namespace; IE won't normally get here unless
		// _they_ "fix" the DOM2 implementation.
		el = document.createElementNS("http://www.w3.org/1999/xhtml", type);
	} else {
		el = document.createElement(type);
	}
	if (typeof parent != "undefined") {
		parent.appendChild(el);
	}
	return el;
};

// END: UTILITY FUNCTIONS

// BEGIN: CALENDAR STATIC FUNCTIONS

/** Internal -- adds a set of events to make some element behave like a button. */
Calendar._add_evs = function(el) {
	with (Calendar) {
		addEvent(el, "mouseover", dayMouseOver);
		addEvent(el, "mousedown", dayMouseDown);
		addEvent(el, "mouseout", dayMouseOut);
		if (is_ie) {
			addEvent(el, "dblclick", dayMouseDblClick);
			el.setAttribute("unselectable", true);
		}
	}
};

Calendar.findMonth = function(el) {
	if (typeof el.month != "undefined") {
		return el;
	} else if (typeof el.parentNode.month != "undefined") {
		return el.parentNode;
	}
	return null;
};

Calendar.findYear = function(el) {
	if (typeof el.year != "undefined") {
		return el;
	} else if (typeof el.parentNode.year != "undefined") {
		return el.parentNode;
	}
	return null;
};

Calendar.showMonthsCombo = function () {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	var cal = cal;
	var cd = cal.activeDiv;
	var mc = cal.monthsCombo;
	if (cal.hilitedMonth) {
		Calendar.removeClass(cal.hilitedMonth, "hilite");
	}
	if (cal.activeMonth) {
		Calendar.removeClass(cal.activeMonth, "active");
	}
	var mon = cal.monthsCombo.getElementsByTagName("div")[cal.date.getMonth()];
	Calendar.addClass(mon, "active");
	cal.activeMonth = mon;
	var s = mc.style;
	s.display = "block";
	if (cd.navtype < 0)
		s.left = cd.offsetLeft + "px";
	else {
		var mcw = mc.offsetWidth;
		if (typeof mcw == "undefined")
			// Konqueror brain-dead techniques
			mcw = 50;
		s.left = (cd.offsetLeft + cd.offsetWidth - mcw) + "px";
	}
	s.top = (cd.offsetTop + cd.offsetHeight) + "px";
};

Calendar.showYearsCombo = function (fwd) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	var cal = cal;
	var cd = cal.activeDiv;
	var yc = cal.yearsCombo;
	if (cal.hilitedYear) {
		Calendar.removeClass(cal.hilitedYear, "hilite");
	}
	if (cal.activeYear) {
		Calendar.removeClass(cal.activeYear, "active");
	}
	cal.activeYear = null;
	var Y = cal.date.getFullYear() + (fwd ? 1 : -1);
	var yr = yc.firstChild;
	var show = false;
	for (var i = 12; i > 0; --i) {
		if (Y >= cal.minYear && Y <= cal.maxYear) {
			yr.innerHTML = Y;
			yr.year = Y;
			yr.style.display = "block";
			show = true;
		} else {
			yr.style.display = "none";
		}
		yr = yr.nextSibling;
		Y += fwd ? cal.yearStep : -cal.yearStep;
	}
	if (show) {
		var s = yc.style;
		s.display = "block";
		if (cd.navtype < 0)
			s.left = cd.offsetLeft + "px";
		else {
			var ycw = yc.offsetWidth;
			if (typeof ycw == "undefined")
				// Konqueror brain-dead techniques
				ycw = 50;
			s.left = (cd.offsetLeft + cd.offsetWidth - ycw) + "px";
		}
		s.top = (cd.offsetTop + cd.offsetHeight) + "px";
	}
};

// event handlers

Calendar.tableMouseUp = function(ev) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	if (cal.timeout) {
		clearTimeout(cal.timeout);
	}
	var el = cal.activeDiv;
	if (!el) {
		return false;
	}
	var target = Calendar.getTargetElement(ev);
	ev || (ev = window.event);
	Calendar.removeClass(el, "active");
	if (target == el || target.parentNode == el) {
		Calendar.cellClick(el, ev);
	}
	var mon = Calendar.findMonth(target);
	var date = null;
	if (mon) {
		date = new Date(cal.date);
		if (mon.month != date.getMonth()) {
			date.setMonth(mon.month);
			cal.setDate(date);
			cal.dateClicked = false;
			cal.callHandler();
		}
	} else {
		var year = Calendar.findYear(target);
		if (year) {
			date = new Date(cal.date);
			if (year.year != date.getFullYear()) {
				date.setFullYear(year.year);
				cal.setDate(date);
				cal.dateClicked = false;
				cal.callHandler();
			}
		}
	}
	with (Calendar) {
		removeEvent(document, "mouseup", tableMouseUp);
		removeEvent(document, "mouseover", tableMouseOver);
		removeEvent(document, "mousemove", tableMouseOver);
		cal._hideCombos();
		_C = null;
		return stopEvent(ev);
	}
};

Calendar.tableMouseOver = function (ev) {
	var cal = Calendar._C;
	if (!cal) {
		return;
	}
	var el = cal.activeDiv;
	var target = Calendar.getTargetElement(ev);
	if (target == el || target.parentNode == el) {
		Calendar.addClass(el, "hilite active");
		Calendar.addClass(el.parentNode, "rowhilite");
	} else {
		if (typeof el.navtype == "undefined" || (el.navtype != 50 && (el.navtype == 0 || Math.abs(el.navtype) > 2)))
			Calendar.removeClass(el, "active");
		Calendar.removeClass(el, "hilite");
		Calendar.removeClass(el.parentNode, "rowhilite");
	}
	ev || (ev = window.event);
	if (el.navtype == 50 && target != el) {
		var pos = Calendar.getAbsolutePos(el);
		var w = el.offsetWidth;
		var x = ev.clientX;
		var dx;
		var decrease = true;
		if (x > pos.x + w) {
			dx = x - pos.x - w;
			decrease = false;
		} else
			dx = pos.x - x;

		if (dx < 0) dx = 0;
		var range = el._range;
		var current = el._current;
		var count = Math.floor(dx / 10) % range.length;
		for (var i = range.length; --i >= 0;)
			if (range[i] == current)
				break;
		while (count-- > 0)
			if (decrease) {
				if (--i < 0)
					i = range.length - 1;
			} else if ( ++i >= range.length )
				i = 0;
		var newval = range[i];
		el.innerHTML = newval;

		cal.onUpdateTime();
	}
	var mon = Calendar.findMonth(target);
	if (mon) {
		if (mon.month != cal.date.getMonth()) {
			if (cal.hilitedMonth) {
				Calendar.removeClass(cal.hilitedMonth, "hilite");
			}
			Calendar.addClass(mon, "hilite");
			cal.hilitedMonth = mon;
		} else if (cal.hilitedMonth) {
			Calendar.removeClass(cal.hilitedMonth, "hilite");
		}
	} else {
		if (cal.hilitedMonth) {
			Calendar.removeClass(cal.hilitedMonth, "hilite");
		}
		var year = Calendar.findYear(target);
		if (year) {
			if (year.year != cal.date.getFullYear()) {
				if (cal.hilitedYear) {
					Calendar.removeClass(cal.hilitedYear, "hilite");
				}
				Calendar.addClass(year, "hilite");
				cal.hilitedYear = year;
			} else if (cal.hilitedYear) {
				Calendar.removeClass(cal.hilitedYear, "hilite");
			}
		} else if (cal.hilitedYear) {
			Calendar.removeClass(cal.hilitedYear, "hilite");
		}
	}
	return Calendar.stopEvent(ev);
};

Calendar.tableMouseDown = function (ev) {
	if (Calendar.getTargetElement(ev) == Calendar.getElement(ev)) {
		return Calendar.stopEvent(ev);
	}
};

Calendar.calDragIt = function (ev) {
	var cal = Calendar._C;
	if (!(cal && cal.dragging)) {
		return false;
	}
	var posX;
	var posY;
	if (Calendar.is_ie) {
		posY = window.event.clientY + document.body.scrollTop;
		posX = window.event.clientX + document.body.scrollLeft;
	} else {
		posX = ev.pageX;
		posY = ev.pageY;
	}
	cal.hideShowCovered();
	var st = cal.element.style;
	st.left = (posX - cal.xOffs) + "px";
	st.top = (posY - cal.yOffs) + "px";
	return Calendar.stopEvent(ev);
};

Calendar.calDragEnd = function (ev) {
	var cal = Calendar._C;
	if (!cal) {
		return false;
	}
	cal.dragging = false;
	with (Calendar) {
		removeEvent(document, "mousemove", calDragIt);
		removeEvent(document, "mouseup", calDragEnd);
		tableMouseUp(ev);
	}
	cal.hideShowCovered();
};

Calendar.dayMouseDown = function(ev) {
	var el = Calendar.getElement(ev);
	if (el.disabled) {
		return false;
	}
	var cal = el.calendar;
	cal.activeDiv = el;
	Calendar._C = cal;
	if (el.navtype != 300) with (Calendar) {
		if (el.navtype == 50) {
			el._current = el.innerHTML;
			addEvent(document, "mousemove", tableMouseOver);
		} else
			addEvent(document, Calendar.is_ie5 ? "mousemove" : "mouseover", tableMouseOver);
		addClass(el, "hilite active");
		addEvent(document, "mouseup", tableMouseUp);
	} else if (cal.isPopup) {
		cal._dragStart(ev);
	}
	if (el.navtype == -1 || el.navtype == 1) {
		if (cal.timeout) clearTimeout(cal.timeout);
		cal.timeout = setTimeout("Calendar.showMonthsCombo()", 250);
	} else if (el.navtype == -2 || el.navtype == 2) {
		if (cal.timeout) clearTimeout(cal.timeout);
		cal.timeout = setTimeout((el.navtype > 0) ? "Calendar.showYearsCombo(true)" : "Calendar.showYearsCombo(false)", 250);
	} else {
		cal.timeout = null;
	}
	return Calendar.stopEvent(ev);
};

Calendar.dayMouseDblClick = function(ev) {
	Calendar.cellClick(Calendar.getElement(ev), ev || window.event);
	if (Calendar.is_ie) {
		document.selection.empty();
	}
};

Calendar.dayMouseOver = function(ev) {
	var el = Calendar.getElement(ev);
	if (Calendar.isRelated(el, ev) || Calendar._C || el.disabled) {
		return false;
	}
	if (el.ttip) {
		if (el.ttip.substr(0, 1) == "_") {
			el.ttip = el.caldate.print(el.calendar.ttDateFormat) + el.ttip.substr(1);
		}
		el.calendar.tooltips.innerHTML = el.ttip;
	}
	if (el.navtype != 300) {
		Calendar.addClass(el, "hilite");
		if (el.caldate) {
			Calendar.addClass(el.parentNode, "rowhilite");
		}
	}
	return Calendar.stopEvent(ev);
};

Calendar.dayMouseOut = function(ev) {
	with (Calendar) {
		var el = getElement(ev);
		if (isRelated(el, ev) || _C || el.disabled)
			return false;
		removeClass(el, "hilite");
		if (el.caldate)
			removeClass(el.parentNode, "rowhilite");
		if (el.calendar)
			el.calendar.tooltips.innerHTML = _TT["SEL_DATE"];
		return stopEvent(ev);
	}
};

/**
 *  A generic "click" handler :) handles all types of buttons defined in this
 *  calendar.
 */
Calendar.cellClick = function(el, ev) {
	var cal = el.calendar;
	var closing = false;
	var newdate = false;
	var date = null;
	if (typeof el.navtype == "undefined") {
		if (cal.currentDateEl) {
			Calendar.removeClass(cal.currentDateEl, "selected");
			Calendar.addClass(el, "selected");
			closing = (cal.currentDateEl == el);
			if (!closing) {
				cal.currentDateEl = el;
			}
		}
		cal.date.setDateOnly(el.caldate);
		date = cal.date;
		var other_month = !(cal.dateClicked = !el.otherMonth);
		if (!other_month && !cal.currentDateEl)
			cal._toggleMultipleDate(new Date(date));
		else
			newdate = !el.disabled;
		// a date was clicked
		if (other_month)
			cal._init(cal.firstDayOfWeek, date);
	} else {
		if (el.navtype == 200) {
			Calendar.removeClass(el, "hilite");
			cal.callCloseHandler();
			return;
		}
		date = new Date(cal.date);
		if (el.navtype == 0)
			date.setDateOnly(new Date()); // TODAY
		// unless "today" was clicked, we assume no date was clicked so
		// the selected handler will know not to close the calenar when
		// in single-click mode.
		// cal.dateClicked = (el.navtype == 0);
		cal.dateClicked = false;
		var year = date.getFullYear();
		var mon = date.getMonth();
		function setMonth(m) {
			var day = date.getDate();
			var max = date.getMonthDays(m);
			if (day > max) {
				date.setDate(max);
			}
			date.setMonth(m);
		};
		switch (el.navtype) {
		    case 400:
			Calendar.removeClass(el, "hilite");
			var text = Calendar._TT["ABOUT"];
			if (typeof text != "undefined") {
				text += cal.showsTime ? Calendar._TT["ABOUT_TIME"] : "";
			} else {
				// FIXME: this should be removed as soon as lang files get updated!
				text = "Help and about box text is not translated into this language.\n" +
					"If you know this language and you feel generous please update\n" +
					"the corresponding file in \"lang\" subdir to match calendar-en.js\n" +
					"and send it back to <mihai_bazon@yahoo.com> to get it into the distribution  ;-)\n\n" +
					"Thank you!\n" +
					"http://dynarch.com/mishoo/calendar.epl\n";
			}
			return;
		    case -2:
			if (year > cal.minYear) {
				date.setFullYear(year - 1);
			}
			break;
		    case -1:
			if (mon > 0) {
				setMonth(mon - 1);
			} else if (year-- > cal.minYear) {
				date.setFullYear(year);
				setMonth(11);
			}
			break;
		    case 1:
			if (mon < 11) {
				setMonth(mon + 1);
			} else if (year < cal.maxYear) {
				date.setFullYear(year + 1);
				setMonth(0);
			}
			break;
		    case 2:
			if (year < cal.maxYear) {
				date.setFullYear(year + 1);
			}
			break;
		    case 100:
			cal.setFirstDayOfWeek(el.fdow);
			return;
		    case 50:
			var range = el._range;
			var current = el.innerHTML;
			for (var i = range.length; --i >= 0;)
				if (range[i] == current)
					break;
			if (ev && ev.shiftKey) {
				if (--i < 0)
					i = range.length - 1;
			} else if ( ++i >= range.length )
				i = 0;
			var newval = range[i];
			el.innerHTML = newval;
			cal.onUpdateTime();
			return;
		    case 0:
			// TODAY will bring us here
			if ((typeof cal.getDateStatus == "function") &&
			    cal.getDateStatus(date, date.getFullYear(), date.getMonth(), date.getDate())) {
				return false;
			}
			break;
		}
		if (!date.equalsTo(cal.date)) {
			cal.setDate(date);
			newdate = true;
		} else if (el.navtype == 0)
			newdate = closing = true;
	}
	if (newdate) {
		ev && cal.callHandler();
	}
	if (closing) {
		Calendar.removeClass(el, "hilite");
		ev && cal.callCloseHandler();
	}
};

// END: CALENDAR STATIC FUNCTIONS

// BEGIN: CALENDAR OBJECT FUNCTIONS

/**
 *  This function creates the calendar inside the given parent.  If _par is
 *  null than it creates a popup calendar inside the BODY element.  If _par is
 *  an element, be it BODY, then it creates a non-popup calendar (still
 *  hidden).  Some properties need to be set before calling this function.
 */
Calendar.prototype.create = function (_par) {
	var parent = null;
	if (! _par) {
		// default parent is the document body, in which case we create
		// a popup calendar.
		parent = document.getElementsByTagName("body")[0];
		this.isPopup = true;
	} else {
		parent = _par;
		this.isPopup = false;
	}
	this.date = this.dateStr ? new Date(this.dateStr) : new Date();

	var table = Calendar.createElement("table");
	this.table = table;
	table.cellSpacing = 0;
	table.cellPadding = 0;
	table.calendar = this;
	Calendar.addEvent(table, "mousedown", Calendar.tableMouseDown);

	var div = Calendar.createElement("div");
	this.element = div;
	div.className = "calendar";
	if (this.isPopup) {
		div.style.position = "absolute";
		div.style.display = "none";
		div.style.zIndex = "1000"; 
	}
	div.appendChild(table);

	var thead = Calendar.createElement("thead", table);
	var cell = null;
	var row = null;

	var cal = this;
	var hh = function (text, cs, navtype) {
		cell = Calendar.createElement("td", row);
		cell.colSpan = cs;
		cell.className = "button";
		if (navtype != 0 && Math.abs(navtype) <= 2)
			cell.className += " nav";
		Calendar._add_evs(cell);
		cell.calendar = cal;
		cell.navtype = navtype;
		cell.innerHTML = "<div unselectable='on'>" + text + "</div>";
		return cell;
	};

	row = Calendar.createElement("tr", thead);
	var title_length = 6;
	(this.isPopup) && --title_length;
	(this.weekNumbers) && ++title_length;

	hh("?", 1, 400).ttip = Calendar._TT["INFO"];
	this.title = hh("", title_length, 300);
	this.title.className = "title";
	if (this.isPopup) {
		this.title.ttip = Calendar._TT["DRAG_TO_MOVE"];
		this.title.style.cursor = "move";
		hh("&#x00d7;", 1, 200).ttip = Calendar._TT["CLOSE"];
	}

	row = Calendar.createElement("tr", thead);
	row.className = "headrow";

	this._nav_py = hh("&#x00ab;", 1, -2);
	this._nav_py.ttip = Calendar._TT["PREV_YEAR"];

	this._nav_pm = hh("&#x2039;", 1, -1);
	this._nav_pm.ttip = Calendar._TT["PREV_MONTH"];

	this._nav_now = hh(Calendar._TT["TODAY"], this.weekNumbers ? 4 : 3, 0);
	this._nav_now.ttip = Calendar._TT["GO_TODAY"];

	this._nav_nm = hh("&#x203a;", 1, 1);
	this._nav_nm.ttip = Calendar._TT["NEXT_MONTH"];

	this._nav_ny = hh("&#x00bb;", 1, 2);
	this._nav_ny.ttip = Calendar._TT["NEXT_YEAR"];

	// day names
	row = Calendar.createElement("tr", thead);
	row.className = "daynames";
	if (this.weekNumbers) {
		cell = Calendar.createElement("td", row);
		cell.className = "name wn";
		cell.innerHTML = Calendar._TT["WK"];
	}
	for (var i = 7; i > 0; --i) {
		cell = Calendar.createElement("td", row);
		if (!i) {
			cell.navtype = 100;
			cell.calendar = this;
			Calendar._add_evs(cell);
		}
	}
	this.firstdayname = (this.weekNumbers) ? row.firstChild.nextSibling : row.firstChild;
	this._displayWeekdays();

	var tbody = Calendar.createElement("tbody", table);
	this.tbody = tbody;

	for (i = 6; i > 0; --i) {
		row = Calendar.createElement("tr", tbody);
		if (this.weekNumbers) {
			cell = Calendar.createElement("td", row);
		}
		for (var j = 7; j > 0; --j) {
			cell = Calendar.createElement("td", row);
			cell.calendar = this;
			Calendar._add_evs(cell);
		}
	}

	if (this.showsTime) {
		row = Calendar.createElement("tr", tbody);
		row.className = "time";

		cell = Calendar.createElement("td", row);
		cell.className = "time";
		cell.colSpan = 2;
		cell.innerHTML = Calendar._TT["TIME"] || "&nbsp;";

		cell = Calendar.createElement("td", row);
		cell.className = "time";
		cell.colSpan = this.weekNumbers ? 4 : 3;

		(function(){
			function makeTimePart(className, init, range_start, range_end) {
				var part = Calendar.createElement("span", cell);
				part.className = className;
				part.innerHTML = init;
				part.calendar = cal;
				part.ttip = Calendar._TT["TIME_PART"];
				part.navtype = 50;
				part._range = [];
				if (typeof range_start != "number")
					part._range = range_start;
				else {
					for (var i = range_start; i <= range_end; ++i) {
						var txt;
						if (i < 10 && range_end >= 10) txt = '0' + i;
						else txt = '' + i;
						part._range[part._range.length] = txt;
					}
				}
				Calendar._add_evs(part);
				return part;
			};
			var hrs = cal.date.getHours();
			var mins = cal.date.getMinutes();
			var t12 = !cal.time24;
			var pm = (hrs > 12);
			if (t12 && pm) hrs -= 12;
			var H = makeTimePart("hour", hrs, t12 ? 1 : 0, t12 ? 12 : 23);
			var span = Calendar.createElement("span", cell);
			span.innerHTML = ":";
			span.className = "colon";
			var M = makeTimePart("minute", mins, 0, 59);
			var AP = null;
			cell = Calendar.createElement("td", row);
			cell.className = "time";
			cell.colSpan = 2;
			if (t12)
				AP = makeTimePart("ampm", pm ? "pm" : "am", ["am", "pm"]);
			else
				cell.innerHTML = "&nbsp;";

			cal.onSetTime = function() {
				var pm, hrs = this.date.getHours(),
					mins = this.date.getMinutes();
				if (t12) {
					pm = (hrs >= 12);
					if (pm) hrs -= 12;
					if (hrs == 0) hrs = 12;
					AP.innerHTML = pm ? "pm" : "am";
				}
				H.innerHTML = (hrs < 10) ? ("0" + hrs) : hrs;
				M.innerHTML = (mins < 10) ? ("0" + mins) : mins;
			};

			cal.onUpdateTime = function() {
				var date = this.date;
				var h = parseInt(H.innerHTML, 10);
				if (t12) {
					if (/pm/i.test(AP.innerHTML) && h < 12)
						h += 12;
					else if (/am/i.test(AP.innerHTML) && h == 12)
						h = 0;
				}
				var d = date.getDate();
				var m = date.getMonth();
				var y = date.getFullYear();
				date.setHours(h);
				date.setMinutes(parseInt(M.innerHTML, 10));
				date.setFullYear(y);
				date.setMonth(m);
				date.setDate(d);
				this.dateClicked = false;
				this.callHandler();
			};
		})();
	} else {
		this.onSetTime = this.onUpdateTime = function() {};
	}

	var tfoot = Calendar.createElement("tfoot", table);

	row = Calendar.createElement("tr", tfoot);
	row.className = "footrow";

	cell = hh(Calendar._TT["SEL_DATE"], this.weekNumbers ? 8 : 7, 300);
	cell.className = "ttip";
	if (this.isPopup) {
		cell.ttip = Calendar._TT["DRAG_TO_MOVE"];
		cell.style.cursor = "move";
	}
	this.tooltips = cell;

	div = Calendar.createElement("div", this.element);
	this.monthsCombo = div;
	div.className = "combo";
	for (i = 0; i < Calendar._MN.length; ++i) {
		var mn = Calendar.createElement("div");
		mn.className = Calendar.is_ie ? "label-IEfix" : "label";
		mn.month = i;
		mn.innerHTML = Calendar._SMN[i];
		div.appendChild(mn);
	}

	div = Calendar.createElement("div", this.element);
	this.yearsCombo = div;
	div.className = "combo";
	for (i = 12; i > 0; --i) {
		var yr = Calendar.createElement("div");
		yr.className = Calendar.is_ie ? "label-IEfix" : "label";
		div.appendChild(yr);
	}

	this._init(this.firstDayOfWeek, this.date);
	parent.appendChild(this.element);
};

/** keyboard navigation, only for popup calendars */
Calendar._keyEvent = function(ev) {
	var cal = window._dynarch_popupCalendar;
	if (!cal || cal.multiple)
		return false;
	(Calendar.is_ie) && (ev = window.event);
	var act = (Calendar.is_ie || ev.type == "keypress"),
		K = ev.keyCode;
	if (ev.ctrlKey) {
		switch (K) {
		    case 37: // KEY left
			act && Calendar.cellClick(cal._nav_pm);
			break;
		    case 38: // KEY up
			act && Calendar.cellClick(cal._nav_py);
			break;
		    case 39: // KEY right
			act && Calendar.cellClick(cal._nav_nm);
			break;
		    case 40: // KEY down
			act && Calendar.cellClick(cal._nav_ny);
			break;
		    default:
			return false;
		}
	} else switch (K) {
	    case 32: // KEY space (now)
		Calendar.cellClick(cal._nav_now);
		break;
	    case 27: // KEY esc
		act && cal.callCloseHandler();
		break;
	    case 37: // KEY left
	    case 38: // KEY up
	    case 39: // KEY right
	    case 40: // KEY down
		if (act) {
			var prev, x, y, ne, el, step;
			prev = K == 37 || K == 38;
			step = (K == 37 || K == 39) ? 1 : 7;
			function setVars() {
				el = cal.currentDateEl;
				var p = el.pos;
				x = p & 15;
				y = p >> 4;
				ne = cal.ar_days[y][x];
			};setVars();
			function prevMonth() {
				var date = new Date(cal.date);
				date.setDate(date.getDate() - step);
				cal.setDate(date);
			};
			function nextMonth() {
				var date = new Date(cal.date);
				date.setDate(date.getDate() + step);
				cal.setDate(date);
			};
			while (1) {
				switch (K) {
				    case 37: // KEY left
					if (--x >= 0)
						ne = cal.ar_days[y][x];
					else {
						x = 6;
						K = 38;
						continue;
					}
					break;
				    case 38: // KEY up
					if (--y >= 0)
						ne = cal.ar_days[y][x];
					else {
						prevMonth();
						setVars();
					}
					break;
				    case 39: // KEY right
					if (++x < 7)
						ne = cal.ar_days[y][x];
					else {
						x = 0;
						K = 40;
						continue;
					}
					break;
				    case 40: // KEY down
					if (++y < cal.ar_days.length)
						ne = cal.ar_days[y][x];
					else {
						nextMonth();
						setVars();
					}
					break;
				}
				break;
			}
			if (ne) {
				if (!ne.disabled)
					Calendar.cellClick(ne);
				else if (prev)
					prevMonth();
				else
					nextMonth();
			}
		}
		break;
	    case 13: // KEY enter
		if (act)
			Calendar.cellClick(cal.currentDateEl, ev);
		break;
	    default:
		return false;
	}
	return Calendar.stopEvent(ev);
};

/**
 *  (RE)Initializes the calendar to the given date and firstDayOfWeek
 */
Calendar.prototype._init = function (firstDayOfWeek, date) {
	var today = new Date(),
		TY = today.getFullYear(),
		TM = today.getMonth(),
		TD = today.getDate();
	this.table.style.visibility = "hidden";
	var year = date.getFullYear();
	if (year < this.minYear) {
		year = this.minYear;
		date.setFullYear(year);
	} else if (year > this.maxYear) {
		year = this.maxYear;
		date.setFullYear(year);
	}
	this.firstDayOfWeek = firstDayOfWeek;
	this.date = new Date(date);
	var month = date.getMonth();
	var mday = date.getDate();
	var no_days = date.getMonthDays();

	// calendar voodoo for computing the first day that would actually be
	// displayed in the calendar, even if it's from the previous month.
	// WARNING: this is magic. ;-)
	date.setDate(1);
	var day1 = (date.getDay() - this.firstDayOfWeek) % 7;
	if (day1 < 0)
		day1 += 7;
	date.setDate(-day1);
	date.setDate(date.getDate() + 1);

	var row = this.tbody.firstChild;
	var MN = Calendar._SMN[month];
	var ar_days = this.ar_days = new Array();
	var weekend = Calendar._TT["WEEKEND"];
	var dates = this.multiple ? (this.datesCells = {}) : null;
	for (var i = 0; i < 6; ++i, row = row.nextSibling) {
		var cell = row.firstChild;
		if (this.weekNumbers) {
			cell.className = "day wn";
			cell.innerHTML = date.getWeekNumber();
			cell = cell.nextSibling;
		}
		row.className = "daysrow";
		var hasdays = false, iday, dpos = ar_days[i] = [];
		for (var j = 0; j < 7; ++j, cell = cell.nextSibling, date.setDate(iday + 1)) {
			iday = date.getDate();
			var wday = date.getDay();
			cell.className = "day";
			cell.pos = i << 4 | j;
			dpos[j] = cell;
			var current_month = (date.getMonth() == month);
			if (!current_month) {
				if (this.showsOtherMonths) {
					cell.className += " othermonth";
					cell.otherMonth = true;
				} else {
					cell.className = "emptycell";
					cell.innerHTML = "&nbsp;";
					cell.disabled = true;
					continue;
				}
			} else {
				cell.otherMonth = false;
				hasdays = true;
			}
			cell.disabled = false;
			cell.innerHTML = this.getDateText ? this.getDateText(date, iday) : iday;
			if (dates)
				dates[date.print("%Y%m%d")] = cell;
			if (this.getDateStatus) {
				var status = this.getDateStatus(date, year, month, iday);
				if (this.getDateToolTip) {
					var toolTip = this.getDateToolTip(date, year, month, iday);
					if (toolTip)
						cell.title = toolTip;
				}
				if (status === true) {
					cell.className += " disabled";
					cell.disabled = true;
				} else {
					if (/disabled/i.test(status))
						cell.disabled = true;
					cell.className += " " + status;
				}
			}
			if (!cell.disabled) {
				cell.caldate = new Date(date);
				cell.ttip = "_";
				if (!this.multiple && current_month
				    && iday == mday && this.hiliteToday) {
					cell.className += " selected";
					this.currentDateEl = cell;
				}
				if (date.getFullYear() == TY &&
				    date.getMonth() == TM &&
				    iday == TD) {
					cell.className += " today";
					cell.ttip += Calendar._TT["PART_TODAY"];
				}
				if (weekend.indexOf(wday.toString()) != -1)
					cell.className += cell.otherMonth ? " oweekend" : " weekend";
			}
		}
		if (!(hasdays || this.showsOtherMonths))
			row.className = "emptyrow";
	}
	this.title.innerHTML = Calendar._MN[month] + ", " + year;
	this.onSetTime();
	this.table.style.visibility = "visible";
	this._initMultipleDates();
	// PROFILE
	// this.tooltips.innerHTML = "Generated in " + ((new Date()) - today) + " ms";
};

Calendar.prototype._initMultipleDates = function() {
	if (this.multiple) {
		for (var i in this.multiple) {
			var cell = this.datesCells[i];
			var d = this.multiple[i];
			if (!d)
				continue;
			if (cell)
				cell.className += " selected";
		}
	}
};

Calendar.prototype._toggleMultipleDate = function(date) {
	if (this.multiple) {
		var ds = date.print("%Y%m%d");
		var cell = this.datesCells[ds];
		if (cell) {
			var d = this.multiple[ds];
			if (!d) {
				Calendar.addClass(cell, "selected");
				this.multiple[ds] = date;
			} else {
				Calendar.removeClass(cell, "selected");
				delete this.multiple[ds];
			}
		}
	}
};

Calendar.prototype.setDateToolTipHandler = function (unaryFunction) {
	this.getDateToolTip = unaryFunction;
};

/**
 *  Calls _init function above for going to a certain date (but only if the
 *  date is different than the currently selected one).
 */
Calendar.prototype.setDate = function (date) {
	if (!date.equalsTo(this.date)) {
		this._init(this.firstDayOfWeek, date);
	}
};

/**
 *  Refreshes the calendar.  Useful if the "disabledHandler" function is
 *  dynamic, meaning that the list of disabled date can change at runtime.
 *  Just * call this function if you think that the list of disabled dates
 *  should * change.
 */
Calendar.prototype.refresh = function () {
	this._init(this.firstDayOfWeek, this.date);
};

/** Modifies the "firstDayOfWeek" parameter (pass 0 for Synday, 1 for Monday, etc.). */
Calendar.prototype.setFirstDayOfWeek = function (firstDayOfWeek) {
	this._init(firstDayOfWeek, this.date);
	this._displayWeekdays();
};

/**
 *  Allows customization of what dates are enabled.  The "unaryFunction"
 *  parameter must be a function object that receives the date (as a JS Date
 *  object) and returns a boolean value.  If the returned value is true then
 *  the passed date will be marked as disabled.
 */
Calendar.prototype.setDateStatusHandler = Calendar.prototype.setDisabledHandler = function (unaryFunction) {
	this.getDateStatus = unaryFunction;
};

/** Customization of allowed year range for the calendar. */
Calendar.prototype.setRange = function (a, z) {
	this.minYear = a;
	this.maxYear = z;
};

/** Calls the first user handler (selectedHandler). */
Calendar.prototype.callHandler = function () {
	if (this.onSelected) {
		this.onSelected(this, this.date.print(this.dateFormat));
	}
};

/** Calls the second user handler (closeHandler). */
Calendar.prototype.callCloseHandler = function () {
	if (this.onClose) {
		this.onClose(this);
	}
	this.hideShowCovered();
};

/** Removes the calendar object from the DOM tree and destroys it. */
Calendar.prototype.destroy = function () {
	var el = this.element.parentNode;
	el.removeChild(this.element);
	Calendar._C = null;
	window._dynarch_popupCalendar = null;
};

/**
 *  Moves the calendar element to a different section in the DOM tree (changes
 *  its parent).
 */
Calendar.prototype.reparent = function (new_parent) {
	var el = this.element;
	el.parentNode.removeChild(el);
	new_parent.appendChild(el);
};

// This gets called when the user presses a mouse button anywhere in the
// document, if the calendar is shown.  If the click was outside the open
// calendar this function closes it.
Calendar._checkCalendar = function(ev) {
	var calendar = window._dynarch_popupCalendar;
	if (!calendar) {
		return false;
	}
	var el = Calendar.is_ie ? Calendar.getElement(ev) : Calendar.getTargetElement(ev);
	for (; el != null && el != calendar.element; el = el.parentNode);
	if (el == null) {
		// calls closeHandler which should hide the calendar.
		window._dynarch_popupCalendar.callCloseHandler();
		return Calendar.stopEvent(ev);
	}
};

/** Shows the calendar. */
Calendar.prototype.show = function () {
	var rows = this.table.getElementsByTagName("tr");
	for (var i = rows.length; i > 0;) {
		var row = rows[--i];
		Calendar.removeClass(row, "rowhilite");
		var cells = row.getElementsByTagName("td");
		for (var j = cells.length; j > 0;) {
			var cell = cells[--j];
			Calendar.removeClass(cell, "hilite");
			Calendar.removeClass(cell, "active");
		}
	}
	this.element.style.display = "block";
	this.hidden = false;
	if (this.isPopup) {
		window._dynarch_popupCalendar = this;
		Calendar.addEvent(document, "keydown", Calendar._keyEvent);
		Calendar.addEvent(document, "keypress", Calendar._keyEvent);
		Calendar.addEvent(document, "mousedown", Calendar._checkCalendar);
	}
	this.hideShowCovered();
};

/**
 *  Hides the calendar.  Also removes any "hilite" from the class of any TD
 *  element.
 */
Calendar.prototype.hide = function () {
	if (this.isPopup) {
		Calendar.removeEvent(document, "keydown", Calendar._keyEvent);
		Calendar.removeEvent(document, "keypress", Calendar._keyEvent);
		Calendar.removeEvent(document, "mousedown", Calendar._checkCalendar);
	}
	this.element.style.display = "none";
	this.hidden = true;
	this.hideShowCovered();
};

/**
 *  Shows the calendar at a given absolute position (beware that, depending on
 *  the calendar element style -- position property -- this might be relative
 *  to the parent's containing rectangle).
 */
Calendar.prototype.showAt = function (x, y) {
	var s = this.element.style;
	s.left = x + "px";
	s.top = y + "px";
	this.show();
};

/** Shows the calendar near a given element. */
Calendar.prototype.showAtElement = function (el, opts) {
	var self = this;
	var p = Calendar.getAbsolutePos(el);
	if (!opts || typeof opts != "string") {
		this.showAt(p.x, p.y + el.offsetHeight);
		return true;
	}
	function fixPosition(box) {
		if (box.x < 0)
			box.x = 0;
		if (box.y < 0)
			box.y = 0;
		var cp = document.createElement("div");
		var s = cp.style;
		s.position = "absolute";
		s.right = s.bottom = s.width = s.height = "0px";
		document.body.appendChild(cp);
		var br = Calendar.getAbsolutePos(cp);
		document.body.removeChild(cp);
		if (Calendar.is_ie) {
			br.y += document.body.scrollTop;
			br.x += document.body.scrollLeft;
		} else {
			br.y += window.scrollY;
			br.x += window.scrollX;
		}
		var tmp = box.x + box.width - br.x;
		if (tmp > 0) box.x -= tmp;
		tmp = box.y + box.height - br.y;
		if (tmp > 0) box.y -= tmp;
	};
	this.element.style.display = "block";
	Calendar.continuation_for_the_fucking_khtml_browser = function() {
		var w = self.element.offsetWidth;
		var h = self.element.offsetHeight;
		self.element.style.display = "none";
		var valign = opts.substr(0, 1);
		var halign = "l";
		if (opts.length > 1) {
			halign = opts.substr(1, 1);
		}
		// vertical alignment
		switch (valign) {
		    case "T": p.y -= h; break;
		    case "B": p.y += el.offsetHeight; break;
		    case "C": p.y += (el.offsetHeight - h) / 2; break;
		    case "t": p.y += el.offsetHeight - h; break;
		    case "b": break; // already there
		}
		// horizontal alignment
		switch (halign) {
		    case "L": p.x -= w; break;
		    case "R": p.x += el.offsetWidth; break;
		    case "C": p.x += (el.offsetWidth - w) / 2; break;
		    case "l": p.x += el.offsetWidth - w; break;
		    case "r": break; // already there
		}
		p.width = w;
		p.height = h + 40;
		self.monthsCombo.style.display = "none";
		fixPosition(p);
		self.showAt(p.x, p.y);
	};
	if (Calendar.is_khtml)
		setTimeout("Calendar.continuation_for_the_fucking_khtml_browser()", 10);
	else
		Calendar.continuation_for_the_fucking_khtml_browser();
};

/** Customizes the date format. */
Calendar.prototype.setDateFormat = function (str) {
	this.dateFormat = str;
};

/** Customizes the tooltip date format. */
Calendar.prototype.setTtDateFormat = function (str) {
	this.ttDateFormat = str;
};

/**
 *  Tries to identify the date represented in a string.  If successful it also
 *  calls this.setDate which moves the calendar to the given date.
 */
Calendar.prototype.parseDate = function(str, fmt) {
	if (!fmt)
		fmt = this.dateFormat;
	this.setDate(Date.parseDate(str, fmt));
};

Calendar.prototype.hideShowCovered = function () {
	if (!Calendar.is_ie && !Calendar.is_opera)
		return;
	function getVisib(obj){
		var value = obj.style.visibility;
		if (!value) {
			if (document.defaultView && typeof (document.defaultView.getComputedStyle) == "function") { // Gecko, W3C
				if (!Calendar.is_khtml)
					value = document.defaultView.
						getComputedStyle(obj, "").getPropertyValue("visibility");
				else
					value = '';
			} else if (obj.currentStyle) { // IE
				value = obj.currentStyle.visibility;
			} else
				value = '';
		}
		return value;
	};

	var tags = new Array("applet", "iframe", "select");
	var el = this.element;

	var p = Calendar.getAbsolutePos(el);
	var EX1 = p.x;
	var EX2 = el.offsetWidth + EX1;
	var EY1 = p.y;
	var EY2 = el.offsetHeight + EY1;

	for (var k = tags.length; k > 0; ) {
		var ar = document.getElementsByTagName(tags[--k]);
		var cc = null;

		for (var i = ar.length; i > 0;) {
			cc = ar[--i];

			p = Calendar.getAbsolutePos(cc);
			var CX1 = p.x;
			var CX2 = cc.offsetWidth + CX1;
			var CY1 = p.y;
			var CY2 = cc.offsetHeight + CY1;

			if (this.hidden || (CX1 > EX2) || (CX2 < EX1) || (CY1 > EY2) || (CY2 < EY1)) {
				if (!cc.__msh_save_visibility) {
					cc.__msh_save_visibility = getVisib(cc);
				}
				cc.style.visibility = cc.__msh_save_visibility;
			} else {
				if (!cc.__msh_save_visibility) {
					cc.__msh_save_visibility = getVisib(cc);
				}
				cc.style.visibility = "hidden";
			}
		}
	}
};

/** Internal function; it displays the bar with the names of the weekday. */
Calendar.prototype._displayWeekdays = function () {
	var fdow = this.firstDayOfWeek;
	var cell = this.firstdayname;
	var weekend = Calendar._TT["WEEKEND"];
	for (var i = 0; i < 7; ++i) {
		cell.className = "day name";
		var realday = (i + fdow) % 7;
		if (i) {
			cell.ttip = Calendar._TT["DAY_FIRST"].replace("%s", Calendar._DN[realday]);
			cell.navtype = 100;
			cell.calendar = this;
			cell.fdow = realday;
			Calendar._add_evs(cell);
		}
		if (weekend.indexOf(realday.toString()) != -1) {
			Calendar.addClass(cell, "weekend");
		}
		cell.innerHTML = Calendar._SDN[(i + fdow) % 7];
		cell = cell.nextSibling;
	}
};

/** Internal function.  Hides all combo boxes that might be displayed. */
Calendar.prototype._hideCombos = function () {
	this.monthsCombo.style.display = "none";
	this.yearsCombo.style.display = "none";
};

/** Internal function.  Starts dragging the element. */
Calendar.prototype._dragStart = function (ev) {
	if (this.dragging) {
		return;
	}
	this.dragging = true;
	var posX;
	var posY;
	if (Calendar.is_ie) {
		posY = window.event.clientY + document.body.scrollTop;
		posX = window.event.clientX + document.body.scrollLeft;
	} else {
		posY = ev.clientY + window.scrollY;
		posX = ev.clientX + window.scrollX;
	}
	var st = this.element.style;
	this.xOffs = posX - parseInt(st.left);
	this.yOffs = posY - parseInt(st.top);
	with (Calendar) {
		addEvent(document, "mousemove", calDragIt);
		addEvent(document, "mouseup", calDragEnd);
	}
};

// BEGIN: DATE OBJECT PATCHES

/** Adds the number of days array to the Date object. */
Date._MD = new Array(31,28,31,30,31,30,31,31,30,31,30,31);

/** Constants used for time computations */
Date.SECOND = 1000 /* milliseconds */;
Date.MINUTE = 60 * Date.SECOND;
Date.HOUR   = 60 * Date.MINUTE;
Date.DAY    = 24 * Date.HOUR;
Date.WEEK   =  7 * Date.DAY;

Date.parseDate = function(str, fmt) {
	var today = new Date();
	var y = 0;
	var m = -1;
	var d = 0;
	var a = str.split(/\W+/);
	var b = fmt.match(/%./g);
	var i = 0, j = 0;
	var hr = 0;
	var min = 0;
	for (i = 0; i < a.length; ++i) {
		if (!a[i])
			continue;
		switch (b[i]) {
		    case "%d":
		    case "%e":
			d = parseInt(a[i], 10);
			break;

		    case "%m":
			m = parseInt(a[i], 10) - 1;
			break;

		    case "%Y":
		    case "%y":
			y = parseInt(a[i], 10);
			(y < 100) && (y += (y > 29) ? 1900 : 2000);
			break;

		    case "%b":
		    case "%B":
			for (j = 0; j < 12; ++j) {
				if (Calendar._MN[j].substr(0, a[i].length).toLowerCase() == a[i].toLowerCase()) { m = j; break; }
			}
			break;

		    case "%H":
		    case "%I":
		    case "%k":
		    case "%l":
			hr = parseInt(a[i], 10);
			break;

		    case "%P":
		    case "%p":
			if (/pm/i.test(a[i]) && hr < 12)
				hr += 12;
			else if (/am/i.test(a[i]) && hr >= 12)
				hr -= 12;
			break;

		    case "%M":
			min = parseInt(a[i], 10);
			break;
		}
	}
	if (isNaN(y)) y = today.getFullYear();
	if (isNaN(m)) m = today.getMonth();
	if (isNaN(d)) d = today.getDate();
	if (isNaN(hr)) hr = today.getHours();
	if (isNaN(min)) min = today.getMinutes();
	if (y != 0 && m != -1 && d != 0)
		return new Date(y, m, d, hr, min, 0);
	y = 0; m = -1; d = 0;
	for (i = 0; i < a.length; ++i) {
		if (a[i].search(/[a-zA-Z]+/) != -1) {
			var t = -1;
			for (j = 0; j < 12; ++j) {
				if (Calendar._MN[j].substr(0, a[i].length).toLowerCase() == a[i].toLowerCase()) { t = j; break; }
			}
			if (t != -1) {
				if (m != -1) {
					d = m+1;
				}
				m = t;
			}
		} else if (parseInt(a[i], 10) <= 12 && m == -1) {
			m = a[i]-1;
		} else if (parseInt(a[i], 10) > 31 && y == 0) {
			y = parseInt(a[i], 10);
			(y < 100) && (y += (y > 29) ? 1900 : 2000);
		} else if (d == 0) {
			d = a[i];
		}
	}
	if (y == 0)
		y = today.getFullYear();
	if (m != -1 && d != 0)
		return new Date(y, m, d, hr, min, 0);
	return today;
};

/** Returns the number of days in the current month */
Date.prototype.getMonthDays = function(month) {
	var year = this.getFullYear();
	if (typeof month == "undefined") {
		month = this.getMonth();
	}
	if (((0 == (year%4)) && ( (0 != (year%100)) || (0 == (year%400)))) && month == 1) {
		return 29;
	} else {
		return Date._MD[month];
	}
};

/** Returns the number of day in the year. */
Date.prototype.getDayOfYear = function() {
	var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0);
	var then = new Date(this.getFullYear(), 0, 0, 0, 0, 0);
	var time = now - then;
	return Math.floor(time / Date.DAY);
};

/** Returns the number of the week in year, as defined in ISO 8601. */
Date.prototype.getWeekNumber = function() {
	var d = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0);
	var DoW = d.getDay();
	d.setDate(d.getDate() - (DoW + 6) % 7 + 3); // Nearest Thu
	var ms = d.valueOf(); // GMT
	d.setMonth(0);
	d.setDate(4); // Thu in Week 1
	return Math.round((ms - d.valueOf()) / (7 * 864e5)) + 1;
};

/** Checks date and time equality */
Date.prototype.equalsTo = function(date) {
	return ((this.getFullYear() == date.getFullYear()) &&
		(this.getMonth() == date.getMonth()) &&
		(this.getDate() == date.getDate()) &&
		(this.getHours() == date.getHours()) &&
		(this.getMinutes() == date.getMinutes()));
};

/** Set only the year, month, date parts (keep existing time) */
Date.prototype.setDateOnly = function(date) {
	var tmp = new Date(date);
	this.setDate(1);
	this.setFullYear(tmp.getFullYear());
	this.setMonth(tmp.getMonth());
	this.setDate(tmp.getDate());
};

/** Prints the date in a string according to the given format. */
Date.prototype.print = function (str) {
	var m = this.getMonth();
	var d = this.getDate();
	var y = this.getFullYear();
	var wn = this.getWeekNumber();
	var w = this.getDay();
	var s = {};
	var hr = this.getHours();
	var pm = (hr >= 12);
	var ir = (pm) ? (hr - 12) : hr;
	var dy = this.getDayOfYear();
	if (ir == 0)
		ir = 12;
	var min = this.getMinutes();
	var sec = this.getSeconds();
	s["%a"] = Calendar._SDN[w]; // abbreviated weekday name [FIXME: I18N]
	s["%A"] = Calendar._DN[w]; // full weekday name
	s["%b"] = Calendar._SMN[m]; // abbreviated month name [FIXME: I18N]
	s["%B"] = Calendar._MN[m]; // full month name
	// FIXME: %c : preferred date and time representation for the current locale
	s["%C"] = 1 + Math.floor(y / 100); // the century number
	s["%d"] = (d < 10) ? ("0" + d) : d; // the day of the month (range 01 to 31)
	s["%e"] = d; // the day of the month (range 1 to 31)
	// FIXME: %D : american date style: %m/%d/%y
	// FIXME: %E, %F, %G, %g, %h (man strftime)
	s["%H"] = (hr < 10) ? ("0" + hr) : hr; // hour, range 00 to 23 (24h format)
	s["%I"] = (ir < 10) ? ("0" + ir) : ir; // hour, range 01 to 12 (12h format)
	s["%j"] = (dy < 100) ? ((dy < 10) ? ("00" + dy) : ("0" + dy)) : dy; // day of the year (range 001 to 366)
	s["%k"] = hr;		// hour, range 0 to 23 (24h format)
	s["%l"] = ir;		// hour, range 1 to 12 (12h format)
	s["%m"] = (m < 9) ? ("0" + (1+m)) : (1+m); // month, range 01 to 12
	s["%M"] = (min < 10) ? ("0" + min) : min; // minute, range 00 to 59
	s["%n"] = "\n";		// a newline character
	s["%p"] = pm ? "PM" : "AM";
	s["%P"] = pm ? "pm" : "am";
	// FIXME: %r : the time in am/pm notation %I:%M:%S %p
	// FIXME: %R : the time in 24-hour notation %H:%M
	s["%s"] = Math.floor(this.getTime() / 1000);
	s["%S"] = (sec < 10) ? ("0" + sec) : sec; // seconds, range 00 to 59
	s["%t"] = "\t";		// a tab character
	// FIXME: %T : the time in 24-hour notation (%H:%M:%S)
	s["%U"] = s["%W"] = s["%V"] = (wn < 10) ? ("0" + wn) : wn;
	s["%u"] = w + 1;	// the day of the week (range 1 to 7, 1 = MON)
	s["%w"] = w;		// the day of the week (range 0 to 6, 0 = SUN)
	// FIXME: %x : preferred date representation for the current locale without the time
	// FIXME: %X : preferred time representation for the current locale without the date
	s["%y"] = ('' + y).substr(2, 2); // year without the century (range 00 to 99)
	s["%Y"] = y;		// year with the century
	s["%%"] = "%";		// a literal '%' character

	var re = /%./g;
	if (!Calendar.is_ie5 && !Calendar.is_khtml)
		return str.replace(re, function (par) { return s[par] || par; });

	var a = str.match(re);
	for (var i = 0; i < a.length; i++) {
		var tmp = s[a[i]];
		if (tmp) {
			re = new RegExp(a[i], 'g');
			str = str.replace(re, tmp);
		}
	}

	return str;
};

Date.prototype.__msh_oldSetFullYear = Date.prototype.setFullYear;
Date.prototype.setFullYear = function(y) {
	var d = new Date(this);
	d.__msh_oldSetFullYear(y);
	if (d.getMonth() != this.getMonth())
		this.setDate(28);
	this.__msh_oldSetFullYear(y);
};

// END: DATE OBJECT PATCHES


// global object that remembers the calendar
window._dynarch_popupCalendar = null;

// ** I18N

// Calendar EN language
// Author: Mihai Bazon, <mihai_bazon@yahoo.com>
// Encoding: any
// Distributed under the same terms as the calendar itself.

// For translators: please use UTF-8 if possible.  We strongly believe that
// Unicode is the answer to a real internationalized world.  Also please
// include your contact information in the header, as can be seen above.

// full day names
Calendar._DN = new Array
("Sunday",
 "Monday",
 "Tuesday",
 "Wednesday",
 "Thursday",
 "Friday",
 "Saturday",
 "Sunday");

// Please note that the following array of short day names (and the same goes
// for short month names, _SMN) isn't absolutely necessary.  We give it here
// for exemplification on how one can customize the short day names, but if
// they are simply the first N letters of the full name you can simply say:
//
//   Calendar._SDN_len = N; // short day name length
//   Calendar._SMN_len = N; // short month name length
//
// If N = 3 then this is not needed either since we assume a value of 3 if not
// present, to be compatible with translation files that were written before
// this feature.

// short day names
Calendar._SDN = new Array
("Sun",
 "Mon",
 "Tue",
 "Wed",
 "Thu",
 "Fri",
 "Sat",
 "Sun");

// First day of the week. "0" means display Sunday first, "1" means display
// Monday first, etc.
Calendar._FD = 0;

// full month names
Calendar._MN = new Array
("January",
 "February",
 "March",
 "April",
 "May",
 "June",
 "July",
 "August",
 "September",
 "October",
 "November",
 "December");

// short month names
Calendar._SMN = new Array
("Jan",
 "Feb",
 "Mar",
 "Apr",
 "May",
 "Jun",
 "Jul",
 "Aug",
 "Sep",
 "Oct",
 "Nov",
 "Dec");

// tooltips
Calendar._TT = {};
Calendar._TT["INFO"] = "About the calendar";

Calendar._TT["ABOUT"] =
"DHTML Date/Time Selector\n" +
"(c) dynarch.com 2002-2005 / Author: Mihai Bazon\n" + // don't translate this this ;-)
"For latest version visit: http://www.dynarch.com/projects/calendar/\n" +
"Distributed under GNU LGPL.  See http://gnu.org/licenses/lgpl.html for details." +
"\n\n" +
"Date selection:\n" +
"- Use the \xab, \xbb buttons to select year\n" +
"- Use the " + String.fromCharCode(0x2039) + ", " + String.fromCharCode(0x203a) + " buttons to select month\n" +
"- Hold mouse button on any of the above buttons for faster selection.";
Calendar._TT["ABOUT_TIME"] = "\n\n" +
"Time selection:\n" +
"- Click on any of the time parts to increase it\n" +
"- or Shift-click to decrease it\n" +
"- or click and drag for faster selection.";

Calendar._TT["PREV_YEAR"] = "Prev. year (hold for menu)";
Calendar._TT["PREV_MONTH"] = "Prev. month (hold for menu)";
Calendar._TT["GO_TODAY"] = "Go Today";
Calendar._TT["NEXT_MONTH"] = "Next month (hold for menu)";
Calendar._TT["NEXT_YEAR"] = "Next year (hold for menu)";
Calendar._TT["SEL_DATE"] = "Select date";
Calendar._TT["DRAG_TO_MOVE"] = "Drag to move";
Calendar._TT["PART_TODAY"] = " (today)";

// the following is to inform that "%s" is to be the first day of week
// %s will be replaced with the day name.
Calendar._TT["DAY_FIRST"] = "Display %s first";

// This may be locale-dependent.  It specifies the week-end days, as an array
// of comma-separated numbers.  The numbers are from 0 to 6: 0 means Sunday, 1
// means Monday, etc.
Calendar._TT["WEEKEND"] = "0,6";

Calendar._TT["CLOSE"] = "Close";
Calendar._TT["TODAY"] = "Today";
Calendar._TT["TIME_PART"] = "(Shift-)Click or drag to change value";

// date formats
Calendar._TT["DEF_DATE_FORMAT"] = "%Y-%m-%d";
Calendar._TT["TT_DATE_FORMAT"] = "%a, %b %e";

Calendar._TT["WK"] = "wk";
Calendar._TT["TIME"] = "Time:";

/*  Copyright Mihai Bazon, 2002, 2003  |  http://dynarch.com/mishoo/
 * ---------------------------------------------------------------------------
 *
 * The DHTML Calendar
 *
 * Details and latest version at:
 * http://dynarch.com/mishoo/calendar.epl
 *
 * This script is distributed under the GNU Lesser General Public License.
 * Read the entire license text here: http://www.gnu.org/licenses/lgpl.html
 *
 * This file defines helper functions for setting up the calendar.  They are
 * intended to help non-programmers get a working calendar on their site
 * quickly.  This script should not be seen as part of the calendar.  It just
 * shows you what one can do with the calendar, while in the same time
 * providing a quick and simple method for setting it up.  If you need
 * exhaustive customization of the calendar creation process feel free to
 * modify this code to suit your needs (this is recommended and much better
 * than modifying calendar.js itself).
 */

// $Id: calendar-setup.js,v 1.25 2005/03/07 09:51:33 mishoo Exp $

/**
 *  This function "patches" an input field (or other element) to use a calendar
 *  widget for date selection.
 *
 *  The "params" is a single object that can have the following properties:
 *
 *    prop. name   | description
 *  -------------------------------------------------------------------------------------------------
 *   inputField    | the ID of an input field to store the date
 *   displayArea   | the ID of a DIV or other element to show the date
 *   button        | ID of a button or other element that will trigger the calendar
 *   eventName     | event that will trigger the calendar, without the "on" prefix (default: "click")
 *   ifFormat      | date format that will be stored in the input field
 *   daFormat      | the date format that will be used to display the date in displayArea
 *   singleClick   | (true/false) wether the calendar is in single click mode or not (default: true)
 *   firstDay      | numeric: 0 to 6.  "0" means display Sunday first, "1" means display Monday first, etc.
 *   align         | alignment (default: "Br"); if you don't know what's this see the calendar documentation
 *   range         | array with 2 elements.  Default: [1900, 2999] -- the range of years available
 *   weekNumbers   | (true/false) if it's true (default) the calendar will display week numbers
 *   flat          | null or element ID; if not null the calendar will be a flat calendar having the parent with the given ID
 *   flatCallback  | function that receives a JS Date object and returns an URL to point the browser to (for flat calendar)
 *   disableFunc   | function that receives a JS Date object and should return true if that date has to be disabled in the calendar
 *   onSelect      | function that gets called when a date is selected.  You don't _have_ to supply this (the default is generally okay)
 *   onClose       | function that gets called when the calendar is closed.  [default]
 *   onUpdate      | function that gets called after the date is updated in the input field.  Receives a reference to the calendar.
 *   date          | the date that the calendar will be initially displayed to
 *   showsTime     | default: false; if true the calendar will include a time selector
 *   timeFormat    | the time format; can be "12" or "24", default is "12"
 *   electric      | if true (default) then given fields/date areas are updated for each move; otherwise they're updated only on close
 *   step          | configures the step of the years in drop-down boxes; default: 2
 *   position      | configures the calendar absolute position; default: null
 *   cache         | if "true" (but default: "false") it will reuse the same calendar object, where possible
 *   showOthers    | if "true" (but default: "false") it will show days from other months too
 *
 *  None of them is required, they all have default values.  However, if you
 *  pass none of "inputField", "displayArea" or "button" you'll get a warning
 *  saying "nothing to setup".
 */
Calendar.setup = function (params) {
	function param_default(pname, def) { if (typeof params[pname] == "undefined") { params[pname] = def; } };

	param_default("inputField",     null);
	param_default("displayArea",    null);
	param_default("button",         null);
	param_default("eventName",      "click");
	param_default("ifFormat",       "%Y/%m/%d");
	param_default("daFormat",       "%Y/%m/%d");
	param_default("singleClick",    true);
	param_default("disableFunc",    null);
	param_default("dateStatusFunc", params["disableFunc"]);	// takes precedence if both are defined
	param_default("dateText",       null);
	param_default("firstDay",       null);
	param_default("align",          "Br");
	param_default("range",          [1900, 2999]);
	param_default("weekNumbers",    true);
	param_default("flat",           null);
	param_default("flatCallback",   null);
	param_default("onSelect",       null);
	param_default("onClose",        null);
	param_default("onUpdate",       null);
	param_default("date",           null);
	param_default("showsTime",      false);
	param_default("timeFormat",     "24");
	param_default("electric",       true);
	param_default("step",           2);
	param_default("position",       null);
	param_default("cache",          false);
	param_default("showOthers",     false);
	param_default("multiple",       null);

	var tmp = ["inputField", "displayArea", "button"];
	for (var i in tmp) {
		if (typeof params[tmp[i]] == "string") {
			params[tmp[i]] = document.getElementById(params[tmp[i]]);
		}
	}
	if (!(params.flat || params.multiple || params.inputField || params.displayArea || params.button)) {
		alert("Calendar.setup:\n  Nothing to setup (no fields found).  Please check your code");
		return false;
	}

	function onSelect(cal) {
		var p = cal.params;
		var update = (cal.dateClicked || p.electric);
		if (update && p.inputField) {
			p.inputField.value = cal.date.print(p.ifFormat);
			if (typeof p.inputField.onchange == "function")
				p.inputField.onchange();
		}
		if (update && p.displayArea)
			p.displayArea.innerHTML = cal.date.print(p.daFormat);
		if (update && typeof p.onUpdate == "function")
			p.onUpdate(cal);
		if (update && p.flat) {
			if (typeof p.flatCallback == "function")
				p.flatCallback(cal);
		}
		if (update && p.singleClick && cal.dateClicked)
			cal.callCloseHandler();
	};

	if (params.flat != null) {
		if (typeof params.flat == "string")
			params.flat = document.getElementById(params.flat);
		if (!params.flat) {
			alert("Calendar.setup:\n  Flat specified but can't find parent.");
			return false;
		}
		var cal = new Calendar(params.firstDay, params.date, params.onSelect || onSelect);
		cal.showsOtherMonths = params.showOthers;
		cal.showsTime = params.showsTime;
		cal.time24 = (params.timeFormat == "24");
		cal.params = params;
		cal.weekNumbers = params.weekNumbers;
		cal.setRange(params.range[0], params.range[1]);
		cal.setDateStatusHandler(params.dateStatusFunc);
		cal.getDateText = params.dateText;
		if (params.ifFormat) {
			cal.setDateFormat(params.ifFormat);
		}
		if (params.inputField && typeof params.inputField.value == "string") {
		  cal.parseDate(params.inputField.value);
		}
		cal.create(params.flat);
		cal.show();
		return false;
	}

	var triggerEl = params.button || params.displayArea || params.inputField;
	triggerEl["on" + params.eventName] = function() {

		// ADDED BY LIH TO HANDLE RETENTION MONTHLY CALENDAR
 		var date_component_lst = params.inputField.value.split("-");
 		var oldInputFieldValue = params.inputField.value;

		var reset_to_old = false;
 		if(date_component_lst.length == 2)
 		{
		  reset_to_old = true;
 		  date_component_lst.push('01');
 		  params.inputField.value = date_component_lst.join("-");
 		}
		// END: ADDED BY LIH TO HANDLE RETENTION MONTHLY CALENDAR


	        var dateEl = params.inputField || params.displayArea;
		var dateFmt = params.inputField ? params.ifFormat : params.daFormat;
		var mustCreate = false;
		var cal = window.calendar;
		if (dateEl)
			params.date = Date.parseDate(dateEl.value || dateEl.innerHTML, dateFmt);
		if (!(cal && params.cache)) {
			window.calendar = cal = new Calendar(params.firstDay,
							     params.date,
							     params.onSelect || onSelect,
							     params.onClose || function(cal) { cal.hide(); });
			cal.showsTime = params.showsTime;
			cal.time24 = (params.timeFormat == "24");
			cal.weekNumbers = params.weekNumbers;
			mustCreate = true;
		} else {
			if (params.date)
				cal.setDate(params.date);
			cal.hide();
		}
		if (params.multiple) {
			cal.multiple = {};
			for (var i = params.multiple.length; --i >= 0;) {
				var d = params.multiple[i];
				var ds = d.print("%Y%m%d");
				cal.multiple[ds] = d;
			}
		}


		cal.showsOtherMonths = params.showOthers;
		cal.yearStep = params.step;
		cal.setRange(params.range[0], params.range[1]);
		cal.params = params;
		cal.setDateStatusHandler(params.dateStatusFunc);
		cal.getDateText = params.dateText;
		cal.setDateFormat(dateFmt);
		if (mustCreate)
			cal.create();
		cal.refresh();

	        // ADDED BY LIH TO HANDLE RETENTION MONTHLY CALENDAR
		if(reset_to_old)
		  params.inputField.value = oldInputFieldValue;
	        // END: ADDED BY LIH TO HANDLE RETENTION MONTHLY CALENDAR

		if (!params.position)
		{
		  cal.showAtElement(params.button || params.displayArea || params.inputField, params.align);
		}
		else
		{
		  cal.showAt(params.position[0], params.position[1]);
		}
		return false;
	};

	return cal;
};

/**
 *
 * Date picker
 * Author: Stefan Petre www.eyecon.ro
 * 
 * Dual licensed under the MIT and GPL licenses
 * 
 */
(function ($) {
	var DatePicker = function () {
		var	ids = {},
			views = {
				years: 'datepickerViewYears',
				moths: 'datepickerViewMonths',
				days: 'datepickerViewDays'
			},
			tpl = {
				wrapper: '<div class="datepicker"><div class="datepickerBorderT" /><div class="datepickerBorderB" /><div class="datepickerBorderL" /><div class="datepickerBorderR" /><div class="datepickerBorderTL" /><div class="datepickerBorderTR" /><div class="datepickerBorderBL" /><div class="datepickerBorderBR" /><div class="datepickerContainer"><table cellspacing="0" cellpadding="0"><tbody><tr></tr></tbody></table></div></div>',
				head: [
					'<td>',
					'<table cellspacing="0" cellpadding="0">',
						'<thead>',
							'<tr>',
								'<th class="datepickerGoPrev"><a href="#"><span><%=prev%></span></a></th>',
								'<th colspan="6" class="datepickerMonth"><a href="#"><span></span></a></th>',
								'<th class="datepickerGoNext"><a href="#"><span><%=next%></span></a></th>',
							'</tr>',
							'<tr class="datepickerDoW">',
								'<th><span><%=week%></span></th>',
								'<th><span><%=day1%></span></th>',
								'<th><span><%=day2%></span></th>',
								'<th><span><%=day3%></span></th>',
								'<th><span><%=day4%></span></th>',
								'<th><span><%=day5%></span></th>',
								'<th><span><%=day6%></span></th>',
								'<th><span><%=day7%></span></th>',
							'</tr>',
						'</thead>',
					'</table></td>'
				],
				space : '<td class="datepickerSpace"><div></div></td>',
				days: [
					'<tbody class="datepickerDays">',
						'<tr>',
							'<th class="datepickerWeek"><a href="#"><span><%=weeks[0].week%></span></a></th>',
							'<td class="<%=weeks[0].days[0].classname%>"><a href="#"><span><%=weeks[0].days[0].text%></span></a></td>',
							'<td class="<%=weeks[0].days[1].classname%>"><a href="#"><span><%=weeks[0].days[1].text%></span></a></td>',
							'<td class="<%=weeks[0].days[2].classname%>"><a href="#"><span><%=weeks[0].days[2].text%></span></a></td>',
							'<td class="<%=weeks[0].days[3].classname%>"><a href="#"><span><%=weeks[0].days[3].text%></span></a></td>',
							'<td class="<%=weeks[0].days[4].classname%>"><a href="#"><span><%=weeks[0].days[4].text%></span></a></td>',
							'<td class="<%=weeks[0].days[5].classname%>"><a href="#"><span><%=weeks[0].days[5].text%></span></a></td>',
							'<td class="<%=weeks[0].days[6].classname%>"><a href="#"><span><%=weeks[0].days[6].text%></span></a></td>',
						'</tr>',
						'<tr>',
							'<th class="datepickerWeek"><a href="#"><span><%=weeks[1].week%></span></a></th>',
							'<td class="<%=weeks[1].days[0].classname%>"><a href="#"><span><%=weeks[1].days[0].text%></span></a></td>',
							'<td class="<%=weeks[1].days[1].classname%>"><a href="#"><span><%=weeks[1].days[1].text%></span></a></td>',
							'<td class="<%=weeks[1].days[2].classname%>"><a href="#"><span><%=weeks[1].days[2].text%></span></a></td>',
							'<td class="<%=weeks[1].days[3].classname%>"><a href="#"><span><%=weeks[1].days[3].text%></span></a></td>',
							'<td class="<%=weeks[1].days[4].classname%>"><a href="#"><span><%=weeks[1].days[4].text%></span></a></td>',
							'<td class="<%=weeks[1].days[5].classname%>"><a href="#"><span><%=weeks[1].days[5].text%></span></a></td>',
							'<td class="<%=weeks[1].days[6].classname%>"><a href="#"><span><%=weeks[1].days[6].text%></span></a></td>',
						'</tr>',
						'<tr>',
							'<th class="datepickerWeek"><a href="#"><span><%=weeks[2].week%></span></a></th>',
							'<td class="<%=weeks[2].days[0].classname%>"><a href="#"><span><%=weeks[2].days[0].text%></span></a></td>',
							'<td class="<%=weeks[2].days[1].classname%>"><a href="#"><span><%=weeks[2].days[1].text%></span></a></td>',
							'<td class="<%=weeks[2].days[2].classname%>"><a href="#"><span><%=weeks[2].days[2].text%></span></a></td>',
							'<td class="<%=weeks[2].days[3].classname%>"><a href="#"><span><%=weeks[2].days[3].text%></span></a></td>',
							'<td class="<%=weeks[2].days[4].classname%>"><a href="#"><span><%=weeks[2].days[4].text%></span></a></td>',
							'<td class="<%=weeks[2].days[5].classname%>"><a href="#"><span><%=weeks[2].days[5].text%></span></a></td>',
							'<td class="<%=weeks[2].days[6].classname%>"><a href="#"><span><%=weeks[2].days[6].text%></span></a></td>',
						'</tr>',
						'<tr>',
							'<th class="datepickerWeek"><a href="#"><span><%=weeks[3].week%></span></a></th>',
							'<td class="<%=weeks[3].days[0].classname%>"><a href="#"><span><%=weeks[3].days[0].text%></span></a></td>',
							'<td class="<%=weeks[3].days[1].classname%>"><a href="#"><span><%=weeks[3].days[1].text%></span></a></td>',
							'<td class="<%=weeks[3].days[2].classname%>"><a href="#"><span><%=weeks[3].days[2].text%></span></a></td>',
							'<td class="<%=weeks[3].days[3].classname%>"><a href="#"><span><%=weeks[3].days[3].text%></span></a></td>',
							'<td class="<%=weeks[3].days[4].classname%>"><a href="#"><span><%=weeks[3].days[4].text%></span></a></td>',
							'<td class="<%=weeks[3].days[5].classname%>"><a href="#"><span><%=weeks[3].days[5].text%></span></a></td>',
							'<td class="<%=weeks[3].days[6].classname%>"><a href="#"><span><%=weeks[3].days[6].text%></span></a></td>',
						'</tr>',
						'<tr>',
							'<th class="datepickerWeek"><a href="#"><span><%=weeks[4].week%></span></a></th>',
							'<td class="<%=weeks[4].days[0].classname%>"><a href="#"><span><%=weeks[4].days[0].text%></span></a></td>',
							'<td class="<%=weeks[4].days[1].classname%>"><a href="#"><span><%=weeks[4].days[1].text%></span></a></td>',
							'<td class="<%=weeks[4].days[2].classname%>"><a href="#"><span><%=weeks[4].days[2].text%></span></a></td>',
							'<td class="<%=weeks[4].days[3].classname%>"><a href="#"><span><%=weeks[4].days[3].text%></span></a></td>',
							'<td class="<%=weeks[4].days[4].classname%>"><a href="#"><span><%=weeks[4].days[4].text%></span></a></td>',
							'<td class="<%=weeks[4].days[5].classname%>"><a href="#"><span><%=weeks[4].days[5].text%></span></a></td>',
							'<td class="<%=weeks[4].days[6].classname%>"><a href="#"><span><%=weeks[4].days[6].text%></span></a></td>',
						'</tr>',
						'<tr>',
							'<th class="datepickerWeek"><a href="#"><span><%=weeks[5].week%></span></a></th>',
							'<td class="<%=weeks[5].days[0].classname%>"><a href="#"><span><%=weeks[5].days[0].text%></span></a></td>',
							'<td class="<%=weeks[5].days[1].classname%>"><a href="#"><span><%=weeks[5].days[1].text%></span></a></td>',
							'<td class="<%=weeks[5].days[2].classname%>"><a href="#"><span><%=weeks[5].days[2].text%></span></a></td>',
							'<td class="<%=weeks[5].days[3].classname%>"><a href="#"><span><%=weeks[5].days[3].text%></span></a></td>',
							'<td class="<%=weeks[5].days[4].classname%>"><a href="#"><span><%=weeks[5].days[4].text%></span></a></td>',
							'<td class="<%=weeks[5].days[5].classname%>"><a href="#"><span><%=weeks[5].days[5].text%></span></a></td>',
							'<td class="<%=weeks[5].days[6].classname%>"><a href="#"><span><%=weeks[5].days[6].text%></span></a></td>',
						'</tr>',
					'</tbody>'
				],
				months: [
					'<tbody class="<%=className%>">',
						'<tr>',
							'<td colspan="2"><a href="#"><span><%=data[0]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[1]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[2]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[3]%></span></a></td>',
						'</tr>',
						'<tr>',
							'<td colspan="2"><a href="#"><span><%=data[4]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[5]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[6]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[7]%></span></a></td>',
						'</tr>',
						'<tr>',
							'<td colspan="2"><a href="#"><span><%=data[8]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[9]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[10]%></span></a></td>',
							'<td colspan="2"><a href="#"><span><%=data[11]%></span></a></td>',
						'</tr>',
					'</tbody>'
				]
			},
			defaults = {
				flat: false,
				starts: 1,
				prev: '&#9664;',
				next: '&#9654;',
				lastSel: false,
				mode: 'single',
				view: 'days',
				calendars: 1,
				format: 'Y-m-d',
				position: 'bottom',
				eventName: 'click',
				onRender: function(){return {};},
				onChange: function(){return true;},
				onShow: function(){return true;},
				onBeforeShow: function(){return true;},
				onHide: function(){return true;},
				locale: {
					days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
					daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
					daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
					months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
					monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
					weekMin: 'wk'
				}
			},
			fill = function(el) {
				var options = $(el).data('datepicker');
				var cal = $(el);
				var currentCal = Math.floor(options.calendars/2), date, data, dow, month, cnt = 0, week, days, indic, indic2, html, tblCal;
				cal.find('td>table tbody').remove();
				for (var i = 0; i < options.calendars; i++) {
					date = new Date(options.current);
					date.addMonths(-currentCal + i);
					tblCal = cal.find('table').eq(i+1);
					switch (tblCal[0].className) {
						case 'datepickerViewDays':
							dow = formatDate(date, 'B, Y');
							break;
						case 'datepickerViewMonths':
							dow = date.getFullYear();
							break;
						case 'datepickerViewYears':
							dow = (date.getFullYear()-6) + ' - ' + (date.getFullYear()+5);
							break;
					} 
					tblCal.find('thead tr:first th:eq(1) span').text(dow);
					dow = date.getFullYear()-6;
					data = {
						data: [],
						className: 'datepickerYears'
					}
					for ( var j = 0; j < 12; j++) {
						data.data.push(dow + j);
					}
					html = tmpl(tpl.months.join(''), data);
					date.setDate(1);
					data = {weeks:[], test: 10};
					month = date.getMonth();
					var dow = (date.getDay() - options.starts) % 7;
					date.addDays(-(dow + (dow < 0 ? 7 : 0)));
					week = -1;
					cnt = 0;
					while (cnt < 42) {
						indic = parseInt(cnt/7,10);
						indic2 = cnt%7;
						if (!data.weeks[indic]) {
							week = date.getWeekNumber();
							data.weeks[indic] = {
								week: week,
								days: []
							};
						}
						data.weeks[indic].days[indic2] = {
							text: date.getDate(),
							classname: []
						};
						if (month != date.getMonth()) {
							data.weeks[indic].days[indic2].classname.push('datepickerNotInMonth');
						}
						if (date.getDay() == 0) {
							data.weeks[indic].days[indic2].classname.push('datepickerSunday');
						}
						if (date.getDay() == 6) {
							data.weeks[indic].days[indic2].classname.push('datepickerSaturday');
						}
						var fromUser = options.onRender(date);
						var val = date.valueOf();
						if (fromUser.selected || options.date == val || $.inArray(val, options.date) > -1 || (options.mode == 'range' && val >= options.date[0] && val <= options.date[1])) {
							data.weeks[indic].days[indic2].classname.push('datepickerSelected');
						}
						if (fromUser.disabled) {
							data.weeks[indic].days[indic2].classname.push('datepickerDisabled');
						}
						if (fromUser.className) {
							data.weeks[indic].days[indic2].classname.push(fromUser.className);
						}
						data.weeks[indic].days[indic2].classname = data.weeks[indic].days[indic2].classname.join(' ');
						cnt++;
						date.addDays(1);
					}
					html = tmpl(tpl.days.join(''), data) + html;
					data = {
						data: options.locale.monthsShort,
						className: 'datepickerMonths'
					};
					html = tmpl(tpl.months.join(''), data) + html;
					tblCal.append(html);
				}
			},
			parseDate = function (date, format) {
				if (date.constructor == Date) {
					return new Date(date);
				}
				var parts = date.split(/\W+/);
				var against = format.split(/\W+/), d, m, y, h, min, now = new Date();
				for (var i = 0; i < parts.length; i++) {
					switch (against[i]) {
						case 'd':
						case 'e':
							d = parseInt(parts[i],10);
							break;
						case 'm':
							m = parseInt(parts[i], 10)-1;
							break;
						case 'Y':
						case 'y':
							y = parseInt(parts[i], 10);
							y += y > 100 ? 0 : (y < 29 ? 2000 : 1900);
							break;
						case 'H':
						case 'I':
						case 'k':
						case 'l':
							h = parseInt(parts[i], 10);
							break;
						case 'P':
						case 'p':
							if (/pm/i.test(parts[i]) && h < 12) {
								h += 12;
							} else if (/am/i.test(parts[i]) && h >= 12) {
								h -= 12;
							}
							break;
						case 'M':
							min = parseInt(parts[i], 10);
							break;
					}
				}
				return new Date(
					y === undefined ? now.getFullYear() : y,
					m === undefined ? now.getMonth() : m,
					d === undefined ? now.getDate() : d,
					h === undefined ? now.getHours() : h,
					min === undefined ? now.getMinutes() : min,
					0
				);
			},
			formatDate = function(date, format) {
				var m = date.getMonth();
				var d = date.getDate();
				var y = date.getFullYear();
				var wn = date.getWeekNumber();
				var w = date.getDay();
				var s = {};
				var hr = date.getHours();
				var pm = (hr >= 12);
				var ir = (pm) ? (hr - 12) : hr;
				var dy = date.getDayOfYear();
				if (ir == 0) {
					ir = 12;
				}
				var min = date.getMinutes();
				var sec = date.getSeconds();
				var parts = format.split(''), part;
				for ( var i = 0; i < parts.length; i++ ) {
					part = parts[i];
					switch (parts[i]) {
						case 'a':
							part = date.getDayName();
							break;
						case 'A':
							part = date.getDayName(true);
							break;
						case 'b':
							part = date.getMonthName();
							break;
						case 'B':
							part = date.getMonthName(true);
							break;
						case 'C':
							part = 1 + Math.floor(y / 100);
							break;
						case 'd':
							part = (d < 10) ? ("0" + d) : d;
							break;
						case 'e':
							part = d;
							break;
						case 'H':
							part = (hr < 10) ? ("0" + hr) : hr;
							break;
						case 'I':
							part = (ir < 10) ? ("0" + ir) : ir;
							break;
						case 'j':
							part = (dy < 100) ? ((dy < 10) ? ("00" + dy) : ("0" + dy)) : dy;
							break;
						case 'k':
							part = hr;
							break;
						case 'l':
							part = ir;
							break;
						case 'm':
							part = (m < 9) ? ("0" + (1+m)) : (1+m);
							break;
						case 'M':
							part = (min < 10) ? ("0" + min) : min;
							break;
						case 'p':
						case 'P':
							part = pm ? "PM" : "AM";
							break;
						case 's':
							part = Math.floor(date.getTime() / 1000);
							break;
						case 'S':
							part = (sec < 10) ? ("0" + sec) : sec;
							break;
						case 'u':
							part = w + 1;
							break;
						case 'w':
							part = w;
							break;
						case 'y':
							part = ('' + y).substr(2, 2);
							break;
						case 'Y':
							part = y;
							break;
					}
					parts[i] = part;
				}
				return parts.join('');
			},
			extendDate = function(options) {
				if (Date.prototype.tempDate) {
					return;
				}
				Date.prototype.tempDate = null;
				Date.prototype.months = options.months;
				Date.prototype.monthsShort = options.monthsShort;
				Date.prototype.days = options.days;
				Date.prototype.daysShort = options.daysShort;
				Date.prototype.getMonthName = function(fullName) {
					return this[fullName ? 'months' : 'monthsShort'][this.getMonth()];
				};
				Date.prototype.getDayName = function(fullName) {
					return this[fullName ? 'days' : 'daysShort'][this.getDay()];
				};
				Date.prototype.addDays = function (n) {
					this.setDate(this.getDate() + n);
					this.tempDate = this.getDate();
				};
				Date.prototype.addMonths = function (n) {
					if (this.tempDate == null) {
						this.tempDate = this.getDate();
					}
					this.setDate(1);
					this.setMonth(this.getMonth() + n);
					this.setDate(Math.min(this.tempDate, this.getMaxDays()));
				};
				Date.prototype.addYears = function (n) {
					if (this.tempDate == null) {
						this.tempDate = this.getDate();
					}
					this.setDate(1);
					this.setFullYear(this.getFullYear() + n);
					this.setDate(Math.min(this.tempDate, this.getMaxDays()));
				};
				Date.prototype.getMaxDays = function() {
					var tmpDate = new Date(Date.parse(this)),
						d = 28, m;
					m = tmpDate.getMonth();
					d = 28;
					while (tmpDate.getMonth() == m) {
						d ++;
						tmpDate.setDate(d);
					}
					return d - 1;
				};
				Date.prototype.getFirstDay = function() {
					var tmpDate = new Date(Date.parse(this));
					tmpDate.setDate(1);
					return tmpDate.getDay();
				};
				Date.prototype.getWeekNumber = function() {
					var tempDate = new Date(this);
					tempDate.setDate(tempDate.getDate() - (tempDate.getDay() + 6) % 7 + 3);
					var dms = tempDate.valueOf();
					tempDate.setMonth(0);
					tempDate.setDate(4);
					return Math.round((dms - tempDate.valueOf()) / (604800000)) + 1;
				};
				Date.prototype.getDayOfYear = function() {
					var now = new Date(this.getFullYear(), this.getMonth(), this.getDate(), 0, 0, 0);
					var then = new Date(this.getFullYear(), 0, 0, 0, 0, 0);
					var time = now - then;
					return Math.floor(time / 24*60*60*1000);
				};
			},
			layout = function (el) {
				var options = $(el).data('datepicker');
				var cal = $('#' + options.id);
				if (!options.extraHeight) {
					var divs = $(el).find('div');
					options.extraHeight = divs.get(0).offsetHeight + divs.get(1).offsetHeight;
					options.extraWidth = divs.get(2).offsetWidth + divs.get(3).offsetWidth;
				}
				var tbl = cal.find('table:first').get(0);
				var width = tbl.offsetWidth;
				var height = tbl.offsetHeight;
				cal.css({
					width: width + options.extraWidth + 'px',
					height: height + options.extraHeight + 'px'
				}).find('div.datepickerContainer').css({
					width: width + 'px',
					height: height + 'px'
				});
			},
			click = function(ev) {
				if ($(ev.target).is('span')) {
					ev.target = ev.target.parentNode;
				}
				var el = $(ev.target);
				if (el.is('a')) {
					ev.target.blur();
					if (el.hasClass('datepickerDisabled')) {
						return false;
					}
					var options = $(this).data('datepicker');
					var parentEl = el.parent();
					var tblEl = parentEl.parent().parent().parent();
					var tblIndex = $('table', this).index(tblEl.get(0)) - 1;
					var tmp = new Date(options.current);
					var changed = false;
					var fillIt = false;
					if (parentEl.is('th')) {
						if (parentEl.hasClass('datepickerWeek') && options.mode == 'range' && !parentEl.next().hasClass('datepickerDisabled')) {
							var val = parseInt(parentEl.next().text(), 10);
							tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
							if (parentEl.next().hasClass('datepickerNotInMonth')) {
								tmp.addMonths(val > 15 ? -1 : 1);
							}
							tmp.setDate(val);
							options.date[0] = (tmp.setHours(0,0,0,0)).valueOf();
							tmp.setHours(23,59,59,0);
							tmp.addDays(6);
							options.date[1] = tmp.valueOf();
							fillIt = true;
							changed = true;
							options.lastSel = false;
						} else if (parentEl.hasClass('datepickerMonth')) {
							tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
							switch (tblEl.get(0).className) {
								case 'datepickerViewDays':
									tblEl.get(0).className = 'datepickerViewMonths';
									el.find('span').text(tmp.getFullYear());
									break;
								case 'datepickerViewMonths':
									tblEl.get(0).className = 'datepickerViewYears';
									el.find('span').text((tmp.getFullYear()-6) + ' - ' + (tmp.getFullYear()+5));
									break;
								case 'datepickerViewYears':
									tblEl.get(0).className = 'datepickerViewDays';
									el.find('span').text(formatDate(tmp, 'B, Y'));
									break;
							}
						} else if (parentEl.parent().parent().is('thead')) {
							switch (tblEl.get(0).className) {
								case 'datepickerViewDays':
									options.current.addMonths(parentEl.hasClass('datepickerGoPrev') ? -1 : 1);
									break;
								case 'datepickerViewMonths':
									options.current.addYears(parentEl.hasClass('datepickerGoPrev') ? -1 : 1);
									break;
								case 'datepickerViewYears':
									options.current.addYears(parentEl.hasClass('datepickerGoPrev') ? -12 : 12);
									break;
							}
							fillIt = true;
						}
					} else if (parentEl.is('td') && !parentEl.hasClass('datepickerDisabled')) {
						switch (tblEl.get(0).className) {
							case 'datepickerViewMonths':
								options.current.setMonth(tblEl.find('tbody.datepickerMonths td').index(parentEl));
								options.current.setFullYear(parseInt(tblEl.find('thead th.datepickerMonth span').text(), 10));
								options.current.addMonths(Math.floor(options.calendars/2) - tblIndex);
								tblEl.get(0).className = 'datepickerViewDays';
								break;
							case 'datepickerViewYears':
								options.current.setFullYear(parseInt(el.text(), 10));
								tblEl.get(0).className = 'datepickerViewMonths';
								break;
							default:
								var val = parseInt(el.text(), 10);
								tmp.addMonths(tblIndex - Math.floor(options.calendars/2));
								if (parentEl.hasClass('datepickerNotInMonth')) {
									tmp.addMonths(val > 15 ? -1 : 1);
								}
								tmp.setDate(val);
								switch (options.mode) {
									case 'multiple':
										val = (tmp.setHours(0,0,0,0)).valueOf();
										if ($.inArray(val, options.date) > -1) {
											$.each(options.date, function(nr, dat){
												if (dat == val) {
													options.date.splice(nr,1);
													return false;
												}
											});
										} else {
											options.date.push(val);
										}
										break;
									case 'range':
										if (!options.lastSel) {
											options.date[0] = (tmp.setHours(0,0,0,0)).valueOf();
										}
										val = (tmp.setHours(23,59,59,0)).valueOf();
										if (val < options.date[0]) {
											options.date[1] = options.date[0] + 86399000;
											options.date[0] = val - 86399000;
										} else {
											options.date[1] = val;
										}
										options.lastSel = !options.lastSel;
										break;
									default:
										options.date = tmp.valueOf();
										break;
								}
								break;
						}
						fillIt = true;
						changed = true;
					}
					if (fillIt) {
						fill(this);
					}
					if (changed) {
						options.onChange.apply(this, prepareDate(options));
					}
				}
				return false;
			},
			prepareDate = function (options) {
				var tmp;
				if (options.mode == 'single') {
					tmp = new Date(options.date);
					return [formatDate(tmp, options.format), tmp, options.el];
				} else {
					tmp = [[],[], options.el];
					$.each(options.date, function(nr, val){
						var date = new Date(val);
						tmp[0].push(formatDate(date, options.format));
						tmp[1].push(date);
					});
					return tmp;
				}
			},
			getViewport = function () {
				var m = document.compatMode == 'CSS1Compat';
				return {
					l : window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
					t : window.pageYOffset || (m ? document.documentElement.scrollTop : document.body.scrollTop),
					w : window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth),
					h : window.innerHeight || (m ? document.documentElement.clientHeight : document.body.clientHeight)
				};
			},
			isChildOf = function(parentEl, el, container) {
				if (parentEl == el) {
					return true;
				}
				if (parentEl.contains) {
					return parentEl.contains(el);
				}
				if ( parentEl.compareDocumentPosition ) {
					return !!(parentEl.compareDocumentPosition(el) & 16);
				}
				var prEl = el.parentNode;
				while(prEl && prEl != container) {
					if (prEl == parentEl)
						return true;
					prEl = prEl.parentNode;
				}
				return false;
			},
			show = function (ev) {
				var cal = $('#' + $(this).data('datepickerId'));
				if (!cal.is(':visible')) {
					var calEl = cal.get(0);
					fill(calEl);
					var options = cal.data('datepicker');
					options.onBeforeShow.apply(this, [cal.get(0)]);
					var pos = $(this).offset();
					var viewPort = getViewport();
					var top = pos.top;
					var left = pos.left;
					var oldDisplay = $.curCSS(calEl, 'display');
					cal.css({
						visibility: 'hidden',
						display: 'block'
					});
					layout(calEl);
					switch (options.position){
						case 'top':
							top -= calEl.offsetHeight;
							break;
						case 'left':
							left -= calEl.offsetWidth;
							break;
						case 'right':
							left += this.offsetWidth;
							break;
						case 'bottom':
							top += this.offsetHeight;
							break;
					}
					if (top + calEl.offsetHeight > viewPort.t + viewPort.h) {
						top = pos.top  - calEl.offsetHeight;
					}
					if (top < viewPort.t) {
						top = pos.top + this.offsetHeight + calEl.offsetHeight;
					}
					if (left + calEl.offsetWidth > viewPort.l + viewPort.w) {
						left = pos.left - calEl.offsetWidth;
					}
					if (left < viewPort.l) {
						left = pos.left + this.offsetWidth
					}
					cal.css({
						visibility: 'visible',
						display: 'block',
						top: top + 'px',
						left: left + 'px'
					});
					if (options.onShow.apply(this, [cal.get(0)]) != false) {
						cal.show();
					}
					$(document).bind('mousedown', {cal: cal, trigger: this}, hide);
				}
				return false;
			},
			hide = function (ev) {
				if (ev.target != ev.data.trigger && !isChildOf(ev.data.cal.get(0), ev.target, ev.data.cal.get(0))) {
					if (ev.data.cal.data('datepicker').onHide.apply(this, [ev.data.cal.get(0)]) != false) {
						ev.data.cal.hide();
					}
					$(document).unbind('mousedown', hide);
				}
			};
		return {
			init: function(options){
				options = $.extend({}, defaults, options||{});
				extendDate(options.locale);
				options.calendars = Math.max(1, parseInt(options.calendars,10)||1);
				options.mode = /single|multiple|range/.test(options.mode) ? options.mode : 'single';
				return this.each(function(){
					if (!$(this).data('datepicker')) {
						options.el = this;
						if (options.date.constructor == String) {
							options.date = parseDate(options.date, options.format);
							options.date.setHours(0,0,0,0);
						}
						if (options.mode != 'single') {
							if (options.date.constructor != Array) {
								options.date = [options.date.valueOf()];
								if (options.mode == 'range') {
									options.date.push(((new Date(options.date[0])).setHours(23,59,59,0)).valueOf());
								}
							} else {
								for (var i = 0; i < options.date.length; i++) {
									options.date[i] = (parseDate(options.date[i], options.format).setHours(0,0,0,0)).valueOf();
								}
								if (options.mode == 'range') {
									options.date[1] = ((new Date(options.date[1])).setHours(23,59,59,0)).valueOf();
								}
							}
						} else {
							options.date = options.date.valueOf();
						}
						if (!options.current) {
							options.current = new Date();
						} else {
							options.current = parseDate(options.current, options.format);
						} 
						options.current.setDate(1);
						options.current.setHours(0,0,0,0);
						var id = 'datepicker_' + parseInt(Math.random() * 1000), cnt;
						options.id = id;
						$(this).data('datepickerId', options.id);
						var cal = $(tpl.wrapper).attr('id', id).bind('click', click).data('datepicker', options);
						if (options.className) {
							cal.addClass(options.className);
						}
						var html = '';
						for (var i = 0; i < options.calendars; i++) {
							cnt = options.starts;
							if (i > 0) {
								html += tpl.space;
							}
							html += tmpl(tpl.head.join(''), {
									week: options.locale.weekMin,
									prev: options.prev,
									next: options.next,
									day1: options.locale.daysMin[(cnt++)%7],
									day2: options.locale.daysMin[(cnt++)%7],
									day3: options.locale.daysMin[(cnt++)%7],
									day4: options.locale.daysMin[(cnt++)%7],
									day5: options.locale.daysMin[(cnt++)%7],
									day6: options.locale.daysMin[(cnt++)%7],
									day7: options.locale.daysMin[(cnt++)%7]
								});
						}
						cal
							.find('tr:first').append(html)
								.find('table').addClass(views[options.view]);
						fill(cal.get(0));
						if (options.flat) {
							cal.appendTo(this).show().css('position', 'relative');
							layout(cal.get(0));
						} else {
							cal.appendTo(document.body);
							$(this).bind(options.eventName, show);
						}
					}
				});
			},
			showPicker: function() {
				return this.each( function () {
					if ($(this).data('datepickerId')) {
						show.apply(this);
					}
				});
			},
			hidePicker: function() {
				return this.each( function () {
					if ($(this).data('datepickerId')) {
						$('#' + $(this).data('datepickerId')).hide();
					}
				});
			},
			setDate: function(date, shiftTo){
				return this.each(function(){
					if ($(this).data('datepickerId')) {
						var cal = $('#' + $(this).data('datepickerId'));
						var options = cal.data('datepicker');
						options.date = date;
						if (options.date.constructor == String) {
							options.date = parseDate(options.date, options.format);
							options.date.setHours(0,0,0,0);
						}
						if (options.mode != 'single') {
							if (options.date.constructor != Array) {
								options.date = [options.date.valueOf()];
								if (options.mode == 'range') {
									options.date.push(((new Date(options.date[0])).setHours(23,59,59,0)).valueOf());
								}
							} else {
								for (var i = 0; i < options.date.length; i++) {
									options.date[i] = (parseDate(options.date[i], options.format).setHours(0,0,0,0)).valueOf();
								}
								if (options.mode == 'range') {
									options.date[1] = ((new Date(options.date[1])).setHours(23,59,59,0)).valueOf();
								}
							}
						} else {
							options.date = options.date.valueOf();
						}
						if (shiftTo) {
							options.current = new Date (options.mode != 'single' ? options.date[0] : options.date);
						}
						fill(cal.get(0));
					}
				});
			},
			getDate: function(formated) {
				if (this.size() > 0) {
					return prepareDate($('#' + $(this).data('datepickerId')).data('datepicker'))[formated ? 0 : 1];
				}
			},
			clear: function(){
				return this.each(function(){
					if ($(this).data('datepickerId')) {
						var cal = $('#' + $(this).data('datepickerId'));
						var options = cal.data('datepicker');
						if (options.mode != 'single') {
							options.date = [];
							fill(cal.get(0));
						}
					}
				});
			},
			fixLayout: function(){
				return this.each(function(){
					if ($(this).data('datepickerId')) {
						var cal = $('#' + $(this).data('datepickerId'));
						var options = cal.data('datepicker');
						if (options.flat) {
							layout(cal.get(0));
						}
					}
				});
			}
		};
	}();
	$.fn.extend({
		DatePicker: DatePicker.init,
		DatePickerHide: DatePicker.hidePicker,
		DatePickerShow: DatePicker.showPicker,
		DatePickerSetDate: DatePicker.setDate,
		DatePickerGetDate: DatePicker.getDate,
		DatePickerClear: DatePicker.clear,
		DatePickerLayout: DatePicker.fixLayout
	});
})(jQuery);

(function(){
  var cache = {};
 
  this.tmpl = function tmpl(str, data){
    // Figure out if we're getting a template, or if we need to
    // load the template - and be sure to cache the result.
    var fn = !/\W/.test(str) ?
      cache[str] = cache[str] ||
        tmpl(document.getElementById(str).innerHTML) :
     
      // Generate a reusable function that will serve as a template
      // generator (and which will be cached).
      new Function("obj",
        "var p=[],print=function(){p.push.apply(p,arguments);};" +
       
        // Introduce the data as local variables using with(){}
        "with(obj){p.push('" +
       
        // Convert the template into pure JavaScript
        str
          .replace(/[\r\t\n]/g, " ")
          .split("<%").join("\t")
          .replace(/((^|%>)[^\t]*)'/g, "$1\r")
          .replace(/\t=(.*?)%>/g, "',$1,'")
          .split("\t").join("');")
          .split("%>").join("p.push('")
          .split("\r").join("\\'")
      + "');}return p.join('');");
   
    // Provide some basic currying to the user
    return data ? fn( data ) : fn;
  };
})();

/* SpinButton control
 *
 * Adds bells and whistles to any ordinary textbox to
 * make it look and feel like a SpinButton Control.
 *
 * Originally written by George Adamson, Software Unity (george.jquery@softwareunity.com) August 2006.
 * - Added min/max options
 * - Added step size option
 * - Added bigStep (page up/down) option
 *
 * Modifications made by Mark Gibson, (mgibson@designlinks.net) September 2006:
 * - Converted to jQuery plugin
 * - Allow limited or unlimited min/max values
 * - Allow custom class names, and add class to input element
 * - Removed global vars
 * - Reset (to original or through config) when invalid value entered
 * - Repeat whilst holding mouse button down (with initial pause, like keyboard repeat)
 * - Support mouse wheel in Firefox
 * - Fix double click in IE
 * - Refactored some code and renamed some vars
 *
 * Tested in IE6, Opera9, Firefox 1.5
 * v1.0  11 Aug 2006 - George Adamson	- First release
 * v1.1     Aug 2006 - George Adamson	- Minor enhancements
 * v1.2  27 Sep 2006 - Mark Gibson		- Major enhancements
 * v1.3a 28 Sep 2006 - George Adamson	- Minor enhancements
 
 Sample usage:
 
	// Create group of settings to initialise spinbutton(s). (Optional)
	var myOptions = {
					min: 0,						// Set lower limit.
					max: 100,					// Set upper limit.
					step: 1,					// Set increment size.
					spinClass: mySpinBtnClass,	// CSS class to style the spinbutton. (Class also specifies url of the up/down button image.)
					upClass: mySpinUpClass,		// CSS class for style when mouse over up button.
					downClass: mySpinDnClass	// CSS class for style when mouse over down button.
					}
 
	$(document).ready(function(){

		// Initialise INPUT element(s) as SpinButtons: (passing options if desired)
		$("#myInputElement").SpinButton(myOptions);

	});
 
 */
jQuery.fn.SpinButton = function(cfg){
	return this.each(function(){

		// Apply specified options or defaults:
		// (Ought to refactor this some day to use jQuery.extend() instead)
		this.spinCfg = {
			//min: cfg && cfg.min ? Number(cfg.min) : null,
			//max: cfg && cfg.max ? Number(cfg.max) : null,
			min: cfg && !isNaN(parseFloat(cfg.min)) ? Number(cfg.min) : null,	// Fixes bug with min:0
			max: cfg && !isNaN(parseFloat(cfg.max)) ? Number(cfg.max) : null,
			step: cfg && cfg.step ? Number(cfg.step) : 1,
			page: cfg && cfg.page ? Number(cfg.page) : 10,
			upClass: cfg && cfg.upClass ? cfg.upClass : 'up',
			downClass: cfg && cfg.downClass ? cfg.downClass : 'down',
			reset: cfg && cfg.reset ? cfg.reset : this.value,
			delay: cfg && cfg.delay ? Number(cfg.delay) : 500,
			interval: cfg && cfg.interval ? Number(cfg.interval) : 100,
			_btn_width: 20,
			_btn_height: 12,
			_direction: null,
			_delay: null,
			_repeat: null
		};
		
		this.adjustValue = function(i){
			var v = (isNaN(this.value) ? this.spinCfg.reset : Number(this.value)) + Number(i);
			if (this.spinCfg.min !== null) v = Math.max(v, this.spinCfg.min);
			if (this.spinCfg.max !== null) v = Math.min(v, this.spinCfg.max);
			this.value = v;
		};
		
		jQuery(this)
		.addClass(cfg && cfg.spinClass ? cfg.spinClass : 'spin-button')
		
		.mousemove(function(e){
			// Determine which button mouse is over, or not (spin direction):
			var x = e.pageX || e.x;
			var y = e.pageY || e.y;
			var el = e.target || e.srcElement;
			var direction = 
				(x > coord(el,'offsetLeft') + el.offsetWidth - this.spinCfg._btn_width)
				? ((y < coord(el,'offsetTop') + this.spinCfg._btn_height) ? 1 : -1) : 0;
			
			if (direction !== this.spinCfg._direction) {
				// Style up/down buttons:
				switch(direction){
					case 1: // Up arrow:
						jQuery(this).removeClass(this.spinCfg.downClass).addClass(this.spinCfg.upClass);
						break;
					case -1: // Down arrow:
						jQuery(this).removeClass(this.spinCfg.upClass).addClass(this.spinCfg.downClass);
						break;
					default: // Mouse is elsewhere in the textbox
						jQuery(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
				}
				
				// Set spin direction:
				this.spinCfg._direction = direction;
			}
		})
		
		.mouseout(function(){
			// Reset up/down buttons to their normal appearance when mouse moves away:
			jQuery(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
			this.spinCfg._direction = null;
		})
		
		.mousedown(function(e){
			if (this.spinCfg._direction != 0) {
				// Respond to click on one of the buttons:
				var self = this;
				var adjust = function() {
					self.adjustValue(self.spinCfg._direction * self.spinCfg.step);
				};
			
				adjust();
				
				// Initial delay before repeating adjustment
				self.spinCfg._delay = window.setTimeout(function() {
					adjust();
					// Repeat adjust at regular intervals
					self.spinCfg._repeat = window.setInterval(adjust, self.spinCfg.interval);
				}, self.spinCfg.delay);
			}
		})
		
		.mouseup(function(e){
			// Cancel repeating adjustment
			window.clearInterval(this.spinCfg._repeat);
			window.clearTimeout(this.spinCfg._delay);
		})
		
		.dblclick(function(e) {
			if (jQuery.browser.msie)
				this.adjustValue(this.spinCfg._direction * this.spinCfg.step);
		})
		
		.keydown(function(e){
			// Respond to up/down arrow keys.
			switch(e.keyCode){
				case 38: this.adjustValue(this.spinCfg.step);  break; // Up
				case 40: this.adjustValue(-this.spinCfg.step); break; // Down
				case 33: this.adjustValue(this.spinCfg.page);  break; // PageUp
				case 34: this.adjustValue(-this.spinCfg.page); break; // PageDown
			}
		})

		.bind("mousewheel", function(e){
			// Respond to mouse wheel in IE. (It returns up/dn motion in multiples of 120)
			if (e.wheelDelta >= 120)
				this.adjustValue(this.spinCfg.step);
			else if (e.wheelDelta <= -120)
				this.adjustValue(-this.spinCfg.step);
			
			e.preventDefault();
		})
		
		.change(function(e){
			this.adjustValue(0);
		});
		
		if (this.addEventListener) {
			// Respond to mouse wheel in Firefox
			this.addEventListener('DOMMouseScroll', function(e) {
				if (e.detail > 0)
					this.adjustValue(-this.spinCfg.step);
				else if (e.detail < 0)
					this.adjustValue(this.spinCfg.step);
				
				e.preventDefault();
			}, false);
		}
	});
	
	function coord(el,prop) {
		var c = el[prop], b = document.body;
		
		while ((el = el.offsetParent) && (el != b)) {
			if (!jQuery.browser.msie || (el.currentStyle.position != 'relative'))
				c += el[prop];
		}
		
		return c;
	}
};

// Backbone.js 0.5.3
// (c) 2010 Jeremy Ashkenas, DocumentCloud Inc.
// Backbone may be freely distributed under the MIT license.
// For all details and documentation:
// http://documentcloud.github.com/backbone
(function(){var h=this,p=h.Backbone,e;e=typeof exports!=="undefined"?exports:h.Backbone={};e.VERSION="0.5.3";var f=h._;if(!f&&typeof require!=="undefined")f=require("underscore")._;var g=h.jQuery||h.Zepto;e.noConflict=function(){h.Backbone=p;return this};e.emulateHTTP=!1;e.emulateJSON=!1;e.Events={bind:function(a,b,c){var d=this._callbacks||(this._callbacks={});(d[a]||(d[a]=[])).push([b,c]);return this},unbind:function(a,b){var c;if(a){if(c=this._callbacks)if(b){c=c[a];if(!c)return this;for(var d=
0,e=c.length;d<e;d++)if(c[d]&&b===c[d][0]){c[d]=null;break}}else c[a]=[]}else this._callbacks={};return this},trigger:function(a){var b,c,d,e,f=2;if(!(c=this._callbacks))return this;for(;f--;)if(b=f?a:"all",b=c[b])for(var g=0,h=b.length;g<h;g++)(d=b[g])?(e=f?Array.prototype.slice.call(arguments,1):arguments,d[0].apply(d[1]||this,e)):(b.splice(g,1),g--,h--);return this}};e.Model=function(a,b){var c;a||(a={});if(c=this.defaults)f.isFunction(c)&&(c=c.call(this)),a=f.extend({},c,a);this.attributes={};
this._escapedAttributes={};this.cid=f.uniqueId("c");this.set(a,{silent:!0});this._changed=!1;this._previousAttributes=f.clone(this.attributes);if(b&&b.collection)this.collection=b.collection;this.initialize(a,b)};f.extend(e.Model.prototype,e.Events,{_previousAttributes:null,_changed:!1,idAttribute:"id",initialize:function(){},toJSON:function(){return f.clone(this.attributes)},get:function(a){return this.attributes[a]},escape:function(a){var b;if(b=this._escapedAttributes[a])return b;b=this.attributes[a];
return this._escapedAttributes[a]=(b==null?"":""+b).replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/\//g,"&#x2F;")},has:function(a){return this.attributes[a]!=null},set:function(a,b){b||(b={});if(!a)return this;if(a.attributes)a=a.attributes;var c=this.attributes,d=this._escapedAttributes;if(!b.silent&&this.validate&&!this._performValidation(a,b))return!1;if(this.idAttribute in a)this.id=a[this.idAttribute];
var e=this._changing;this._changing=!0;for(var g in a){var h=a[g];if(!f.isEqual(c[g],h))c[g]=h,delete d[g],this._changed=!0,b.silent||this.trigger("change:"+g,this,h,b)}!e&&!b.silent&&this._changed&&this.change(b);this._changing=!1;return this},unset:function(a,b){if(!(a in this.attributes))return this;b||(b={});var c={};c[a]=void 0;if(!b.silent&&this.validate&&!this._performValidation(c,b))return!1;delete this.attributes[a];delete this._escapedAttributes[a];a==this.idAttribute&&delete this.id;this._changed=
!0;b.silent||(this.trigger("change:"+a,this,void 0,b),this.change(b));return this},clear:function(a){a||(a={});var b,c=this.attributes,d={};for(b in c)d[b]=void 0;if(!a.silent&&this.validate&&!this._performValidation(d,a))return!1;this.attributes={};this._escapedAttributes={};this._changed=!0;if(!a.silent){for(b in c)this.trigger("change:"+b,this,void 0,a);this.change(a)}return this},fetch:function(a){a||(a={});var b=this,c=a.success;a.success=function(d,e,f){if(!b.set(b.parse(d,f),a))return!1;c&&
c(b,d)};a.error=i(a.error,b,a);return(this.sync||e.sync).call(this,"read",this,a)},save:function(a,b){b||(b={});if(a&&!this.set(a,b))return!1;var c=this,d=b.success;b.success=function(a,e,f){if(!c.set(c.parse(a,f),b))return!1;d&&d(c,a,f)};b.error=i(b.error,c,b);var f=this.isNew()?"create":"update";return(this.sync||e.sync).call(this,f,this,b)},destroy:function(a){a||(a={});if(this.isNew())return this.trigger("destroy",this,this.collection,a);var b=this,c=a.success;a.success=function(d){b.trigger("destroy",
b,b.collection,a);c&&c(b,d)};a.error=i(a.error,b,a);return(this.sync||e.sync).call(this,"delete",this,a)},url:function(){var a=k(this.collection)||this.urlRoot||l();if(this.isNew())return a;return a+(a.charAt(a.length-1)=="/"?"":"/")+encodeURIComponent(this.id)},parse:function(a){return a},clone:function(){return new this.constructor(this)},isNew:function(){return this.id==null},change:function(a){this.trigger("change",this,a);this._previousAttributes=f.clone(this.attributes);this._changed=!1},hasChanged:function(a){if(a)return this._previousAttributes[a]!=
this.attributes[a];return this._changed},changedAttributes:function(a){a||(a=this.attributes);var b=this._previousAttributes,c=!1,d;for(d in a)f.isEqual(b[d],a[d])||(c=c||{},c[d]=a[d]);return c},previous:function(a){if(!a||!this._previousAttributes)return null;return this._previousAttributes[a]},previousAttributes:function(){return f.clone(this._previousAttributes)},_performValidation:function(a,b){var c=this.validate(a);if(c)return b.error?b.error(this,c,b):this.trigger("error",this,c,b),!1;return!0}});
e.Collection=function(a,b){b||(b={});if(b.comparator)this.comparator=b.comparator;f.bindAll(this,"_onModelEvent","_removeReference");this._reset();a&&this.reset(a,{silent:!0});this.initialize.apply(this,arguments)};f.extend(e.Collection.prototype,e.Events,{model:e.Model,initialize:function(){},toJSON:function(){return this.map(function(a){return a.toJSON()})},add:function(a,b){if(f.isArray(a))for(var c=0,d=a.length;c<d;c++)this._add(a[c],b);else this._add(a,b);return this},remove:function(a,b){if(f.isArray(a))for(var c=
0,d=a.length;c<d;c++)this._remove(a[c],b);else this._remove(a,b);return this},get:function(a){if(a==null)return null;return this._byId[a.id!=null?a.id:a]},getByCid:function(a){return a&&this._byCid[a.cid||a]},at:function(a){return this.models[a]},sort:function(a){a||(a={});if(!this.comparator)throw Error("Cannot sort a set without a comparator");this.models=this.sortBy(this.comparator);a.silent||this.trigger("reset",this,a);return this},pluck:function(a){return f.map(this.models,function(b){return b.get(a)})},
reset:function(a,b){a||(a=[]);b||(b={});this.each(this._removeReference);this._reset();this.add(a,{silent:!0});b.silent||this.trigger("reset",this,b);return this},fetch:function(a){a||(a={});var b=this,c=a.success;a.success=function(d,f,e){b[a.add?"add":"reset"](b.parse(d,e),a);c&&c(b,d)};a.error=i(a.error,b,a);return(this.sync||e.sync).call(this,"read",this,a)},create:function(a,b){var c=this;b||(b={});a=this._prepareModel(a,b);if(!a)return!1;var d=b.success;b.success=function(a,e,f){c.add(a,b);
d&&d(a,e,f)};a.save(null,b);return a},parse:function(a){return a},chain:function(){return f(this.models).chain()},_reset:function(){this.length=0;this.models=[];this._byId={};this._byCid={}},_prepareModel:function(a,b){if(a instanceof e.Model){if(!a.collection)a.collection=this}else{var c=a;a=new this.model(c,{collection:this});a.validate&&!a._performValidation(c,b)&&(a=!1)}return a},_add:function(a,b){b||(b={});a=this._prepareModel(a,b);if(!a)return!1;var c=this.getByCid(a);if(c)throw Error(["Can't add the same model to a set twice",
c.id]);this._byId[a.id]=a;this._byCid[a.cid]=a;this.models.splice(b.at!=null?b.at:this.comparator?this.sortedIndex(a,this.comparator):this.length,0,a);a.bind("all",this._onModelEvent);this.length++;b.silent||a.trigger("add",a,this,b);return a},_remove:function(a,b){b||(b={});a=this.getByCid(a)||this.get(a);if(!a)return null;delete this._byId[a.id];delete this._byCid[a.cid];this.models.splice(this.indexOf(a),1);this.length--;b.silent||a.trigger("remove",a,this,b);this._removeReference(a);return a},
_removeReference:function(a){this==a.collection&&delete a.collection;a.unbind("all",this._onModelEvent)},_onModelEvent:function(a,b,c,d){(a=="add"||a=="remove")&&c!=this||(a=="destroy"&&this._remove(b,d),b&&a==="change:"+b.idAttribute&&(delete this._byId[b.previous(b.idAttribute)],this._byId[b.id]=b),this.trigger.apply(this,arguments))}});f.each(["forEach","each","map","reduce","reduceRight","find","detect","filter","select","reject","every","all","some","any","include","contains","invoke","max",
"min","sortBy","sortedIndex","toArray","size","first","rest","last","without","indexOf","lastIndexOf","isEmpty","groupBy"],function(a){e.Collection.prototype[a]=function(){return f[a].apply(f,[this.models].concat(f.toArray(arguments)))}});e.Router=function(a){a||(a={});if(a.routes)this.routes=a.routes;this._bindRoutes();this.initialize.apply(this,arguments)};var q=/:([\w\d]+)/g,r=/\*([\w\d]+)/g,s=/[-[\]{}()+?.,\\^$|#\s]/g;f.extend(e.Router.prototype,e.Events,{initialize:function(){},route:function(a,
b,c){e.history||(e.history=new e.History);f.isRegExp(a)||(a=this._routeToRegExp(a));e.history.route(a,f.bind(function(d){d=this._extractParameters(a,d);c.apply(this,d);this.trigger.apply(this,["route:"+b].concat(d))},this))},navigate:function(a,b){e.history.navigate(a,b)},_bindRoutes:function(){if(this.routes){var a=[],b;for(b in this.routes)a.unshift([b,this.routes[b]]);b=0;for(var c=a.length;b<c;b++)this.route(a[b][0],a[b][1],this[a[b][1]])}},_routeToRegExp:function(a){a=a.replace(s,"\\$&").replace(q,
"([^/]*)").replace(r,"(.*?)");return RegExp("^"+a+"$")},_extractParameters:function(a,b){return a.exec(b).slice(1)}});e.History=function(){this.handlers=[];f.bindAll(this,"checkUrl")};var j=/^#*/,t=/msie [\w.]+/,m=!1;f.extend(e.History.prototype,{interval:50,getFragment:function(a,b){if(a==null)if(this._hasPushState||b){a=window.location.pathname;var c=window.location.search;c&&(a+=c);a.indexOf(this.options.root)==0&&(a=a.substr(this.options.root.length))}else a=window.location.hash;return decodeURIComponent(a.replace(j,
""))},start:function(a){if(m)throw Error("Backbone.history has already been started");this.options=f.extend({},{root:"/"},this.options,a);this._wantsPushState=!!this.options.pushState;this._hasPushState=!(!this.options.pushState||!window.history||!window.history.pushState);a=this.getFragment();var b=document.documentMode;if(b=t.exec(navigator.userAgent.toLowerCase())&&(!b||b<=7))this.iframe=g('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow,this.navigate(a);
this._hasPushState?g(window).bind("popstate",this.checkUrl):"onhashchange"in window&&!b?g(window).bind("hashchange",this.checkUrl):setInterval(this.checkUrl,this.interval);this.fragment=a;m=!0;a=window.location;b=a.pathname==this.options.root;if(this._wantsPushState&&!this._hasPushState&&!b)return this.fragment=this.getFragment(null,!0),window.location.replace(this.options.root+"#"+this.fragment),!0;else if(this._wantsPushState&&this._hasPushState&&b&&a.hash)this.fragment=a.hash.replace(j,""),window.history.replaceState({},
document.title,a.protocol+"//"+a.host+this.options.root+this.fragment);if(!this.options.silent)return this.loadUrl()},route:function(a,b){this.handlers.unshift({route:a,callback:b})},checkUrl:function(){var a=this.getFragment();a==this.fragment&&this.iframe&&(a=this.getFragment(this.iframe.location.hash));if(a==this.fragment||a==decodeURIComponent(this.fragment))return!1;this.iframe&&this.navigate(a);this.loadUrl()||this.loadUrl(window.location.hash)},loadUrl:function(a){var b=this.fragment=this.getFragment(a);
return f.any(this.handlers,function(a){if(a.route.test(b))return a.callback(b),!0})},navigate:function(a,b){var c=(a||"").replace(j,"");if(!(this.fragment==c||this.fragment==decodeURIComponent(c))){if(this._hasPushState){var d=window.location;c.indexOf(this.options.root)!=0&&(c=this.options.root+c);this.fragment=c;window.history.pushState({},document.title,d.protocol+"//"+d.host+c)}else if(window.location.hash=this.fragment=c,this.iframe&&c!=this.getFragment(this.iframe.location.hash))this.iframe.document.open().close(),
this.iframe.location.hash=c;b&&this.loadUrl(a)}}});e.View=function(a){this.cid=f.uniqueId("view");this._configure(a||{});this._ensureElement();this.delegateEvents();this.initialize.apply(this,arguments)};var u=/^(\S+)\s*(.*)$/,n=["model","collection","el","id","attributes","className","tagName"];f.extend(e.View.prototype,e.Events,{tagName:"div",$:function(a){return g(a,this.el)},initialize:function(){},render:function(){return this},remove:function(){g(this.el).remove();return this},make:function(a,
b,c){a=document.createElement(a);b&&g(a).attr(b);c&&g(a).html(c);return a},delegateEvents:function(a){if(a||(a=this.events))for(var b in f.isFunction(a)&&(a=a.call(this)),g(this.el).unbind(".delegateEvents"+this.cid),a){var c=this[a[b]];if(!c)throw Error('Event "'+a[b]+'" does not exist');var d=b.match(u),e=d[1];d=d[2];c=f.bind(c,this);e+=".delegateEvents"+this.cid;d===""?g(this.el).bind(e,c):g(this.el).delegate(d,e,c)}},_configure:function(a){this.options&&(a=f.extend({},this.options,a));for(var b=
0,c=n.length;b<c;b++){var d=n[b];a[d]&&(this[d]=a[d])}this.options=a},_ensureElement:function(){if(this.el){if(f.isString(this.el))this.el=g(this.el).get(0)}else{var a=this.attributes||{};if(this.id)a.id=this.id;if(this.className)a["class"]=this.className;this.el=this.make(this.tagName,a)}}});e.Model.extend=e.Collection.extend=e.Router.extend=e.View.extend=function(a,b){var c=v(this,a,b);c.extend=this.extend;return c};var w={create:"POST",update:"PUT","delete":"DELETE",read:"GET"};e.sync=function(a,
b,c){var d=w[a];c=f.extend({type:d,dataType:"json"},c);if(!c.url)c.url=k(b)||l();if(!c.data&&b&&(a=="create"||a=="update"))c.contentType="application/json",c.data=JSON.stringify(b.toJSON());if(e.emulateJSON)c.contentType="application/x-www-form-urlencoded",c.data=c.data?{model:c.data}:{};if(e.emulateHTTP&&(d==="PUT"||d==="DELETE")){if(e.emulateJSON)c.data._method=d;c.type="POST";c.beforeSend=function(a){a.setRequestHeader("X-HTTP-Method-Override",d)}}if(c.type!=="GET"&&!e.emulateJSON)c.processData=
!1;return g.ajax(c)};var o=function(){},v=function(a,b,c){var d;d=b&&b.hasOwnProperty("constructor")?b.constructor:function(){return a.apply(this,arguments)};f.extend(d,a);o.prototype=a.prototype;d.prototype=new o;b&&f.extend(d.prototype,b);c&&f.extend(d,c);d.prototype.constructor=d;d.__super__=a.prototype;return d},k=function(a){if(!a||!a.url)return null;return f.isFunction(a.url)?a.url():a.url},l=function(){throw Error('A "url" property or function must be specified');},i=function(a,b,c){return function(d){a?
a(b,d,c):b.trigger("error",b,d,c)}}}).call(this);

String.prototype.rsplit=function(F){var E=this;var A=F.exec(E);var G=new Array();while(A!=null){var D=A.index;var C=F.lastIndex;if((D)!=0){var B=E.substring(0,D);G.push(E.substring(0,D));E=E.slice(D)}G.push(A[0]);E=E.slice(A[0].length);A=F.exec(E)}if(!E==""){G.push(E)}return G};String.prototype.chop=function(){return this.substr(0,this.length-1)};var EjsScanner=function(B,C,A){this.left_delimiter=C+"%";this.right_delimiter="%"+A;this.double_left=C+"%%";this.double_right="%%"+A;this.left_equal=C+"%=";this.left_comment=C+"%#";if(C=="["){this.SplitRegexp=/(\[%%)|(%%\])|(\[%=)|(\[%#)|(\[%)|(%\]\n)|(%\])|(\n)/}else{this.SplitRegexp=new RegExp("("+this.double_left+")|(%%"+this.double_right+")|("+this.left_equal+")|("+this.left_comment+")|("+this.left_delimiter+")|("+this.right_delimiter+"\n)|("+this.right_delimiter+")|(\n)")}this.source=B;this.stag=null;this.lines=0};EjsView=function(A){this.data=A};EjsView.prototype.partial=function(A,B){if(!B){B=this.data}return new EJS(A).render(B)};EjsScanner.to_text=function(A){if(A==null||A===undefined){return""}if(A instanceof Date){return A.toDateString()}if(A.toString){return A.toString()}return""};EjsScanner.prototype={scan:function(D){scanline=this.scanline;regex=this.SplitRegexp;if(!this.source==""){var C=this.source.rsplit(/\n/);for(var A=0;A<C.length;A++){var B=C[A];this.scanline(B,regex,D)}}},scanline:function(A,D,G){this.lines++;var E=A.rsplit(D);for(var C=0;C<E.length;C++){var B=E[C];if(B!=null){try{G(B,this)}catch(F){throw {type:"EjsScanner",line:this.lines}}}}}};var EjsBuffer=function(B,C){this.line=new Array();this.script="";this.pre_cmd=B;this.post_cmd=C;for(var A=0;A<this.pre_cmd.length;A++){this.push(B[A])}};EjsBuffer.prototype={push:function(A){this.line.push(A)},cr:function(){this.script=this.script+this.line.join("; ");this.line=new Array();this.script=this.script+"\n"},close:function(){if(this.line.length>0){for(var A=0;A<this.post_cmd.length;A++){this.push(pre_cmd[A])}this.script=this.script+this.line.join("; ");line=null}}};EjsCompiler=function(B,C){this.pre_cmd=['___ejsO = "";'];this.post_cmd=new Array();this.source=" ";if(B!=null){if(typeof B=="string"){B=B.replace(/\r\n/g,"\n");B=B.replace(/\r/g,"\n");this.source=B}else{if(B.innerHTML){this.source=B.innerHTML}}if(typeof this.source!="string"){this.source=""}}C=C||"<";var A=">";switch(C){case"[":A="]";break;case"<":break;default:throw C+" is not a supported deliminator";break}this.scanner=new EjsScanner(this.source,C,A);this.out=""};EjsCompiler.prototype={compile:function(options){options=options||{};this.out="";var put_cmd="___ejsO += ";var insert_cmd=put_cmd;var buff=new EjsBuffer(this.pre_cmd,this.post_cmd);var content="";var clean=function(content){content=content.replace(/\\/g,"\\\\");content=content.replace(/\n/g,"\\n");content=content.replace(/"/g,'\\"');return content};this.scanner.scan(function(token,scanner){if(scanner.stag==null){switch(token){case"\n":content=content+"\n";buff.push(put_cmd+'"'+clean(content)+'";');buff.cr();content="";break;case scanner.left_delimiter:case scanner.left_equal:case scanner.left_comment:scanner.stag=token;if(content.length>0){buff.push(put_cmd+'"'+clean(content)+'"')}content="";break;case scanner.double_left:content=content+scanner.left_delimiter;break;default:content=content+token;break}}else{switch(token){case scanner.right_delimiter:switch(scanner.stag){case scanner.left_delimiter:if(content[content.length-1]=="\n"){content=content.chop();buff.push(content);buff.cr()}else{buff.push(content)}break;case scanner.left_equal:buff.push(insert_cmd+"(EjsScanner.to_text("+content+"))");break}scanner.stag=null;content="";break;case scanner.double_right:content=content+scanner.right_delimiter;break;default:content=content+token;break}}});if(content.length>0){buff.push(put_cmd+'"'+clean(content)+'"')}buff.close();this.out=buff.script+";";var to_be_evaled="this.process = function(_CONTEXT,_VIEW) { try { with(_VIEW) { with (_CONTEXT) {"+this.out+" return ___ejsO;}}}catch(e){e.lineNumber=null;throw e;}};";try{eval(to_be_evaled)}catch(e){if(typeof JSLINT!="undefined"){JSLINT(this.out);for(var i=0;i<JSLINT.errors.length;i++){var error=JSLINT.errors[i];if(error.reason!="Unnecessary semicolon."){error.line++;var e=new Error();e.lineNumber=error.line;e.message=error.reason;if(options.url){e.fileName=options.url}throw e}}}else{throw e}}}};EJS=function(B){this.set_options(B);if(B.url){var C=EJS.get(B.url,this.cache);if(C){return C}if(C==EJS.INVALID_PATH){return null}this.text=EJS.request(B.url);if(this.text==null){throw"There is no template at "+B.url}this.name=B.url}else{if(B.element){if(typeof B.element=="string"){var A=B.element;B.element=document.getElementById(B.element);if(B.element==null){throw A+"does not exist!"}}if(B.element.value){this.text=B.element.value}else{this.text=B.element.innerHTML}this.name=B.element.id;this.type="["}}var C=new EjsCompiler(this.text,this.type);C.compile(B);EJS.update(this.name,this);this.template=C};EJS.config=function(B){EJS.cache=B.cache!=null?B.cache:EJS.cache;EJS.type=B.type!=null?B.type:EJS.type;var A={};EJS.get=function(D,C){if(C==false){return null}if(A[D]){return A[D]}return null};EJS.update=function(D,C){if(D==null){return }A[D]=C};EJS.INVALID_PATH=-1};EJS.config({cache:true,type:"<"});EJS.prototype={render:function(B){var A=new EjsView(B);return this.template.process.call(A,B,A)},out:function(){return this.template.out},set_options:function(A){this.type=A.type!=null?A.type:EJS.type;this.cache=A.cache!=null?A.cache:EJS.cache;this.text=A.text!=null?A.text:null;this.name=A.name!=null?A.name:null},update:function(element,options){if(typeof element=="string"){element=document.getElementById(element)}if(options==null){_template=this;return function(object){EJS.prototype.update.call(_template,element,object)}}if(typeof options=="string"){params={};params.url=options;_template=this;params.onComplete=function(request){var object=eval(request.responseText);EJS.prototype.update.call(_template,element,object)};EJS.ajax_request(params)}else{element.innerHTML=this.render(options)}}};EJS.newRequest=function(){var C=[function(){return new ActiveXObject("Msxml2.XMLHTTP")},function(){return new XMLHttpRequest()},function(){return new ActiveXObject("Microsoft.XMLHTTP")}];for(var A=0;A<C.length;A++){try{var B=C[A]();if(B!=null){return B}}catch(D){continue}}};EJS.request=function(C){var A=new EJS.newRequest();A.open("GET",C,false);try{A.send(null)}catch(B){return null}if(A.status==404||A.status==2||(A.status==0&&A.responseText=="")){return null}return A.responseText};EJS.ajax_request=function(B){B.method=(B.method?B.method:"GET");var A=new EJS.newRequest();A.onreadystatechange=function(){if(A.readyState==4){if(A.status==200){B.onComplete(A)}else{B.onComplete(A)}}};A.open(B.method,B.url);A.send(null)};EjsView.prototype.date_tag=function(C,O,A){if(!(O instanceof Date)){O=new Date()}var B=["January","February","March","April","May","June","July","August","September","October","November","December"];var G=[],D=[],P=[];var J=O.getFullYear();var H=O.getMonth();var N=O.getDate();for(var M=J-15;M<J+15;M++){G.push({value:M,text:M})}for(var E=0;E<12;E++){D.push({value:(E),text:B[E]})}for(var I=0;I<31;I++){P.push({value:(I+1),text:(I+1)})}var L=this.select_tag(C+"[year]",J,G,{id:C+"[year]"});var F=this.select_tag(C+"[month]",H,D,{id:C+"[month]"});var K=this.select_tag(C+"[day]",N,P,{id:C+"[day]"});return L+F+K};EjsView.prototype.form_tag=function(B,A){A=A||{};A.action=B;if(A.multipart==true){A.method="post";A.enctype="multipart/form-data"}return this.start_tag_for("form",A)};EjsView.prototype.form_tag_end=function(){return this.tag_end("form")};EjsView.prototype.hidden_field_tag=function(A,C,B){return this.input_field_tag(A,C,"hidden",B)};EjsView.prototype.input_field_tag=function(A,D,C,B){B=B||{};B.id=B.id||A;B.value=D||"";B.type=C||"text";B.name=A;return this.single_tag_for("input",B)};EjsView.prototype.is_current_page=function(A){return(window.location.href==A||window.location.pathname==A?true:false)};EjsView.prototype.link_to=function(B,A,C){if(!B){var B="null"}if(!C){var C={}}if(C.confirm){C.onclick=' var ret_confirm = confirm("'+C.confirm+'"); if(!ret_confirm){ return false;} ';C.confirm=null}C.href=A;return this.start_tag_for("a",C)+B+this.tag_end("a")};EjsView.prototype.submit_link_to=function(B,A,C){if(!B){var B="null"}if(!C){var C={}}C.onclick=C.onclick||"";if(C.confirm){C.onclick=' var ret_confirm = confirm("'+C.confirm+'"); if(!ret_confirm){ return false;} ';C.confirm=null}C.value=B;C.type="submit";C.onclick=C.onclick+(A?this.url_for(A):"")+"return false;";return this.start_tag_for("input",C)};EjsView.prototype.link_to_if=function(F,B,A,D,C,E){return this.link_to_unless((F==false),B,A,D,C,E)};EjsView.prototype.link_to_unless=function(E,B,A,C,D){C=C||{};if(E){if(D&&typeof D=="function"){return D(B,A,C,D)}else{return B}}else{return this.link_to(B,A,C)}};EjsView.prototype.link_to_unless_current=function(B,A,C,D){C=C||{};return this.link_to_unless(this.is_current_page(A),B,A,C,D)};EjsView.prototype.password_field_tag=function(A,C,B){return this.input_field_tag(A,C,"password",B)};EjsView.prototype.select_tag=function(D,G,H,F){F=F||{};F.id=F.id||D;F.value=G;F.name=D;var B="";B+=this.start_tag_for("select",F);for(var E=0;E<H.length;E++){var C=H[E];var A={value:C.value};if(C.value==G){A.selected="selected"}B+=this.start_tag_for("option",A)+C.text+this.tag_end("option")}B+=this.tag_end("select");return B};EjsView.prototype.single_tag_for=function(A,B){return this.tag(A,B,"/>")};EjsView.prototype.start_tag_for=function(A,B){return this.tag(A,B)};EjsView.prototype.submit_tag=function(A,B){B=B||{};B.type=B.type||"submit";B.value=A||"Submit";return this.single_tag_for("input",B)};EjsView.prototype.tag=function(C,E,D){if(!D){var D=">"}var B=" ";for(var A in E){if(E[A]!=null){var F=E[A].toString()}else{var F=""}if(A=="Class"){A="class"}if(F.indexOf("'")!=-1){B+=A+'="'+F+'" '}else{B+=A+"='"+F+"' "}}return"<"+C+B+D};EjsView.prototype.tag_end=function(A){return"</"+A+">"};EjsView.prototype.text_area_tag=function(A,C,B){B=B||{};B.id=B.id||A;B.name=B.name||A;C=C||"";if(B.size){B.cols=B.size.split("x")[0];B.rows=B.size.split("x")[1];delete B.size}B.cols=B.cols||50;B.rows=B.rows||4;return this.start_tag_for("textarea",B)+C+this.tag_end("textarea")};EjsView.prototype.text_tag=EjsView.prototype.text_area_tag;EjsView.prototype.text_field_tag=function(A,C,B){return this.input_field_tag(A,C,"text",B)};EjsView.prototype.url_for=function(A){return'window.location="'+A+'";'};EjsView.prototype.img_tag=function(B,C,A){A=A||{};A.src=B;A.alt=C;return this.single_tag_for("img",A)};

/*
 Copyright 2012 Igor Vaynberg

 Licensed under the Apache License, Version 2.0 (the "License"); you may not use this work except in
 compliance with the License. You may obtain a copy of the License in the LICENSE file, or at:

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under the License is
 distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and limitations under the License.
 */
(function ($, undefined) {
    "use strict";
    /*global document, window, jQuery, console */

    if (window.Select2 !== undefined) {
        return;
    }

    var KEY, AbstractSelect2, SingleSelect2, MultiSelect2;

    KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        isArrow: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.LEFT:
            case KEY.RIGHT:
            case KEY.UP:
            case KEY.DOWN:
                return true;
            }
            return false;
        },
        isControl: function (k) {
            k = k.which ? k.which : k;
            switch (k) {
            case KEY.SHIFT:
            case KEY.CTRL:
            case KEY.ALT:
                return true;
            }
            return false;
        },
        isFunctionKey: function (k) {
            k = k.which ? k.which : k;
            return k >= 112 && k <= 123;
        }
    };

    function indexOf(value, array) {
        var i = 0, l = array.length, v;

        if (value.constructor === String) {
            for (; i < l; i = i + 1) if (value.localeCompare(array[i]) === 0) return i;
        } else {
            for (; i < l; i = i + 1) {
                v = array[i];
                if (v.constructor === String) {
                    if (v.localeCompare(value) === 0) return i;
                } else {
                    if (v === value) return i;
                }
            }
        }
        return -1;
    }

    /**
     * Compares equality of a and b taking into account that a and b may be strings, in which case localCompare is used
     * @param a
     * @param b
     */
    function equal(a, b) {
        if (a === b) return true;
        if (a === undefined || b === undefined) return false;
        if (a === null || b === null) return false;
        if (a.constructor === String) return a.localeCompare(b) === 0;
        if (b.constructor === String) return b.localeCompare(a) === 0;
        return false;
    }

    /**
     * Splits the string into an array of values, trimming each value. An empty array is returned for nulls or empty
     * strings
     * @param string
     * @param separator
     */
    function splitVal(string, separator) {
        var val, i, l;
        if (string === null || string.length < 1) return [];
        val = string.split(separator);
        for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
        return val;
    }

    function getSideBorderPadding(element) {
        return element.outerWidth() - element.width();
    }

    function installKeyUpChangeEvent(element) {
        element.bind("keydown", function () {
            element.data("keyup-change-value", element.val());
        });
        element.bind("keyup", function () {
            if (element.val() !== element.data("keyup-change-value")) {
                element.trigger("keyup-change");
            }
        });
    }

    /**
     * filters mouse events so an event is fired only if the mouse moved.
     *
     * filters out mouse events that occur when mouse is stationary but
     * the elements under the pointer are scrolled.
     */
    $(document).delegate("*", "mousemove", function (e) {
        $(document).data("select2-lastpos", {x: e.pageX, y: e.pageY});
    });
    function installFilteredMouseMove(element) {
        element.bind("mousemove", function (e) {
            var lastpos = $(document).data("select2-lastpos");
            if (lastpos === undefined || lastpos.x !== e.pageX || lastpos.y !== e.pageY) {
                $(e.target).trigger("mousemove-filtered", e);
            }
        });
    }

    /**
     * Debounces a function. Returns a function that calls the original fn function only if no invocations have been made
     * within the last quietMillis milliseconds.
     *
     * @param quietMillis number of milliseconds to wait before invoking fn
     * @param fn function to be debounced
     * @return debounced version of fn
     */
    function debounce(quietMillis, fn) {
        var timeout;
        return function () {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(fn, quietMillis);
        };
    }

    function installDebouncedScroll(threshold, element) {
        var notify = debounce(threshold, function (e) { element.trigger("scroll-debounced", e);});
        element.bind("scroll", function (e) {
            if (indexOf(e.target, element.get()) >= 0) notify(e);
        });
    }

    function killEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    function measureTextWidth(e) {
        var sizer, width;
        sizer = $("<div></div>").css({
            position: "absolute",
            left: "-1000px",
            top: "-1000px",
            display: "none",
            fontSize: e.css("fontSize"),
            fontFamily: e.css("fontFamily"),
            fontStyle: e.css("fontStyle"),
            fontWeight: e.css("fontWeight"),
            letterSpacing: e.css("letterSpacing"),
            textTransform: e.css("textTransform"),
            whiteSpace: "nowrap"
        });
        sizer.text(e.val());
        $("body").append(sizer);
        width = sizer.width();
        sizer.remove();
        return width;
    }

    /**
     * Produces an ajax-based query function
     *
     * @param options object containing configuration paramters
     * @param options.transport function that will be used to execute the ajax request. must be compatible with parameters supported by $.ajax
     * @param options.url url for the data
     * @param options.data a function(searchTerm, pageNumber) that should return an object containing query string parameters for the above url.
     * @param options.dataType request data type: ajax, jsonp, other datatatypes supported by jQuery's $.ajax function or the transport function if specified
     * @param options.quietMillis (optional) milliseconds to wait before making the ajaxRequest, helps debounce the ajax function if invoked too often
     * @param options.results a function(remoteData, pageNumber) that converts data returned form the remote request to the format expected by Select2.
     *      The expected format is an object containing the following keys:
     *      results array of objects that will be used as choices
     *      more (optional) boolean indicating whether there are more results available
     *      Example: {results:[{id:1, text:'Red'},{id:2, text:'Blue'}], more:true}
     */
    function ajax(options) {
        var timeout, // current scheduled but not yet executed request
            requestSequence = 0, // sequence used to drop out-of-order responses
            handler = null,
            quietMillis = options.quietMillis || 100;

        return function (query) {
            window.clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                requestSequence += 1; // increment the sequence
                var requestNumber = requestSequence, // this request's sequence number
                    data = options.data, // ajax data function
                    transport = options.transport || $.ajax;

                data = data.call(this, query.term, query.page);

                if( null !== handler){
                    handler.abort();
                }
                handler = transport.call(null, {
                    url: options.url,
                    dataType: options.dataType,
                    data: data,
                    success: function (data) {
                        if (requestNumber < requestSequence) {
                            return;
                        }
                        // TODO 3.0 - replace query.page with query so users have access to term, page, etc.
                        query.callback(options.results(data, query.page));
                    }
                });
            }, quietMillis);
        };
    }

    /**
     * Produces a query function that works with a local array
     *
     * @param options object containing configuration parameters. The options parameter can either be an array or an
     * object.
     *
     * If the array form is used it is assumed that it contains objects with 'id' and 'text' keys.
     *
     * If the object form is used ti is assumed that it contains 'data' and 'text' keys. The 'data' key should contain
     * an array of objects that will be used as choices. These objects must contain at least an 'id' key. The 'text'
     * key can either be a String in which case it is expected that each element in the 'data' array has a key with the
     * value of 'text' which will be used to match choices. Alternatively, text can be a function(item) that can extract
     * the text.
     */
    function local(options) {
        var data = options, // data elements
            text = function (item) { return item.text; }; // function used to retrieve the text portion of a data item that is matched against the search

        if (!$.isArray(data)) {
            text = data.text;
            // if text is not a function we assume it to be a key name
            if (!$.isFunction(text)) text = function (item) { return item[data.text]; };
            data = data.results;
        }

        return function (query) {
            var t = query.term.toUpperCase(), filtered = {};
            if (t === "") {
                query.callback({results: data});
                return;
            }
            filtered.results = $(data)
                .filter(function () {return text(this).toUpperCase().indexOf(t) >= 0;})
                .get();
            query.callback(filtered);
        };
    }

    // TODO javadoc
    function tags(data) {
        // TODO even for a function we should probably return a wrapper that does the same object/string check as
        // the function for arrays. otherwise only functions that return objects are supported.
        if ($.isFunction(data)) {
            return data;
        }

        // if not a function we assume it to be an array

        return function (query) {
            var t = query.term.toUpperCase(), filtered = {results: []};
            $(data).each(function () {
                var isObject = this.text !== undefined,
                    text = isObject ? this.text : this;
                if (t === "" || text.toUpperCase().indexOf(t) >= 0) {
                    filtered.results.push(isObject ? this : {id: this, text: this});
                }
            });
            query.callback(filtered);
        };
    }

    /**
     * blurs any Select2 container that has focus when an element outside them was clicked or received focus
     */
    $(document).ready(function () {
        $(document).delegate("*", "mousedown focusin", function (e) {
            var target = $(e.target).closest("div.select2-container").get(0);
            $(document).find("div.select2-container-active").each(function () {
                if (this !== target) $(this).data("select2").blur();
            });
        });
    });

    /**
     * Creates a new class
     *
     * @param superClass
     * @param methods
     */
    function clazz(SuperClass, methods) {
        var constructor = function () {};
        constructor.prototype = new SuperClass;
        constructor.prototype.constructor = constructor;
        constructor.prototype.parent = SuperClass.prototype;
        constructor.prototype = $.extend(constructor.prototype, methods);
        return constructor;
    }

    AbstractSelect2 = clazz(Object, {

        bind: function (func) {
            var self = this;
            return function () {
                func.apply(self, arguments);
            };
        },

        init: function (opts) {
            var results, search, resultsSelector = ".select2-results";

            // prepare options
            this.opts = opts = this.prepareOpts(opts);

            this.id=opts.id;

            // destroy if called on an existing component
            if (opts.element.data("select2") !== undefined) {
                this.destroy();
            }

            this.container = this.createContainer();

            if (opts.element.attr("class") !== undefined) {
                this.container.addClass(opts.element.attr("class"));
            }

            // swap container for the element
            this.opts.element
                .data("select2", this)
                .hide()
                .after(this.container);
            this.container.data("select2", this);

            this.dropdown = this.container.find(".select2-drop");
            this.results = results = this.container.find(resultsSelector);
            this.search = search = this.container.find("input[type=text]");

            this.resultsPage = 0;

            // initialize the container
            this.initContainer();

            installFilteredMouseMove(this.results);
            this.container.delegate(resultsSelector, "mousemove-filtered", this.bind(this.highlightUnderEvent));

            installDebouncedScroll(80, this.results);
            this.container.delegate(resultsSelector, "scroll-debounced", this.bind(this.loadMoreIfNeeded));

            // if jquery.mousewheel plugin is installed we can prevent out-of-bounds scrolling of results via mousewheel
            if ($.fn.mousewheel) {
                results.mousewheel(function (e, delta, deltaX, deltaY) {
                    var top = results.scrollTop(), height;
                    if (deltaY > 0 && top - deltaY <= 0) {
                        results.scrollTop(0);
                        killEvent(e);
                    } else if (deltaY < 0 && results.get(0).scrollHeight - results.scrollTop() + deltaY <= results.height()) {
                        results.scrollTop(results.get(0).scrollHeight - results.height());
                        killEvent(e);
                    }
                });
            }

            installKeyUpChangeEvent(search);
            search.bind("keyup-change", this.bind(this.updateResults));
            search.bind("focus", function () { search.addClass("select2-focused");});
            search.bind("blur", function () { search.removeClass("select2-focused");});

            this.container.delegate(resultsSelector, "click", this.bind(function (e) {
                if ($(e.target).closest(".select2-result:not(.select2-disabled)").length > 0) {
                    this.highlightUnderEvent(e);
                    this.selectHighlighted(e);
                } else {
                    killEvent(e);
                    this.focusSearch();
                }
            }));

            if ($.isFunction(this.opts.initSelection)) {
                // initialize selection based on the current value of the source element
                this.initSelection();

                // if the user has provided a function that can set selection based on the value of the source element
                // we monitor the change event on the element and trigger it, allowing for two way synchronization
                this.monitorSource();
            }
        },

        destroy: function () {
            var select2 = this.opts.element.data("select2");
            if (select2 !== undefined && select2 !== null) {
                select2.container.remove();
                select2.opts.element
                    .removeData("select2")
                    .unbind(".select2")
                    .show();
            }
        },

       // Transform an argument value into an object with arrays of IDs/Data objects.
       argify : function(value) {
          var values = [];
          var ids = [];
          if(typeof(value) === 'string'){
             values.push(value);
          }
          /*
           According to StackOverflow this is the ECMAScript standard way of detecting an array
           Link : http://stackoverflow.com/questions/4775722/javascript-check-if-object-is-array
           */
          else if(Object.prototype.toString.call( value ) === '[object Array]')
             values = value;
          else if($.isPlainObject(value))
             values.push(value);
          else
             throw "Unsupported value type.  Values must be a either a string, object, or array of either";

          // Validate that each value in the array is a plain object with at least
          // the `id` property.
          $.each(values,function(index){
             var val = values[index];
             // Convert plain string values into objects used by select2
             if(typeof(val) === 'string')
                val = values[index] = {id:val,text:val};
             // Validate the object
             if(!$.isPlainObject(val) || val.id === undefined)
                throw ("Value (" + val + ") missing property (id)");
             else
                ids.push(val.id);
          });
          if(ids.length !== values.length)
             throw "Inconsistent argument ID/Object counts.";
          return {ids: ids, objects: values};
       },       

        prepareOpts: function (opts) {
            var element, select, idKey;

            element = opts.element;

            if (element.get(0).tagName.toLowerCase() === "select") {
                this.select = select = opts.element;
            }

            if (select) {
                // these options are not allowed when attached to a select because they are picked up off the element itself
                $.each(["id", "multiple", "ajax", "query", "createSearchChoice", "initSelection", "data", "tags"], function () {
                 if (this in opts) {
                        throw new Error("Option '" + this + "' is not allowed for Select2 when attached to a <select> element.");
                    }
                });
                 }

            opts = $.extend({}, {
                formatResult: function (data) { return data.text; },
                formatSelection: function (data) { return data.text; },
                formatNoMatches: function () { return "No matches found"; },
                formatInputTooShort: function (input, min) { return "Please enter " + (min - input.length) + " more characters"; },
                minimumResultsForSearch: 0,
                minimumInputLength: 0,
                tabIndex: -1,
                id: function (e) { return e.id; }
                }, opts);

            if (typeof(opts.id) !== "function") {
                idKey = opts.id;
                opts.id = function (e) { return e[idKey]; };
            }

            if (select) {
                opts.query = this.bind(function (query) {
                    var data = {results: [], more: false},
                        term = query.term.toUpperCase(),
                        placeholder = this.getPlaceholder();
                    element.find("option").each(function (i) {
                        var e = $(this),
                            text = e.text();

                        if (i === 0 && placeholder !== undefined && text === "") return true;

                        if (text.toUpperCase().indexOf(term) >= 0) {
                            data.results.push({id: e.attr("value"), text: text});
                        }
                    });
                    query.callback(data);
                });
                // this is needed because inside val() we construct choices from options and there id is hardcoded
                opts.id=function(e) { return e.id; };
            } else {
                if (!("query" in opts)) {
                    if ("ajax" in opts) {
                        opts.query = ajax(opts.ajax);
                    } else if ("data" in opts) {
                        opts.query = local(opts.data);
                    } else if ("tags" in opts) {
                        opts.query = tags(opts.tags);
                        opts.createSearchChoice = function (term) { return {id: term, text: term}; };
                        opts.initSelection = function (element) {
                            var data = [];
                            $(splitVal(element.val(), ",")).each(function () {
                                data.push({id: this, text: this});
                            });
                            return data;
                        };
                    }
                }
            }
            if (typeof(opts.query) !== "function") {
                throw "query function not defined for Select2 " + opts.element.attr("id");
            }

            return opts;
        },

        /**
         * Monitor the original element for changes and update select2 accordingly
         */
        monitorSource: function () {
            this.opts.element.bind("change.select2", this.bind(function (e) {
                if (this.opts.element.data("select2-change-triggered") !== true) {
                    this.initSelection();
                }
            }));
        },

        /**
         * Triggers the change event on the source element
         */
        triggerChange: function () {
            // Prevents recursive triggering
            this.opts.element.data("select2-change-triggered", true);
            this.opts.element.trigger("change");
            this.opts.element.data("select2-change-triggered", false);
        },

        opened: function () {
            return this.container.hasClass("select2-dropdown-open");
        },

        tabIndex: function() {
            return this.opts.tabIndex !== null ? "tabindex='" + this.opts.tabIndex + "'" : '';
        },

        open: function () {
            if (this.opened()) return;

            this.container.addClass("select2-dropdown-open").addClass("select2-container-active");

            this.updateResults(true);
            this.dropdown.show();
            this.focusSearch();
        },

        close: function () {
            if (!this.opened()) return;

            this.dropdown.hide();
            this.container.removeClass("select2-dropdown-open");
            this.results.empty();
            this.clearSearch();
        },

        clearSearch: function () {

        },

        ensureHighlightVisible: function () {
            var results = this.results, children, index, child, hb, rb, y, more;

            children = results.children(".select2-result");
            index = this.highlight();

            if (index < 0) return;

            child = $(children[index]);

            hb = child.offset().top + child.outerHeight();

            // if this is the last child lets also make sure select2-more-results is visible
            if (index === children.length - 1) {
                more = results.find("li.select2-more-results");
                if (more.length > 0) {
                    hb = more.offset().top + more.outerHeight();
                }
            }

            rb = results.offset().top + results.outerHeight();
            if (hb > rb) {
                results.scrollTop(results.scrollTop() + (hb - rb));
            }
            y = child.offset().top - results.offset().top;

            // make sure the top of the element is visible
            if (y < 0) {
                results.scrollTop(results.scrollTop() + y); // y is negative
            }
        },

        moveHighlight: function (delta) {
            var choices = this.results.children(".select2-result"),
                index = this.highlight();

            while (index > -1 && index < choices.length) {
                index += delta;
                if (!$(choices[index]).hasClass("select2-disabled")) {
                    this.highlight(index);
                    break;
                }
            }
        },

        highlight: function (index) {
            var choices = this.results.children(".select2-result");

            if (arguments.length === 0) {
                return indexOf(choices.filter(".select2-highlighted")[0], choices.get());
            }

            choices.removeClass("select2-highlighted");

            if (index >= choices.length) index = choices.length - 1;
            if (index < 0) index = 0;

            $(choices[index]).addClass("select2-highlighted");
            this.ensureHighlightVisible();

            if (this.opened()) this.focusSearch();
        },

        highlightUnderEvent: function (event) {
            var el = $(event.target).closest(".select2-result");
            if (el.length > 0) {
                this.highlight(el.index());
            }
        },

        loadMoreIfNeeded: function () {
            var results = this.results,
                more = results.find("li.select2-more-results"),
                below, // pixels the element is below the scroll fold, below==0 is when the element is starting to be visible
                offset = -1, // index of first element without data
                page = this.resultsPage + 1;

            if (more.length === 0) return;

            below = more.offset().top - results.offset().top - results.height();

            if (below <= 0) {
                more.addClass("select2-active");
                this.opts.query({term: this.search.val(), page: page, callback: this.bind(function (data) {
                    var parts = [], self = this;
                    $(data.results).each(function () {
                        parts.push("<li class='select2-result'>");
                        parts.push(self.opts.formatResult(this));
                        parts.push("</li>");
                    });
                    more.before(parts.join(""));
                    results.find(".select2-result").each(function (i) {
                        var e = $(this);
                        if (e.data("select2-data") !== undefined) {
                            offset = i;
                        } else {
                            e.data("select2-data", data.results[i - offset - 1]);
                        }
                    });
                    if (data.more) {
                        more.removeClass("select2-active");
                    } else {
                        more.remove();
                    }
                    this.resultsPage = page;
                })});
            }
        },

        /**
         * @param initial whether or not this is the call to this method right after the dropdown has been opened
         */
        updateResults: function (initial) {
        var search = this.search,
            results = this.results,
            opts = this.opts,
            self = this,
            val = search.val();

            search.addClass("select2-active");

            function render(html) {
                results.html(html);
                results.scrollTop(0);
                search.removeClass("select2-active");
            }

        if (val !== null && val.length < opts.minimumInputLength) {
                render("<li class='select2-no-results'>" + opts.formatInputTooShort(search.val(), opts.minimumInputLength) + "</li>");
                return;
            }

            this.resultsPage = 1;
        opts.query({term: val, page: this.resultsPage, callback: this.bind(function (data) {
                var parts = [], // html parts
                    def; // default choice

                // create a default choice and prepend it to the list
                if (this.opts.createSearchChoice && search.val() !== "") {
                    def = this.opts.createSearchChoice.call(null, search.val(), data.results);
                    if (def !== undefined && def !== null && self.id(def) !== undefined && self.id(def) !== null) {
                        if ($(data.results).filter(
                            function () {
                                return equal(self.id(this), self.id(def));
                            }).length === 0) {
                            data.results.unshift(def);
                        }
                    }
                }

                if (data.results.length === 0) {
                    render("<li class='select2-no-results'>" + opts.formatNoMatches(search.val()) + "</li>");
                    return;
                }

                $(data.results).each(function () {
                    parts.push("<li class='select2-result'>");
                    parts.push(opts.formatResult(this));
                    parts.push("</li>");
                });

                if (data.more === true) {
                    parts.push("<li class='select2-more-results'>Loading more results...</li>");
                }

                render(parts.join(""));
                results.children(".select2-result").each(function (i) {
                    var d = data.results[i];
                    $(this).data("select2-data", d);
                });
                this.postprocessResults(data, initial);
            })});
        },

        cancel: function () {
            this.close();
        },

        blur: function () {
            /* we do this in a timeout so that current event processing can complete before this code is executed.
             this allows tab index to be preserved even if this code blurs the textfield */
            window.setTimeout(this.bind(function () {
                this.close();
                this.container.removeClass("select2-container-active");
                this.clearSearch();
                this.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                this.search.blur();
            }), 10);
        },

        focusSearch: function () {
            /* we do this in a timeout so that current event processing can complete before this code is executed.
             this makes sure the search field is focussed even if the current event would blur it */
            window.setTimeout(this.bind(function () {
                this.search.focus();
            }), 10);
        },

        selectHighlighted: function () {
            var data = this.results.find(".select2-highlighted:not(.select2-disabled)").data("select2-data");
            if (data) {
                this.onSelect(data);
            }
        },

        getPlaceholder: function () {
            return this.opts.element.attr("placeholder") || this.opts.element.data("placeholder") || this.opts.placeholder;
        },

        /**
         * Get the desired width for the container element.  This is
         * derived first from option `width` passed to select2, then
         * the inline 'style' on the original element, and finally
         * falls back to the jQuery calculated element width.
         *
         * @returns The width string (with units) for the container.
         */
        getContainerWidth: function () {
            var style, attrs, matches, i, l;
            if (this.opts.width !== undefined)
                return this.opts.width;

            style = this.opts.element.attr('style');
            if (style !== undefined) {
                attrs = style.split(';');
                for (i = 0, l = attrs.length; i < l; i = i + 1) {
                    matches = attrs[i].replace(/\s/g, '')
                        .match(/width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/);
                    if (matches !== null && matches.length >= 1)
                        return matches[1];
                }
            }
            return this.opts.element.width() + 'px';
        }
    });

    SingleSelect2 = clazz(AbstractSelect2, {

        createContainer: function () {
            return $("<div></div>", {
                "class": "select2-container",
                "style": "width: " + this.getContainerWidth()
            }).html([
                "    <a href='javascript:void(0)' class='select2-choice'>",
                "   <span></span><abbr class='select2-search-choice-close' style='display:none;'></abbr>",
                "   <div><b></b></div>" ,
                "</a>",
                "    <div class='select2-drop' style='display:none;'>" ,
                "   <div class='select2-search'>" ,
                "       <input type='text' autocomplete='off' " + this.tabIndex() + "/>" ,
                "   </div>" ,
                "   <ul class='select2-results'>" ,
                "   </ul>" ,
                "</div>"].join(""));
        },

        open: function () {

            if (this.opened()) return;

            this.parent.open.apply(this, arguments);

        },

        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        focus: function () {
            this.close();
            this.selection.focus();
        },

        isFocused: function () {
            return this.selection.is(":focus");
        },

        cancel: function () {
            this.parent.cancel.apply(this, arguments);
            this.selection.focus();
        },

        initContainer: function () {

            var selection, container = this.container, clickingInside = false,
                selector = ".select2-choice";

            this.selection = selection = container.find(selector);

            this.search.bind("keydown", this.bind(function (e) {
                switch (e.which) {
                case KEY.UP:
                case KEY.DOWN:
                    this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                    killEvent(e);
                    return;
                case KEY.TAB:
                case KEY.ENTER:
                    this.selectHighlighted();
                    killEvent(e);
                    return;
                case KEY.ESC:
                    this.cancel(e);
                    e.preventDefault();
                    return;
                }
            }));

        selection.bind("click", this.bind(function (e) {
                clickingInside = true;

                if (this.opened()) {
                    this.close();
                    selection.focus();
                } else {
                    this.open();
                }
                e.preventDefault();

                clickingInside = false;
            }));
        selection.bind("keydown", this.bind(function (e) {
                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                    return;
                }
                this.open();
                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN || e.which === KEY.SPACE) {
                    // prevent the page from scrolling
                    killEvent(e);
                }
                if (e.which === KEY.ENTER) {
                    // do not propagate the event otherwise we open, and propagate enter which closes
                    killEvent(e);
                }
            }));
        selection.bind("focus", function () { container.addClass("select2-container-active"); });
        selection.bind("blur", this.bind(function () {
                if (clickingInside) return;
                if (!this.opened()) this.blur();
            }));

            selection.delegate("abbr", "click", this.bind(function (e) {
                this.val("");
                killEvent(e);
                this.close();
                this.triggerChange();
            }));

            this.setPlaceholder();
        },

        /**
         * Sets selection based on source element's value
         */
        initSelection: function () {
            var selected;
            if (this.opts.element.val() === "") {
                this.updateSelection({id: "", text: ""});
            } else {
                selected = this.opts.initSelection.call(null, this.opts.element);
                if (selected !== undefined && selected !== null) {
                    this.updateSelection(selected);
                }
            }

            this.close();
            this.setPlaceholder();
        },

        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments);

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install sthe selection initializer
                opts.initSelection = function (element) {
                    var selected = element.find(":selected");
                    // a single select box always has a value, no need to null check 'selected'
                    return {id: selected.attr("value"), text: selected.text()};
                };
            }

            return opts;
        },

        setPlaceholder: function () {
            var placeholder = this.getPlaceholder();

            if (this.opts.element.val() === "" && placeholder !== undefined) {

                // check for a first blank option if attached to a select
                if (this.select && this.select.find("option:first").text() !== "") return;

                if (typeof(placeholder) === "object") {
                    this.updateSelection(placeholder);
                } else {
                    this.selection.find("span").html(placeholder);
                }
                this.selection.addClass("select2-default");

                this.selection.find("abbr").hide();
            }
        },

        postprocessResults: function (data, initial) {
            var selected = 0, self = this, showSearchInput = true;

            // find the selected element in the result list

            this.results.find(".select2-result").each(function (i) {
                if (equal(self.id($(this).data("select2-data")), self.opts.element.val())) {
                    selected = i;
                    return false;
                }
            });

            // and highlight it

            this.highlight(selected);

            // hide the search box if this is the first we got the results and there are a few of them

            if (initial === true) {
               showSearchInput = data.results.length >= this.opts.minimumResultsForSearch;
               this.search.parent().toggle(showSearchInput);

               //add "select2-with-searchbox" to the container if search box is shown
               this.container[showSearchInput ? "addClass" : "removeClass"]("select2-with-searchbox");
            }

        },

        onSelect: function (data) {
            var old = this.opts.element.val();

            this.opts.element.val(this.id(data));
            this.updateSelection(data);
            this.close();
            this.selection.focus();

            if (!equal(old, this.id(data))) { this.triggerChange(); }
        },

        updateSelection: function (data) {
            this.selection
                .find("span")
                .html(this.opts.formatSelection(data));

            this.selection.removeClass("select2-default");

            if (this.opts.allowClear && this.getPlaceholder() !== undefined) {
                this.selection.find("abbr").show();
            }
        },

        val: function () {
            var val, data = null;

            if (arguments.length === 0) {
                return this.opts.element.val();
            }

            val = arguments[0];

            if (this.select) {
                // val is an id
                this.select
                    .val(val)
                    .find(":selected").each(function () {
                        data = {id: $(this).attr("value"), text: $(this).text()};
                        return false;
                    });

                this.updateSelection(data);
            } else {
                // val is an object. !val is true for [undefined,null,'']
                this.opts.element.val(!val ? "" : this.id(val));
                this.updateSelection(val);
            }
            this.setPlaceholder();

        },

        clearSearch: function () {
            this.search.val("");
        }
    });

    MultiSelect2 = clazz(AbstractSelect2, {

        createContainer: function () {
            return $("<div></div>", {
                "class": "select2-container select2-container-multi",
                "style": "width: " + this.getContainerWidth()
            }).html([
            "<ul class='select2-choices'>",
                //"<li class='select2-search-choice'><span>California</span><a href="javascript:void(0)" class="select2-search-choice-close"></a></li>" ,
                "  <li class='select2-search-field'>" ,
                "    <input type='text' autocomplete='off' style='width: 25px;' " + this.tabIndex() + ">" ,
                "  </li>" ,
                "</ul>" ,
                "<div class='select2-drop' style='display:none;'>" ,
                "   <ul class='select2-results'>" ,
                "   </ul>" ,
                "</div>"].join(""));
        },

        prepareOpts: function () {
            var opts = this.parent.prepareOpts.apply(this, arguments);

            opts = $.extend({}, {
                closeOnSelect: true
            }, opts);

            // TODO validate placeholder is a string if specified

            if (opts.element.get(0).tagName.toLowerCase() === "select") {
                // install sthe selection initializer
                opts.initSelection = function (element) {
                    var data = [];
                    element.find(":selected").each(function () {
                        data.push({id: $(this).attr("value"), text: $(this).text()});
                    });
                    return data;
                };
            }

            return opts;
        },

        initContainer: function () {

            var selector = ".select2-choices", selection;

            this.searchContainer = this.container.find(".select2-search-field");
            this.selection = selection = this.container.find(selector);

            this.search.bind("keydown", this.bind(function (e) {
                if (e.which === KEY.BACKSPACE && this.search.val() === "") {
                    this.close();

                    var choices,
                        selected = selection.find(".select2-search-choice-focus");
                    if (selected.length > 0) {
                        this.unselect(selected.first());
                        this.search.width(10);
                        killEvent(e);
                        return;
                    }

                    choices = selection.find(".select2-search-choice");
                    if (choices.length > 0) {
                        choices.last().addClass("select2-search-choice-focus");
                    }
                } else {
                    selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                }

                if (this.opened()) {
                    switch (e.which) {
                    case KEY.UP:
                    case KEY.DOWN:
                        this.moveHighlight((e.which === KEY.UP) ? -1 : 1);
                        killEvent(e);
                        return;
                    case KEY.ENTER:
                        this.selectHighlighted();
                        killEvent(e);
                        return;
                    case KEY.ESC:
                        this.cancel(e);
                        e.preventDefault();
                        return;
                    }
                }

                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.BACKSPACE || e.which === KEY.ESC) {
                    return;
                }

                this.open();

                if (e.which === KEY.PAGE_UP || e.which === KEY.PAGE_DOWN) {
                    // prevent the page from scrolling
                    killEvent(e);
                }
            }));

            this.search.bind("keyup", this.bind(this.resizeSearch));

        this.selection.bind("click", this.bind(function (e) {
                this.open();
                this.focusSearch();
                e.preventDefault();
            }));

        this.selection.bind("focus", this.bind(function () {
                this.container.addClass("select2-container-active");
                this.clearPlaceholder();
            }));

            // set the placeholder if necessary
            this.clearSearch();
        },

        initSelection: function () {
            var data;
            if (this.opts.element.val() === "") {
                this.updateSelection([]);
            }
            if (this.select || this.opts.element.val() !== "") {
                data = this.opts.initSelection.call(null, this.opts.element);
                if (data !== undefined && data !== null) {
                    this.updateSelection(data);
                }
            }

            this.close();

            // set the placeholder if necessary
            this.clearSearch();
        },

        clearSearch: function () {
            var placeholder = this.getPlaceholder();

            if (placeholder !== undefined
                && this.getVal().length === 0
                && this.search.hasClass("select2-focused") === false) {

                this.search.val(placeholder).addClass("select2-default");
                // stretch the search box to full width of the container so as much of the placeholder is visible as possible
                this.search.width(this.getContainerWidth());
            } else {
                this.search.val("").width(10);
            }
        },

        clearPlaceholder: function () {
            if (this.search.hasClass("select2-default")) {
                this.search.val("").removeClass("select2-default");
            }
        },

        open: function () {
            if (this.opened()) return;
        this.clearPlaceholder();
            this.parent.open.apply(this, arguments);
            this.resizeSearch();
            this.focusSearch();
        },

        close: function () {
            if (!this.opened()) return;
            this.parent.close.apply(this, arguments);
        },

        focus: function () {
            this.close();
            this.search.focus();
        },

        isFocused: function () {
            return this.search.hasClass("select2-focused");
        },

        updateSelection: function (data) {
            this.selection.find(".select2-search-choice").remove();
        this.addSelectedChoices(data);
        this.postprocessResults();
        },

        onSelect: function (data) {
        this.addSelectedChoices(data);
            if (this.select) { this.postprocessResults(); }

            if (this.opts.closeOnSelect) {
            this.close();
            this.search.width(10);
            } else {
                this.search.width(10);
                this.resizeSearch();
            }

            // since its not possible to select an element that has already been
            // added we do not need to check if this is a new element before firing change
            this.triggerChange();

            this.focusSearch();
        },

        cancel: function () {
            this.close();
            this.focusSearch();
        },

        addSelectedChoices: function (data) {

        var self = this,
            val = this.getVal(),
            selected = this.argify(data);


        $.each(selected.objects,function(){
            var datum = this,
                choice,
                parts;

            // Skip this item if its ID is already present in `val`.
            if(indexOf(datum.id,val) !== -1)
                return true;

            parts = ["<li class='select2-search-choice'>",
                self.opts.formatSelection(datum),
                "<a href='javascript:void(0)' class='select2-search-choice-close' tabindex='-1'></a>",
                "</li>"
            ];

            choice = $(parts.join(""));
            choice.find("a").bind("click dblclick", function (e) {
                self.unselect($(e.target));
                self.selection.find(".select2-search-choice-focus").removeClass("select2-search-choice-focus");
                killEvent(e);
                self.close();
                self.focusSearch();
            }).bind("focus", function () {
                self.container.addClass("select2-container-active");
            });
            choice.data("select2-data", datum);
            choice.insertBefore(self.searchContainer);
            val.push(datum.id);

        });
            this.setVal(val);
        },

        unselect: function (selected) {
            var val = this.getVal(),
                index;

            selected = selected.closest(".select2-search-choice");

            if (selected.length === 0) {
                throw "Invalid argument: " + selected + ". Must be .select2-search-choice";
            }

            index = indexOf(this.id(selected.data("select2-data")), val);

            if (index >= 0) {
                val.splice(index, 1);
                this.setVal(val);
                if (this.select) this.postprocessResults();
            }
            selected.remove();
            this.triggerChange();
        },

        postprocessResults: function () {
            var val = this.getVal(),
                choices = this.results.find(".select2-result"),
                self = this;

            choices.each(function () {
                var choice = $(this), id = self.id(choice.data("select2-data"));
                if (indexOf(id, val) >= 0) {
                    choice.addClass("select2-disabled");
                } else {
                    choice.removeClass("select2-disabled");
                }
            });

            choices.each(function (i) {
                if (!$(this).hasClass("select2-disabled")) {
                    self.highlight(i);
                    return false;
                }
            });

        },

        resizeSearch: function () {

            var minimumWidth, left, maxWidth, containerLeft, searchWidth;

            minimumWidth = measureTextWidth(this.search) + 10;

            left = this.search.offset().left;

            maxWidth = this.selection.width();
            containerLeft = this.selection.offset().left;

            searchWidth = maxWidth - (left - containerLeft) - getSideBorderPadding(this.search);

            if (searchWidth < minimumWidth) {
                searchWidth = maxWidth - getSideBorderPadding(this.search);
            }

            if (searchWidth < 40) {
                searchWidth = maxWidth - getSideBorderPadding(this.search);
            }
            this.search.width(searchWidth);
        },

        getVal: function () {
            var val;
            if (this.select) {
                val = this.select.val();
                return val === null ? [] : val;
            } else {
                val = this.opts.element.val();
                return splitVal(val, ",");
            }
        },

        setVal: function (val) {
            if (this.select) {
                this.select.val(val);
            } else {
            this.opts.element.val((val !== undefined && val !== null)? val.join(",") : []);
            }
        },

        ktVal: function () {
            var val, data = [], self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

        val = arguments[0];

            if (this.select) {
                // val is a list of ids
                this.setVal(val);

                var that = this;

                if(val) {
                  _.each(val, function(id) {
                    var $ele = $(that.select.find('option[value="' + id + '"]'));
                    data.push({id: $ele.attr("value"), text: $ele.text()});
                  });
                }

                this.setVal([]);
                this.updateSelection(data);
            } else {
            this.setVal();
            if(val.objects.length == 0)
                this.clearSearch();
            else
                this.updateSelection(val.objects);
            }
        // Trigger a chance because we set the value
        this.triggerChange();

            this.clearSearch();
        },

        val: function () {
            var val, data = [], self=this;

            if (arguments.length === 0) {
                return this.getVal();
            }

        // Sanitize incoming arguments here so that all internal methods
        // can assume the existence of a consistent object structure:
        //   val = [{id:1,text:'something'}, ...]
        val = this.argify(arguments[0]);

            if (this.select) {
                // val is a list of ids
                this.setVal(val);
                this.select.find(":selected").each(function () {
                    data.push({id: $(this).attr("value"), text: $(this).text()});
                });
                this.updateSelection(data);
            } else {
            this.setVal();
            if(val.objects.length == 0)
                this.clearSearch();
            else
                this.updateSelection(val.objects);
            }
        // Trigger a chance because we set the value
        this.triggerChange();

            this.clearSearch();
        }
    });

    $.fn.select2 = function () {

        var args = Array.prototype.slice.call(arguments, 0),
            opts,
            select2,
            value, multiple, allowedMethods = ["ktVal", "val", "destroy", "open", "close", "focus", "isFocused"];

        this.each(function () {
            if (args.length === 0 || typeof(args[0]) === "object") {
                opts = args.length === 0 ? {} : $.extend({}, args[0]);
                opts.element = $(this);

                if (opts.element.get(0).tagName.toLowerCase() === "select") {
                    multiple = opts.element.attr("multiple");
                } else {
                    multiple = opts.multiple || false;
                    if ("tags" in opts) {opts.multiple = multiple = true;}
                }

                select2 = multiple ? new MultiSelect2() : new SingleSelect2();
                select2.init(opts);
            } else if (typeof(args[0]) === "string") {

                if (indexOf(args[0], allowedMethods) < 0) {
                    throw "Unknown method: " + args[0];
                }

                value = undefined;
                select2 = $(this).data("select2");
                if (select2 === undefined) return;
                value = select2[args[0]].apply(select2, args.slice(1));
                if (value !== undefined) {return false;}
            } else {
                throw "Invalid arguments to select2 plugin: " + args;
            }
        });
        return (value === undefined) ? this : value;
    };

    // exports
    window.Select2 = {
        query: {
            ajax: ajax,
            local: local,
            tags: tags
        }, util: {
            debounce: debounce
        }, "class": {
            "abstract": AbstractSelect2,
            "single": SingleSelect2,
            "multi": MultiSelect2
        }
    };

}(jQuery));


// numeral.js
// version : 1.3.0
// author : Adam Draper
// license : MIT
// http://adamwdraper.github.com/Numeral-js/
(function(){function u(e){this._n=e}function a(e,t,n){var r=Math.pow(10,t),i;i=(Math.round(e*r)/r).toFixed(t);if(n){var s=new RegExp("0{1,"+n+"}$");i=i.replace(s,"")}return i}function f(e,t){var n;t.indexOf("$")>-1?n=c(e,t):t.indexOf("%")>-1?n=h(e,t):t.indexOf(":")>-1?n=p(e,t):n=v(e,t);return n}function l(e,t){if(t.indexOf(":")>-1)e._n=d(t);else{var n=t;i[s].delimiters.decimal!=="."&&(t=t.replace(/\./g,"").replace(i[s].delimiters.decimal,"."));var r=new RegExp(i[s].abbreviations.thousand+"(?:\\)|\\"+i[s].currency.symbol+"?(?:\\))?)?$"),o=new RegExp(i[s].abbreviations.million+"(?:\\)|\\"+i[s].currency.symbol+"?(?:\\))?)?$"),u=["KB","MB","GB","TB","PB","EB","ZB","YB"],a=!1;for(var f=0;f<=u.length;f++){a=t.indexOf(u[f])>-1?Math.pow(1024,f+1):!1;if(a)break}e._n=(a?a:1)*(n.match(r)?1e3:1)*(n.match(o)?1e6:1)*(t.indexOf("%")>-1?.01:1)*Number((t.indexOf("(")>-1?"-":"")+t.replace(/[^0-9\.'-]+/g,""));e._n=a?Math.ceil(e._n):e._n}return e._n}function c(e,t){var n=t.indexOf("$")<=1?!0:!1,r="";if(t.indexOf(" $")>-1){r=" ";t=t.replace(" $","")}else if(t.indexOf("$ ")>-1){r=" ";t=t.replace("$ ","")}else t=t.replace("$","");var o=f(e,t);if(n)if(o.indexOf("(")>-1||o.indexOf("-")>-1){o=o.split("");o.splice(1,0,i[s].currency.symbol+r);o=o.join("")}else o=i[s].currency.symbol+r+o;else if(o.indexOf(")")>-1){o=o.split("");o.splice(-1,0,r+i[s].currency.symbol);o=o.join("")}else o=o+r+i[s].currency.symbol;return o}function h(e,t){var n="";if(t.indexOf(" %")>-1){n=" ";t=t.replace(" %","")}else t=t.replace("%","");e._n=e._n*100;var r=f(e,t);if(r.indexOf(")")>-1){r=r.split("");r.splice(-1,0,n+"%");r=r.join("")}else r=r+n+"%";return r}function p(e,t){var n=Math.floor(e._n/60/60),r=Math.floor((e._n-n*60*60)/60),i=Math.round(e._n-n*60*60-r*60);return n+":"+(r<10?"0"+r:r)+":"+(i<10?"0"+i:i)}function d(e){var t=e.split(":"),n=0;if(t.length===3){n+=Number(t[0])*60*60;n+=Number(t[1])*60;n+=Number(t[2])}else if(t.lenght===2){n+=Number(t[0])*60;n+=Number(t[1])}return Number(n)}function v(e,t){var n=!1,r="",o="",u="";if(t.indexOf("(")>-1){n=!0;t=t.slice(1,-1)}if(t.indexOf("a")>-1){if(t.indexOf(" a")>-1){r=" ";t=t.replace(" a","")}else t=t.replace("a","");if(e._n>1e6){r+=i[s].abbreviations.million;e._n=e._n/1e6}else{r+=i[s].abbreviations.thousand;e._n=e._n/1e3}}if(t.indexOf("b")>-1){if(t.indexOf(" b")>-1){o=" ";t=t.replace(" b","")}else t=t.replace("b","");var f=["B","KB","MB","GB","TB","PB","EB","ZB","YB"],l,c;for(var h=0;h<=f.length;h++){l=Math.pow(1024,h);c=Math.pow(1024,h+1);if(e._n>l&&e._n<c){o+=f[h];l>0&&(e._n=e._n/l);break}}}if(t.indexOf("o")>-1){if(t.indexOf(" o")>-1){u=" ";t=t.replace(" o","")}else t=t.replace("o","");u+=i[s].ordinal(e._n)}var p=e._n.toString().split(".")[0],d=t.split(".")[1],v=t.indexOf(","),m="",g=!1;d||(p=a(e._n,null));if(e._n<0){p=p.slice(1);g=!0}v>-1&&(p=p.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1"+i[s].delimiters.thousands));t.indexOf(".")===0&&(p="");if(d){if(d.indexOf("[")>-1){d=d.replace("]","");d=d.split("[");m=a(e._n,d[0].length+d[1].length,d[1].length).split(".")[1]}else m=a(e._n,d.length).split(".")[1];m&&(m=i[s].delimiters.decimal+m)}return(n&&g?"(":"")+(!n&&g?"-":"")+p+m+(u?u:"")+(r?r:"")+(o?o:"")+(n&&g?")":"")}function m(e,t){i[e]=t}var e,t="1.3.0",n=Math.round,r,i={},s="en",o=typeof module!="undefined"&&module.exports;e=function(t){e.isNumeral(t)?t=t.value():Number(t)||(t=0);return new u(Number(t))};e.isNumeral=function(e){return e instanceof u};e.version=t;e.isNumeral=function(e){return e instanceof u};e.language=function(e,t){if(!e)return s;e&&!t&&(s=e);(t||!i[e])&&m(e,t);return i};e.language("en",{delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m"},ordinal:function(e){var t=e%10;return~~(e%100/10)===1?"th":t===1?"st":t===2?"nd":t===3?"rd":"th"},currency:{symbol:"$"}});e.fn=u.prototype={clone:function(){return e(this)},format:function(t){return f(this,t?t:e.defaultFormat)},unformat:function(t){return l(this,t?t:e.defaultFormat)},value:function(){return this._n},set:function(e){this._n=Number(e);return this},add:function(e){this._n=this._n+Number(e);return this},subtract:function(e){this._n=this._n-Number(e);return this},multiply:function(e){this._n=this._n*Number(e);return this},divide:function(e){this._n=this._n/Number(e);return this},difference:function(e){var t=this._n-Number(e);t<0&&(t=-t);return t}};o&&(module.exports=e);typeof ender=="undefined"&&(this.numeral=e);typeof define=="function"&&define.amd&&define([],function(){return e})}).call(this);

/**
* Bootstrap.js by @fat & @mdo
* plugins: bootstrap-transition.js, bootstrap-tooltip.js, bootstrap-popover.js
* Copyright 2012 Twitter, Inc.
* http://www.apache.org/licenses/LICENSE-2.0.txt
*/
!function(a){a(function(){a.support.transition=function(){var a=function(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},c;for(c in b)if(a.style[c]!==undefined)return b[c]}();return a&&{end:a}}()})}(window.jQuery),!function(a){var b=function(a,b){this.init("tooltip",a,b)};b.prototype={constructor:b,init:function(b,c,d){var e,f;this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.enabled=!0,this.options.trigger=="click"?this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this)):this.options.trigger!="manual"&&(e=this.options.trigger=="hover"?"mouseenter":"focus",f=this.options.trigger=="hover"?"mouseleave":"blur",this.$element.on(e+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(f+"."+this.type,this.options.selector,a.proxy(this.leave,this))),this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},getOptions:function(b){return b=a.extend({},a.fn[this.type].defaults,b,this.$element.data()),b.delay&&typeof b.delay=="number"&&(b.delay={show:b.delay,hide:b.delay}),b},enter:function(b){var c=a(b.currentTarget)[this.type](this._options).data(this.type);if(!c.options.delay||!c.options.delay.show)return c.show();clearTimeout(this.timeout),c.hoverState="in",this.timeout=setTimeout(function(){c.hoverState=="in"&&c.show()},c.options.delay.show)},leave:function(b){var c=a(b.currentTarget)[this.type](this._options).data(this.type);this.timeout&&clearTimeout(this.timeout);if(!c.options.delay||!c.options.delay.hide)return c.hide();c.hoverState="out",this.timeout=setTimeout(function(){c.hoverState=="out"&&c.hide()},c.options.delay.hide)},show:function(){var a,b,c,d,e,f,g;if(this.hasContent()&&this.enabled){a=this.tip(),this.setContent(),this.options.animation&&a.addClass("fade"),f=typeof this.options.placement=="function"?this.options.placement.call(this,a[0],this.$element[0]):this.options.placement,b=/in/.test(f),a.detach().css({top:0,left:0,display:"block"}).insertAfter(this.$element),c=this.getPosition(b),d=a[0].offsetWidth,e=a[0].offsetHeight;switch(b?f.split(" ")[1]:f){case"bottom":g={top:c.top+c.height,left:c.left+c.width/2-d/2};break;case"top":g={top:c.top-e,left:c.left+c.width/2-d/2};break;case"left":g={top:c.top+c.height/2-e/2,left:c.left-d};break;case"right":g={top:c.top+c.height/2-e/2,left:c.left+c.width}}a.offset(g).addClass(f).addClass("in")}},setContent:function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},hide:function(){function d(){var b=setTimeout(function(){c.off(a.support.transition.end).detach()},500);c.one(a.support.transition.end,function(){clearTimeout(b),c.detach()})}var b=this,c=this.tip();return c.removeClass("in"),a.support.transition&&this.$tip.hasClass("fade")?d():c.detach(),this},fixTitle:function(){var a=this.$element;(a.attr("title")||typeof a.attr("data-original-title")!="string")&&a.attr("data-original-title",a.attr("title")||"").removeAttr("title")},hasContent:function(){return this.getTitle()},getPosition:function(b){return a.extend({},b?{top:0,left:0}:this.$element.offset(),{width:this.$element[0].offsetWidth,height:this.$element[0].offsetHeight})},getTitle:function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||(typeof c.title=="function"?c.title.call(b[0]):c.title),a},tip:function(){return this.$tip=this.$tip||a(this.options.template)},validate:function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},enable:function(){this.enabled=!0},disable:function(){this.enabled=!1},toggleEnabled:function(){this.enabled=!this.enabled},toggle:function(b){var c=a(b.currentTarget)[this.type](this._options).data(this.type);c[c.tip().hasClass("in")?"hide":"show"]()},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}},a.fn.tooltip=function(c){return this.each(function(){var d=a(this),e=d.data("tooltip"),f=typeof c=="object"&&c;e||d.data("tooltip",e=new b(this,f)),typeof c=="string"&&e[c]()})},a.fn.tooltip.Constructor=b,a.fn.tooltip.defaults={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover",title:"",delay:0,html:!1}}(window.jQuery),!function(a){var b=function(a,b){this.init("popover",a,b)};b.prototype=a.extend({},a.fn.tooltip.Constructor.prototype,{constructor:b,setContent:function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content > *")[this.options.html?"html":"text"](c),a.removeClass("fade top bottom left right in")},hasContent:function(){return this.getTitle()||this.getContent()},getContent:function(){var a,b=this.$element,c=this.options;return a=b.attr("data-content")||(typeof c.content=="function"?c.content.call(b[0]):c.content),a},tip:function(){return this.$tip||(this.$tip=a(this.options.template)),this.$tip},destroy:function(){this.hide().$element.off("."+this.type).removeData(this.type)}}),a.fn.popover=function(c){return this.each(function(){var d=a(this),e=d.data("popover"),f=typeof c=="object"&&c;e||d.data("popover",e=new b(this,f)),typeof c=="string"&&e[c]()})},a.fn.popover.Constructor=b,a.fn.popover.defaults=a.extend({},a.fn.tooltip.defaults,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><div class="popover-inner"><h3 class="popover-title"></h3><div class="popover-content"><p></p></div></div></div>'})}(window.jQuery);

/**
* Bootstrap.js by @fat & @mdo
* plugins: bootstrap-modal.js
* Copyright 2012 Twitter, Inc.
* http://www.apache.org/licenses/LICENSE-2.0.txt
*/
!function(a){var b=function(b,c){this.options=c,this.$element=a(b).delegate('[data-dismiss="modal"]',"click.dismiss.modal",a.proxy(this.hide,this)),this.options.remote&&this.$element.find(".modal-body").load(this.options.remote)};b.prototype={constructor:b,toggle:function(){return this[this.isShown?"hide":"show"]()},show:function(){var b=this,c=a.Event("show");this.$element.trigger(c);if(this.isShown||c.isDefaultPrevented())return;this.isShown=!0,this.escape(),this.backdrop(function(){var c=a.support.transition&&b.$element.hasClass("fade");b.$element.parent().length||b.$element.appendTo(document.body),b.$element.show(),c&&b.$element[0].offsetWidth,b.$element.addClass("in").attr("aria-hidden",!1),b.enforceFocus(),c?b.$element.one(a.support.transition.end,function(){b.$element.focus().trigger("shown")}):b.$element.focus().trigger("shown")})},hide:function(b){b&&b.preventDefault();var c=this;b=a.Event("hide"),this.$element.trigger(b);if(!this.isShown||b.isDefaultPrevented())return;this.isShown=!1,this.escape(),a(document).off("focusin.modal"),this.$element.removeClass("in").attr("aria-hidden",!0),a.support.transition&&this.$element.hasClass("fade")?this.hideWithTransition():this.hideModal()},enforceFocus:function(){var b=this;a(document).on("focusin.modal",function(a){b.$element[0]!==a.target&&!b.$element.has(a.target).length&&b.$element.focus()})},escape:function(){var a=this;this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.modal",function(b){b.which==27&&a.hide()}):this.isShown||this.$element.off("keyup.dismiss.modal")},hideWithTransition:function(){var b=this,c=setTimeout(function(){b.$element.off(a.support.transition.end),b.hideModal()},500);this.$element.one(a.support.transition.end,function(){clearTimeout(c),b.hideModal()})},hideModal:function(){var a=this;this.$element.hide(),this.backdrop(function(){a.removeBackdrop(),a.$element.trigger("hidden")})},removeBackdrop:function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},backdrop:function(b){var c=this,d=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var e=a.support.transition&&d;this.$backdrop=a('<div class="modal-backdrop '+d+'" />').appendTo(document.body),this.$backdrop.click(this.options.backdrop=="static"?a.proxy(this.$element[0].focus,this.$element[0]):a.proxy(this.hide,this)),e&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in");if(!b)return;e?this.$backdrop.one(a.support.transition.end,b):b()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(a.support.transition.end,b):b()):b&&b()}};var c=a.fn.modal;a.fn.modal=function(c){return this.each(function(){var d=a(this),e=d.data("modal"),f=a.extend({},a.fn.modal.defaults,d.data(),typeof c=="object"&&c);e||d.data("modal",e=new b(this,f)),typeof c=="string"?e[c]():f.show&&e.show()})},a.fn.modal.defaults={backdrop:!0,keyboard:!0,show:!0},a.fn.modal.Constructor=b,a.fn.modal.noConflict=function(){return a.fn.modal=c,this},a(document).on("click.modal.data-api",'[data-toggle="modal"]',function(b){var c=a(this),d=c.attr("href"),e=a(c.attr("data-target")||d&&d.replace(/.*(?=#[^\s]+$)/,"")),f=e.data("modal")?"toggle":a.extend({remote:!/#/.test(d)&&d},e.data(),c.data());b.preventDefault(),e.modal(f).one("hide",function(){c.focus()})})}(window.jQuery);

/*!
 * Raphael 1.5.2 - JavaScript Vector Library
 *
 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 */
(function () {
    function R() {
        if (R.is(arguments[0], array)) {
            var a = arguments[0],
                cnv = create[apply](R, a.splice(0, 3 + R.is(a[0], nu))),
                res = cnv.set();
            for (var i = 0, ii = a[length]; i < ii; i++) {
                var j = a[i] || {};
                elements[has](j.type) && res[push](cnv[j.type]().attr(j));
            }
            return res;
        }
        return create[apply](R, arguments);
    }
    R.version = "1.5.2";
    var separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        doc = document,
        win = window,
        oldRaphael = {
            was: Object[proto][has].call(win, "Raphael"),
            is: win.Raphael
        },
        Paper = function () {
            this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = "createTouch" in doc,
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        join = "join",
        length = "length",
        lowerCase = Str[proto].toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object[proto][toString],
        paper = {},
        push = "push",
        ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        ms = " progid:DXImageTransform.Microsoft",
        upperCase = Str[proto].toUpperCase,
        availableAttrs = {blur: 0, "clip-rect": "0 0 1e9 1e9", cursor: "default", cx: 0, cy: 0, fill: "#fff", "fill-opacity": 1, font: '10px "Arial"', "font-family": '"Arial"', "font-size": "10", "font-style": "normal", "font-weight": 400, gradient: 0, height: 0, href: "http://raphaeljs.com/", opacity: 1, path: "M0,0", r: 0, rotation: 0, rx: 0, ry: 0, scale: "1 1", src: "", stroke: "#000", "stroke-dasharray": "", "stroke-linecap": "butt", "stroke-linejoin": "butt", "stroke-miterlimit": 0, "stroke-opacity": 1, "stroke-width": 1, target: "_blank", "text-anchor": "middle", title: "Raphael", translation: "0 0", width: 0, x: 0, y: 0},
        availableAnimAttrs = {along: "along", blur: nu, "clip-rect": "csv", cx: nu, cy: nu, fill: "colour", "fill-opacity": nu, "font-size": nu, height: nu, opacity: nu, path: "path", r: nu, rotation: "csv", rx: nu, ry: nu, scale: "csv", stroke: "colour", "stroke-opacity": nu, "stroke-width": nu, translation: "csv", width: nu, x: nu, y: nu},
        rp = "replace",
        animKeyFrames= /^(from|to|\d+%?)$/,
        commaSpaces = /\s*,\s*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
        radial_gradient = /^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,
        sortByKey = function (a, b) {
            return a.key - b.key;
        };

    R.type = (win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return R.type = null;
        }
        d = null;
    }
    R.svg = !(R.vml = R.type == "VML");
    Paper[proto] = R[proto];
    paperproto = Paper[proto];
    R._id = 0;
    R._oid = 0;
    R.fn = {};
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        return  (type == "null" && o === null) ||
                (type == typeof o) ||
                (type == "object" && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return ((x < 0) * 180 + math.atan(-y / -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    R.deg = function (rad) {
        return rad * 180 / PI % 360;
    };
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };
    function createUUID() {
        // http://www.ietf.org/rfc/rfc4122.txt
        var s = [],
            i = 0;
        for (; i < 32; i++) {
            s[i] = (~~(math.random() * 16))[toString](16);
        }
        s[12] = 4;  // bits 12-15 of the time_hi_and_version field to 0010
        s[16] = ((s[16] & 3) | 8)[toString](16);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
        return "r-" + s[join]("");
    }

    R.setWindow = function (newwin) {
        win = newwin;
        doc = win.document;
    };
    // colour utilities
    var toHex = function (color) {
        if (R.vml) {
            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
            var trim = /^\s+|\s+$/g;
            var bod;
            try {
                var docum = new ActiveXObject("htmlfile");
                docum.write("<body>");
                docum.close();
                bod = docum.body;
            } catch(e) {
                bod = createPopup().document.body;
            }
            var range = bod.createTextRange();
            toHex = cacher(function (color) {
                try {
                    bod.style.color = Str(color)[rp](trim, E);
                    var value = range.queryCommandValue("ForeColor");
                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                    return "#" + ("000000" + value[toString](16)).slice(-6);
                } catch(e) {
                    return "none";
                }
            });
        } else {
            var i = doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            doc.body[appendChild](i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
    hsbtoString = function () {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
        return this.hex;
    };
    R.hsb2rgb = function (h, s, b, o) {
        if (R.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            b = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        return R.hsl2rgb(h, s, b / 2, o);
    };
    R.hsl2rgb = function (h, s, l, o) {
        if (R.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        var rgb = {},
            channels = ["r", "g", "b"],
            t2, t1, t3, r, g, b;
        if (!s) {
            rgb = {
                r: l,
                g: l,
                b: l
            };
        } else {
            if (l < .5) {
                t2 = l * (1 + s);
            } else {
                t2 = l + s - l * s;
            }
            t1 = 2 * l - t2;
            for (var i = 0; i < 3; i++) {
                t3 = h + 1 / 3 * -(i - 1);
                t3 < 0 && t3++;
                t3 > 1 && t3--;
                if (t3 * 6 < 1) {
                    rgb[channels[i]] = t1 + (t2 - t1) * 6 * t3;
                } else if (t3 * 2 < 1) {
                    rgb[channels[i]] = t2;
                } else if (t3 * 3 < 2) {
                    rgb[channels[i]] = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                } else {
                    rgb[channels[i]] = t1;
                }
            }
        }
        rgb.r *= 255;
        rgb.g *= 255;
        rgb.b *= 255;
        rgb.hex = "#" + (16777216 | rgb.b | (rgb.g << 8) | (rgb.r << 16)).toString(16).slice(1);
        R.is(o, "finite") && (rgb.opacity = o);
        rgb.toString = rgbtoString;
        return rgb;
    };
    R.rgb2hsb = function (red, green, blue) {
        if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
            blue = red.b;
            green = red.g;
            red = red.r;
        }
        if (green == null && R.is(red, string)) {
            var clr = R.getRGB(red);
            red = clr.r;
            green = clr.g;
            blue = clr.b;
        }
        if (red > 1 || green > 1 || blue > 1) {
            red /= 255;
            green /= 255;
            blue /= 255;
        }
        var max = mmax(red, green, blue),
            min = mmin(red, green, blue),
            hue,
            saturation,
            brightness = max;
        if (min == max) {
            return {h: 0, s: 0, b: max, toString: hsbtoString};
        } else {
            var delta = (max - min);
            saturation = delta / max;
            if (red == max) {
                hue = (green - blue) / delta;
            } else if (green == max) {
                hue = 2 + ((blue - red) / delta);
            } else {
                hue = 4 + ((red - green) / delta);
            }
            hue /= 6;
            hue < 0 && hue++;
            hue > 1 && hue--;
        }
        return {h: hue, s: saturation, b: brightness, toString: hsbtoString};
    };
    R.rgb2hsl = function (red, green, blue) {
        if (green == null && R.is(red, "object") && "r" in red && "g" in red && "b" in red) {
            blue = red.b;
            green = red.g;
            red = red.r;
        }
        if (green == null && R.is(red, string)) {
            var clr = R.getRGB(red);
            red = clr.r;
            green = clr.g;
            blue = clr.b;
        }
        if (red > 1 || green > 1 || blue > 1) {
            red /= 255;
            green /= 255;
            blue /= 255;
        }
        var max = mmax(red, green, blue),
            min = mmin(red, green, blue),
            h,
            s,
            l = (max + min) / 2,
            hsl;
        if (min == max) {
            hsl =  {h: 0, s: 0, l: l};
        } else {
            var delta = max - min;
            s = l < .5 ? delta / (max + min) : delta / (2 - max - min);
            if (red == max) {
                h = (green - blue) / delta;
            } else if (green == max) {
                h = 2 + (blue - red) / delta;
            } else {
                h = 4 + (red - green) / delta;
            }
            h /= 6;
            h < 0 && h++;
            h > 1 && h--;
            hsl = {h: h, s: s, l: l};
        }
        hsl.toString = hsltoString;
        return hsl;
    };
    R._path2string = function () {
        return this.join(",")[rp](p2s, "$1");
    };
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array[proto].slice.call(arguments, 0),
                args = arg[join]("\u25ba"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count[length] >= 1e3 && delete cache[count.shift()];
            count[push](args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none"};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1};
    }, R);
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    R.getColor.reset = function () {
        delete this.start;
    };
    // path utilities
    R.parsePathString = cacher(function (pathString) {
        if (!pathString) {
            return null;
        }
        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data[length]) {
            Str(pathString)[rp](pathCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c[rp](pathValues, function (a, b) {
                    b && params[push](+b);
                });
                if (name == "m" && params[length] > 2) {
                    data[push]([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                while (params[length] >= paramCounts[name]) {
                    data[push]([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data[toString] = R._path2string;
        return data;
    });
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            x = pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y = pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t * t * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t * t * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t * t * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t * t * (p2y - 2 * c2y + c1y),
            ax = (1 - t) * p1x + t * c1x,
            ay = (1 - t) * p1y + t * c1y,
            cx = (1 - t) * c2x + t * p2x,
            cy = (1 - t) * c2y + t * p2y,
            alpha = (90 - math.atan((mx - nx) / (my - ny)) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {x: x, y: y, m: {x: mx, y: my}, n: {x: nx, y: ny}, start: {x: ax, y: ay}, end: {x: cx, y: cy}, alpha: alpha};
    };
    var pathDimensions = cacher(function (path) {
        if (!path) {
            return {x: 0, y: 0, width: 0, height: 0};
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path[length]; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X[push](x);
                Y[push](y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y);
        return {
            x: xmin,
            y: ymin,
            width: mmax[apply](0, X) - xmin,
            height: mmax[apply](0, Y) - ymin
        };
    }),
        pathClone = function (pathArray) {
            var res = [];
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            for (var i = 0, ii = pathArray[length]; i < ii; i++) {
                res[i] = [];
                for (var j = 0, jj = pathArray[i][length]; j < jj; j++) {
                    res[i][j] = pathArray[i][j];
                }
            }
            res[toString] = R._path2string;
            return res;
        },
        pathToRelative = cacher(function (pathArray) {
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[push](["M", x, y]);
            }
            for (var i = start, ii = pathArray[length]; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa[length]; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa[length]; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i][length];
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res[toString] = R._path2string;
            return res;
        }, 0, pathClone),
        pathToAbsolute = cacher(function (pathArray) {
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            for (var i = start, ii = pathArray[length]; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (var j = 1, jj = pa[length]; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else {
                    for (var k = 0, kk = pa[length]; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = res[i][res[i][length] - 2];
                        my = res[i][res[i][length] - 1];
                    default:
                        x = res[i][res[i][length] - 2];
                        y = res[i][res[i][length] - 1];
                }
            }
            res[toString] = R._path2string;
            return res;
        }, null, pathClone),
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                    _13 * x1 + _23 * ax,
                    _13 * y1 + _23 * ay,
                    _13 * x2 + _23 * ax,
                    _13 * y2 + _23 * ay,
                    x2,
                    y2
                ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res)[join]()[split](",");
                var newres = [];
                for (var i = 0, ii = res[length]; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x[push](dot.x);
                y[push](dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x[push](dot.x);
                y[push](dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x[push](dot.x);
                y[push](dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x[push](dot.x);
                y[push](dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = cacher(function (path, path2) {
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d) {
                    var nx, ny;
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in {T:1, Q:1}) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            nx = d.x + (d.x - (d.bx || d.x));
                            ny = d.y + (d.y - (d.by || d.y));
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            d.qx = d.x + (d.x - (d.qx || d.x));
                            d.qy = d.y + (d.y - (d.qy || d.y));
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i][length] > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi[length]) {
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p[length], p2 && p2[length] || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p[length], p2 && p2[length] || 0);
                    }
                };
            for (var i = 0, ii = mmax(p[length], p2 && p2[length] || 0); i < ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 && (p2[i] = processPath(p2[i], attrs2));
                p2 && fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg[length],
                    seg2len = p2 && seg2[length];
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient[length]; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots[push](dot);
            }
            for (i = 1, ii = dots[length] - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        getContainer = function (x, y, w, h) {
            var container;
            if (R.is(x, string) || R.is(x, "object")) {
                container = R.is(x, string) ? doc.getElementById(x) : x;
                if (container.tagName) {
                    if (y == null) {
                        return {
                            container: container,
                            width: container.style.pixelWidth || container.offsetWidth,
                            height: container.style.pixelHeight || container.offsetHeight
                        };
                    } else {
                        return {container: container, width: y, height: w};
                    }
                }
            } else {
                return {container: 1, x: x, y: y, width: w, height: h};
            }
        },
        plugins = function (con, add) {
            var that = this;
            for (var prop in add) {
                if (add[has](prop) && !(prop in con)) {
                    switch (typeof add[prop]) {
                        case "function":
                            (function (f) {
                                con[prop] = con === that ? f : function () { return f[apply](that, arguments); };
                            })(add[prop]);
                        break;
                        case "object":
                            con[prop] = con[prop] || {};
                            plugins.call(this, con[prop], add[prop]);
                        break;
                        default:
                            con[prop] = add[prop];
                        break;
                    }
                }
            }
        },
        tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        removed = function (methodname) {
            return function () {
                throw new Error("Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object");
            };
        };
    R.pathToRelative = pathToRelative;
    // SVG
    if (R.svg) {
        paperproto.svgns = "http://www.w3.org/2000/svg";
        paperproto.xlink = "http://www.w3.org/1999/xlink";
        round = function (num) {
            return +num + (~~num === num) * .5;
        };
        var $ = function (el, attr) {
            if (attr) {
                for (var key in attr) {
                    if (attr[has](key)) {
                        el[setAttribute](key, Str(attr[key]));
                    }
                }
            } else {
                el = doc.createElementNS(paperproto.svgns, el);
                el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
                return el;
            }
        };
        R[toString] = function () {
            return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
        };
        var thePath = function (pathString, SVG) {
            var el = $("path");
            SVG.canvas && SVG.canvas[appendChild](el);
            var p = new Element(el, SVG);
            p.type = "path";
            setFillAndStroke(p, {fill: "none", stroke: "#000", path: pathString});
            return p;
        };
        var addGradientFill = function (o, gradient, SVG) {
            var type = "linear",
                fx = .5, fy = .5,
                s = o.style;
            gradient = Str(gradient)[rp](radial_gradient, function (all, _fx, _fy) {
                type = "radial";
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    var dir = ((fy > .5) * 2 - 1);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient[split](/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                var vector = [0, 0, math.cos(angle * PI / 180), math.sin(angle * PI / 180)],
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            var dots = parseDots(gradient);
            if (!dots) {
                return null;
            }
            var id = o.getAttribute(fillString);
            id = id.match(/^url\(#(.*)\)$/);
            id && SVG.defs.removeChild(doc.getElementById(id[1]));

            var el = $(type + "Gradient");
            el.id = createUUID();
            $(el, type == "radial" ? {fx: fx, fy: fy} : {x1: vector[0], y1: vector[1], x2: vector[2], y2: vector[3]});
            SVG.defs[appendChild](el);
            for (var i = 0, ii = dots[length]; i < ii; i++) {
                var stop = $("stop");
                $(stop, {
                    offset: dots[i].offset ? dots[i].offset : !i ? "0%" : "100%",
                    "stop-color": dots[i].color || "#fff"
                });
                el[appendChild](stop);
            }
            $(o, {
                fill: "url(#" + el.id + ")",
                opacity: 1,
                "fill-opacity": 1
            });
            s.fill = E;
            s.opacity = 1;
            s.fillOpacity = 1;
            return 1;
        };
        var updatePosition = function (o) {
            var bbox = o.getBBox();
            $(o.pattern, {patternTransform: R.format("translate({0},{1})", bbox.x, bbox.y)});
        };
        var setFillAndStroke = function (o, params) {
            var dasharray = {
                    "": [0],
                    "none": [0],
                    "-": [3, 1],
                    ".": [1, 1],
                    "-.": [3, 1, 1, 1],
                    "-..": [3, 1, 1, 1, 1, 1],
                    ". ": [1, 3],
                    "- ": [4, 3],
                    "--": [8, 3],
                    "- .": [4, 3, 1, 3],
                    "--.": [8, 3, 1, 3],
                    "--..": [8, 3, 1, 3, 1, 3]
                },
                node = o.node,
                attrs = o.attrs,
                rot = o.rotate(),
                addDashes = function (o, value) {
                    value = dasharray[lowerCase.call(value)];
                    if (value) {
                        var width = o.attrs["stroke-width"] || "1",
                            butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                            dashes = [];
                        var i = value[length];
                        while (i--) {
                            dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
                        }
                        $(node, {"stroke-dasharray": dashes[join](",")});
                    }
                };
            params[has]("rotation") && (rot = params.rotation);
            var rotxy = Str(rot)[split](separator);
            if (!(rotxy.length - 1)) {
                rotxy = null;
            } else {
                rotxy[1] = +rotxy[1];
                rotxy[2] = +rotxy[2];
            }
            toFloat(rot) && o.rotate(0, true);
            for (var att in params) {
                if (params[has](att)) {
                    if (!availableAttrs[has](att)) {
                        continue;
                    }
                    var value = params[att];
                    attrs[att] = value;
                    switch (att) {
                        case "blur":
                            o.blur(value);
                            break;
                        case "rotation":
                            o.rotate(value, true);
                            break;
                        case "href":
                        case "title":
                        case "target":
                            var pn = node.parentNode;
                            if (lowerCase.call(pn.tagName) != "a") {
                                var hl = $("a");
                                pn.insertBefore(hl, node);
                                hl[appendChild](node);
                                pn = hl;
                            }
                            if (att == "target" && value == "blank") {
                                pn.setAttributeNS(o.paper.xlink, "show", "new");
                            } else {
                                pn.setAttributeNS(o.paper.xlink, att, value);
                            }
                            break;
                        case "cursor":
                            node.style.cursor = value;
                            break;
                        case "clip-rect":
                            var rect = Str(value)[split](separator);
                            if (rect[length] == 4) {
                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                                var el = $("clipPath"),
                                    rc = $("rect");
                                el.id = createUUID();
                                $(rc, {
                                    x: rect[0],
                                    y: rect[1],
                                    width: rect[2],
                                    height: rect[3]
                                });
                                el[appendChild](rc);
                                o.paper.defs[appendChild](el);
                                $(node, {"clip-path": "url(#" + el.id + ")"});
                                o.clip = rc;
                            }
                            if (!value) {
                                var clip = doc.getElementById(node.getAttribute("clip-path")[rp](/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {"clip-path": E});
                                delete o.clip;
                            }
                        break;
                        case "path":
                            if (o.type == "path") {
                                $(node, {d: value ? attrs.path = pathToAbsolute(value) : "M0,0"});
                            }
                            break;
                        case "width":
                            node[setAttribute](att, value);
                            if (attrs.fx) {
                                att = "x";
                                value = attrs.x;
                            } else {
                                break;
                            }
                        case "x":
                            if (attrs.fx) {
                                value = -attrs.x - (attrs.width || 0);
                            }
                        case "rx":
                            if (att == "rx" && o.type == "rect") {
                                break;
                            }
                        case "cx":
                            rotxy && (att == "x" || att == "cx") && (rotxy[1] += value - attrs[att]);
                            node[setAttribute](att, value);
                            o.pattern && updatePosition(o);
                            break;
                        case "height":
                            node[setAttribute](att, value);
                            if (attrs.fy) {
                                att = "y";
                                value = attrs.y;
                            } else {
                                break;
                            }
                        case "y":
                            if (attrs.fy) {
                                value = -attrs.y - (attrs.height || 0);
                            }
                        case "ry":
                            if (att == "ry" && o.type == "rect") {
                                break;
                            }
                        case "cy":
                            rotxy && (att == "y" || att == "cy") && (rotxy[2] += value - attrs[att]);
                            node[setAttribute](att, value);
                            o.pattern && updatePosition(o);
                            break;
                        case "r":
                            if (o.type == "rect") {
                                $(node, {rx: value, ry: value});
                            } else {
                                node[setAttribute](att, value);
                            }
                            break;
                        case "src":
                            if (o.type == "image") {
                                node.setAttributeNS(o.paper.xlink, "href", value);
                            }
                            break;
                        case "stroke-width":
                            node.style.strokeWidth = value;
                            // Need following line for Firefox
                            node[setAttribute](att, value);
                            if (attrs["stroke-dasharray"]) {
                                addDashes(o, attrs["stroke-dasharray"]);
                            }
                            break;
                        case "stroke-dasharray":
                            addDashes(o, value);
                            break;
                        case "translation":
                            var xy = Str(value)[split](separator);
                            xy[0] = +xy[0] || 0;
                            xy[1] = +xy[1] || 0;
                            if (rotxy) {
                                rotxy[1] += xy[0];
                                rotxy[2] += xy[1];
                            }
                            translate.call(o, xy[0], xy[1]);
                            break;
                        case "scale":
                            xy = Str(value)[split](separator);
                            o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, isNaN(toFloat(xy[2])) ? null : +xy[2], isNaN(toFloat(xy[3])) ? null : +xy[3]);
                            break;
                        case fillString:
                            var isURL = Str(value).match(ISURL);
                            if (isURL) {
                                el = $("pattern");
                                var ig = $("image");
                                el.id = createUUID();
                                $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                                $(ig, {x: 0, y: 0});
                                ig.setAttributeNS(o.paper.xlink, "href", isURL[1]);
                                el[appendChild](ig);

                                var img = doc.createElement("img");
                                img.style.cssText = "position:absolute;left:-9999em;top-9999em";
                                img.onload = function () {
                                    $(el, {width: this.offsetWidth, height: this.offsetHeight});
                                    $(ig, {width: this.offsetWidth, height: this.offsetHeight});
                                    doc.body.removeChild(this);
                                    o.paper.safari();
                                };
                                doc.body[appendChild](img);
                                img.src = isURL[1];
                                o.paper.defs[appendChild](el);
                                node.style.fill = "url(#" + el.id + ")";
                                $(node, {fill: "url(#" + el.id + ")"});
                                o.pattern = el;
                                o.pattern && updatePosition(o);
                                break;
                            }
                            var clr = R.getRGB(value);
                            if (!clr.error) {
                                delete params.gradient;
                                delete attrs.gradient;
                                !R.is(attrs.opacity, "undefined") &&
                                    R.is(params.opacity, "undefined") &&
                                    $(node, {opacity: attrs.opacity});
                                !R.is(attrs["fill-opacity"], "undefined") &&
                                    R.is(params["fill-opacity"], "undefined") &&
                                    $(node, {"fill-opacity": attrs["fill-opacity"]});
                            } else if ((({circle: 1, ellipse: 1})[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper)) {
                                attrs.gradient = value;
                                attrs.fill = "none";
                                break;
                            }
                            clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        case "stroke":
                            clr = R.getRGB(value);
                            node[setAttribute](att, clr.hex);
                            att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                            break;
                        case "gradient":
                            (({circle: 1, ellipse: 1})[has](o.type) || Str(value).charAt() != "r") && addGradientFill(node, value, o.paper);
                            break;
                        case "opacity":
                            if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                                $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                            }
                            // fall
                        case "fill-opacity":
                            if (attrs.gradient) {
                                var gradient = doc.getElementById(node.getAttribute(fillString)[rp](/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    stops[stops[length] - 1][setAttribute]("stop-opacity", value);
                                }
                                break;
                            }
                        default:
                            att == "font-size" && (value = toInt(value, 10) + "px");
                            var cssrule = att[rp](/(\-.)/g, function (w) {
                                return upperCase.call(w.substring(1));
                            });
                            node.style[cssrule] = value;
                            // Need following line for Firefox
                            node[setAttribute](att, value);
                            break;
                    }
                }
            }

            tuneText(o, params);
            if (rotxy) {
                o.rotate(rotxy.join(S));
            } else {
                toFloat(rot) && o.rotate(rot, true);
            }
        };
        var leading = 1.2,
        tuneText = function (el, params) {
            if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
                return;
            }
            var a = el.attrs,
                node = el.node,
                fontSize = node.firstChild ? toInt(doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

            if (params[has]("text")) {
                a.text = params.text;
                while (node.firstChild) {
                    node.removeChild(node.firstChild);
                }
                var texts = Str(params.text)[split]("\n");
                for (var i = 0, ii = texts[length]; i < ii; i++) if (texts[i]) {
                    var tspan = $("tspan");
                    i && $(tspan, {dy: fontSize * leading, x: a.x});
                    tspan[appendChild](doc.createTextNode(texts[i]));
                    node[appendChild](tspan);
                }
            } else {
                texts = node.getElementsByTagName("tspan");
                for (i = 0, ii = texts[length]; i < ii; i++) {
                    i && $(texts[i], {dy: fontSize * leading, x: a.x});
                }
            }
            $(node, {y: a.y});
            var bb = el.getBBox(),
                dif = a.y - (bb.y + bb.height / 2);
            dif && R.is(dif, "finite") && $(node, {y: a.y + dif});
        },
        Element = function (node, svg) {
            var X = 0,
                Y = 0;
            this[0] = node;
            this.id = R._oid++;
            this.node = node;
            node.raphael = this;
            this.paper = svg;
            this.attrs = this.attrs || {};
            this.transformations = []; // rotate, translate, scale
            this._ = {
                tx: 0,
                ty: 0,
                rt: {deg: 0, cx: 0, cy: 0},
                sx: 1,
                sy: 1
            };
            !svg.bottom && (svg.bottom = this);
            this.prev = svg.top;
            svg.top && (svg.top.next = this);
            svg.top = this;
            this.next = null;
        };
        var elproto = Element[proto];
        Element[proto].rotate = function (deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            if (deg == null) {
                if (this._.rt.cx) {
                    return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
                }
                return this._.rt.deg;
            }
            var bbox = this.getBBox();
            deg = Str(deg)[split](separator);
            if (deg[length] - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            if (cx != null && cx !== false) {
                this._.rt.deg = deg;
            } else {
                this._.rt.deg += deg;
            }
            (cy == null) && (cx = null);
            this._.rt.cx = cx;
            this._.rt.cy = cy;
            cx = cx == null ? bbox.x + bbox.width / 2 : cx;
            cy = cy == null ? bbox.y + bbox.height / 2 : cy;
            if (this._.rt.deg) {
                this.transformations[0] = R.format("rotate({0} {1} {2})", this._.rt.deg, cx, cy);
                this.clip && $(this.clip, {transform: R.format("rotate({0} {1} {2})", -this._.rt.deg, cx, cy)});
            } else {
                this.transformations[0] = E;
                this.clip && $(this.clip, {transform: E});
            }
            $(this.node, {transform: this.transformations[join](S)});
            return this;
        };
        Element[proto].hide = function () {
            !this.removed && (this.node.style.display = "none");
            return this;
        };
        Element[proto].show = function () {
            !this.removed && (this.node.style.display = "");
            return this;
        };
        Element[proto].remove = function () {
            if (this.removed) {
                return;
            }
            tear(this, this.paper);
            this.node.parentNode.removeChild(this.node);
            for (var i in this) {
                delete this[i];
            }
            this.removed = true;
        };
        Element[proto].getBBox = function () {
            if (this.removed) {
                return this;
            }
            if (this.type == "path") {
                return pathDimensions(this.attrs.path);
            }
            if (this.node.style.display == "none") {
                this.show();
                var hide = true;
            }
            var bbox = {};
            try {
                bbox = this.node.getBBox();
            } catch(e) {
                // Firefox 3.0.x plays badly here
            } finally {
                bbox = bbox || {};
            }
            if (this.type == "text") {
                bbox = {x: bbox.x, y: Infinity, width: 0, height: 0};
                for (var i = 0, ii = this.node.getNumberOfChars(); i < ii; i++) {
                    var bb = this.node.getExtentOfChar(i);
                    (bb.y < bbox.y) && (bbox.y = bb.y);
                    (bb.y + bb.height - bbox.y > bbox.height) && (bbox.height = bb.y + bb.height - bbox.y);
                    (bb.x + bb.width - bbox.x > bbox.width) && (bbox.width = bb.x + bb.width - bbox.x);
                }
            }
            hide && this.hide();
            return bbox;
        };
        Element[proto].attr = function (name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var i in this.attrs) if (this.attrs[has](i)) {
                    res[i] = this.attrs[i];
                }
                this._.rt.deg && (res.rotation = this.rotate());
                (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                return res;
            }
            if (value == null && R.is(name, string)) {
                if (name == "translation") {
                    return translate.call(this);
                }
                if (name == "rotation") {
                    return this.rotate();
                }
                if (name == "scale") {
                    return this.scale();
                }
                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                return this.attrs[name];
            }
            if (value == null && R.is(name, array)) {
                var values = {};
                for (var j = 0, jj = name.length; j < jj; j++) {
                    values[name[j]] = this.attr(name[j]);
                }
                return values;
            }
            if (value != null) {
                var params = {};
                params[name] = value;
            } else if (name != null && R.is(name, "object")) {
                params = name;
            }
            for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            setFillAndStroke(this, params);
            return this;
        };
        Element[proto].toFront = function () {
            if (this.removed) {
                return this;
            }
            this.node.parentNode[appendChild](this.node);
            var svg = this.paper;
            svg.top != this && tofront(this, svg);
            return this;
        };
        Element[proto].toBack = function () {
            if (this.removed) {
                return this;
            }
            if (this.node.parentNode.firstChild != this.node) {
                this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
                toback(this, this.paper);
                var svg = this.paper;
            }
            return this;
        };
        Element[proto].insertAfter = function (element) {
            if (this.removed) {
                return this;
            }
            var node = element.node || element[element.length - 1].node;
            if (node.nextSibling) {
                node.parentNode.insertBefore(this.node, node.nextSibling);
            } else {
                node.parentNode[appendChild](this.node);
            }
            insertafter(this, element, this.paper);
            return this;
        };
        Element[proto].insertBefore = function (element) {
            if (this.removed) {
                return this;
            }
            var node = element.node || element[0].node;
            node.parentNode.insertBefore(this.node, node);
            insertbefore(this, element, this.paper);
            return this;
        };
        Element[proto].blur = function (size) {
            // Experimental. No Safari support. Use it on your own risk.
            var t = this;
            if (+size !== 0) {
                var fltr = $("filter"),
                    blur = $("feGaussianBlur");
                t.attrs.blur = size;
                fltr.id = createUUID();
                $(blur, {stdDeviation: +size || 1.5});
                fltr.appendChild(blur);
                t.paper.defs.appendChild(fltr);
                t._blur = fltr;
                $(t.node, {filter: "url(#" + fltr.id + ")"});
            } else {
                if (t._blur) {
                    t._blur.parentNode.removeChild(t._blur);
                    delete t._blur;
                    delete t.attrs.blur;
                }
                t.node.removeAttribute("filter");
            }
        };
        var theCircle = function (svg, x, y, r) {
            var el = $("circle");
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
            res.type = "circle";
            $(el, res.attrs);
            return res;
        },
        theRect = function (svg, x, y, w, h, r) {
            var el = $("rect");
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
            res.type = "rect";
            $(el, res.attrs);
            return res;
        },
        theEllipse = function (svg, x, y, rx, ry) {
            var el = $("ellipse");
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
            res.type = "ellipse";
            $(el, res.attrs);
            return res;
        },
        theImage = function (svg, src, x, y, w, h) {
            var el = $("image");
            $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
            el.setAttributeNS(svg.xlink, "href", src);
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {x: x, y: y, width: w, height: h, src: src};
            res.type = "image";
            return res;
        },
        theText = function (svg, x, y, text) {
            var el = $("text");
            $(el, {x: x, y: y, "text-anchor": "middle"});
            svg.canvas && svg.canvas[appendChild](el);
            var res = new Element(el, svg);
            res.attrs = {x: x, y: y, "text-anchor": "middle", text: text, font: availableAttrs.font, stroke: "none", fill: "#000"};
            res.type = "text";
            setFillAndStroke(res, res.attrs);
            return res;
        },
        setSize = function (width, height) {
            this.width = width || this.width;
            this.height = height || this.height;
            this.canvas[setAttribute]("width", this.width);
            this.canvas[setAttribute]("height", this.height);
            return this;
        },
        create = function () {
            var con = getContainer[apply](0, arguments),
                container = con && con.container,
                x = con.x,
                y = con.y,
                width = con.width,
                height = con.height;
            if (!container) {
                throw new Error("SVG container not found.");
            }
            var cnvs = $("svg");
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            $(cnvs, {
                xmlns: "http://www.w3.org/2000/svg",
                version: 1.1,
                width: width,
                height: height
            });
            if (container == 1) {
                cnvs.style.cssText = "position:absolute;left:" + x + "px;top:" + y + "px";
                doc.body[appendChild](cnvs);
            } else {
                if (container.firstChild) {
                    container.insertBefore(cnvs, container.firstChild);
                } else {
                    container[appendChild](cnvs);
                }
            }
            container = new Paper;
            container.width = width;
            container.height = height;
            container.canvas = cnvs;
            plugins.call(container, container, R.fn);
            container.clear();
            return container;
        };
        paperproto.clear = function () {
            var c = this.canvas;
            while (c.firstChild) {
                c.removeChild(c.firstChild);
            }
            this.bottom = this.top = null;
            (this.desc = $("desc"))[appendChild](doc.createTextNode("Created with Rapha\xebl"));
            c[appendChild](this.desc);
            c[appendChild](this.defs = $("defs"));
        };
        paperproto.remove = function () {
            this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = removed(i);
            }
        };
    }

    // VML
    if (R.vml) {
        var map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
            bites = /([clmz]),?([^clmz]*)/gi,
            blurregexp = / progid:\S+Blur\([^\)]+\)/g,
            val = /-?[^,\s-]+/g,
            coordsize = 1e3 + S + 1e3,
            zoom = 10,
            pathlike = {path: 1, rect: 1},
            path2vml = function (path) {
                var total =  /[ahqstv]/ig,
                    command = pathToAbsolute;
                Str(path).match(total) && (command = path2curve);
                total = /[clmz]/g;
                if (command == pathToAbsolute && !Str(path).match(total)) {
                    var res = Str(path)[rp](bites, function (all, command, args) {
                        var vals = [],
                            isMove = lowerCase.call(command) == "m",
                            res = map[command];
                        args[rp](val, function (value) {
                            if (isMove && vals[length] == 2) {
                                res += vals + map[command == "m" ? "l" : "L"];
                                vals = [];
                            }
                            vals[push](round(value * zoom));
                        });
                        return res + vals;
                    });
                    return res;
                }
                var pa = command(path), p, r;
                res = [];
                for (var i = 0, ii = pa[length]; i < ii; i++) {
                    p = pa[i];
                    r = lowerCase.call(pa[i][0]);
                    r == "z" && (r = "x");
                    for (var j = 1, jj = p[length]; j < jj; j++) {
                        r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                    }
                    res[push](r);
                }
                return res[join](S);
            };

        R[toString] = function () {
            return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
        };
        thePath = function (pathString, vml) {
            var g = createNode("group");
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = vml.coordsize;
            g.coordorigin = vml.coordorigin;
            var el = createNode("shape"), ol = el.style;
            ol.width = vml.width + "px";
            ol.height = vml.height + "px";
            el.coordsize = coordsize;
            el.coordorigin = vml.coordorigin;
            g[appendChild](el);
            var p = new Element(el, g, vml),
                attr = {fill: "none", stroke: "#000"};
            pathString && (attr.path = pathString);
            p.type = "path";
            p.path = [];
            p.Path = E;
            setFillAndStroke(p, attr);
            vml.canvas[appendChild](g);
            return p;
        };
        setFillAndStroke = function (o, params) {
            o.attrs = o.attrs || {};
            var node = o.node,
                a = o.attrs,
                s = node.style,
                xy,
                newpath = (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.r != a.r) && o.type == "rect",
                res = o;

            for (var par in params) if (params[has](par)) {
                a[par] = params[par];
            }
            if (newpath) {
                a.path = rectPath(a.x, a.y, a.width, a.height, a.r);
                o.X = a.x;
                o.Y = a.y;
                o.W = a.width;
                o.H = a.height;
            }
            params.href && (node.href = params.href);
            params.title && (node.title = params.title);
            params.target && (node.target = params.target);
            params.cursor && (s.cursor = params.cursor);
            "blur" in params && o.blur(params.blur);
            if (params.path && o.type == "path" || newpath) {
                node.path = path2vml(a.path);
            }
            if (params.rotation != null) {
                o.rotate(params.rotation, true);
            }
            if (params.translation) {
                xy = Str(params.translation)[split](separator);
                translate.call(o, xy[0], xy[1]);
                if (o._.rt.cx != null) {
                    o._.rt.cx +=+ xy[0];
                    o._.rt.cy +=+ xy[1];
                    o.setBox(o.attrs, xy[0], xy[1]);
                }
            }
            if (params.scale) {
                xy = Str(params.scale)[split](separator);
                o.scale(+xy[0] || 1, +xy[1] || +xy[0] || 1, +xy[2] || null, +xy[3] || null);
            }
            if ("clip-rect" in params) {
                var rect = Str(params["clip-rect"])[split](separator);
                if (rect[length] == 4) {
                    rect[2] = +rect[2] + (+rect[0]);
                    rect[3] = +rect[3] + (+rect[1]);
                    var div = node.clipRect || doc.createElement("div"),
                        dstyle = div.style,
                        group = node.parentNode;
                    dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                    if (!node.clipRect) {
                        dstyle.position = "absolute";
                        dstyle.top = 0;
                        dstyle.left = 0;
                        dstyle.width = o.paper.width + "px";
                        dstyle.height = o.paper.height + "px";
                        group.parentNode.insertBefore(div, group);
                        div[appendChild](group);
                        node.clipRect = div;
                    }
                }
                if (!params["clip-rect"]) {
                    node.clipRect && (node.clipRect.style.clip = E);
                }
            }
            if (o.type == "image" && params.src) {
                node.src = params.src;
            }
            if (o.type == "image" && params.opacity) {
                node.filterOpacity = ms + ".Alpha(opacity=" + (params.opacity * 100) + ")";
                s.filter = (node.filterMatrix || E) + (node.filterOpacity || E);
            }
            params.font && (s.font = params.font);
            params["font-family"] && (s.fontFamily = '"' + params["font-family"][split](",")[0][rp](/^[\'\"]+|[\'\"]+$/g, E) + '"');
            params["font-size"] && (s.fontSize = params["font-size"]);
            params["font-weight"] && (s.fontWeight = params["font-weight"]);
            params["font-style"] && (s.fontStyle = params["font-style"]);
            if (params.opacity != null ||
                params["stroke-width"] != null ||
                params.fill != null ||
                params.stroke != null ||
                params["stroke-width"] != null ||
                params["stroke-opacity"] != null ||
                params["fill-opacity"] != null ||
                params["stroke-dasharray"] != null ||
                params["stroke-miterlimit"] != null ||
                params["stroke-linejoin"] != null ||
                params["stroke-linecap"] != null) {
                node = o.shape || node;
                var fill = (node.getElementsByTagName(fillString) && node.getElementsByTagName(fillString)[0]),
                    newfill = false;
                !fill && (newfill = fill = createNode(fillString));
                if ("fill-opacity" in params || "opacity" in params) {
                    var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                    opacity = mmin(mmax(opacity, 0), 1);
                    fill.opacity = opacity;
                }
                params.fill && (fill.on = true);
                if (fill.on == null || params.fill == "none") {
                    fill.on = false;
                }
                if (fill.on && params.fill) {
                    var isURL = params.fill.match(ISURL);
                    if (isURL) {
                        fill.src = isURL[1];
                        fill.type = "tile";
                    } else {
                        fill.color = R.getRGB(params.fill).hex;
                        fill.src = E;
                        fill.type = "solid";
                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill)) {
                            a.fill = "none";
                            a.gradient = params.fill;
                        }
                    }
                }
                newfill && node[appendChild](fill);
                var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                newstroke = false;
                !stroke && (newstroke = stroke = createNode("stroke"));
                if ((params.stroke && params.stroke != "none") ||
                    params["stroke-width"] ||
                    params["stroke-opacity"] != null ||
                    params["stroke-dasharray"] ||
                    params["stroke-miterlimit"] ||
                    params["stroke-linejoin"] ||
                    params["stroke-linecap"]) {
                    stroke.on = true;
                }
                (params.stroke == "none" || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
                var strokeColor = R.getRGB(params.stroke);
                stroke.on && params.stroke && (stroke.color = strokeColor.hex);
                opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
                var width = (toFloat(params["stroke-width"]) || 1) * .75;
                opacity = mmin(mmax(opacity, 0), 1);
                params["stroke-width"] == null && (width = a["stroke-width"]);
                params["stroke-width"] && (stroke.weight = width);
                width && width < 1 && (opacity *= width) && (stroke.weight = 1);
                stroke.opacity = opacity;

                params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
                stroke.miterlimit = params["stroke-miterlimit"] || 8;
                params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
                if (params["stroke-dasharray"]) {
                    var dasharray = {
                        "-": "shortdash",
                        ".": "shortdot",
                        "-.": "shortdashdot",
                        "-..": "shortdashdotdot",
                        ". ": "dot",
                        "- ": "dash",
                        "--": "longdash",
                        "- .": "dashdot",
                        "--.": "longdashdot",
                        "--..": "longdashdotdot"
                    };
                    stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
                }
                newstroke && node[appendChild](stroke);
            }
            if (res.type == "text") {
                s = res.paper.span.style;
                a.font && (s.font = a.font);
                a["font-family"] && (s.fontFamily = a["font-family"]);
                a["font-size"] && (s.fontSize = a["font-size"]);
                a["font-weight"] && (s.fontWeight = a["font-weight"]);
                a["font-style"] && (s.fontStyle = a["font-style"]);
                res.node.string && (res.paper.span.innerHTML = Str(res.node.string)[rp](/</g, "&#60;")[rp](/&/g, "&#38;")[rp](/\n/g, "<br>"));
                res.W = a.w = res.paper.span.offsetWidth;
                res.H = a.h = res.paper.span.offsetHeight;
                res.X = a.x;
                res.Y = a.y + round(res.H / 2);

                // text-anchor emulationm
                switch (a["text-anchor"]) {
                    case "start":
                        res.node.style["v-text-align"] = "left";
                        res.bbx = round(res.W / 2);
                    break;
                    case "end":
                        res.node.style["v-text-align"] = "right";
                        res.bbx = -round(res.W / 2);
                    break;
                    default:
                        res.node.style["v-text-align"] = "center";
                    break;
                }
            }
        };
        addGradientFill = function (o, gradient) {
            o.attrs = o.attrs || {};
            var attrs = o.attrs,
                fill,
                type = "linear",
                fxfy = ".5 .5";
            o.attrs.gradient = gradient;
            gradient = Str(gradient)[rp](radial_gradient, function (all, fx, fy) {
                type = "radial";
                if (fx && fy) {
                    fx = toFloat(fx);
                    fy = toFloat(fy);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                    fxfy = fx + S + fy;
                }
                return E;
            });
            gradient = gradient[split](/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
            }
            var dots = parseDots(gradient);
            if (!dots) {
                return null;
            }
            o = o.shape || o.node;
            fill = o.getElementsByTagName(fillString)[0] || createNode(fillString);
            !fill.parentNode && o.appendChild(fill);
            if (dots[length]) {
                fill.on = true;
                fill.method = "none";
                fill.color = dots[0].color;
                fill.color2 = dots[dots[length] - 1].color;
                var clrs = [];
                for (var i = 0, ii = dots[length]; i < ii; i++) {
                    dots[i].offset && clrs[push](dots[i].offset + S + dots[i].color);
                }
                fill.colors && (fill.colors.value = clrs[length] ? clrs[join]() : "0% " + fill.color);
                if (type == "radial") {
                    fill.type = "gradientradial";
                    fill.focus = "100%";
                    fill.focussize = fxfy;
                    fill.focusposition = fxfy;
                } else {
                    fill.type = "gradient";
                    fill.angle = (270 - angle) % 360;
                }
            }
            return 1;
        };
        Element = function (node, group, vml) {
            var Rotation = 0,
                RotX = 0,
                RotY = 0,
                Scale = 1;
            this[0] = node;
            this.id = R._oid++;
            this.node = node;
            node.raphael = this;
            this.X = 0;
            this.Y = 0;
            this.attrs = {};
            this.Group = group;
            this.paper = vml;
            this._ = {
                tx: 0,
                ty: 0,
                rt: {deg:0},
                sx: 1,
                sy: 1
            };
            !vml.bottom && (vml.bottom = this);
            this.prev = vml.top;
            vml.top && (vml.top.next = this);
            vml.top = this;
            this.next = null;
        };
        elproto = Element[proto];
        elproto.rotate = function (deg, cx, cy) {
            if (this.removed) {
                return this;
            }
            if (deg == null) {
                if (this._.rt.cx) {
                    return [this._.rt.deg, this._.rt.cx, this._.rt.cy][join](S);
                }
                return this._.rt.deg;
            }
            deg = Str(deg)[split](separator);
            if (deg[length] - 1) {
                cx = toFloat(deg[1]);
                cy = toFloat(deg[2]);
            }
            deg = toFloat(deg[0]);
            if (cx != null) {
                this._.rt.deg = deg;
            } else {
                this._.rt.deg += deg;
            }
            cy == null && (cx = null);
            this._.rt.cx = cx;
            this._.rt.cy = cy;
            this.setBox(this.attrs, cx, cy);
            this.Group.style.rotation = this._.rt.deg;
            // gradient fix for rotation. TODO
            // var fill = (this.shape || this.node).getElementsByTagName(fillString);
            // fill = fill[0] || {};
            // var b = ((360 - this._.rt.deg) - 270) % 360;
            // !R.is(fill.angle, "undefined") && (fill.angle = b);
            return this;
        };
        elproto.setBox = function (params, cx, cy) {
            if (this.removed) {
                return this;
            }
            var gs = this.Group.style,
                os = (this.shape && this.shape.style) || this.node.style;
            params = params || {};
            for (var i in params) if (params[has](i)) {
                this.attrs[i] = params[i];
            }
            cx = cx || this._.rt.cx;
            cy = cy || this._.rt.cy;
            var attr = this.attrs,
                x,
                y,
                w,
                h;
            switch (this.type) {
                case "circle":
                    x = attr.cx - attr.r;
                    y = attr.cy - attr.r;
                    w = h = attr.r * 2;
                    break;
                case "ellipse":
                    x = attr.cx - attr.rx;
                    y = attr.cy - attr.ry;
                    w = attr.rx * 2;
                    h = attr.ry * 2;
                    break;
                case "image":
                    x = +attr.x;
                    y = +attr.y;
                    w = attr.width || 0;
                    h = attr.height || 0;
                    break;
                case "text":
                    this.textpath.v = ["m", round(attr.x), ", ", round(attr.y - 2), "l", round(attr.x) + 1, ", ", round(attr.y - 2)][join](E);
                    x = attr.x - round(this.W / 2);
                    y = attr.y - this.H / 2;
                    w = this.W;
                    h = this.H;
                    break;
                case "rect":
                case "path":
                    if (!this.attrs.path) {
                        x = 0;
                        y = 0;
                        w = this.paper.width;
                        h = this.paper.height;
                    } else {
                        var dim = pathDimensions(this.attrs.path);
                        x = dim.x;
                        y = dim.y;
                        w = dim.width;
                        h = dim.height;
                    }
                    break;
                default:
                    x = 0;
                    y = 0;
                    w = this.paper.width;
                    h = this.paper.height;
                    break;
            }
            cx = (cx == null) ? x + w / 2 : cx;
            cy = (cy == null) ? y + h / 2 : cy;
            var left = cx - this.paper.width / 2,
                top = cy - this.paper.height / 2, t;
            gs.left != (t = left + "px") && (gs.left = t);
            gs.top != (t = top + "px") && (gs.top = t);
            this.X = pathlike[has](this.type) ? -left : x;
            this.Y = pathlike[has](this.type) ? -top : y;
            this.W = w;
            this.H = h;
            if (pathlike[has](this.type)) {
                os.left != (t = -left * zoom + "px") && (os.left = t);
                os.top != (t = -top * zoom + "px") && (os.top = t);
            } else if (this.type == "text") {
                os.left != (t = -left + "px") && (os.left = t);
                os.top != (t = -top + "px") && (os.top = t);
            } else {
                gs.width != (t = this.paper.width + "px") && (gs.width = t);
                gs.height != (t = this.paper.height + "px") && (gs.height = t);
                os.left != (t = x - left + "px") && (os.left = t);
                os.top != (t = y - top + "px") && (os.top = t);
                os.width != (t = w + "px") && (os.width = t);
                os.height != (t = h + "px") && (os.height = t);
            }
        };
        elproto.hide = function () {
            !this.removed && (this.Group.style.display = "none");
            return this;
        };
        elproto.show = function () {
            !this.removed && (this.Group.style.display = "block");
            return this;
        };
        elproto.getBBox = function () {
            if (this.removed) {
                return this;
            }
            if (pathlike[has](this.type)) {
                return pathDimensions(this.attrs.path);
            }
            return {
                x: this.X + (this.bbx || 0),
                y: this.Y,
                width: this.W,
                height: this.H
            };
        };
        elproto.remove = function () {
            if (this.removed) {
                return;
            }
            tear(this, this.paper);
            this.node.parentNode.removeChild(this.node);
            this.Group.parentNode.removeChild(this.Group);
            this.shape && this.shape.parentNode.removeChild(this.shape);
            for (var i in this) {
                delete this[i];
            }
            this.removed = true;
        };
        elproto.attr = function (name, value) {
            if (this.removed) {
                return this;
            }
            if (name == null) {
                var res = {};
                for (var i in this.attrs) if (this.attrs[has](i)) {
                    res[i] = this.attrs[i];
                }
                this._.rt.deg && (res.rotation = this.rotate());
                (this._.sx != 1 || this._.sy != 1) && (res.scale = this.scale());
                res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
                return res;
            }
            if (value == null && R.is(name, "string")) {
                if (name == "translation") {
                    return translate.call(this);
                }
                if (name == "rotation") {
                    return this.rotate();
                }
                if (name == "scale") {
                    return this.scale();
                }
                if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                    return this.attrs.gradient;
                }
                return this.attrs[name];
            }
            if (this.attrs && value == null && R.is(name, array)) {
                var ii, values = {};
                for (i = 0, ii = name[length]; i < ii; i++) {
                    values[name[i]] = this.attr(name[i]);
                }
                return values;
            }
            var params;
            if (value != null) {
                params = {};
                params[name] = value;
            }
            value == null && R.is(name, "object") && (params = name);
            if (params) {
                for (var key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                    var par = this.paper.customAttributes[key].apply(this, [][concat](params[key]));
                    this.attrs[key] = params[key];
                    for (var subkey in par) if (par[has](subkey)) {
                        params[subkey] = par[subkey];
                    }
                }
                if (params.text && this.type == "text") {
                    this.node.string = params.text;
                }
                setFillAndStroke(this, params);
                if (params.gradient && (({circle: 1, ellipse: 1})[has](this.type) || Str(params.gradient).charAt() != "r")) {
                    addGradientFill(this, params.gradient);
                }
                (!pathlike[has](this.type) || this._.rt.deg) && this.setBox(this.attrs);
            }
            return this;
        };
        elproto.toFront = function () {
            !this.removed && this.Group.parentNode[appendChild](this.Group);
            this.paper.top != this && tofront(this, this.paper);
            return this;
        };
        elproto.toBack = function () {
            if (this.removed) {
                return this;
            }
            if (this.Group.parentNode.firstChild != this.Group) {
                this.Group.parentNode.insertBefore(this.Group, this.Group.parentNode.firstChild);
                toback(this, this.paper);
            }
            return this;
        };
        elproto.insertAfter = function (element) {
            if (this.removed) {
                return this;
            }
            if (element.constructor == Set) {
                element = element[element.length - 1];
            }
            if (element.Group.nextSibling) {
                element.Group.parentNode.insertBefore(this.Group, element.Group.nextSibling);
            } else {
                element.Group.parentNode[appendChild](this.Group);
            }
            insertafter(this, element, this.paper);
            return this;
        };
        elproto.insertBefore = function (element) {
            if (this.removed) {
                return this;
            }
            if (element.constructor == Set) {
                element = element[0];
            }
            element.Group.parentNode.insertBefore(this.Group, element.Group);
            insertbefore(this, element, this.paper);
            return this;
        };
        elproto.blur = function (size) {
            var s = this.node.runtimeStyle,
                f = s.filter;
            f = f.replace(blurregexp, E);
            if (+size !== 0) {
                this.attrs.blur = size;
                s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
                s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
            } else {
                s.filter = f;
                s.margin = 0;
                delete this.attrs.blur;
            }
        };

        theCircle = function (vml, x, y, r) {
            var g = createNode("group"),
                o = createNode("oval"),
                ol = o.style;
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            g[appendChild](o);
            var res = new Element(o, g, vml);
            res.type = "circle";
            setFillAndStroke(res, {stroke: "#000", fill: "none"});
            res.attrs.cx = x;
            res.attrs.cy = y;
            res.attrs.r = r;
            res.setBox({x: x - r, y: y - r, width: r * 2, height: r * 2});
            vml.canvas[appendChild](g);
            return res;
        };
        function rectPath(x, y, w, h, r) {
            if (r) {
                return R.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", x + r, y, w - r * 2, r, -r, h - r * 2, r * 2 - w, r * 2 - h);
            } else {
                return R.format("M{0},{1}l{2},0,0,{3},{4},0z", x, y, w, h, -w);
            }
        }
        theRect = function (vml, x, y, w, h, r) {
            var path = rectPath(x, y, w, h, r),
                res = vml.path(path),
                a = res.attrs;
            res.X = a.x = x;
            res.Y = a.y = y;
            res.W = a.width = w;
            res.H = a.height = h;
            a.r = r;
            a.path = path;
            res.type = "rect";
            return res;
        };
        theEllipse = function (vml, x, y, rx, ry) {
            var g = createNode("group"),
                o = createNode("oval"),
                ol = o.style;
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            g[appendChild](o);
            var res = new Element(o, g, vml);
            res.type = "ellipse";
            setFillAndStroke(res, {stroke: "#000"});
            res.attrs.cx = x;
            res.attrs.cy = y;
            res.attrs.rx = rx;
            res.attrs.ry = ry;
            res.setBox({x: x - rx, y: y - ry, width: rx * 2, height: ry * 2});
            vml.canvas[appendChild](g);
            return res;
        };
        theImage = function (vml, src, x, y, w, h) {
            var g = createNode("group"),
                o = createNode("image");
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            o.src = src;
            g[appendChild](o);
            var res = new Element(o, g, vml);
            res.type = "image";
            res.attrs.src = src;
            res.attrs.x = x;
            res.attrs.y = y;
            res.attrs.w = w;
            res.attrs.h = h;
            res.setBox({x: x, y: y, width: w, height: h});
            vml.canvas[appendChild](g);
            return res;
        };
        theText = function (vml, x, y, text) {
            var g = createNode("group"),
                el = createNode("shape"),
                ol = el.style,
                path = createNode("path"),
                ps = path.style,
                o = createNode("textpath");
            g.style.cssText = "position:absolute;left:0;top:0;width:" + vml.width + "px;height:" + vml.height + "px";
            g.coordsize = coordsize;
            g.coordorigin = vml.coordorigin;
            path.v = R.format("m{0},{1}l{2},{1}", round(x * 10), round(y * 10), round(x * 10) + 1);
            path.textpathok = true;
            ol.width = vml.width;
            ol.height = vml.height;
            o.string = Str(text);
            o.on = true;
            el[appendChild](o);
            el[appendChild](path);
            g[appendChild](el);
            var res = new Element(o, g, vml);
            res.shape = el;
            res.textpath = path;
            res.type = "text";
            res.attrs.text = text;
            res.attrs.x = x;
            res.attrs.y = y;
            res.attrs.w = 1;
            res.attrs.h = 1;
            setFillAndStroke(res, {font: availableAttrs.font, stroke: "none", fill: "#000"});
            res.setBox();
            vml.canvas[appendChild](g);
            return res;
        };
        setSize = function (width, height) {
            var cs = this.canvas.style;
            width == +width && (width += "px");
            height == +height && (height += "px");
            cs.width = width;
            cs.height = height;
            cs.clip = "rect(0 " + width + " " + height + " 0)";
            return this;
        };
        var createNode;
        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        try {
            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
            createNode = function (tagName) {
                return doc.createElement('<rvml:' + tagName + ' class="rvml">');
            };
        } catch (e) {
            createNode = function (tagName) {
                return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
            };
        }
        create = function () {
            var con = getContainer[apply](0, arguments),
                container = con.container,
                height = con.height,
                s,
                width = con.width,
                x = con.x,
                y = con.y;
            if (!container) {
                throw new Error("VML container not found.");
            }
            var res = new Paper,
                c = res.canvas = doc.createElement("div"),
                cs = c.style;
            x = x || 0;
            y = y || 0;
            width = width || 512;
            height = height || 342;
            width == +width && (width += "px");
            height == +height && (height += "px");
            res.width = 1e3;
            res.height = 1e3;
            res.coordsize = zoom * 1e3 + S + zoom * 1e3;
            res.coordorigin = "0 0";
            res.span = doc.createElement("span");
            res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
            c[appendChild](res.span);
            cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
            if (container == 1) {
                doc.body[appendChild](c);
                cs.left = x + "px";
                cs.top = y + "px";
                cs.position = "absolute";
            } else {
                if (container.firstChild) {
                    container.insertBefore(c, container.firstChild);
                } else {
                    container[appendChild](c);
                }
            }
            plugins.call(res, res, R.fn);
            return res;
        };
        paperproto.clear = function () {
            this.canvas.innerHTML = E;
            this.span = doc.createElement("span");
            this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
            this.canvas[appendChild](this.span);
            this.bottom = this.top = null;
        };
        paperproto.remove = function () {
            this.canvas.parentNode.removeChild(this.canvas);
            for (var i in this) {
                this[i] = removed(i);
            }
            return true;
        };
    }

    // rest
    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP")) {
        paperproto.safari = function () {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
            win.setTimeout(function () {rect.remove();});
        };
    } else {
        paperproto.safari = function () {};
    }

    // Events
    var preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = (function () {
        if (doc.addEventListener) {
            return function (obj, type, fn, element) {
                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type;
                var f = function (e) {
                    if (supportsTouch && touchMap[has](type)) {
                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                var olde = e;
                                e = olde.targetTouches[i];
				olde.targetTouches[i] = null;
				e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }
                    }
                    return fn.call(element, e);
                };
                obj.addEventListener(realName, f, false);
                return function () {
                    obj.removeEventListener(realName, f, false);
                    return true;
                };
            };
        } else if (doc.attachEvent) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    e = e || win.event;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function () {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
            scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft,
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            x += scrollX;
            y += scrollY;
            dragi.move && dragi.move.call(dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            dragi.end && dragi.end.call(dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };
    for (var i = events[length]; i--;) {
        (function (eventName) {
            R[eventName] = Element[proto][eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = Element[proto]["un" + eventName] = function (fn) {
                var events = this.events,
                    l = events[length];
                while (l--) if (events[l].name == eventName && events[l].f == fn) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        this._drag = {};
        this.mousedown(function (e) {
            (e.originalEvent || e).preventDefault();
            var scrollY = doc.documentElement.scrollTop || doc.body.scrollTop,
                scrollX = doc.documentElement.scrollLeft || doc.body.scrollLeft;
            this._drag.x = e.clientX + scrollX;
            this._drag.y = e.clientY + scrollY;
            this._drag.id = e.identifier;
            onstart && onstart.call(start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move: onmove, end: onend, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
        });
        return this;
    };
    elproto.undrag = function (onmove, onstart, onend) {
        var i = drag.length;
        while (i--) {
            drag[i].el == this && (drag[i].move == onmove && drag[i].end == onend) && drag.splice(i++, 1);
        }
        !drag.length && R.unmousemove(dragMove).unmouseup(dragUp);
    };
    paperproto.circle = function (x, y, r) {
        return theCircle(this, x || 0, y || 0, r || 0);
    };
    paperproto.rect = function (x, y, w, h, r) {
        return theRect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
    };
    paperproto.ellipse = function (x, y, rx, ry) {
        return theEllipse(this, x || 0, y || 0, rx || 0, ry || 0);
    };
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        return thePath(R.format[apply](R, arguments), this);
    };
    paperproto.image = function (src, x, y, w, h) {
        return theImage(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
    };
    paperproto.text = function (x, y, text) {
        return theText(this, x || 0, y || 0, Str(text));
    };
    paperproto.set = function (itemsArray) {
        arguments[length] > 1 && (itemsArray = Array[proto].splice.call(arguments, 0, arguments[length]));
        return new Set(itemsArray);
    };
    paperproto.setSize = setSize;
    paperproto.top = paperproto.bottom = null;
    paperproto.raphael = R;
    function x_y() {
        return this.x + S + this.y;
    }
    elproto.resetScale = function () {
        if (this.removed) {
            return this;
        }
        this._.sx = 1;
        this._.sy = 1;
        this.attrs.scale = "1 1";
    };
    elproto.scale = function (x, y, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (x == null && y == null) {
            return {
                x: this._.sx,
                y: this._.sy,
                toString: x_y
            };
        }
        y = y || x;
        !+y && (y = x);
        var dx,
            dy,
            dcx,
            dcy,
            a = this.attrs;
        if (x != 0) {
            var bb = this.getBBox(),
                rcx = bb.x + bb.width / 2,
                rcy = bb.y + bb.height / 2,
                kx = abs(x / this._.sx),
                ky = abs(y / this._.sy);
            cx = (+cx || cx == 0) ? cx : rcx;
            cy = (+cy || cy == 0) ? cy : rcy;
            var posx = this._.sx > 0,
                posy = this._.sy > 0,
                dirx = ~~(x / abs(x)),
                diry = ~~(y / abs(y)),
                dkx = kx * dirx,
                dky = ky * diry,
                s = this.node.style,
                ncx = cx + abs(rcx - cx) * dkx * (rcx > cx == posx ? 1 : -1),
                ncy = cy + abs(rcy - cy) * dky * (rcy > cy == posy ? 1 : -1),
                fr = (x * dirx > y * diry ? ky : kx);
            switch (this.type) {
                case "rect":
                case "image":
                    var neww = a.width * kx,
                        newh = a.height * ky;
                    this.attr({
                        height: newh,
                        r: a.r * fr,
                        width: neww,
                        x: ncx - neww / 2,
                        y: ncy - newh / 2
                    });
                    break;
                case "circle":
                case "ellipse":
                    this.attr({
                        rx: a.rx * kx,
                        ry: a.ry * ky,
                        r: a.r * fr,
                        cx: ncx,
                        cy: ncy
                    });
                    break;
                case "text":
                    this.attr({
                        x: ncx,
                        y: ncy
                    });
                    break;
                case "path":
                    var path = pathToRelative(a.path),
                        skip = true,
                        fx = posx ? dkx : kx,
                        fy = posy ? dky : ky;
                    for (var i = 0, ii = path[length]; i < ii; i++) {
                        var p = path[i],
                            P0 = upperCase.call(p[0]);
                        if (P0 == "M" && skip) {
                            continue;
                        } else {
                            skip = false;
                        }
                        if (P0 == "A") {
                            p[path[i][length] - 2] *= fx;
                            p[path[i][length] - 1] *= fy;
                            p[1] *= kx;
                            p[2] *= ky;
                            p[5] = +(dirx + diry ? !!+p[5] : !+p[5]);
                        } else if (P0 == "H") {
                            for (var j = 1, jj = p[length]; j < jj; j++) {
                                p[j] *= fx;
                            }
                        } else if (P0 == "V") {
                            for (j = 1, jj = p[length]; j < jj; j++) {
                                p[j] *= fy;
                            }
                         } else {
                            for (j = 1, jj = p[length]; j < jj; j++) {
                                p[j] *= (j % 2) ? fx : fy;
                            }
                        }
                    }
                    var dim2 = pathDimensions(path);
                    dx = ncx - dim2.x - dim2.width / 2;
                    dy = ncy - dim2.y - dim2.height / 2;
                    path[0][1] += dx;
                    path[0][2] += dy;
                    this.attr({path: path});
                break;
            }
            if (this.type in {text: 1, image:1} && (dirx != 1 || diry != 1)) {
                if (this.transformations) {
                    this.transformations[2] = "scale("[concat](dirx, ",", diry, ")");
                    this.node[setAttribute]("transform", this.transformations[join](S));
                    dx = (dirx == -1) ? -a.x - (neww || 0) : a.x;
                    dy = (diry == -1) ? -a.y - (newh || 0) : a.y;
                    this.attr({x: dx, y: dy});
                    a.fx = dirx - 1;
                    a.fy = diry - 1;
                } else {
                    this.node.filterMatrix = ms + ".Matrix(M11="[concat](dirx,
                        ", M12=0, M21=0, M22=", diry,
                        ", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");
                    s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
                }
            } else {
                if (this.transformations) {
                    this.transformations[2] = E;
                    this.node[setAttribute]("transform", this.transformations[join](S));
                    a.fx = 0;
                    a.fy = 0;
                } else {
                    this.node.filterMatrix = E;
                    s.filter = (this.node.filterMatrix || E) + (this.node.filterOpacity || E);
                }
            }
            a.scale = [x, y, cx, cy][join](S);
            this._.sx = x;
            this._.sy = y;
        }
        return this;
    };
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var attr = this.attr();
        delete attr.scale;
        delete attr.translation;
        return this.paper[this.type]().attr(attr);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        var len = 0,
            precision = 100,
            name = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y].join(),
            cache = curveslengths[name],
            old, dot;
        !cache && (curveslengths[name] = cache = {data: []});
        cache.timer && clearTimeout(cache.timer);
        cache.timer = setTimeout(function () {delete curveslengths[name];}, 2000);
        if (length != null) {
            var total = getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
            precision = ~~total * 10;
        }
        for (var i = 0; i < precision + 1; i++) {
            if (cache.data[length] > i) {
                dot = cache.data[i * precision];
            } else {
                dot = R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, i / precision);
                cache.data[i] = dot;
            }
            i && (len += pow(pow(old.x - dot.x, 2) + pow(old.y - dot.y, 2), .5));
            if (length != null && len >= length) {
                return dot;
            }
            old = dot;
        }
        if (length == null) {
            return len;
        }
    },
    getLengthFactory = function (istotal, subpath) {
        return function (path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C", point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = ["M", point.x, point.y + "C", point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]][join]();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {x: point.x, y: point.y, alpha: point.alpha};
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[1], p[2], p[3], p[4], p[5], p[6], 1);
            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    elproto.getTotalLength = function () {
        if (this.type != "path") {return;}
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
        return getTotalLength(this.attrs.path);
    };
    elproto.getPointAtLength = function (length) {
        if (this.type != "path") {return;}
        return getPointAtLength(this.attrs.path, length);
    };
    elproto.getSubpath = function (from, to) {
        if (this.type != "path") {return;}
        if (abs(this.getTotalLength() - to) < "1e-6") {
            return getSubpathsAtLength(this.attrs.path, from).end;
        }
        var a = getSubpathsAtLength(this.attrs.path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };

    // animation easing formulas
    R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 3);
        },
        ">": function (n) {
            return pow(n - 1, 3) + 1;
        },
        "<>": function (n) {
            n = n * 2;
            if (n < 1) {
                return pow(n, 3) / 2;
            }
            n -= 2;
            return (pow(n, 3) + 2) / 2;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == 0 || n == 1) {
                return n;
            }
            var p = .3,
                s = p / 4;
            return pow(2, -10 * n) * math.sin((n - s) * (2 * PI) / p) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };

    var animationElements = [],
        animation = function () {
            var Now = +new Date;
            for (var l = 0; l < animationElements[length]; l++) {
                var e = animationElements[l];
                if (e.stop || e.el.removed) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now;
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case "along":
                                now = pos * ms * diff[attr];
                                to.back && (now = to.len - now);
                                var point = getPointAtLength(to[attr], now);
                                that.translate(diff.sx - diff.x || 0, diff.sy - diff.y || 0);
                                diff.x = point.x;
                                diff.y = point.y;
                                that.translate(point.x - diff.sx, point.y - diff.sy);
                                to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
                                break;
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ][join](",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i][join](S);
                                }
                                now = now[join](S);
                                break;
                            case "csv":
                                switch (attr) {
                                    case "translation":
                                        var x = pos * ms * diff[attr][0] - t.x,
                                            y = pos * ms * diff[attr][1] - t.y;
                                        t.x += x;
                                        t.y += y;
                                        now = x + S + y;
                                    break;
                                    case "rotation":
                                        now = +from[attr][0] + pos * ms * diff[attr][0];
                                        from[attr][1] && (now += "," + from[attr][1] + "," + from[attr][2]);
                                    break;
                                    case "scale":
                                        now = [+from[attr][0] + pos * ms * diff[attr][0], +from[attr][1] + pos * ms * diff[attr][1], (2 in to[attr] ? to[attr][2] : E), (3 in to[attr] ? to[attr][3] : E)][join](S);
                                    break;
                                    case "clip-rect":
                                        now = [];
                                        i = 4;
                                        while (i--) {
                                            now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                        }
                                    break;
                                }
                                break;
                            default:
                              var from2 = [].concat(from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    that._run && that._run.call(that);
                } else {
                    if (to.along) {
                        point = getPointAtLength(to.along, to.len * !to.back);
                        that.translate(diff.sx - (diff.x || 0) + point.x - diff.sx, diff.sy - (diff.y || 0) + point.y - diff.sy);
                        to.rot && that.rotate(diff.r + point.alpha, point.x, point.y);
                    }
                    (t.x || t.y) && that.translate(-t.x, -t.y);
                    to.scale && (to.scale += E);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                }
            }
            R.svg && that && that.paper && that.paper.safari();
            animationElements[length] && setTimeout(animation);
        },
        keyframesRun = function (attr, element, time, prev, prevcallback) {
            var dif = time - prev;
            element.timeouts.push(setTimeout(function () {
                R.is(prevcallback, "function") && prevcallback.call(element);
                element.animate(attr, dif, attr.easing);
            }, prev));
        },
        upto255 = function (color) {
            return mmax(mmin(color, 255), 0);
        },
        translate = function (x, y) {
            if (x == null) {
                return {x: this._.tx, y: this._.ty, toString: x_y};
            }
            this._.tx += +x;
            this._.ty += +y;
            switch (this.type) {
                case "circle":
                case "ellipse":
                    this.attr({cx: +x + this.attrs.cx, cy: +y + this.attrs.cy});
                    break;
                case "rect":
                case "image":
                case "text":
                    this.attr({x: +x + this.attrs.x, y: +y + this.attrs.y});
                    break;
                case "path":
                    var path = pathToRelative(this.attrs.path);
                    path[0][1] += +x;
                    path[0][2] += +y;
                    this.attr({path: path});
                break;
            }
            return this;
        };
    elproto.animateWith = function (element, params, ms, easing, callback) {
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].el.id == element.id) {
                params.start = animationElements[i].start;
            }
        }
        return this.animate(params, ms, easing, callback);
    };
    elproto.animateAlong = along();
    elproto.animateAlongBack = along(1);
    function along(isBack) {
        return function (path, ms, rotate, callback) {
            var params = {back: isBack};
            R.is(rotate, "function") ? (callback = rotate) : (params.rot = rotate);
            path && path.constructor == Element && (path = path.attrs.path);
            path && (params.along = path);
            return this.animate(params, ms, callback);
        };
    }
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        this._run = f || 0;
        return this;
    };
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        element.timeouts = element.timeouts || [];
        if (R.is(easing, "function") || !easing) {
            callback = easing || null;
        }
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var from = {},
            to = {},
            animateable = false,
            diff = {};
        for (var attr in params) if (params[has](attr)) {
            if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                animateable = true;
                from[attr] = element.attr(attr);
                (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                to[attr] = params[attr];
                switch (availableAnimAttrs[attr]) {
                    case "along":
                        var len = getTotalLength(params[attr]);
                        var point = getPointAtLength(params[attr], len * !!params.back);
                        var bb = element.getBBox();
                        diff[attr] = len / ms;
                        diff.tx = bb.x;
                        diff.ty = bb.y;
                        diff.sx = point.x;
                        diff.sy = point.y;
                        to.rot = params.rot;
                        to.back = params.back;
                        to.len = len;
                        params.rot && (diff.r = toFloat(element.rotate()) || 0);
                        break;
                    case nu:
                        diff[attr] = (to[attr] - from[attr]) / ms;
                        break;
                    case "colour":
                        from[attr] = R.getRGB(from[attr]);
                        var toColour = R.getRGB(to[attr]);
                        diff[attr] = {
                            r: (toColour.r - from[attr].r) / ms,
                            g: (toColour.g - from[attr].g) / ms,
                            b: (toColour.b - from[attr].b) / ms
                        };
                        break;
                    case "path":
                        var pathes = path2curve(from[attr], to[attr]);
                        from[attr] = pathes[0];
                        var toPath = pathes[1];
                        diff[attr] = [];
                        for (var i = 0, ii = from[attr][length]; i < ii; i++) {
                            diff[attr][i] = [0];
                            for (var j = 1, jj = from[attr][i][length]; j < jj; j++) {
                                diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                            }
                        }
                        break;
                    case "csv":
                        var values = Str(params[attr])[split](separator),
                            from2 = Str(from[attr])[split](separator);
                        switch (attr) {
                            case "translation":
                                from[attr] = [0, 0];
                                diff[attr] = [values[0] / ms, values[1] / ms];
                            break;
                            case "rotation":
                                from[attr] = (from2[1] == values[1] && from2[2] == values[2]) ? from2 : [0, values[1], values[2]];
                                diff[attr] = [(values[0] - from[attr][0]) / ms, 0, 0];
                            break;
                            case "scale":
                                params[attr] = values;
                                from[attr] = Str(from[attr])[split](separator);
                                diff[attr] = [(values[0] - from[attr][0]) / ms, (values[1] - from[attr][1]) / ms, 0, 0];
                            break;
                            case "clip-rect":
                                from[attr] = Str(from[attr])[split](separator);
                                diff[attr] = [];
                                i = 4;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            break;
                        }
                        to[attr] = values;
                        break;
                    default:
                        values = [].concat(params[attr]);
                        from2 = [].concat(from[attr]);
                        diff[attr] = [];
                        i = element.paper.customAttributes[attr][length];
                        while (i--) {
                            diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                        }
                        break;
                }
            }
        }
        if (!animateable) {
            var attrs = [],
                lastcall;
            for (var key in params) if (params[has](key) && animKeyFrames.test(key)) {
                attr = {value: params[key]};
                key == "from" && (key = 0);
                key == "to" && (key = 100);
                attr.key = toInt(key, 10);
                attrs.push(attr);
            }
            attrs.sort(sortByKey);
            if (attrs[0].key) {
                attrs.unshift({key: 0, value: element.attrs});
            }
            for (i = 0, ii = attrs[length]; i < ii; i++) {
                keyframesRun(attrs[i].value, element, ms / 100 * attrs[i].key, ms / 100 * (attrs[i - 1] && attrs[i - 1].key || 0), attrs[i - 1] && attrs[i - 1].value.callback);
            }
            lastcall = attrs[attrs[length] - 1].value.callback;
            if (lastcall) {
                element.timeouts.push(setTimeout(function () {lastcall.call(element);}, ms));
            }
        } else {
            var easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy[length] == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = function (t) {
                        return t;
                    };
                }
            }
            animationElements.push({
                start: params.start || +new Date,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                t: {x: 0, y: 0}
            });
            R.is(callback, "function") && (element._ac = setTimeout(function () {
                callback.call(element);
            }, ms));
            animationElements[length] == 1 && setTimeout(animation);
        }
        return this;
    };
    elproto.stop = function () {
        for (var i = 0; i < animationElements.length; i++) {
            animationElements[i].el.id == this.id && animationElements.splice(i--, 1);
        }
        for (i = 0, ii = this.timeouts && this.timeouts.length; i < ii; i++) {
            clearTimeout(this.timeouts[i]);
        }
        this.timeouts = [];
        clearTimeout(this._ac);
        delete this._ac;
        return this;
    };
    elproto.translate = function (x, y) {
        return this.attr({translation: x + " " + y});
    };
    elproto[toString] = function () {
        return "Rapha\xebl\u2019s object";
    };
    R.ae = animationElements;

    // Set
    var Set = function (items) {
        this.items = [];
        this[length] = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items[length]; i < ii; i++) {
                if (items[i] && (items[i].constructor == Element || items[i].constructor == Set)) {
                    this[this.items[length]] = this.items[this.items[length]] = items[i];
                    this[length]++;
                }
            }
        }
    };
    Set[proto][push] = function () {
        var item,
            len;
        for (var i = 0, ii = arguments[length]; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == Element || item.constructor == Set)) {
                len = this.items[length];
                this[len] = this.items[len] = item;
                this[length]++;
            }
        }
        return this;
    };
    Set[proto].pop = function () {
        delete this[this[length]--];
        return this.items.pop();
    };
    for (var method in elproto) if (elproto[has](method)) {
        Set[proto][method] = (function (methodname) {
            return function () {
                for (var i = 0, ii = this.items[length]; i < ii; i++) {
                    this.items[i][methodname][apply](this.items[i], arguments);
                }
                return this;
            };
        })(method);
    }
    Set[proto].attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name[length]; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items[length]; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    Set[proto].animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items[length],
            i = len,
            item,
            set = this,
            collector;
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        item = this.items[--i].animate(params, ms, easing, collector);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, params, ms, easing, collector);
        }
        return this;
    };
    Set[proto].insertAfter = function (el) {
        var i = this.items[length];
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    Set[proto].getBBox = function () {
        var x = [],
            y = [],
            w = [],
            h = [];
        for (var i = this.items[length]; i--;) {
            var box = this.items[i].getBBox();
            x[push](box.x);
            y[push](box.y);
            w[push](box.x + box.width);
            h[push](box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        return {
            x: x,
            y: y,
            width: mmax[apply](0, w) - x,
            height: mmax[apply](0, h) - y
        };
    };
    Set[proto].clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items[length]; i < ii; i++) {
            s[push](this.items[i].clone());
        }
        return s;
    };

    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family][push](fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d[rp](/[mlcxtrv]/g, function (command) {
                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                        }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family[rp](/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font[length]; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        var out = this.set(),
            letters = Str(string)[split](E),
            shift = 0,
            path = E,
            scale;
        R.is(font, string) && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox.split(separator),
                top = +bb[0],
                height = +bb[1] + (origin == "baseline" ? bb[3] - bb[1] + (+font.face.descent) : (bb[3] - bb[1]) / 2);
            for (var i = 0, ii = letters[length]; i < ii; i++) {
                var prev = i && font.glyphs[letters[i - 1]] || {},
                    curr = font.glyphs[letters[i]];
                shift += i ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                curr && curr.d && out[push](this.path(curr.d).attr({fill: "#000", stroke: "none", translation: [shift, 0]}));
            }
            out.scale(scale, scale, top, height).translate(x - top, y - height);
        }
        return out;
    };

    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args[length] - 1 && (token = token[rp](formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    R.ninja = function () {
        oldRaphael.was ? (win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    R.el = elproto;
    R.st = Set[proto];

    oldRaphael.was ? (win.Raphael = R) : (Raphael = R);
})();

/*!
 * g.Raphael 0.4.1 - Charting library, based on Raphaël
 *
 * Copyright (c) 2009 Dmitry Baranovskiy (http://g.raphaeljs.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */
 
 
(function () {
    var mmax = Math.max,
        mmin = Math.min;
    Raphael.fn.g = Raphael.fn.g || {};
    Raphael.fn.g.markers = {
        disc: "disc",
        o: "disc",
        flower: "flower",
        f: "flower",
        diamond: "diamond",
        d: "diamond",
        square: "square",
        s: "square",
        triangle: "triangle",
        t: "triangle",
        star: "star",
        "*": "star",
        cross: "cross",
        x: "cross",
        plus: "plus",
        "+": "plus",
        arrow: "arrow",
        "->": "arrow"
    };
    Raphael.fn.g.shim = {stroke: "none", fill: "#000", "fill-opacity": 0};
    Raphael.fn.g.txtattr = {font: "12px Arial, sans-serif"};
    Raphael.fn.g.colors = [];
    var hues = [.6, .2, .05, .1333, .75, 0];
    for (var i = 0; i < 10; i++) {
        if (i < hues.length) {
            Raphael.fn.g.colors.push("hsb(" + hues[i] + ", .75, .75)");
        } else {
            Raphael.fn.g.colors.push("hsb(" + hues[i - hues.length] + ", 1, .5)");
        }
    }
    Raphael.fn.g.text = function (x, y, text) {
        return this.text(x, y, text).attr(this.g.txtattr);
    };
    Raphael.fn.g.labelise = function (label, val, total) {
        if (label) {
            return (label + "").replace(/(##+(?:\.#+)?)|(%%+(?:\.%+)?)/g, function (all, value, percent) {
                if (value) {
                    return (+val).toFixed(value.replace(/^#+\.?/g, "").length);
                }
                if (percent) {
                    return (val * 100 / total).toFixed(percent.replace(/^%+\.?/g, "").length) + "%";
                }
            });
        } else {
            return (+val).toFixed(0);
        }
    };

    Raphael.fn.g.finger = function (x, y, width, height, dir, ending, isPath) {
        // dir 0 for horisontal and 1 for vertical
        if ((dir && !height) || (!dir && !width)) {
            return isPath ? "" : this.path();
        }
        ending = {square: "square", sharp: "sharp", soft: "soft"}[ending] || "round";
        var path;
        height = Math.round(height);
        width = Math.round(width);
        x = Math.round(x);
        y = Math.round(y);
        switch (ending) {
            case "round":
            if (!dir) {
                var r = ~~(height / 2);
                if (width < r) {
                    r = width;
                    path = ["M", x + .5, y + .5 - ~~(height / 2), "l", 0, 0, "a", r, ~~(height / 2), 0, 0, 1, 0, height, "l", 0, 0, "z"];
                } else {
                    path = ["M", x + .5, y + .5 - r, "l", width - r, 0, "a", r, r, 0, 1, 1, 0, height, "l", r - width, 0, "z"];
                }
            } else {
                r = ~~(width / 2);
                if (height < r) {
                    r = height;
                    path = ["M", x - ~~(width / 2), y, "l", 0, 0, "a", ~~(width / 2), r, 0, 0, 1, width, 0, "l", 0, 0, "z"];
                } else {
                    path = ["M", x - r, y, "l", 0, r - height, "a", r, r, 0, 1, 1, width, 0, "l", 0, height - r, "z"];
                }
            }
            break;
            case "sharp":
            if (!dir) {
                var half = ~~(height / 2);
                path = ["M", x, y + half, "l", 0, -height, mmax(width - half, 0), 0, mmin(half, width), half, -mmin(half, width), half + (half * 2 < height), "z"];
            } else {
                half = ~~(width / 2);
                path = ["M", x + half, y, "l", -width, 0, 0, -mmax(height - half, 0), half, -mmin(half, height), half, mmin(half, height), half, "z"];
            }
            break;
            case "square":
            if (!dir) {
                path = ["M", x, y + ~~(height / 2), "l", 0, -height, width, 0, 0, height, "z"];
            } else {
                path = ["M", x + ~~(width / 2), y, "l", 1 - width, 0, 0, -height, width - 1, 0, "z"];
            }
            break;
            case "soft":
            if (!dir) {
                r = mmin(width, Math.round(height / 5));
                path = ["M", x + .5, y + .5 - ~~(height / 2), "l", width - r, 0, "a", r, r, 0, 0, 1, r, r, "l", 0, height - r * 2, "a", r, r, 0, 0, 1, -r, r, "l", r - width, 0, "z"];
            } else {
                r = mmin(Math.round(width / 5), height);
                path = ["M", x - ~~(width / 2), y, "l", 0, r - height, "a", r, r, 0, 0, 1, r, -r, "l", width - 2 * r, 0, "a", r, r, 0, 0, 1, r, r, "l", 0, height - r, "z"];
            }
        }
        if (isPath) {
            return path.join(",");
        } else {
            return this.path(path);
        }
    };

    // Symbols
    Raphael.fn.g.disc = function (cx, cy, r) {
        return this.circle(cx, cy, r);
    };
    Raphael.fn.g.line = function (cx, cy, r) {
        return this.rect(cx - r, cy - r / 5, 2 * r, 2 * r / 5);
    };
    Raphael.fn.g.square = function (cx, cy, r) {
        r = r * .7;
        return this.rect(cx - r, cy - r, 2 * r, 2 * r);
    };
    Raphael.fn.g.triangle = function (cx, cy, r) {
        r *= 1.75;
        return this.path("M".concat(cx, ",", cy, "m0-", r * .58, "l", r * .5, ",", r * .87, "-", r, ",0z"));
    };
    Raphael.fn.g.diamond = function (cx, cy, r) {
        return this.path(["M", cx, cy - r, "l", r, r, -r, r, -r, -r, r, -r, "z"]);
    };
    Raphael.fn.g.flower = function (cx, cy, r, n) {
        r = r * 1.25;
        var rout = r,
            rin = rout * .5;
        n = +n < 3 || !n ? 5 : n;
        var points = ["M", cx, cy + rin, "Q"],
            R;
        for (var i = 1; i < n * 2 + 1; i++) {
            R = i % 2 ? rout : rin;
            points = points.concat([+(cx + R * Math.sin(i * Math.PI / n)).toFixed(3), +(cy + R * Math.cos(i * Math.PI / n)).toFixed(3)]);
        }
        points.push("z");
        return this.path(points.join(","));
    };
    Raphael.fn.g.star = function (cx, cy, r, r2, rays) {
        r2 = r2 || r * .382;
        rays = rays || 5;
        var points = ["M", cx, cy + r2, "L"],
            R;
        for (var i = 1; i < rays * 2; i++) {
            R = i % 2 ? r : r2;
            points = points.concat([(cx + R * Math.sin(i * Math.PI / rays)), (cy + R * Math.cos(i * Math.PI / rays))]);
        }
        points.push("z");
        return this.path(points.join(","));
    };
    Raphael.fn.g.cross = function (cx, cy, r) {
        r = r / 2.5;
        return this.path("M".concat(cx - r, ",", cy, "l", [-r, -r, r, -r, r, r, r, -r, r, r, -r, r, r, r, -r, r, -r, -r, -r, r, -r, -r, "z"]));
    };
    Raphael.fn.g.plus = function (cx, cy, r) {
        r = r / 2;
        return this.path("M".concat(cx - r / 2, ",", cy - r / 2, "l", [0, -r, r, 0, 0, r, r, 0, 0, r, -r, 0, 0, r, -r, 0, 0, -r, -r, 0, 0, -r, "z"]));
    };
    Raphael.fn.g.arrow = function (cx, cy, r) {
        return this.path("M".concat(cx - r * .7, ",", cy - r * .4, "l", [r * .6, 0, 0, -r * .4, r, r * .8, -r, r * .8, 0, -r * .4, -r * .6, 0], "z"));
    };

    // Tooltips
    Raphael.fn.g.tag = function (x, y, text, angle, r) {
        angle = angle || 0;
        r = r == null ? 5 : r;
        text = text == null ? "$9.99" : text;
        var R = .5522 * r,
            res = this.set(),
            d = 3;
        res.push(this.path().attr({fill: "#000", stroke: "#000"}));
        res.push(this.text(x, y, text).attr(this.g.txtattr).attr({fill: "#fff", "font-family": "Helvetica, Arial"}));
        res.update = function () {
            this.rotate(0, x, y);
            var bb = this[1].getBBox();
            if (bb.height >= r * 2) {
                this[0].attr({path: ["M", x, y + r, "a", r, r, 0, 1, 1, 0, -r * 2, r, r, 0, 1, 1, 0, r * 2, "m", 0, -r * 2 -d, "a", r + d, r + d, 0, 1, 0, 0, (r + d) * 2, "L", x + r + d, y + bb.height / 2 + d, "l", bb.width + 2 * d, 0, 0, -bb.height - 2 * d, -bb.width - 2 * d, 0, "L", x, y - r - d].join(",")});
            } else {
                var dx = Math.sqrt(Math.pow(r + d, 2) - Math.pow(bb.height / 2 + d, 2));
                this[0].attr({path: ["M", x, y + r, "c", -R, 0, -r, R - r, -r, -r, 0, -R, r - R, -r, r, -r, R, 0, r, r - R, r, r, 0, R, R - r, r, -r, r, "M", x + dx, y - bb.height / 2 - d, "a", r + d, r + d, 0, 1, 0, 0, bb.height + 2 * d, "l", r + d - dx + bb.width + 2 * d, 0, 0, -bb.height - 2 * d, "L", x + dx, y - bb.height / 2 - d].join(",")});
            }
            this[1].attr({x: x + r + d + bb.width / 2, y: y});
            angle = (360 - angle) % 360;
            this.rotate(angle, x, y);
            angle > 90 && angle < 270 && this[1].attr({x: x - r - d - bb.width / 2, y: y, rotation: [180 + angle, x, y]});
            return this;
        };
        res.update();
        return res;
    };
    Raphael.fn.g.popupit = function (x, y, set, dir, size) {
        dir = dir == null ? 2 : dir;
        size = size || 5;
        x = Math.round(x);
        y = Math.round(y);
        var bb = set.getBBox(),
            w = Math.round(bb.width / 2),
            h = Math.round(bb.height / 2),
            dx = [0, w + size * 2, 0, -w - size * 2],
            dy = [-h * 2 - size * 3, -h - size, 0, -h - size],
            p = ["M", x - dx[dir], y - dy[dir], "l", -size, (dir == 2) * -size, -mmax(w - size, 0), 0, "a", size, size, 0, 0, 1, -size, -size,
                "l", 0, -mmax(h - size, 0), (dir == 3) * -size, -size, (dir == 3) * size, -size, 0, -mmax(h - size, 0), "a", size, size, 0, 0, 1, size, -size,
                "l", mmax(w - size, 0), 0, size, !dir * -size, size, !dir * size, mmax(w - size, 0), 0, "a", size, size, 0, 0, 1, size, size,
                "l", 0, mmax(h - size, 0), (dir == 1) * size, size, (dir == 1) * -size, size, 0, mmax(h - size, 0), "a", size, size, 0, 0, 1, -size, size,
                "l", -mmax(w - size, 0), 0, "z"].join(","),
            xy = [{x: x, y: y + size * 2 + h}, {x: x - size * 2 - w, y: y}, {x: x, y: y - size * 2 - h}, {x: x + size * 2 + w, y: y}][dir];
        set.translate(xy.x - w - bb.x, xy.y - h - bb.y);
        return this.path(p).attr({fill: "#000", stroke: "none"}).insertBefore(set.node ? set : set[0]);
    };
    Raphael.fn.g.popup = function (x, y, text, dir, size) {
        dir = dir == null ? 2 : dir > 3 ? 3 : dir;
        size = size || 5;
        text = text || "$9.99";
        var res = this.set(),
            d = 3;
        res.push(this.path().attr({fill: "#000", stroke: "#000"}));
        res.push(this.text(x, y, text).attr(this.g.txtattr).attr({fill: "#fff", "font-family": "Helvetica, Arial"}));
        res.update = function (X, Y, withAnimation) {
            X = X || x;
            Y = Y || y;
            var bb = this[1].getBBox(),
                w = bb.width / 2,
                h = bb.height / 2,
                dx = [0, w + size * 2, 0, -w - size * 2],
                dy = [-h * 2 - size * 3, -h - size, 0, -h - size],
                p = ["M", X - dx[dir], Y - dy[dir], "l", -size, (dir == 2) * -size, -mmax(w - size, 0), 0, "a", size, size, 0, 0, 1, -size, -size,
                    "l", 0, -mmax(h - size, 0), (dir == 3) * -size, -size, (dir == 3) * size, -size, 0, -mmax(h - size, 0), "a", size, size, 0, 0, 1, size, -size,
                    "l", mmax(w - size, 0), 0, size, !dir * -size, size, !dir * size, mmax(w - size, 0), 0, "a", size, size, 0, 0, 1, size, size,
                    "l", 0, mmax(h - size, 0), (dir == 1) * size, size, (dir == 1) * -size, size, 0, mmax(h - size, 0), "a", size, size, 0, 0, 1, -size, size,
                    "l", -mmax(w - size, 0), 0, "z"].join(","),
                xy = [{x: X, y: Y + size * 2 + h}, {x: X - size * 2 - w, y: Y}, {x: X, y: Y - size * 2 - h}, {x: X + size * 2 + w, y: Y}][dir];
            xy.path = p;
            if (withAnimation) {
                this.animate(xy, 500, ">");
            } else {
                this.attr(xy);
            }
            return this;
        };
        return res.update(x, y);
    };
    Raphael.fn.g.flag = function (x, y, text, angle) {
        angle = angle || 0;
        text = text || "$9.99";
        var res = this.set(),
            d = 3;
        res.push(this.path().attr({fill: "#000", stroke: "#000"}));
        res.push(this.text(x, y, text).attr(this.g.txtattr).attr({fill: "#fff", "font-family": "Helvetica, Arial"}));
        res.update = function (x, y) {
            this.rotate(0, x, y);
            var bb = this[1].getBBox(),
                h = bb.height / 2;
            this[0].attr({path: ["M", x, y, "l", h + d, -h - d, bb.width + 2 * d, 0, 0, bb.height + 2 * d, -bb.width - 2 * d, 0, "z"].join(",")});
            this[1].attr({x: x + h + d + bb.width / 2, y: y});
            angle = 360 - angle;
            this.rotate(angle, x, y);
            angle > 90 && angle < 270 && this[1].attr({x: x - r - d - bb.width / 2, y: y, rotation: [180 + angle, x, y]});
            return this;
        };
        return res.update(x, y);
    };
    Raphael.fn.g.label = function (x, y, text) {
        var res = this.set();
        res.push(this.rect(x, y, 10, 10).attr({stroke: "none", fill: "#000"}));
        res.push(this.text(x, y, text).attr(this.g.txtattr).attr({fill: "#fff"}));
        res.update = function () {
            var bb = this[1].getBBox(),
                r = mmin(bb.width + 10, bb.height + 10) / 2;
            this[0].attr({x: bb.x - r / 2, y: bb.y - r / 2, width: bb.width + r, height: bb.height + r, r: r});
        };
        res.update();
        return res;
    };
    Raphael.fn.g.labelit = function (set) {
        var bb = set.getBBox(),
            r = mmin(20, bb.width + 10, bb.height + 10) / 2;
        return this.rect(bb.x - r / 2, bb.y - r / 2, bb.width + r, bb.height + r, r).attr({stroke: "none", fill: "#000"}).insertBefore(set.node ? set : set[0]);
    };
    Raphael.fn.g.drop = function (x, y, text, size, angle) {
        size = size || 30;
        angle = angle || 0;
        var res = this.set();
        res.push(this.path(["M", x, y, "l", size, 0, "A", size * .4, size * .4, 0, 1, 0, x + size * .7, y - size * .7, "z"]).attr({fill: "#000", stroke: "none", rotation: [22.5 - angle, x, y]}));
        angle = (angle + 90) * Math.PI / 180;
        res.push(this.text(x + size * Math.sin(angle), y + size * Math.cos(angle), text).attr(this.g.txtattr).attr({"font-size": size * 12 / 30, fill: "#fff"}));
        res.drop = res[0];
        res.text = res[1];
        return res;
    };
    Raphael.fn.g.blob = function (x, y, text, angle, size) {
        angle = (+angle + 1 ? angle : 45) + 90;
        size = size || 12;
        var rad = Math.PI / 180,
            fontSize = size * 12 / 12;
        var res = this.set();
        res.push(this.path().attr({fill: "#000", stroke: "none"}));
        res.push(this.text(x + size * Math.sin((angle) * rad), y + size * Math.cos((angle) * rad) - fontSize / 2, text).attr(this.g.txtattr).attr({"font-size": fontSize, fill: "#fff"}));
        res.update = function (X, Y, withAnimation) {
            X = X || x;
            Y = Y || y;
            var bb = this[1].getBBox(),
                w = mmax(bb.width + fontSize, size * 25 / 12),
                h = mmax(bb.height + fontSize, size * 25 / 12),
                x2 = X + size * Math.sin((angle - 22.5) * rad),
                y2 = Y + size * Math.cos((angle - 22.5) * rad),
                x1 = X + size * Math.sin((angle + 22.5) * rad),
                y1 = Y + size * Math.cos((angle + 22.5) * rad),
                dx = (x1 - x2) / 2,
                dy = (y1 - y2) / 2,
                rx = w / 2,
                ry = h / 2,
                k = -Math.sqrt(Math.abs(rx * rx * ry * ry - rx * rx * dy * dy - ry * ry * dx * dx) / (rx * rx * dy * dy + ry * ry * dx * dx)),
                cx = k * rx * dy / ry + (x1 + x2) / 2,
                cy = k * -ry * dx / rx + (y1 + y2) / 2;
            if (withAnimation) {
                this.animate({x: cx, y: cy, path: ["M", x, y, "L", x1, y1, "A", rx, ry, 0, 1, 1, x2, y2, "z"].join(",")}, 500, ">");
            } else {
                this.attr({x: cx, y: cy, path: ["M", x, y, "L", x1, y1, "A", rx, ry, 0, 1, 1, x2, y2, "z"].join(",")});
            }
            return this;
        };
        res.update(x, y);
        return res;
    };

    Raphael.fn.g.colorValue = function (value, total, s, b) {
        return "hsb(" + [mmin((1 - value / total) * .4, 1), s || .75, b || .75] + ")";
    };

    Raphael.fn.g.snapEnds = function (from, to, steps) {
        var f = from,
            t = to;
        if (f == t) {
            return {from: f, to: t, power: 0};
        }
        function round(a) {
            return Math.abs(a - .5) < .25 ? ~~(a) + .5 : Math.round(a);
        }
        var d = (t - f) / steps,
            r = ~~(d),
            R = r,
            i = 0;
        if (r) {
            while (R) {
                i--;
                R = ~~(d * Math.pow(10, i)) / Math.pow(10, i);
            }
            i ++;
        } else {
            while (!r) {
                i = i || 1;
                r = ~~(d * Math.pow(10, i)) / Math.pow(10, i);
                i++;
            }
            i && i--;
        }
        t = round(to * Math.pow(10, i)) / Math.pow(10, i);
        if (t < to) {
            t = round((to + .5) * Math.pow(10, i)) / Math.pow(10, i);
        }
        f = round((from - (i > 0 ? 0 : .5)) * Math.pow(10, i)) / Math.pow(10, i);
        return {from: f, to: t, power: i};
    };
    Raphael.fn.g.axis = function (x, y, length, from, to, steps, orientation, labels, type, dashsize) {
        dashsize = dashsize == null ? 2 : dashsize;
        type = type || "t";
        steps = steps || 10;
        var path = type == "|" || type == " " ? ["M", x + .5, y, "l", 0, .001] : orientation == 1 || orientation == 3 ? ["M", x + .5, y, "l", 0, -length] : ["M", x, y + .5, "l", length, 0],
            ends = this.g.snapEnds(from, to, steps),
            f = ends.from,
            t = ends.to,
            i = ends.power,
            j = 0,
            text = this.set();
        d = (t - f) / steps;
        var label = f,
            rnd = i > 0 ? i : 0;
            dx = length / steps;
        if (+orientation == 1 || +orientation == 3) {
            var Y = y,
                addon = (orientation - 1 ? 1 : -1) * (dashsize + 3 + !!(orientation - 1));
            while (Y >= y - length) {
                type != "-" && type != " " && (path = path.concat(["M", x - (type == "+" || type == "|" ? dashsize : !(orientation - 1) * dashsize * 2), Y + .5, "l", dashsize * 2 + 1, 0]));
                text.push(this.text(x + addon, Y, (labels && labels[j++]) || (Math.round(label) == label ? label : +label.toFixed(rnd))).attr(this.g.txtattr).attr({"text-anchor": orientation - 1 ? "start" : "end"}));
                label += d;
                Y -= dx;
            }
            if (Math.round(Y + dx - (y - length))) {
                type != "-" && type != " " && (path = path.concat(["M", x - (type == "+" || type == "|" ? dashsize : !(orientation - 1) * dashsize * 2), y - length + .5, "l", dashsize * 2 + 1, 0]));
                text.push(this.text(x + addon, y - length, (labels && labels[j]) || (Math.round(label) == label ? label : +label.toFixed(rnd))).attr(this.g.txtattr).attr({"text-anchor": orientation - 1 ? "start" : "end"}));
            }
        } else {
            label = f;
            rnd = (i > 0) * i;
            addon = (orientation ? -1 : 1) * (dashsize + 9 + !orientation);
            var X = x,
                dx = length / steps,
                txt = 0,
                prev = 0;
            while (X <= x + length) {
                type != "-" && type != " " && (path = path.concat(["M", X + .5, y - (type == "+" ? dashsize : !!orientation * dashsize * 2), "l", 0, dashsize * 2 + 1]));
                text.push(txt = this.text(X, y + addon, (labels && labels[j++]) || (Math.round(label) == label ? label : +label.toFixed(rnd))).attr(this.g.txtattr));
                var bb = txt.getBBox();
                if (prev >= bb.x - 5) {
                    text.pop(text.length - 1).remove();
                } else {
                    prev = bb.x + bb.width;
                }
                label += d;
                X += dx;
            }
            if (Math.round(X - dx - x - length)) {
                type != "-" && type != " " && (path = path.concat(["M", x + length + .5, y - (type == "+" ? dashsize : !!orientation * dashsize * 2), "l", 0, dashsize * 2 + 1]));
                text.push(this.text(x + length, y + addon, (labels && labels[j]) || (Math.round(label) == label ? label : +label.toFixed(rnd))).attr(this.g.txtattr));
            }
        }
        var res = this.path(path);
        res.text = text;
        res.all = this.set([res, text]);
        res.remove = function () {
            this.text.remove();
            this.constructor.prototype.remove.call(this);
        };
        return res;
    };

    Raphael.el.lighter = function (times) {
        times = times || 2;
        var fs = [this.attrs.fill, this.attrs.stroke];
        this.fs = this.fs || [fs[0], fs[1]];
        fs[0] = Raphael.rgb2hsb(Raphael.getRGB(fs[0]).hex);
        fs[1] = Raphael.rgb2hsb(Raphael.getRGB(fs[1]).hex);
        fs[0].b = mmin(fs[0].b * times, 1);
        fs[0].s = fs[0].s / times;
        fs[1].b = mmin(fs[1].b * times, 1);
        fs[1].s = fs[1].s / times;
        this.attr({fill: "hsb(" + [fs[0].h, fs[0].s, fs[0].b] + ")", stroke: "hsb(" + [fs[1].h, fs[1].s, fs[1].b] + ")"});
    };
    Raphael.el.darker = function (times) {
        times = times || 2;
        var fs = [this.attrs.fill, this.attrs.stroke];
        this.fs = this.fs || [fs[0], fs[1]];
        fs[0] = Raphael.rgb2hsb(Raphael.getRGB(fs[0]).hex);
        fs[1] = Raphael.rgb2hsb(Raphael.getRGB(fs[1]).hex);
        fs[0].s = mmin(fs[0].s * times, 1);
        fs[0].b = fs[0].b / times;
        fs[1].s = mmin(fs[1].s * times, 1);
        fs[1].b = fs[1].b / times;
        this.attr({fill: "hsb(" + [fs[0].h, fs[0].s, fs[0].b] + ")", stroke: "hsb(" + [fs[1].h, fs[1].s, fs[1].b] + ")"});
    };
    Raphael.el.original = function () {
        if (this.fs) {
            this.attr({fill: this.fs[0], stroke: this.fs[1]});
            delete this.fs;
        }
    };
})();
/*!
 * g.Raphael 0.4.1 - Charting library, based on Raphaël
 *
 * Copyright (c) 2009 Dmitry Baranovskiy (http://g.raphaeljs.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */
Raphael.fn.g.barchart = function (x, y, width, height, values, opts) {
    opts = opts || {};
    var type = {round: "round", sharp: "sharp", soft: "soft"}[opts.type] || "square",
        gutter = parseFloat(opts.gutter || "20%"),
        chart = this.set(),
        bars = this.set(),
        covers = this.set(),
        covers2 = this.set(),
        total = Math.max.apply(Math, values),
        stacktotal = [],
        paper = this,
        multi = 0,
        colors = opts.colors || this.g.colors,
        len = values.length;
    if (this.raphael.is(values[0], "array")) {
        total = [];
        multi = len;
        len = 0;
        for (var i = values.length; i--;) {
            bars.push(this.set());
            total.push(Math.max.apply(Math, values[i]));
            len = Math.max(len, values[i].length);
        }
        if (opts.stacked) {
            for (var i = len; i--;) {
                var tot = 0;
                for (var j = values.length; j--;) {
                    tot +=+ values[j][i] || 0;
                }
                stacktotal.push(tot);
            }
        }
        for (var i = values.length; i--;) {
            if (values[i].length < len) {
                for (var j = len; j--;) {
                    values[i].push(0);
                }
            }
        }
        total = Math.max.apply(Math, opts.stacked ? stacktotal : total);
    }
    
    total = (opts.to) || total;
    var barwidth = width / (len * (100 + gutter) + gutter) * 100,
        barhgutter = barwidth * gutter / 100,
        barvgutter = opts.vgutter == null ? 20 : opts.vgutter,
        stack = [],
        X = x + barhgutter,
        Y = (height - 2 * barvgutter) / total;
    if (!opts.stretch) {
        barhgutter = Math.round(barhgutter);
        barwidth = Math.floor(barwidth);
    }
    !opts.stacked && (barwidth /= multi || 1);
    for (var i = 0; i < len; i++) {
        stack = [];
        for (var j = 0; j < (multi || 1); j++) {
            var h = Math.round((multi ? values[j][i] : values[i]) * Y),
                top = y + height - barvgutter - h,
                bar = this.g.finger(Math.round(X + barwidth / 2), top + h, barwidth, h, true, type).attr({stroke: "none", fill: colors[multi ? j : i]});
            if (multi) {
                bars[j].push(bar);
            } else {
                bars.push(bar);
            }
            bar.y = top;
            bar.x = Math.round(X + barwidth / 2);
            bar.w = barwidth;
            bar.h = h;
            bar.value = multi ? values[j][i] : values[i];
            if (!opts.stacked) {
                X += barwidth;
            } else {
                stack.push(bar);
            }
        }
        if (opts.stacked) {
            var cvr;
            covers2.push(cvr = this.rect(stack[0].x - stack[0].w / 2, y, barwidth, height).attr(this.g.shim));
            cvr.bars = this.set();
            var size = 0;
            for (var s = stack.length; s--;) {
                stack[s].toFront();
            }
            for (var s = 0, ss = stack.length; s < ss; s++) {
                var bar = stack[s],
                    cover,
                    h = (size + bar.value) * Y,
                    path = this.g.finger(bar.x, y + height - barvgutter - !!size * .5, barwidth, h, true, type, 1);
                cvr.bars.push(bar);
                size && bar.attr({path: path});
                bar.h = h;
                bar.y = y + height - barvgutter - !!size * .5 - h;
                covers.push(cover = this.rect(bar.x - bar.w / 2, bar.y, barwidth, bar.value * Y).attr(this.g.shim));
                cover.bar = bar;
                cover.value = bar.value;
                size += bar.value;
            }
            X += barwidth;
        }
        X += barhgutter;
    }
    covers2.toFront();
    X = x + barhgutter;
    if (!opts.stacked) {
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < (multi || 1); j++) {
                var cover;
                covers.push(cover = this.rect(Math.round(X), y + barvgutter, barwidth, height - barvgutter).attr(this.g.shim));
                cover.bar = multi ? bars[j][i] : bars[i];
                cover.value = cover.bar.value;
                X += barwidth;
            }
            X += barhgutter;
        }
    }
    chart.label = function (labels, isBottom) {
        labels = labels || [];
        this.labels = paper.set();
        var L, l = -Infinity;
        if (opts.stacked) {
            for (var i = 0; i < len; i++) {
                var tot = 0;
                for (var j = 0; j < (multi || 1); j++) {
                    tot += multi ? values[j][i] : values[i];
                    if (j == multi - 1) {
                        var label = paper.g.labelise(labels[i], tot, total);
                        L = paper.g.text(bars[i * (multi || 1) + j].x, y + height - barvgutter / 2, label).insertBefore(covers[i * (multi || 1) + j]);
                        var bb = L.getBBox();
                        if (bb.x - 7 < l) {
                            L.remove();
                        } else {
                            this.labels.push(L);
                            l = bb.x + bb.width;
                        }
                    }
                }
            }
        } else {
            for (var i = 0; i < len; i++) {
                for (var j = 0; j < (multi || 1); j++) {
                    var label = paper.g.labelise(multi ? labels[j] && labels[j][i] : labels[i], multi ? values[j][i] : values[i], total);
                    L = paper.g.text(bars[i * (multi || 1) + j].x, isBottom ? y + height - barvgutter / 2 : bars[i * (multi || 1) + j].y - 10, label).insertBefore(covers[i * (multi || 1) + j]);
                    var bb = L.getBBox();
                    if (bb.x - 7 < l) {
                        L.remove();
                    } else {
                        this.labels.push(L);
                        l = bb.x + bb.width;
                    }
                }
            }
        }
        return this;
    };
    chart.hover = function (fin, fout) {
        covers2.hide();
        covers.show();
        covers.mouseover(fin).mouseout(fout);
        return this;
    };
    chart.hoverColumn = function (fin, fout) {
        covers.hide();
        covers2.show();
        fout = fout || function () {};
        covers2.mouseover(fin).mouseout(fout);
        return this;
    };
    chart.click = function (f) {
        covers2.hide();
        covers.show();
        covers.click(f);
        return this;
    };
    chart.each = function (f) {
        if (!Raphael.is(f, "function")) {
            return this;
        }
        for (var i = covers.length; i--;) {
            f.call(covers[i]);
        }
        return this;
    };
    chart.eachColumn = function (f) {
        if (!Raphael.is(f, "function")) {
            return this;
        }
        for (var i = covers2.length; i--;) {
            f.call(covers2[i]);
        }
        return this;
    };
    chart.clickColumn = function (f) {
        covers.hide();
        covers2.show();
        covers2.click(f);
        return this;
    };
    chart.push(bars, covers, covers2);
    chart.bars = bars;
    chart.covers = covers;
    return chart;
};
Raphael.fn.g.hbarchart = function (x, y, width, height, values, opts) {
    opts = opts || {};
    var type = {round: "round", sharp: "sharp", soft: "soft"}[opts.type] || "square",
        gutter = parseFloat(opts.gutter || "20%"),
        chart = this.set(),
        bars = this.set(),
        covers = this.set(),
        covers2 = this.set(),
        total = Math.max.apply(Math, values),
        stacktotal = [],
        paper = this,
        multi = 0,
        colors = opts.colors || this.g.colors,
        len = values.length;
    if (this.raphael.is(values[0], "array")) {
        total = [];
        multi = len;
        len = 0;
        for (var i = values.length; i--;) {
            bars.push(this.set());
            total.push(Math.max.apply(Math, values[i]));
            len = Math.max(len, values[i].length);
        }
        if (opts.stacked) {
            for (var i = len; i--;) {
                var tot = 0;
                for (var j = values.length; j--;) {
                    tot +=+ values[j][i] || 0;
                }
                stacktotal.push(tot);
            }
        }
        for (var i = values.length; i--;) {
            if (values[i].length < len) {
                for (var j = len; j--;) {
                    values[i].push(0);
                }
            }
        }
        total = Math.max.apply(Math, opts.stacked ? stacktotal : total);
    }
    
    total = (opts.to) || total;
    var barheight = Math.floor(height / (len * (100 + gutter) + gutter) * 100),
        bargutter = Math.floor(barheight * gutter / 100),
        stack = [],
        Y = y + bargutter,
        X = (width - 1) / total;
    !opts.stacked && (barheight /= multi || 1);
    for (var i = 0; i < len; i++) {
        stack = [];
        for (var j = 0; j < (multi || 1); j++) {
            var val = multi ? values[j][i] : values[i],
                bar = this.g.finger(x, Y + barheight / 2, Math.round(val * X), barheight - 1, false, type).attr({stroke: "none", fill: colors[multi ? j : i]});
            if (multi) {
                bars[j].push(bar);
            } else {
                bars.push(bar);
            }
            bar.x = x + Math.round(val * X);
            bar.y = Y + barheight / 2;
            bar.w = Math.round(val * X);
            bar.h = barheight;
            bar.value = +val;
            if (!opts.stacked) {
                Y += barheight;
            } else {
                stack.push(bar);
            }
        }
        if (opts.stacked) {
            var cvr = this.rect(x, stack[0].y - stack[0].h / 2, width, barheight).attr(this.g.shim);
            covers2.push(cvr);
            cvr.bars = this.set();
            var size = 0;
            for (var s = stack.length; s--;) {
                stack[s].toFront();
            }
            for (var s = 0, ss = stack.length; s < ss; s++) {
                var bar = stack[s],
                    cover,
                    val = Math.round((size + bar.value) * X),
                    path = this.g.finger(x, bar.y, val, barheight - 1, false, type, 1);
                cvr.bars.push(bar);
                size && bar.attr({path: path});
                bar.w = val;
                bar.x = x + val;
                covers.push(cover = this.rect(x + size * X, bar.y - bar.h / 2, bar.value * X, barheight).attr(this.g.shim));
                cover.bar = bar;
                size += bar.value;
            }
            Y += barheight;
        }
        Y += bargutter;
    }
    covers2.toFront();
    Y = y + bargutter;
    if (!opts.stacked) {
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < (multi || 1); j++) {
                var cover = this.rect(x, Y, width, barheight).attr(this.g.shim);
                covers.push(cover);
                cover.bar = multi ? bars[j][i] : bars[i];
                cover.value = cover.bar.value;
                Y += barheight;
            }
            Y += bargutter;
        }
    }
    chart.label = function (labels, isRight) {
        labels = labels || [];
        this.labels = paper.set();
        for (var i = 0; i < len; i++) {
            for (var j = 0; j < multi; j++) {
                var  label = paper.g.labelise(multi ? labels[j] && labels[j][i] : labels[i], multi ? values[j][i] : values[i], total);
                var X = isRight ? bars[i * (multi || 1) + j].x - barheight / 2 + 3 : x + 5,
                    A = isRight ? "end" : "start",
                    L;
                this.labels.push(L = paper.g.text(X, bars[i * (multi || 1) + j].y, label).attr({"text-anchor": A}).insertBefore(covers[0]));
                if (L.getBBox().x < x + 5) {
                    L.attr({x: x + 5, "text-anchor": "start"});
                } else {
                    bars[i * (multi || 1) + j].label = L;
                }
            }
        }
        return this;
    };
    chart.hover = function (fin, fout) {
        covers2.hide();
        covers.show();
        fout = fout || function () {};
        covers.mouseover(fin).mouseout(fout);
        return this;
    };
    chart.hoverColumn = function (fin, fout) {
        covers.hide();
        covers2.show();
        fout = fout || function () {};
        covers2.mouseover(fin).mouseout(fout);
        return this;
    };
    chart.each = function (f) {
        if (!Raphael.is(f, "function")) {
            return this;
        }
        for (var i = covers.length; i--;) {
            f.call(covers[i]);
        }
        return this;
    };
    chart.eachColumn = function (f) {
        if (!Raphael.is(f, "function")) {
            return this;
        }
        for (var i = covers2.length; i--;) {
            f.call(covers2[i]);
        }
        return this;
    };
    chart.click = function (f) {
        covers2.hide();
        covers.show();
        covers.click(f);
        return this;
    };
    chart.clickColumn = function (f) {
        covers.hide();
        covers2.show();
        covers2.click(f);
        return this;
    };
    chart.push(bars, covers, covers2);
    chart.bars = bars;
    chart.covers = covers;
    return chart;
};

/*
 Highcharts JS v2.3.5 (2012-12-19)

 (c) 2009-2012 Torstein Hønsi

 License: www.highcharts.com/license
*/
(function(){function x(a,b){var c;a||(a={});for(c in b)a[c]=b[c];return a}function ia(){for(var a=0,b=arguments,c=b.length,d={};a<c;a++)d[b[a++]]=b[a];return d}function z(a,b){return parseInt(a,b||10)}function ja(a){return typeof a==="string"}function Y(a){return typeof a==="object"}function Ia(a){return Object.prototype.toString.call(a)==="[object Array]"}function Da(a){return typeof a==="number"}function ka(a){return K.log(a)/K.LN10}function aa(a){return K.pow(10,a)}function ta(a,b){for(var c=a.length;c--;)if(a[c]===
b){a.splice(c,1);break}}function r(a){return a!==A&&a!==null}function w(a,b,c){var d,e;if(ja(b))r(c)?a.setAttribute(b,c):a&&a.getAttribute&&(e=a.getAttribute(b));else if(r(b)&&Y(b))for(d in b)a.setAttribute(d,b[d]);return e}function la(a){return Ia(a)?a:[a]}function n(){var a=arguments,b,c,d=a.length;for(b=0;b<d;b++)if(c=a[b],typeof c!=="undefined"&&c!==null)return c}function I(a,b){if(Ea&&b&&b.opacity!==A)b.filter="alpha(opacity="+b.opacity*100+")";x(a.style,b)}function T(a,b,c,d,e){a=C.createElement(a);
b&&x(a,b);e&&I(a,{padding:0,border:Q,margin:0});c&&I(a,c);d&&d.appendChild(a);return a}function ba(a,b){var c=function(){};c.prototype=new a;x(c.prototype,b);return c}function Ja(a,b,c,d){var e=N.lang,f=a;b===-1?(b=(a||0).toString(),a=b.indexOf(".")>-1?b.split(".")[1].length:0):a=isNaN(b=M(b))?2:b;var b=a,c=c===void 0?e.decimalPoint:c,d=d===void 0?e.thousandsSep:d,e=f<0?"-":"",a=String(z(f=M(+f||0).toFixed(b))),g=a.length>3?a.length%3:0;return e+(g?a.substr(0,g)+d:"")+a.substr(g).replace(/(\d{3})(?=\d)/g,
"$1"+d)+(b?c+M(f-a).toFixed(b).slice(2):"")}function ua(a,b){return Array((b||2)+1-String(a).length).join(0)+a}function hb(a,b,c,d){var e,c=n(c,1);e=a/c;b||(b=[1,2,2.5,5,10],d&&d.allowDecimals===!1&&(c===1?b=[1,2,5,10]:c<=0.1&&(b=[1/c])));for(d=0;d<b.length;d++)if(a=b[d],e<=(b[d]+(b[d+1]||b[d]))/2)break;a*=c;return a}function Ab(a,b){var c=b||[[Bb,[1,2,5,10,20,25,50,100,200,500]],[ib,[1,2,5,10,15,30]],[Va,[1,2,5,10,15,30]],[Ka,[1,2,3,4,6,8,12]],[ma,[1,2]],[Wa,[1,2]],[La,[1,2,3,4,6]],[va,null]],d=
c[c.length-1],e=D[d[0]],f=d[1],g;for(g=0;g<c.length;g++)if(d=c[g],e=D[d[0]],f=d[1],c[g+1]&&a<=(e*f[f.length-1]+D[c[g+1][0]])/2)break;e===D[va]&&a<5*e&&(f=[1,2,5]);e===D[va]&&a<5*e&&(f=[1,2,5]);c=hb(a/e,f);return{unitRange:e,count:c,unitName:d[0]}}function Cb(a,b,c,d){var e=[],f={},g=N.global.useUTC,h,i=new Date(b),j=a.unitRange,k=a.count;if(r(b)){j>=D[ib]&&(i.setMilliseconds(0),i.setSeconds(j>=D[Va]?0:k*U(i.getSeconds()/k)));if(j>=D[Va])i[Db](j>=D[Ka]?0:k*U(i[jb]()/k));if(j>=D[Ka])i[Eb](j>=D[ma]?
0:k*U(i[kb]()/k));if(j>=D[ma])i[lb](j>=D[La]?1:k*U(i[Ma]()/k));j>=D[La]&&(i[Fb](j>=D[va]?0:k*U(i[Xa]()/k)),h=i[Ya]());j>=D[va]&&(h-=h%k,i[Gb](h));if(j===D[Wa])i[lb](i[Ma]()-i[mb]()+n(d,1));b=1;h=i[Ya]();for(var d=i.getTime(),l=i[Xa](),m=i[Ma](),i=g?0:(864E5+i.getTimezoneOffset()*6E4)%864E5;d<c;)e.push(d),j===D[va]?d=Za(h+b*k,0):j===D[La]?d=Za(h,l+b*k):!g&&(j===D[ma]||j===D[Wa])?d=Za(h,l,m+b*k*(j===D[ma]?1:7)):(d+=j*k,j<=D[Ka]&&d%D[ma]===i&&(f[d]=ma)),b++;e.push(d)}e.info=x(a,{higherRanks:f,totalRange:j*
k});return e}function Hb(){this.symbol=this.color=0}function Ib(a,b){var c=a.length,d,e;for(e=0;e<c;e++)a[e].ss_i=e;a.sort(function(a,c){d=b(a,c);return d===0?a.ss_i-c.ss_i:d});for(e=0;e<c;e++)delete a[e].ss_i}function Fa(a){for(var b=a.length,c=a[0];b--;)a[b]<c&&(c=a[b]);return c}function wa(a){for(var b=a.length,c=a[0];b--;)a[b]>c&&(c=a[b]);return c}function Ga(a,b){for(var c in a)a[c]&&a[c]!==b&&a[c].destroy&&a[c].destroy(),delete a[c]}function Na(a){$a||($a=T(ga));a&&$a.appendChild(a);$a.innerHTML=
""}function Oa(a,b){var c="Highcharts error #"+a+": www.highcharts.com/errors/"+a;if(b)throw c;else L.console&&console.log(c)}function da(a){return parseFloat(a.toPrecision(14))}function xa(a,b){Pa=n(a,b.animation)}function Jb(){var a=N.global.useUTC,b=a?"getUTC":"get",c=a?"setUTC":"set";Za=a?Date.UTC:function(a,b,c,g,h,i){return(new Date(a,b,n(c,1),n(g,0),n(h,0),n(i,0))).getTime()};jb=b+"Minutes";kb=b+"Hours";mb=b+"Day";Ma=b+"Date";Xa=b+"Month";Ya=b+"FullYear";Db=c+"Minutes";Eb=c+"Hours";lb=c+"Date";
Fb=c+"Month";Gb=c+"FullYear"}function ya(){}function Qa(a,b,c){this.axis=a;this.pos=b;this.type=c||"";this.isNew=!0;c||this.addLabel()}function nb(a,b){this.axis=a;if(b)this.options=b,this.id=b.id;return this}function Kb(a,b,c,d,e,f){var g=a.chart.inverted;this.axis=a;this.isNegative=c;this.options=b;this.x=d;this.stack=e;this.percent=f==="percent";this.alignOptions={align:b.align||(g?c?"left":"right":"center"),verticalAlign:b.verticalAlign||(g?"middle":c?"bottom":"top"),y:n(b.y,g?4:c?14:-6),x:n(b.x,
g?c?-6:6:0)};this.textAlign=b.textAlign||(g?c?"right":"left":"center")}function ob(){this.init.apply(this,arguments)}function pb(a,b){var c=b.borderWidth,d=b.style,e=z(d.padding);this.chart=a;this.options=b;this.crosshairs=[];this.now={x:0,y:0};this.isHidden=!0;this.label=a.renderer.label("",0,0,b.shape,null,null,b.useHTML,null,"tooltip").attr({padding:e,fill:b.backgroundColor,"stroke-width":c,r:b.borderRadius,zIndex:8}).css(d).css({padding:0}).hide().add();V||this.label.shadow(b.shadow);this.shared=
b.shared}function qb(a,b){var c=V?"":b.chart.zoomType;this.zoomX=/x/.test(c);this.zoomY=/y/.test(c);this.options=b;this.chart=a;this.init(a,b.tooltip)}function rb(a){this.init(a)}function sb(){this.init.apply(this,arguments)}var A,C=document,L=window,K=Math,u=K.round,U=K.floor,za=K.ceil,s=K.max,O=K.min,M=K.abs,W=K.cos,Z=K.sin,Aa=K.PI,ab=Aa*2/360,na=navigator.userAgent,Lb=L.opera,Ea=/msie/i.test(na)&&!Lb,Ra=C.documentMode===8,bb=/AppleWebKit/.test(na),cb=/Firefox/.test(na),Mb=/(Mobile|Android|Windows Phone)/.test(na),
oa="http://www.w3.org/2000/svg",ca=!!C.createElementNS&&!!C.createElementNS(oa,"svg").createSVGRect,Sb=cb&&parseInt(na.split("Firefox/")[1],10)<4,V=!ca&&!Ea&&!!C.createElement("canvas").getContext,Sa,Ba=C.documentElement.ontouchstart!==A,Nb={},tb=0,$a,N,db,Pa,ub,D,pa=function(){},Ha=[],ga="div",Q="none",vb="rgba(192,192,192,"+(ca?1.0E-4:0.002)+")",Bb="millisecond",ib="second",Va="minute",Ka="hour",ma="day",Wa="week",La="month",va="year",wb="stroke-width",Za,jb,kb,mb,Ma,Xa,Ya,Db,Eb,lb,Fb,Gb,$={};L.Highcharts=
{};db=function(a,b,c){if(!r(b)||isNaN(b))return"Invalid date";var a=n(a,"%Y-%m-%d %H:%M:%S"),d=new Date(b),e,f=d[kb](),g=d[mb](),h=d[Ma](),i=d[Xa](),j=d[Ya](),k=N.lang,l=k.weekdays,b={a:l[g].substr(0,3),A:l[g],d:ua(h),e:h,b:k.shortMonths[i],B:k.months[i],m:ua(i+1),y:j.toString().substr(2,2),Y:j,H:ua(f),I:ua(f%12||12),l:f%12||12,M:ua(d[jb]()),p:f<12?"AM":"PM",P:f<12?"am":"pm",S:ua(d.getSeconds()),L:ua(u(b%1E3),3)};for(e in b)for(;a.indexOf("%"+e)!==-1;)a=a.replace("%"+e,b[e]);return c?a.substr(0,1).toUpperCase()+
a.substr(1):a};Hb.prototype={wrapColor:function(a){if(this.color>=a)this.color=0},wrapSymbol:function(a){if(this.symbol>=a)this.symbol=0}};D=ia(Bb,1,ib,1E3,Va,6E4,Ka,36E5,ma,864E5,Wa,6048E5,La,26784E5,va,31556952E3);ub={init:function(a,b,c){var b=b||"",d=a.shift,e=b.indexOf("C")>-1,f=e?7:3,g,b=b.split(" "),c=[].concat(c),h,i,j=function(a){for(g=a.length;g--;)a[g]==="M"&&a.splice(g+1,0,a[g+1],a[g+2],a[g+1],a[g+2])};e&&(j(b),j(c));a.isArea&&(h=b.splice(b.length-6,6),i=c.splice(c.length-6,6));if(d<=
c.length/f)for(;d--;)c=[].concat(c).splice(0,f).concat(c);a.shift=0;if(b.length)for(a=c.length;b.length<a;)d=[].concat(b).splice(b.length-f,f),e&&(d[f-6]=d[f-2],d[f-5]=d[f-1]),b=b.concat(d);h&&(b=b.concat(h),c=c.concat(i));return[b,c]},step:function(a,b,c,d){var e=[],f=a.length;if(c===1)e=d;else if(f===b.length&&c<1)for(;f--;)d=parseFloat(a[f]),e[f]=isNaN(d)?a[f]:c*parseFloat(b[f]-d)+d;else e=b;return e}};(function(a){L.HighchartsAdapter=L.HighchartsAdapter||a&&{init:function(b){var c=a.fx,d=c.step,
e,f=a.Tween,g=f&&f.propHooks;a.extend(a.easing,{easeOutQuad:function(a,b,c,d,e){return-d*(b/=e)*(b-2)+c}});a.each(["cur","_default","width","height"],function(a,b){var e=d,k,l;b==="cur"?e=c.prototype:b==="_default"&&f&&(e=g[b],b="set");(k=e[b])&&(e[b]=function(c){c=a?c:this;l=c.elem;return l.attr?l.attr(c.prop,b==="cur"?A:c.now):k.apply(this,arguments)})});e=function(a){var c=a.elem,d;if(!a.started)d=b.init(c,c.d,c.toD),a.start=d[0],a.end=d[1],a.started=!0;c.attr("d",b.step(a.start,a.end,a.pos,c.toD))};
f?g.d={set:e}:d.d=e;this.each=Array.prototype.forEach?function(a,b){return Array.prototype.forEach.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(b.call(a[c],a[c],c,a)===!1)return c}},getScript:a.getScript,inArray:a.inArray,adapterRun:function(b,c){return a(b)[c]()},grep:a.grep,map:function(a,c){for(var d=[],e=0,f=a.length;e<f;e++)d[e]=c.call(a[e],a[e],e,a);return d},merge:function(){var b=arguments;return a.extend(!0,null,b[0],b[1],b[2],b[3])},offset:function(b){return a(b).offset()},
addEvent:function(b,c,d){a(b).bind(c,d)},removeEvent:function(b,c,d){var e=C.removeEventListener?"removeEventListener":"detachEvent";C[e]&&!b[e]&&(b[e]=function(){});a(b).unbind(c,d)},fireEvent:function(b,c,d,e){var f=a.Event(c),g="detached"+c,h;!Ea&&d&&(delete d.layerX,delete d.layerY);x(f,d);b[c]&&(b[g]=b[c],b[c]=null);a.each(["preventDefault","stopPropagation"],function(a,b){var c=f[b];f[b]=function(){try{c.call(f)}catch(a){b==="preventDefault"&&(h=!0)}}});a(b).trigger(f);b[g]&&(b[c]=b[g],b[g]=
null);e&&!f.isDefaultPrevented()&&!h&&e(f)},washMouseEvent:function(a){var c=a.originalEvent||a;if(c.pageX===A)c.pageX=a.pageX,c.pageY=a.pageY;return c},animate:function(b,c,d){var e=a(b);if(c.d)b.toD=c.d,c.d=1;e.stop();e.animate(c,d)},stop:function(b){a(b).stop()}}})(L.jQuery);var ea=L.HighchartsAdapter,G=ea||{};ea&&ea.init.call(ea,ub);var eb=G.adapterRun,Tb=G.getScript,Ub=G.inArray,o=G.each,Ob=G.grep,Vb=G.offset,Ta=G.map,B=G.merge,J=G.addEvent,R=G.removeEvent,F=G.fireEvent,Pb=G.washMouseEvent,xb=
G.animate,fb=G.stop,G={enabled:!0,align:"center",x:0,y:15,style:{color:"#666",fontSize:"11px",lineHeight:"14px"}};N={colors:"#4572A7,#AA4643,#89A54E,#80699B,#3D96AE,#DB843D,#92A8CD,#A47D7C,#B5CA92".split(","),symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January,February,March,April,May,June,July,August,September,October,November,December".split(","),shortMonths:"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),weekdays:"Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
decimalPoint:".",numericSymbols:"k,M,G,T,P,E".split(","),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:","},global:{useUTC:!0,canvasToolsURL:"http://code.highcharts.com/2.3.5/modules/canvas-tools.js",VMLRadialGradientURL:"http://code.highcharts.com/2.3.5/gfx/vml-radial-gradient.png"},chart:{borderColor:"#4572A7",borderRadius:5,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacingTop:10,spacingRight:10,spacingBottom:15,spacingLeft:10,style:{fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
fontSize:"12px"},backgroundColor:"#FFFFFF",plotBorderColor:"#C0C0C0",resetZoomButton:{theme:{zIndex:20},position:{align:"right",x:-10,y:10}}},title:{text:"Chart title",align:"center",y:15,style:{color:"#3E576F",fontSize:"16px"}},subtitle:{text:"",align:"center",y:30,style:{color:"#6D869F"}},plotOptions:{line:{allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},lineWidth:2,shadow:!0,marker:{enabled:!0,lineWidth:0,radius:4,lineColor:"#FFFFFF",states:{hover:{enabled:!0},select:{fillColor:"#FFFFFF",
lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:B(G,{enabled:!1,formatter:function(){return this.y},verticalAlign:"bottom",y:0}),cropThreshold:300,pointRange:0,showInLegend:!0,states:{hover:{marker:{}},select:{marker:{}}},stickyTracking:!0}},labels:{style:{position:"absolute",color:"#3E576F"}},legend:{enabled:!0,align:"center",layout:"horizontal",labelFormatter:function(){return this.name},borderWidth:1,borderColor:"#909090",borderRadius:5,navigation:{activeColor:"#3E576F",inactiveColor:"#CCC"},
shadow:!1,itemStyle:{cursor:"pointer",color:"#3E576F",fontSize:"12px"},itemHoverStyle:{color:"#000"},itemHiddenStyle:{color:"#CCC"},itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},symbolWidth:16,symbolPadding:5,verticalAlign:"bottom",x:0,y:0},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"1em"},style:{position:"absolute",backgroundColor:"white",opacity:0.5,textAlign:"center"}},tooltip:{enabled:!0,backgroundColor:"rgba(255, 255, 255, .85)",borderWidth:2,borderRadius:5,
dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},headerFormat:'<span style="font-size: 10px">{point.key}</span><br/>',pointFormat:'<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',shadow:!0,shared:V,snap:Mb?25:10,style:{color:"#333333",fontSize:"12px",padding:"5px",whiteSpace:"nowrap"}},credits:{enabled:!0,
text:"Highcharts.com",href:"http://www.highcharts.com",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#909090",fontSize:"10px"}}};var X=N.plotOptions,ea=X.line;Jb();var qa=function(a){var b=[],c;(function(a){(c=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(a))?b=[z(c[1]),z(c[2]),z(c[3]),parseFloat(c[4],10)]:(c=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(a))&&(b=[z(c[1],16),z(c[2],16),z(c[3],
16),1])})(a);return{get:function(c){return b&&!isNaN(b[0])?c==="rgb"?"rgb("+b[0]+","+b[1]+","+b[2]+")":c==="a"?b[3]:"rgba("+b.join(",")+")":a},brighten:function(a){if(Da(a)&&a!==0){var c;for(c=0;c<3;c++)b[c]+=z(a*255),b[c]<0&&(b[c]=0),b[c]>255&&(b[c]=255)}return this},setOpacity:function(a){b[3]=a;return this}}};ya.prototype={init:function(a,b){this.element=b==="span"?T(b):C.createElementNS(oa,b);this.renderer=a;this.attrSetters={}},animate:function(a,b,c){b=n(b,Pa,!0);fb(this);if(b){b=B(b);if(c)b.complete=
c;xb(this,a,b)}else this.attr(a),c&&c()},attr:function(a,b){var c,d,e,f,g=this.element,h=g.nodeName.toLowerCase(),i=this.renderer,j,k=this.attrSetters,l=this.shadows,m,q,p=this;ja(a)&&r(b)&&(c=a,a={},a[c]=b);if(ja(a))c=a,h==="circle"?c={x:"cx",y:"cy"}[c]||c:c==="strokeWidth"&&(c="stroke-width"),p=w(g,c)||this[c]||0,c!=="d"&&c!=="visibility"&&(p=parseFloat(p));else for(c in a)if(j=!1,d=a[c],e=k[c]&&k[c].call(this,d,c),e!==!1){e!==A&&(d=e);if(c==="d")d&&d.join&&(d=d.join(" ")),/(NaN| {2}|^$)/.test(d)&&
(d="M 0 0");else if(c==="x"&&h==="text"){for(e=0;e<g.childNodes.length;e++)f=g.childNodes[e],w(f,"x")===w(g,"x")&&w(f,"x",d);this.rotation&&w(g,"transform","rotate("+this.rotation+" "+d+" "+z(a.y||w(g,"y"))+")")}else if(c==="fill")d=i.color(d,g,c);else if(h==="circle"&&(c==="x"||c==="y"))c={x:"cx",y:"cy"}[c]||c;else if(h==="rect"&&c==="r")w(g,{rx:d,ry:d}),j=!0;else if(c==="translateX"||c==="translateY"||c==="rotation"||c==="verticalAlign")j=q=!0;else if(c==="stroke")d=i.color(d,g,c);else if(c==="dashstyle")if(c=
"stroke-dasharray",d=d&&d.toLowerCase(),d==="solid")d=Q;else{if(d){d=d.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(e=d.length;e--;)d[e]=z(d[e])*a["stroke-width"];d=d.join(",")}}else if(c==="isTracker")this[c]=d;else if(c==="width")d=z(d);else if(c==="align")c="text-anchor",d={left:"start",center:"middle",right:"end"}[d];
else if(c==="title")e=g.getElementsByTagName("title")[0],e||(e=C.createElementNS(oa,"title"),g.appendChild(e)),e.textContent=d;c==="strokeWidth"&&(c="stroke-width");if(c==="stroke-width"&&d===0&&(bb||i.forExport))d=1.0E-6;this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(c)&&(m||(this.symbolAttr(a),m=!0),j=!0);if(l&&/^(width|height|visibility|x|y|d|transform)$/.test(c))for(e=l.length;e--;)w(l[e],c,c==="height"?s(d-(l[e].cutHeight||0),0):d);if((c==="width"||c==="height")&&
h==="rect"&&d<0)d=0;this[c]=d;q&&this.updateTransform();c==="text"?(d!==this.textStr&&delete this.bBox,this.textStr=d,this.added&&i.buildText(this)):j||w(g,c,d)}return p},symbolAttr:function(a){var b=this;o("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","),function(c){b[c]=n(a[c],b[c])});b.attr({d:b.renderer.symbols[b.symbolName](b.x,b.y,b.width,b.height,b)})},clip:function(a){return this.attr("clip-path",a?"url("+this.renderer.url+"#"+a.id+")":Q)},crisp:function(a,b,c,d,e){var f,g=
{},h={},i,a=a||this.strokeWidth||this.attr&&this.attr("stroke-width")||0;i=u(a)%2/2;h.x=U(b||this.x||0)+i;h.y=U(c||this.y||0)+i;h.width=U((d||this.width||0)-2*i);h.height=U((e||this.height||0)-2*i);h.strokeWidth=a;for(f in h)this[f]!==h[f]&&(this[f]=g[f]=h[f]);return g},css:function(a){var b=this.element,b=a&&a.width&&b.nodeName.toLowerCase()==="text",c,d="",e=function(a,b){return"-"+b.toLowerCase()};if(a&&a.color)a.fill=a.color;this.styles=a=x(this.styles,a);V&&b&&delete a.width;if(Ea&&!ca)b&&delete a.width,
I(this.element,a);else{for(c in a)d+=c.replace(/([A-Z])/g,e)+":"+a[c]+";";this.attr({style:d})}b&&this.added&&this.renderer.buildText(this);return this},on:function(a,b){if(Ba&&a==="click")this.element.ontouchstart=function(a){a.preventDefault();b()};this.element["on"+a]=b;return this},setRadialReference:function(a){this.element.radialReference=a;return this},translate:function(a,b){return this.attr({translateX:a,translateY:b})},invert:function(){this.inverted=!0;this.updateTransform();return this},
htmlCss:function(a){var b=this.element;if(b=a&&b.tagName==="SPAN"&&a.width)delete a.width,this.textWidth=b,this.updateTransform();this.styles=x(this.styles,a);I(this.element,a);return this},htmlGetBBox:function(){var a=this.element,b=this.bBox;if(!b){if(a.nodeName==="text")a.style.position="absolute";b=this.bBox={x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}}return b},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,b=this.element,c=this.translateX||0,d=
this.translateY||0,e=this.x||0,f=this.y||0,g=this.textAlign||"left",h={left:0,center:0.5,right:1}[g],i=g&&g!=="left",j=this.shadows;if(c||d)I(b,{marginLeft:c,marginTop:d}),j&&o(j,function(a){I(a,{marginLeft:c+1,marginTop:d+1})});this.inverted&&o(b.childNodes,function(c){a.invertChild(c,b)});if(b.tagName==="SPAN"){var k,l,j=this.rotation,m,q=0,p=1,q=0,y;m=z(this.textWidth);var t=this.xCorr||0,H=this.yCorr||0,ra=[j,g,b.innerHTML,this.textWidth].join(",");k={};if(ra!==this.cTT){if(r(j))a.isSVG?(t=Ea?
"-ms-transform":bb?"-webkit-transform":cb?"MozTransform":Lb?"-o-transform":"",k[t]=k.transform="rotate("+j+"deg)"):(q=j*ab,p=W(q),q=Z(q),k.filter=j?["progid:DXImageTransform.Microsoft.Matrix(M11=",p,", M12=",-q,", M21=",q,", M22=",p,", sizingMethod='auto expand')"].join(""):Q),I(b,k);k=n(this.elemWidth,b.offsetWidth);l=n(this.elemHeight,b.offsetHeight);if(k>m&&/[ \-]/.test(b.textContent||b.innerText))I(b,{width:m+"px",display:"block",whiteSpace:"normal"}),k=m;m=a.fontMetrics(b.style.fontSize).b;t=
p<0&&-k;H=q<0&&-l;y=p*q<0;t+=q*m*(y?1-h:h);H-=p*m*(j?y?h:1-h:1);i&&(t-=k*h*(p<0?-1:1),j&&(H-=l*h*(q<0?-1:1)),I(b,{textAlign:g}));this.xCorr=t;this.yCorr=H}I(b,{left:e+t+"px",top:f+H+"px"});if(bb)l=b.offsetHeight;this.cTT=ra}}else this.alignOnAdd=!0},updateTransform:function(){var a=this.translateX||0,b=this.translateY||0,c=this.inverted,d=this.rotation,e=[];c&&(a+=this.attr("width"),b+=this.attr("height"));(a||b)&&e.push("translate("+a+","+b+")");c?e.push("rotate(90) scale(-1,1)"):d&&e.push("rotate("+
d+" "+(this.x||0)+" "+(this.y||0)+")");e.length&&w(this.element,"transform",e.join(" "))},toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,b,c){a?(this.alignOptions=a,this.alignByTranslate=b,c||this.renderer.alignedObjects.push(this)):(a=this.alignOptions,b=this.alignByTranslate);var c=n(c,this.renderer),d=a.align,e=a.verticalAlign,f=(c.x||0)+(a.x||0),g=(c.y||0)+(a.y||0),h={};if(d==="right"||d==="center")f+=(c.width-(a.width||0))/{right:1,center:2}[d];
h[b?"translateX":"x"]=u(f);if(e==="bottom"||e==="middle")g+=(c.height-(a.height||0))/({bottom:1,middle:2}[e]||1);h[b?"translateY":"y"]=u(g);this[this.placed?"animate":"attr"](h);this.placed=!0;this.alignAttr=h;return this},getBBox:function(){var a=this.bBox,b=this.renderer,c,d=this.rotation;c=this.element;var e=this.styles,f=d*ab;if(!a){if(c.namespaceURI===oa||b.forExport){try{a=c.getBBox?x({},c.getBBox()):{width:c.offsetWidth,height:c.offsetHeight}}catch(g){}if(!a||a.width<0)a={width:0,height:0}}else a=
this.htmlGetBBox();if(b.isSVG){b=a.width;c=a.height;if(Ea&&e&&e.fontSize==="11px"&&c===22.700000762939453)a.height=c=14;if(d)a.width=M(c*Z(f))+M(b*W(f)),a.height=M(c*W(f))+M(b*Z(f))}this.bBox=a}return a},show:function(){return this.attr({visibility:"visible"})},hide:function(){return this.attr({visibility:"hidden"})},add:function(a){var b=this.renderer,c=a||b,d=c.element||b.box,e=d.childNodes,f=this.element,g=w(f,"zIndex"),h;if(a)this.parentGroup=a;this.parentInverted=a&&a.inverted;this.textStr!==
void 0&&b.buildText(this);if(g)c.handleZ=!0,g=z(g);if(c.handleZ)for(c=0;c<e.length;c++)if(a=e[c],b=w(a,"zIndex"),a!==f&&(z(b)>g||!r(g)&&r(b))){d.insertBefore(f,a);h=!0;break}h||d.appendChild(f);this.added=!0;F(this,"add");return this},safeRemoveChild:function(a){var b=a.parentNode;b&&b.removeChild(a)},destroy:function(){var a=this,b=a.element||{},c=a.shadows,d,e;b.onclick=b.onmouseout=b.onmouseover=b.onmousemove=null;fb(a);if(a.clipPath)a.clipPath=a.clipPath.destroy();if(a.stops){for(e=0;e<a.stops.length;e++)a.stops[e]=
a.stops[e].destroy();a.stops=null}a.safeRemoveChild(b);c&&o(c,function(b){a.safeRemoveChild(b)});ta(a.renderer.alignedObjects,a);for(d in a)delete a[d];return null},empty:function(){for(var a=this.element,b=a.childNodes,c=b.length;c--;)a.removeChild(b[c])},shadow:function(a,b,c){var d=[],e,f,g=this.element,h,i,j,k;if(a){i=n(a.width,3);j=(a.opacity||0.15)/i;k=this.parentInverted?"(-1,-1)":"("+n(a.offsetX,1)+", "+n(a.offsetY,1)+")";for(e=1;e<=i;e++){f=g.cloneNode(0);h=i*2+1-2*e;w(f,{isShadow:"true",
stroke:a.color||"black","stroke-opacity":j*e,"stroke-width":h,transform:"translate"+k,fill:Q});if(c)w(f,"height",s(w(f,"height")-h,0)),f.cutHeight=h;b?b.element.appendChild(f):g.parentNode.insertBefore(f,g);d.push(f)}this.shadows=d}return this}};var sa=function(){this.init.apply(this,arguments)};sa.prototype={Element:ya,init:function(a,b,c,d){var e=location,f;f=this.createElement("svg").attr({xmlns:oa,version:"1.1"});a.appendChild(f.element);this.isSVG=!0;this.box=f.element;this.boxWrapper=f;this.alignedObjects=
[];this.url=(cb||bb)&&C.getElementsByTagName("base").length?e.href.replace(/#.*?$/,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20"):"";this.defs=this.createElement("defs").add();this.forExport=d;this.gradients={};this.setSize(b,c,!1);var g;if(cb&&a.getBoundingClientRect)this.subPixelFix=b=function(){I(a,{left:0,top:0});g=a.getBoundingClientRect();I(a,{left:za(g.left)-g.left+"px",top:za(g.top)-g.top+"px"})},b(),J(L,"resize",b)},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=
this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();Ga(this.gradients||{});this.gradients=null;if(a)this.defs=a.destroy();this.subPixelFix&&R(L,"resize",this.subPixelFix);return this.alignedObjects=null},createElement:function(a){var b=new this.Element;b.init(this,a);return b},draw:function(){},buildText:function(a){for(var b=a.element,c=n(a.textStr,"").toString().replace(/<(b|strong)>/g,'<span style="font-weight:bold">').replace(/<(i|em)>/g,'<span style="font-style:italic">').replace(/<a/g,
"<span").replace(/<\/(b|strong|i|em|a)>/g,"</span>").split(/<br.*?>/g),d=b.childNodes,e=/style="([^"]+)"/,f=/href="([^"]+)"/,g=w(b,"x"),h=a.styles,i=h&&h.width&&z(h.width),j=h&&h.lineHeight,k,h=d.length,l=[];h--;)b.removeChild(d[h]);i&&!a.added&&this.box.appendChild(b);c[c.length-1]===""&&c.pop();o(c,function(c,d){var h,y=0,t,c=c.replace(/<span/g,"|||<span").replace(/<\/span>/g,"</span>|||");h=c.split("|||");o(h,function(c){if(c!==""||h.length===1){var m={},n=C.createElementNS(oa,"tspan"),o;e.test(c)&&
(o=c.match(e)[1].replace(/(;| |^)color([ :])/,"$1fill$2"),w(n,"style",o));f.test(c)&&(w(n,"onclick",'location.href="'+c.match(f)[1]+'"'),I(n,{cursor:"pointer"}));c=(c.replace(/<(.|\n)*?>/g,"")||" ").replace(/&lt;/g,"<").replace(/&gt;/g,">");n.appendChild(C.createTextNode(c));y?m.dx=3:m.x=g;if(!y){if(d){!ca&&a.renderer.forExport&&I(n,{display:"block"});t=L.getComputedStyle&&z(L.getComputedStyle(k,null).getPropertyValue("line-height"));if(!t||isNaN(t)){var r;if(!(r=j))if(!(r=k.offsetHeight))l[d]=b.getBBox?
b.getBBox().height:a.renderer.fontMetrics(b.style.fontSize).h,r=u(l[d]-(l[d-1]||0))||18;t=r}w(n,"dy",t)}k=n}w(n,m);b.appendChild(n);y++;if(i)for(var c=c.replace(/([^\^])-/g,"$1- ").split(" "),E=[];c.length||E.length;)delete a.bBox,r=a.getBBox().width,m=r>i,!m||c.length===1?(c=E,E=[],c.length&&(n=C.createElementNS(oa,"tspan"),w(n,{dy:j||16,x:g}),o&&w(n,"style",o),b.appendChild(n),r>i&&(i=r))):(n.removeChild(n.firstChild),E.unshift(c.pop())),c.length&&n.appendChild(C.createTextNode(c.join(" ").replace(/- /g,
"-")))}})})},button:function(a,b,c,d,e,f,g){var h=this.label(a,b,c),i=0,j,k,l,m,q,a={x1:0,y1:0,x2:0,y2:1},e=B(ia(wb,1,"stroke","#999","fill",ia("linearGradient",a,"stops",[[0,"#FFF"],[1,"#DDD"]]),"r",3,"padding",3,"style",ia("color","black")),e);l=e.style;delete e.style;f=B(e,ia("stroke","#68A","fill",ia("linearGradient",a,"stops",[[0,"#FFF"],[1,"#ACF"]])),f);m=f.style;delete f.style;g=B(e,ia("stroke","#68A","fill",ia("linearGradient",a,"stops",[[0,"#9BD"],[1,"#CDF"]])),g);q=g.style;delete g.style;
J(h.element,"mouseenter",function(){h.attr(f).css(m)});J(h.element,"mouseleave",function(){j=[e,f,g][i];k=[l,m,q][i];h.attr(j).css(k)});h.setState=function(a){(i=a)?a===2&&h.attr(g).css(q):h.attr(e).css(l)};return h.on("click",function(){d.call(h)}).attr(e).css(x({cursor:"default"},l))},crispLine:function(a,b){a[1]===a[4]&&(a[1]=a[4]=u(a[1])-b%2/2);a[2]===a[5]&&(a[2]=a[5]=u(a[2])+b%2/2);return a},path:function(a){var b={fill:Q};Ia(a)?b.d=a:Y(a)&&x(b,a);return this.createElement("path").attr(b)},circle:function(a,
b,c){a=Y(a)?a:{x:a,y:b,r:c};return this.createElement("circle").attr(a)},arc:function(a,b,c,d,e,f){if(Y(a))b=a.y,c=a.r,d=a.innerR,e=a.start,f=a.end,a=a.x;return this.symbol("arc",a||0,b||0,c||0,c||0,{innerR:d||0,start:e||0,end:f||0})},rect:function(a,b,c,d,e,f){e=Y(a)?a.r:e;e=this.createElement("rect").attr({rx:e,ry:e,fill:Q});return e.attr(Y(a)?a:e.crisp(f,a,b,s(c,0),s(d,0)))},setSize:function(a,b,c){var d=this.alignedObjects,e=d.length;this.width=a;this.height=b;for(this.boxWrapper[n(c,!0)?"animate":
"attr"]({width:a,height:b});e--;)d[e].align()},g:function(a){var b=this.createElement("g");return r(a)?b.attr({"class":"highcharts-"+a}):b},image:function(a,b,c,d,e){var f={preserveAspectRatio:Q};arguments.length>1&&x(f,{x:b,y:c,width:d,height:e});f=this.createElement("image").attr(f);f.element.setAttributeNS?f.element.setAttributeNS("http://www.w3.org/1999/xlink","href",a):f.element.setAttribute("hc-svg-href",a);return f},symbol:function(a,b,c,d,e,f){var g,h=this.symbols[a],h=h&&h(u(b),u(c),d,e,
f),i=/^url\((.*?)\)$/,j,k;h?(g=this.path(h),x(g,{symbolName:a,x:b,y:c,width:d,height:e}),f&&x(g,f)):i.test(a)&&(k=function(a,b){a.element&&(a.attr({width:b[0],height:b[1]}),a.alignByTranslate||a.translate(u((d-b[0])/2),u((e-b[1])/2)))},j=a.match(i)[1],a=Nb[j],g=this.image(j).attr({x:b,y:c}),a?k(g,a):(g.attr({width:0,height:0}),T("img",{onload:function(){k(g,Nb[j]=[this.width,this.height])},src:j})));return g},symbols:{circle:function(a,b,c,d){var e=0.166*c;return["M",a+c/2,b,"C",a+c+e,b,a+c+e,b+d,
a+c/2,b+d,"C",a-e,b+d,a-e,b,a+c/2,b,"Z"]},square:function(a,b,c,d){return["M",a,b,"L",a+c,b,a+c,b+d,a,b+d,"Z"]},triangle:function(a,b,c,d){return["M",a+c/2,b,"L",a+c,b+d,a,b+d,"Z"]},"triangle-down":function(a,b,c,d){return["M",a,b,"L",a+c,b,a+c/2,b+d,"Z"]},diamond:function(a,b,c,d){return["M",a+c/2,b,"L",a+c,b+d/2,a+c/2,b+d,a,b+d/2,"Z"]},arc:function(a,b,c,d,e){var f=e.start,c=e.r||c||d,g=e.end-1.0E-6,d=e.innerR,h=e.open,i=W(f),j=Z(f),k=W(g),g=Z(g),e=e.end-f<Aa?0:1;return["M",a+c*i,b+c*j,"A",c,c,
0,e,1,a+c*k,b+c*g,h?"M":"L",a+d*k,b+d*g,"A",d,d,0,e,0,a+d*i,b+d*j,h?"":"Z"]}},clipRect:function(a,b,c,d){var e="highcharts-"+tb++,f=this.createElement("clipPath").attr({id:e}).add(this.defs),a=this.rect(a,b,c,d,0).add(f);a.id=e;a.clipPath=f;return a},color:function(a,b,c){var d=this,e,f=/^rgba/,g,h,i,j,k,l,m,q=[];a&&a.linearGradient?g="linearGradient":a&&a.radialGradient&&(g="radialGradient");if(g){c=a[g];h=d.gradients;j=a.stops;b=b.radialReference;Ia(c)&&(a[g]=c={x1:c[0],y1:c[1],x2:c[2],y2:c[3],
gradientUnits:"userSpaceOnUse"});g==="radialGradient"&&b&&!r(c.gradientUnits)&&x(c,{cx:b[0]-b[2]/2+c.cx*b[2],cy:b[1]-b[2]/2+c.cy*b[2],r:c.r*b[2],gradientUnits:"userSpaceOnUse"});for(m in c)m!=="id"&&q.push(m,c[m]);for(m in j)q.push(j[m]);q=q.join(",");h[q]?a=h[q].id:(c.id=a="highcharts-"+tb++,h[q]=i=d.createElement(g).attr(c).add(d.defs),i.stops=[],o(j,function(a){f.test(a[1])?(e=qa(a[1]),k=e.get("rgb"),l=e.get("a")):(k=a[1],l=1);a=d.createElement("stop").attr({offset:a[0],"stop-color":k,"stop-opacity":l}).add(i);
i.stops.push(a)}));return"url("+d.url+"#"+a+")"}else return f.test(a)?(e=qa(a),w(b,c+"-opacity",e.get("a")),e.get("rgb")):(b.removeAttribute(c+"-opacity"),a)},text:function(a,b,c,d){var e=N.chart.style,f=V||!ca&&this.forExport;if(d&&!this.forExport)return this.html(a,b,c);b=u(n(b,0));c=u(n(c,0));a=this.createElement("text").attr({x:b,y:c,text:a}).css({fontFamily:e.fontFamily,fontSize:e.fontSize});f&&a.css({position:"absolute"});a.x=b;a.y=c;return a},html:function(a,b,c){var d=N.chart.style,e=this.createElement("span"),
f=e.attrSetters,g=e.element,h=e.renderer;f.text=function(a){a!==g.innerHTML&&delete this.bBox;g.innerHTML=a;return!1};f.x=f.y=f.align=function(a,b){b==="align"&&(b="textAlign");e[b]=a;e.htmlUpdateTransform();return!1};e.attr({text:a,x:u(b),y:u(c)}).css({position:"absolute",whiteSpace:"nowrap",fontFamily:d.fontFamily,fontSize:d.fontSize});e.css=e.htmlCss;if(h.isSVG)e.add=function(a){var b,c=h.box.parentNode,d=[];if(a){if(b=a.div,!b){for(;a;)d.push(a),a=a.parentGroup;o(d.reverse(),function(a){var d;
b=a.div=a.div||T(ga,{className:w(a.element,"class")},{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px"},b||c);d=b.style;x(a.attrSetters,{translateX:function(a){d.left=a+"px"},translateY:function(a){d.top=a+"px"},visibility:function(a,b){d[b]=a}})})}}else b=c;b.appendChild(g);e.added=!0;e.alignOnAdd&&e.htmlUpdateTransform();return e};return e},fontMetrics:function(a){var a=z(a||11),a=a<24?a+4:u(a*1.2),b=u(a*0.8);return{h:a,b:b}},label:function(a,b,c,d,e,f,g,h,i){function j(){var a;
a=y.element.style;H=(s===void 0||yb===void 0||p.styles.textAlign)&&y.getBBox();p.width=(s||H.width||0)+2*v;p.height=(yb||H.height||0)+2*v;zb=v+q.fontMetrics(a&&a.fontSize).b;if(z){if(!n)a=h?-zb:0,p.box=n=d?q.symbol(d,-ra*v,a,p.width,p.height):q.rect(-ra*v,a,p.width,p.height,0,w[wb]),n.add(p);n.attr(B({width:p.width,height:p.height},w));w=null}}function k(){var a=p.styles,a=a&&a.textAlign,b=v*(1-ra),c;c=h?0:zb;if(r(s)&&(a==="center"||a==="right"))b+={center:0.5,right:1}[a]*(s-H.width);(b!==y.x||c!==
y.y)&&y.attr({x:b,y:c});y.x=b;y.y=c}function l(a,b){n?n.attr(a,b):w[a]=b}function m(){y.add(p);p.attr({text:a,x:b,y:c});n&&r(e)&&p.attr({anchorX:e,anchorY:f})}var q=this,p=q.g(i),y=q.text("",0,0,g).attr({zIndex:1}),n,H,ra=0,v=3,s,yb,E,S,Qb=0,w={},zb,g=p.attrSetters,z;J(p,"add",m);g.width=function(a){s=a;return!1};g.height=function(a){yb=a;return!1};g.padding=function(a){r(a)&&a!==v&&(v=a,k());return!1};g.align=function(a){ra={left:0,center:0.5,right:1}[a];return!1};g.text=function(a,b){y.attr(b,a);
j();k();return!1};g[wb]=function(a,b){z=!0;Qb=a%2/2;l(b,a);return!1};g.stroke=g.fill=g.r=function(a,b){b==="fill"&&(z=!0);l(b,a);return!1};g.anchorX=function(a,b){e=a;l(b,a+Qb-E);return!1};g.anchorY=function(a,b){f=a;l(b,a-S);return!1};g.x=function(a){p.x=a;a-=ra*((s||H.width)+v);E=u(a);p.attr("translateX",E);return!1};g.y=function(a){S=p.y=u(a);p.attr("translateY",a);return!1};var C=p.css;return x(p,{css:function(a){if(a){var b={},a=B({},a);o("fontSize,fontWeight,fontFamily,color,lineHeight,width".split(","),
function(c){a[c]!==A&&(b[c]=a[c],delete a[c])});y.css(b)}return C.call(p,a)},getBBox:function(){return{width:H.width+2*v,height:H.height+2*v,x:H.x-v,y:H.y-v}},shadow:function(a){n&&n.shadow(a);return p},destroy:function(){R(p,"add",m);R(p.element,"mouseenter");R(p.element,"mouseleave");y&&(y=y.destroy());n&&(n=n.destroy());ya.prototype.destroy.call(p);p=q=j=k=l=m=null}})}};Sa=sa;var ha;if(!ca&&!V){ha={init:function(a,b){var c=["<",b,' filled="f" stroked="f"'],d=["position: ","absolute",";"];(b===
"shape"||b===ga)&&d.push("left:0;top:0;width:1px;height:1px;");Ra&&d.push("visibility: ",b===ga?"hidden":"visible");c.push(' style="',d.join(""),'"/>');if(b)c=b===ga||b==="span"||b==="img"?c.join(""):a.prepVML(c),this.element=T(c);this.renderer=a;this.attrSetters={}},add:function(a){var b=this.renderer,c=this.element,d=b.box,d=a?a.element||a:d;a&&a.inverted&&b.invertChild(c,d);d.appendChild(c);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();F(this,"add");return this},
updateTransform:ya.prototype.htmlUpdateTransform,attr:function(a,b){var c,d,e,f=this.element||{},g=f.style,h=f.nodeName,i=this.renderer,j=this.symbolName,k,l=this.shadows,m,q=this.attrSetters,p=this;ja(a)&&r(b)&&(c=a,a={},a[c]=b);if(ja(a))c=a,p=c==="strokeWidth"||c==="stroke-width"?this.strokeweight:this[c];else for(c in a)if(d=a[c],m=!1,e=q[c]&&q[c].call(this,d,c),e!==!1&&d!==null){e!==A&&(d=e);if(j&&/^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(c))k||(this.symbolAttr(a),k=!0),m=
!0;else if(c==="d"){d=d||[];this.d=d.join(" ");e=d.length;for(m=[];e--;)m[e]=Da(d[e])?u(d[e]*10)-5:d[e]==="Z"?"x":d[e];d=m.join(" ")||"x";f.path=d;if(l)for(e=l.length;e--;)l[e].path=l[e].cutOff?this.cutOffPath(d,l[e].cutOff):d;m=!0}else if(c==="visibility"){if(l)for(e=l.length;e--;)l[e].style[c]=d;h==="DIV"&&(d=d==="hidden"?"-999em":0,c="top");g[c]=d;m=!0}else if(c==="zIndex")d&&(g[c]=d),m=!0;else if(c==="width"||c==="height")d=s(0,d),this[c]=d,this.updateClipping?(this[c]=d,this.updateClipping()):
g[c]=d,m=!0;else if(c==="x"||c==="y")this[c]=d,g[{x:"left",y:"top"}[c]]=d;else if(c==="class")f.className=d;else if(c==="stroke")d=i.color(d,f,c),c="strokecolor";else if(c==="stroke-width"||c==="strokeWidth")f.stroked=d?!0:!1,c="strokeweight",this[c]=d,Da(d)&&(d+="px");else if(c==="dashstyle")(f.getElementsByTagName("stroke")[0]||T(i.prepVML(["<stroke/>"]),null,null,f))[c]=d||"solid",this.dashstyle=d,m=!0;else if(c==="fill")if(h==="SPAN")g.color=d;else{if(h!=="IMG")f.filled=d!==Q?!0:!1,d=i.color(d,
f,c,this),c="fillcolor"}else if(h==="shape"&&c==="rotation")this[c]=d,f.style.left=-u(Z(d*ab)+1)+"px",f.style.top=u(W(d*ab))+"px";else if(c==="translateX"||c==="translateY"||c==="rotation")this[c]=d,this.updateTransform(),m=!0;else if(c==="text")this.bBox=null,f.innerHTML=d,m=!0;m||(Ra?f[c]=d:w(f,c,d))}return p},clip:function(a){var b=this,c,d=b.element,e=d.parentNode;a?(c=a.members,ta(c,b),c.push(b),b.destroyClip=function(){ta(c,b)},e&&e.className==="highcharts-tracker"&&!Ra&&I(d,{visibility:"hidden"}),
a=a.getCSS(b)):(b.destroyClip&&b.destroyClip(),a={clip:Ra?"inherit":"rect(auto)"});return b.css(a)},css:ya.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&Na(a)},destroy:function(){this.destroyClip&&this.destroyClip();return ya.prototype.destroy.apply(this)},empty:function(){for(var a=this.element.childNodes,b=a.length,c;b--;)c=a[b],c.parentNode.removeChild(c)},on:function(a,b){this.element["on"+a]=function(){var a=L.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,
b){var c,a=a.split(/[ ,]/);c=a.length;if(c===9||c===11)a[c-4]=a[c-2]=z(a[c-2])-10*b;return a.join(" ")},shadow:function(a,b,c){var d=[],e,f=this.element,g=this.renderer,h,i=f.style,j,k=f.path,l,m,q,p;k&&typeof k.value!=="string"&&(k="x");m=k;if(a){q=n(a.width,3);p=(a.opacity||0.15)/q;for(e=1;e<=3;e++){l=q*2+1-2*e;c&&(m=this.cutOffPath(k.value,l+0.5));j=['<shape isShadow="true" strokeweight="',l,'" filled="false" path="',m,'" coordsize="10 10" style="',f.style.cssText,'" />'];h=T(g.prepVML(j),null,
{left:z(i.left)+n(a.offsetX,1),top:z(i.top)+n(a.offsetY,1)});if(c)h.cutOff=l+1;j=['<stroke color="',a.color||"black",'" opacity="',p*e,'"/>'];T(g.prepVML(j),null,null,h);b?b.element.appendChild(h):f.parentNode.insertBefore(h,f);d.push(h)}this.shadows=d}return this}};ha=ba(ya,ha);var fa={Element:ha,isIE8:na.indexOf("MSIE 8.0")>-1,init:function(a,b,c){var d,e;this.alignedObjects=[];d=this.createElement(ga);e=d.element;e.style.position="relative";a.appendChild(d.element);this.box=e;this.boxWrapper=d;
this.setSize(b,c,!1);if(!C.namespaces.hcv)C.namespaces.add("hcv","urn:schemas-microsoft-com:vml"),C.createStyleSheet().cssText="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,b,c,d){var e=this.createElement(),f=Y(a);return x(e,{members:[],left:f?a.x:a,top:f?a.y:b,width:f?a.width:c,height:f?a.height:d,getCSS:function(a){var b=a.inverted,c=this.top,d=this.left,e=d+this.width,
f=c+this.height,c={clip:"rect("+u(b?d:c)+"px,"+u(b?f:e)+"px,"+u(b?e:f)+"px,"+u(b?c:d)+"px)"};!b&&Ra&&a.element.nodeName!=="IMG"&&x(c,{width:e+"px",height:f+"px"});return c},updateClipping:function(){o(e.members,function(a){a.css(e.getCSS(a))})}})},color:function(a,b,c,d){var e=this,f,g=/^rgba/,h,i,j=Q;a&&a.linearGradient?i="gradient":a&&a.radialGradient&&(i="pattern");if(i){var k,l,m=a.linearGradient||a.radialGradient,q,p,n,t,H,r="",a=a.stops,v,s=[],u=function(){h=['<fill colors="'+s.join(",")+'" opacity="',
n,'" o:opacity2="',p,'" type="',i,'" ',r,'focus="100%" method="any" />'];T(e.prepVML(h),null,null,b)};q=a[0];v=a[a.length-1];q[0]>0&&a.unshift([0,q[1]]);v[0]<1&&a.push([1,v[1]]);o(a,function(a,b){g.test(a[1])?(f=qa(a[1]),k=f.get("rgb"),l=f.get("a")):(k=a[1],l=1);s.push(a[0]*100+"% "+k);b?(n=l,t=k):(p=l,H=k)});if(c==="fill")if(i==="gradient")c=m.x1||m[0]||0,a=m.y1||m[1]||0,q=m.x2||m[2]||0,m=m.y2||m[3]||0,r='angle="'+(90-K.atan((m-a)/(q-c))*180/Aa)+'"',u();else{var j=m.r,E=j*2,S=j*2,x=m.cx,A=m.cy,w=
b.radialReference,z,j=function(){w&&(z=d.getBBox(),x+=(w[0]-z.x)/z.width-0.5,A+=(w[1]-z.y)/z.height-0.5,E*=w[2]/z.width,S*=w[2]/z.height);r='src="'+N.global.VMLRadialGradientURL+'" size="'+E+","+S+'" origin="0.5,0.5" position="'+x+","+A+'" color2="'+H+'" ';u()};d.added?j():J(d,"add",j);j=t}else j=k}else if(g.test(a)&&b.tagName!=="IMG")f=qa(a),h=["<",c,' opacity="',f.get("a"),'"/>'],T(this.prepVML(h),null,null,b),j=f.get("rgb");else{j=b.getElementsByTagName(c);if(j.length)j[0].opacity=1;j=a}return j},
prepVML:function(a){var b=this.isIE8,a=a.join("");b?(a=a.replace("/>",' xmlns="urn:schemas-microsoft-com:vml" />'),a=a.indexOf('style="')===-1?a.replace("/>",' style="display:inline-block;behavior:url(#default#VML);" />'):a.replace('style="','style="display:inline-block;behavior:url(#default#VML);')):a=a.replace("<","<hcv:");return a},text:sa.prototype.html,path:function(a){var b={coordsize:"10 10"};Ia(a)?b.d=a:Y(a)&&x(b,a);return this.createElement("shape").attr(b)},circle:function(a,b,c){return this.symbol("circle").attr({x:a-
c,y:b-c,width:2*c,height:2*c})},g:function(a){var b;a&&(b={className:"highcharts-"+a,"class":"highcharts-"+a});return this.createElement(ga).attr(b)},image:function(a,b,c,d,e){var f=this.createElement("img").attr({src:a});arguments.length>1&&f.attr({x:b,y:c,width:d,height:e});return f},rect:function(a,b,c,d,e,f){if(Y(a))b=a.y,c=a.width,d=a.height,f=a.strokeWidth,a=a.x;var g=this.symbol("rect");g.r=e;return g.attr(g.crisp(f,a,b,s(c,0),s(d,0)))},invertChild:function(a,b){var c=b.style;I(a,{flip:"x",
left:z(c.width)-1,top:z(c.height)-1,rotation:-90})},symbols:{arc:function(a,b,c,d,e){var f=e.start,g=e.end,h=e.r||c||d,c=W(f),d=Z(f),i=W(g),j=Z(g),k=e.innerR,l=0.08/h,m=k&&0.1/k||0;if(g-f===0)return["x"];else 2*Aa-g+f<l?i=-l:g-f<m&&(i=W(f+m));f=["wa",a-h,b-h,a+h,b+h,a+h*c,b+h*d,a+h*i,b+h*j];e.open&&!k&&f.push("e","M",a,b);f.push("at",a-k,b-k,a+k,b+k,a+k*i,b+k*j,a+k*c,b+k*d,"x","e");return f},circle:function(a,b,c,d){return["wa",a,b,a+c,b+d,a+c,b+d/2,a+c,b+d/2,"e"]},rect:function(a,b,c,d,e){var f=
a+c,g=b+d,h;!r(e)||!e.r?f=sa.prototype.symbols.square.apply(0,arguments):(h=O(e.r,c,d),f=["M",a+h,b,"L",f-h,b,"wa",f-2*h,b,f,b+2*h,f-h,b,f,b+h,"L",f,g-h,"wa",f-2*h,g-2*h,f,g,f,g-h,f-h,g,"L",a+h,g,"wa",a,g-2*h,a+2*h,g,a+h,g,a,g-h,"L",a,b+h,"wa",a,b,a+2*h,b+2*h,a,b+h,a+h,b,"x","e"]);return f}}};ha=function(){this.init.apply(this,arguments)};ha.prototype=B(sa.prototype,fa);Sa=ha}var gb,Rb;if(V)gb=function(){oa="http://www.w3.org/1999/xhtml"},gb.prototype.symbols={},Rb=function(){function a(){var a=b.length,
d;for(d=0;d<a;d++)b[d]();b=[]}var b=[];return{push:function(c,d){b.length===0&&Tb(d,a);b.push(c)}}}();Sa=ha||gb||sa;Qa.prototype={addLabel:function(){var a=this.axis,b=a.options,c=a.chart,d=a.horiz,e=a.categories,f=this.pos,g=b.labels,h=a.tickPositions,d=e&&d&&e.length&&!g.step&&!g.staggerLines&&!g.rotation&&c.plotWidth/h.length||!d&&c.plotWidth/2,i=f===h[0],j=f===h[h.length-1],k=e&&r(e[f])?e[f]:f,e=this.label,h=h.info,l;a.isDatetimeAxis&&h&&(l=b.dateTimeLabelFormats[h.higherRanks[f]||h.unitName]);
this.isFirst=i;this.isLast=j;b=a.labelFormatter.call({axis:a,chart:c,isFirst:i,isLast:j,dateTimeLabelFormat:l,value:a.isLog?da(aa(k)):k});f=d&&{width:s(1,u(d-2*(g.padding||10)))+"px"};f=x(f,g.style);if(r(e))e&&e.attr({text:b}).css(f);else{d={align:g.align};if(Da(g.rotation))d.rotation=g.rotation;this.label=r(b)&&g.enabled?c.renderer.text(b,0,0,g.useHTML).attr(d).css(f).add(a.labelGroup):null}},getLabelSize:function(){var a=this.label,b=this.axis;return a?(this.labelBBox=a.getBBox())[b.horiz?"height":
"width"]:0},getLabelSides:function(){var a=this.axis.options.labels,b=this.labelBBox.width,a=b*{left:0,center:0.5,right:1}[a.align]-a.x;return[-a,b-a]},handleOverflow:function(a,b){var c=!0,d=this.axis,e=d.chart,f=this.isFirst,g=this.isLast,h=b.x,i=d.reversed,j=d.tickPositions;if(f||g){var k=this.getLabelSides(),l=k[0],k=k[1],e=e.plotLeft,m=e+d.len,j=(d=d.ticks[j[a+(f?1:-1)]])&&d.label.xy&&d.label.xy.x+d.getLabelSides()[f?0:1];f&&!i||g&&i?h+l<e&&(h=e-l,d&&h+k>j&&(c=!1)):h+k>m&&(h=m-k,d&&h+l<j&&(c=
!1));b.x=h}return c},getPosition:function(a,b,c,d){var e=this.axis,f=e.chart,g=d&&f.oldChartHeight||f.chartHeight;return{x:a?e.translate(b+c,null,null,d)+e.transB:e.left+e.offset+(e.opposite?(d&&f.oldChartWidth||f.chartWidth)-e.right-e.left:0),y:a?g-e.bottom+e.offset-(e.opposite?e.height:0):g-e.translate(b+c,null,null,d)-e.transB}},getLabelPosition:function(a,b,c,d,e,f,g,h){var i=this.axis,j=i.transA,k=i.reversed,i=i.staggerLines,a=a+e.x-(f&&d?f*j*(k?-1:1):0),b=b+e.y-(f&&!d?f*j*(k?1:-1):0);r(e.y)||
(b+=z(c.styles.lineHeight)*0.9-c.getBBox().height/2);i&&(b+=g/(h||1)%i*16);return{x:a,y:b}},getMarkPath:function(a,b,c,d,e,f){return f.crispLine(["M",a,b,"L",a+(e?0:-c),b+(e?c:0)],d)},render:function(a,b){var c=this.axis,d=c.options,e=c.chart.renderer,f=c.horiz,g=this.type,h=this.label,i=this.pos,j=d.labels,k=this.gridLine,l=g?g+"Grid":"grid",m=g?g+"Tick":"tick",q=d[l+"LineWidth"],p=d[l+"LineColor"],y=d[l+"LineDashStyle"],t=d[m+"Length"],l=d[m+"Width"]||0,o=d[m+"Color"],r=d[m+"Position"],m=this.mark,
v=j.step,s=!0,u=c.tickmarkOffset,E=this.getPosition(f,i,u,b),S=E.x,E=E.y,x=c.staggerLines;if(q){i=c.getPlotLinePath(i+u,q,b);if(k===A){k={stroke:p,"stroke-width":q};if(y)k.dashstyle=y;if(!g)k.zIndex=1;this.gridLine=k=q?e.path(i).attr(k).add(c.gridGroup):null}if(!b&&k&&i)k[this.isNew?"attr":"animate"]({d:i})}if(l&&t)r==="inside"&&(t=-t),c.opposite&&(t=-t),g=this.getMarkPath(S,E,t,l,f,e),m?m.animate({d:g}):this.mark=e.path(g).attr({stroke:o,"stroke-width":l}).add(c.axisGroup);if(h&&!isNaN(S))h.xy=E=
this.getLabelPosition(S,E,h,f,j,u,a,v),this.isFirst&&!n(d.showFirstLabel,1)||this.isLast&&!n(d.showLastLabel,1)?s=!1:!x&&f&&j.overflow==="justify"&&!this.handleOverflow(a,E)&&(s=!1),v&&a%v&&(s=!1),s?(h[this.isNew?"attr":"animate"](E),this.isNew=!1):h.attr("y",-9999)},destroy:function(){Ga(this,this.axis)}};nb.prototype={render:function(){var a=this,b=a.axis,c=b.horiz,d=(b.pointRange||0)/2,e=a.options,f=e.label,g=a.label,h=e.width,i=e.to,j=e.from,k=r(j)&&r(i),l=e.value,m=e.dashStyle,q=a.svgElem,p=
[],y,t=e.color,o=e.zIndex,u=e.events,v=b.chart.renderer;b.isLog&&(j=ka(j),i=ka(i),l=ka(l));if(h){if(p=b.getPlotLinePath(l,h),d={stroke:t,"stroke-width":h},m)d.dashstyle=m}else if(k){if(j=s(j,b.min-d),i=O(i,b.max+d),p=b.getPlotBandPath(j,i,e),d={fill:t},e.borderWidth)d.stroke=e.borderColor,d["stroke-width"]=e.borderWidth}else return;if(r(o))d.zIndex=o;if(q)p?q.animate({d:p},null,q.onGetPath):(q.hide(),q.onGetPath=function(){q.show()});else if(p&&p.length&&(a.svgElem=q=v.path(p).attr(d).add(),u))for(y in e=
function(b){q.on(b,function(c){u[b].apply(a,[c])})},u)e(y);if(f&&r(f.text)&&p&&p.length&&b.width>0&&b.height>0){f=B({align:c&&k&&"center",x:c?!k&&4:10,verticalAlign:!c&&k&&"middle",y:c?k?16:10:k?6:-4,rotation:c&&!k&&90},f);if(!g)a.label=g=v.text(f.text,0,0).attr({align:f.textAlign||f.align,rotation:f.rotation,zIndex:o}).css(f.style).add();b=[p[1],p[4],n(p[6],p[1])];p=[p[2],p[5],n(p[7],p[2])];c=Fa(b);k=Fa(p);g.align(f,!1,{x:c,y:k,width:wa(b)-c,height:wa(p)-k});g.show()}else g&&g.hide();return a},destroy:function(){ta(this.axis.plotLinesAndBands,
this);Ga(this,this.axis)}};Kb.prototype={destroy:function(){Ga(this,this.axis)},setTotal:function(a){this.cum=this.total=a},render:function(a){var b=this.options.formatter.call(this);this.label?this.label.attr({text:b,visibility:"hidden"}):this.label=this.axis.chart.renderer.text(b,0,0).css(this.options.style).attr({align:this.textAlign,rotation:this.options.rotation,visibility:"hidden"}).add(a)},setOffset:function(a,b){var c=this.axis,d=c.chart,e=d.inverted,f=this.isNegative,g=c.translate(this.percent?
100:this.total,0,0,0,1),c=c.translate(0),c=M(g-c),h=d.xAxis[0].translate(this.x)+a,i=d.plotHeight,f={x:e?f?g:g-c:h,y:e?i-h-b:f?i-g-c:i-g,width:e?c:b,height:e?b:c};if(e=this.label)e.align(this.alignOptions,null,f),f=e.alignAttr,e.attr({visibility:this.options.crop===!1||d.isInsidePlot(f.x,f.y)?ca?"inherit":"visible":"hidden"})}};ob.prototype={defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L",second:"%H:%M:%S",minute:"%H:%M",hour:"%H:%M",day:"%e. %b",week:"%e. %b",month:"%b '%y",year:"%Y"},
endOnTick:!1,gridLineColor:"#C0C0C0",labels:G,lineColor:"#C0D0E0",lineWidth:1,minPadding:0.01,maxPadding:0.01,minorGridLineColor:"#E0E0E0",minorGridLineWidth:1,minorTickColor:"#A0A0A0",minorTickLength:2,minorTickPosition:"outside",startOfWeek:1,startOnTick:!1,tickColor:"#C0D0E0",tickLength:5,tickmarkPlacement:"between",tickPixelInterval:100,tickPosition:"outside",tickWidth:1,title:{align:"middle",style:{color:"#6D869F",fontWeight:"bold"}},type:"linear"},defaultYAxisOptions:{endOnTick:!0,gridLineWidth:1,
tickPixelInterval:72,showLastLabel:!0,labels:{align:"right",x:-8,y:3},lineWidth:0,maxPadding:0.05,minPadding:0.05,startOnTick:!0,tickWidth:0,title:{rotation:270,text:"Y-values"},stackLabels:{enabled:!1,formatter:function(){return this.total},style:G.style}},defaultLeftAxisOptions:{labels:{align:"right",x:-8,y:null},title:{rotation:270}},defaultRightAxisOptions:{labels:{align:"left",x:8,y:null},title:{rotation:90}},defaultBottomAxisOptions:{labels:{align:"center",x:0,y:14},title:{rotation:0}},defaultTopAxisOptions:{labels:{align:"center",
x:0,y:-5},title:{rotation:0}},init:function(a,b){var c=b.isX;this.horiz=a.inverted?!c:c;this.xOrY=(this.isXAxis=c)?"x":"y";this.opposite=b.opposite;this.side=this.horiz?this.opposite?0:2:this.opposite?1:3;this.setOptions(b);var d=this.options,e=d.type,f=e==="datetime";this.labelFormatter=d.labels.formatter||this.defaultLabelFormatter;this.staggerLines=this.horiz&&d.labels.staggerLines;this.userOptions=b;this.minPixelPadding=0;this.chart=a;this.reversed=d.reversed;this.categories=d.categories;this.isLog=
e==="logarithmic";this.isLinked=r(d.linkedTo);this.isDatetimeAxis=f;this.tickmarkOffset=d.categories&&d.tickmarkPlacement==="between"?0.5:0;this.ticks={};this.minorTicks={};this.plotLinesAndBands=[];this.alternateBands={};this.len=0;this.minRange=this.userMinRange=d.minRange||d.maxZoom;this.range=d.range;this.offset=d.offset||0;this.stacks={};this.min=this.max=null;var g,d=this.options.events;a.axes.push(this);a[c?"xAxis":"yAxis"].push(this);this.series=[];if(a.inverted&&c&&this.reversed===A)this.reversed=
!0;this.removePlotLine=this.removePlotBand=this.removePlotBandOrLine;this.addPlotLine=this.addPlotBand=this.addPlotBandOrLine;for(g in d)J(this,g,d[g]);if(this.isLog)this.val2lin=ka,this.lin2val=aa},setOptions:function(a){this.options=B(this.defaultOptions,this.isXAxis?{}:this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],B(N[this.isXAxis?"xAxis":"yAxis"],a))},defaultLabelFormatter:function(){var a=
this.axis,b=this.value,c=this.dateTimeLabelFormat,d=N.lang.numericSymbols,e=d&&d.length,f,g=a.isLog?b:a.tickInterval;if(a.categories)f=b;else if(c)f=db(c,b);else if(e&&g>=1E3)for(;e--&&f===A;)a=Math.pow(1E3,e+1),g>=a&&d[e]!==null&&(f=Ja(b/a,-1)+d[e]);f===A&&(f=b>=1E3?Ja(b,0):Ja(b,-1));return f},getSeriesExtremes:function(){var a=this,b=a.chart,c=a.stacks,d=[],e=[],f;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=null;o(a.series,function(g){if(g.visible||!b.options.chart.ignoreHiddenSeries){var h=g.options,
i,j,k,l,m,q,p,y,t,o=h.threshold,u,v=[],x=0;a.hasVisibleSeries=!0;if(a.isLog&&o<=0)o=h.threshold=null;if(a.isXAxis){if(h=g.xData,h.length)a.dataMin=O(n(a.dataMin,h[0]),Fa(h)),a.dataMax=s(n(a.dataMax,h[0]),wa(h))}else{var z,E,S,w=g.cropped,B=g.xAxis.getExtremes(),C=!!g.modifyValue;i=h.stacking;a.usePercentage=i==="percent";if(i)m=h.stack,l=g.type+n(m,""),q="-"+l,g.stackKey=l,j=d[l]||[],d[l]=j,k=e[q]||[],e[q]=k;if(a.usePercentage)a.dataMin=0,a.dataMax=99;h=g.processedXData;p=g.processedYData;u=p.length;
for(f=0;f<u;f++)if(y=h[f],t=p[f],i&&(E=(z=t<o)?k:j,S=z?q:l,r(E[y])?(E[y]=da(E[y]+t),t=[t,E[y]]):E[y]=t,c[S]||(c[S]={}),c[S][y]||(c[S][y]=new Kb(a,a.options.stackLabels,z,y,m,i)),c[S][y].setTotal(E[y])),t!==null&&t!==A&&(C&&(t=g.modifyValue(t)),w||(h[f+1]||y)>=B.min&&(h[f-1]||y)<=B.max))if(y=t.length)for(;y--;)t[y]!==null&&(v[x++]=t[y]);else v[x++]=t;if(!a.usePercentage&&v.length)a.dataMin=O(n(a.dataMin,v[0]),Fa(v)),a.dataMax=s(n(a.dataMax,v[0]),wa(v));if(r(o))if(a.dataMin>=o)a.dataMin=o,a.ignoreMinPadding=
!0;else if(a.dataMax<o)a.dataMax=o,a.ignoreMaxPadding=!0}}})},translate:function(a,b,c,d,e,f){var g=this.len,h=1,i=0,j=d?this.oldTransA:this.transA,d=d?this.oldMin:this.min,e=this.options.ordinal||this.isLog&&e;if(!j)j=this.transA;c&&(h*=-1,i=g);this.reversed&&(h*=-1,i-=h*g);b?(this.reversed&&(a=g-a),a=a/j+d,e&&(a=this.lin2val(a))):(e&&(a=this.val2lin(a)),a=h*(a-d)*j+i+h*this.minPixelPadding+(f?j*this.pointRange/2:0));return a},getPlotLinePath:function(a,b,c){var d=this.chart,e=this.left,f=this.top,
g,h,i,a=this.translate(a,null,null,c),j=c&&d.oldChartHeight||d.chartHeight,k=c&&d.oldChartWidth||d.chartWidth,l;g=this.transB;c=h=u(a+g);g=i=u(j-a-g);if(isNaN(a))l=!0;else if(this.horiz){if(g=f,i=j-this.bottom,c<e||c>e+this.width)l=!0}else if(c=e,h=k-this.right,g<f||g>f+this.height)l=!0;return l?null:d.renderer.crispLine(["M",c,g,"L",h,i],b||0)},getPlotBandPath:function(a,b){var c=this.getPlotLinePath(b),d=this.getPlotLinePath(a);d&&c?d.push(c[4],c[5],c[1],c[2]):d=null;return d},getLinearTickPositions:function(a,
b,c){for(var d,b=da(U(b/a)*a),c=da(za(c/a)*a),e=[];b<=c;){e.push(b);b=da(b+a);if(b===d)break;d=b}return e},getLogTickPositions:function(a,b,c,d){var e=this.options,f=this.len,g=[];if(!d)this._minorAutoInterval=null;if(a>=0.5)a=u(a),g=this.getLinearTickPositions(a,b,c);else if(a>=0.08)for(var f=U(b),h,i,j,k,l,e=a>0.3?[1,2,4]:a>0.15?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];f<c+1&&!l;f++){i=e.length;for(h=0;h<i&&!l;h++)j=ka(aa(f)*e[h]),j>b&&g.push(k),k>c&&(l=!0),k=j}else if(b=aa(b),c=aa(c),a=e[d?"minorTickInterval":
"tickInterval"],a=n(a==="auto"?null:a,this._minorAutoInterval,(c-b)*(e.tickPixelInterval/(d?5:1))/((d?f/this.tickPositions.length:f)||1)),a=hb(a,null,K.pow(10,U(K.log(a)/K.LN10))),g=Ta(this.getLinearTickPositions(a,b,c),ka),!d)this._minorAutoInterval=a/5;if(!d)this.tickInterval=a;return g},getMinorTickPositions:function(){var a=this.options,b=this.tickPositions,c=this.minorTickInterval,d=[],e;if(this.isLog){e=b.length;for(a=1;a<e;a++)d=d.concat(this.getLogTickPositions(c,b[a-1],b[a],!0))}else if(this.isDatetimeAxis&&
a.minorTickInterval==="auto")d=d.concat(Cb(Ab(c),this.min,this.max,a.startOfWeek));else for(b=this.min+(b[0]-this.min)%c;b<=this.max;b+=c)d.push(b);return d},adjustForMinRange:function(){var a=this.options,b=this.min,c=this.max,d,e=this.dataMax-this.dataMin>=this.minRange,f,g,h,i,j;if(this.isXAxis&&this.minRange===A&&!this.isLog)r(a.min)||r(a.max)?this.minRange=null:(o(this.series,function(a){i=a.xData;for(g=j=a.xIncrement?1:i.length-1;g>0;g--)if(h=i[g]-i[g-1],f===A||h<f)f=h}),this.minRange=O(f*5,
this.dataMax-this.dataMin));if(c-b<this.minRange){var k=this.minRange;d=(k-c+b)/2;d=[b-d,n(a.min,b-d)];if(e)d[2]=this.dataMin;b=wa(d);c=[b+k,n(a.max,b+k)];if(e)c[2]=this.dataMax;c=Fa(c);c-b<k&&(d[0]=c-k,d[1]=n(a.min,c-k),b=wa(d))}this.min=b;this.max=c},setAxisTranslation:function(){var a=this.max-this.min,b=0,c,d=0,e=0,f=this.linkedParent,g=this.transA;if(this.isXAxis)f?(d=f.minPointOffset,e=f.pointRangePadding):o(this.series,function(a){var f=a.pointRange,g=a.options.pointPlacement,k=a.closestPointRange;
b=s(b,f);d=s(d,g?0:f/2);e=s(e,g==="on"?0:f);!a.noSharedTooltip&&r(k)&&(c=r(c)?O(c,k):k)}),this.minPointOffset=d,this.pointRangePadding=e,this.pointRange=b,this.closestPointRange=c;this.oldTransA=g;this.translationSlope=this.transA=g=this.len/(a+e||1);this.transB=this.horiz?this.left:this.bottom;this.minPixelPadding=g*d},setTickPositions:function(a){var b=this,c=b.chart,d=b.options,e=b.isLog,f=b.isDatetimeAxis,g=b.isXAxis,h=b.isLinked,i=b.options.tickPositioner,j=d.maxPadding,k=d.minPadding,l=d.tickInterval,
m=d.minTickInterval,q=d.tickPixelInterval,p=b.categories;h?(b.linkedParent=c[g?"xAxis":"yAxis"][d.linkedTo],c=b.linkedParent.getExtremes(),b.min=n(c.min,c.dataMin),b.max=n(c.max,c.dataMax),d.type!==b.linkedParent.options.type&&Oa(11,1)):(b.min=n(b.userMin,d.min,b.dataMin),b.max=n(b.userMax,d.max,b.dataMax));if(e)!a&&O(b.min,n(b.dataMin,b.min))<=0&&Oa(10,1),b.min=da(ka(b.min)),b.max=da(ka(b.max));if(b.range&&(b.userMin=b.min=s(b.min,b.max-b.range),b.userMax=b.max,a))b.range=null;b.adjustForMinRange();
if(!p&&!b.usePercentage&&!h&&r(b.min)&&r(b.max)&&(c=b.max-b.min)){if(!r(d.min)&&!r(b.userMin)&&k&&(b.dataMin<0||!b.ignoreMinPadding))b.min-=c*k;if(!r(d.max)&&!r(b.userMax)&&j&&(b.dataMax>0||!b.ignoreMaxPadding))b.max+=c*j}b.tickInterval=b.min===b.max||b.min===void 0||b.max===void 0?1:h&&!l&&q===b.linkedParent.options.tickPixelInterval?b.linkedParent.tickInterval:n(l,p?1:(b.max-b.min)*q/(b.len||1));g&&!a&&o(b.series,function(a){a.processData(b.min!==b.oldMin||b.max!==b.oldMax)});b.setAxisTranslation(a);
b.beforeSetTickPositions&&b.beforeSetTickPositions();if(b.postProcessTickInterval)b.tickInterval=b.postProcessTickInterval(b.tickInterval);if(!l&&b.tickInterval<m)b.tickInterval=m;if(!f&&!e&&(a=K.pow(10,U(K.log(b.tickInterval)/K.LN10)),!l))b.tickInterval=hb(b.tickInterval,null,a,d);b.minorTickInterval=d.minorTickInterval==="auto"&&b.tickInterval?b.tickInterval/5:d.minorTickInterval;b.tickPositions=i=d.tickPositions||i&&i.apply(b,[b.min,b.max]);if(!i)i=f?(b.getNonLinearTimeTicks||Cb)(Ab(b.tickInterval,
d.units),b.min,b.max,d.startOfWeek,b.ordinalPositions,b.closestPointRange,!0):e?b.getLogTickPositions(b.tickInterval,b.min,b.max):b.getLinearTickPositions(b.tickInterval,b.min,b.max),b.tickPositions=i;if(!h)e=i[0],f=i[i.length-1],h=b.minPointOffset||0,d.startOnTick?b.min=e:b.min-h>e&&i.shift(),d.endOnTick?b.max=f:b.max+h<f&&i.pop(),i.length===1&&(b.min-=1.0E-9,b.max+=1.0E-9)},setMaxTicks:function(){var a=this.chart,b=a.maxTicks,c=this.tickPositions,d=this.xOrY;b||(b={x:0,y:0});if(!this.isLinked&&
!this.isDatetimeAxis&&c.length>b[d]&&this.options.alignTicks!==!1)b[d]=c.length;a.maxTicks=b},adjustTickAmount:function(){var a=this.xOrY,b=this.tickPositions,c=this.chart.maxTicks;if(c&&c[a]&&!this.isDatetimeAxis&&!this.categories&&!this.isLinked&&this.options.alignTicks!==!1){var d=this.tickAmount,e=b.length;this.tickAmount=a=c[a];if(e<a){for(;b.length<a;)b.push(da(b[b.length-1]+this.tickInterval));this.transA*=(e-1)/(a-1);this.max=b[b.length-1]}if(r(d)&&a!==d)this.isDirty=!0}},setScale:function(){var a=
this.stacks,b,c,d,e;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();e=this.len!==this.oldAxisLength;o(this.series,function(a){if(a.isDirtyData||a.isDirty||a.xAxis.isDirty)d=!0});if(e||d||this.isLinked||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax)if(this.getSeriesExtremes(),this.setTickPositions(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,!this.isDirty)this.isDirty=e||this.min!==this.oldMin||this.max!==this.oldMax;if(!this.isXAxis)for(b in a)for(c in a[b])a[b][c].cum=
a[b][c].total;this.setMaxTicks()},setExtremes:function(a,b,c,d,e){var f=this,g=f.chart,c=n(c,!0),e=x(e,{min:a,max:b});F(f,"setExtremes",e,function(){f.userMin=a;f.userMax=b;f.isDirtyExtremes=!0;c&&g.redraw(d)})},zoom:function(a,b){this.setExtremes(a,b,!1,A,{trigger:"zoom"});return!0},setAxisSize:function(){var a=this.chart,b=this.options,c=b.offsetLeft||0,d=b.offsetRight||0;this.left=n(b.left,a.plotLeft+c);this.top=n(b.top,a.plotTop);this.width=n(b.width,a.plotWidth-c+d);this.height=n(b.height,a.plotHeight);
this.bottom=a.chartHeight-this.height-this.top;this.right=a.chartWidth-this.width-this.left;this.len=s(this.horiz?this.width:this.height,0)},getExtremes:function(){var a=this.isLog;return{min:a?da(aa(this.min)):this.min,max:a?da(aa(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,c=b?aa(this.min):this.min,b=b?aa(this.max):this.max;c>a||a===null?a=c:b<a&&(a=b);return this.translate(a,0,1,0,1)},addPlotBandOrLine:function(a){a=
(new nb(this,a)).render();this.plotLinesAndBands.push(a);return a},getOffset:function(){var a=this,b=a.chart,c=b.renderer,d=a.options,e=a.tickPositions,f=a.ticks,g=a.horiz,h=a.side,i,j=0,k,l=0,m=d.title,q=d.labels,p=0,y=b.axisOffset,t=[-1,1,1,-1][h],H;a.hasData=b=a.hasVisibleSeries||r(a.min)&&r(a.max)&&!!e;a.showAxis=i=b||n(d.showEmpty,!0);if(!a.axisGroup)a.gridGroup=c.g("grid").attr({zIndex:d.gridZIndex||1}).add(),a.axisGroup=c.g("axis").attr({zIndex:d.zIndex||2}).add(),a.labelGroup=c.g("axis-labels").attr({zIndex:q.zIndex||
7}).add();if(b||a.isLinked)o(e,function(b){f[b]?f[b].addLabel():f[b]=new Qa(a,b)}),o(e,function(a){if(h===0||h===2||{1:"left",3:"right"}[h]===q.align)p=s(f[a].getLabelSize(),p)}),a.staggerLines&&(p+=(a.staggerLines-1)*16);else for(H in f)f[H].destroy(),delete f[H];if(m&&m.text){if(!a.axisTitle)a.axisTitle=c.text(m.text,0,0,m.useHTML).attr({zIndex:7,rotation:m.rotation||0,align:m.textAlign||{low:"left",middle:"center",high:"right"}[m.align]}).css(m.style).add(a.axisGroup),a.axisTitle.isNew=!0;if(i)j=
a.axisTitle.getBBox()[g?"height":"width"],l=n(m.margin,g?5:10),k=m.offset;a.axisTitle[i?"show":"hide"]()}a.offset=t*n(d.offset,y[h]);a.axisTitleMargin=n(k,p+l+(h!==2&&p&&t*d.labels[g?"y":"x"]));y[h]=s(y[h],a.axisTitleMargin+j+t*a.offset)},getLinePath:function(a){var b=this.chart,c=this.opposite,d=this.offset,e=this.horiz,f=this.left+(c?this.width:0)+d;this.lineTop=c=b.chartHeight-this.bottom-(c?this.height:0)+d;return b.renderer.crispLine(["M",e?this.left:f,e?c:this.top,"L",e?b.chartWidth-this.right:
f,e?c:b.chartHeight-this.bottom],a)},getTitlePosition:function(){var a=this.horiz,b=this.left,c=this.top,d=this.len,e=this.options.title,f=a?b:c,g=this.opposite,h=this.offset,i=z(e.style.fontSize||12),d={low:f+(a?0:d),middle:f+d/2,high:f+(a?d:0)}[e.align],b=(a?c+this.height:b)+(a?1:-1)*(g?-1:1)*this.axisTitleMargin+(this.side===2?i:0);return{x:a?d:b+(g?this.width:0)+h+(e.x||0),y:a?b-(g?this.height:0)+h:d+(e.y||0)}},render:function(){var a=this,b=a.chart,c=b.renderer,d=a.options,e=a.isLog,f=a.isLinked,
g=a.tickPositions,h=a.axisTitle,i=a.stacks,j=a.ticks,k=a.minorTicks,l=a.alternateBands,m=d.stackLabels,q=d.alternateGridColor,p=a.tickmarkOffset,n=d.lineWidth,t,H=b.hasRendered&&r(a.oldMin)&&!isNaN(a.oldMin),u=a.showAxis,v,s;if(a.hasData||f)if(a.minorTickInterval&&!a.categories&&o(a.getMinorTickPositions(),function(b){k[b]||(k[b]=new Qa(a,b,"minor"));H&&k[b].isNew&&k[b].render(null,!0);k[b].isActive=!0;k[b].render()}),g.length&&o(g.slice(1).concat([g[0]]),function(b,c){c=c===g.length-1?0:c+1;if(!f||
b>=a.min&&b<=a.max)j[b]||(j[b]=new Qa(a,b)),H&&j[b].isNew&&j[b].render(c,!0),j[b].isActive=!0,j[b].render(c)}),q&&o(g,function(b,c){if(c%2===0&&b<a.max)l[b]||(l[b]=new nb(a)),v=b+p,s=g[c+1]!==A?g[c+1]+p:a.max,l[b].options={from:e?aa(v):v,to:e?aa(s):s,color:q},l[b].render(),l[b].isActive=!0}),!a._addedPlotLB)o((d.plotLines||[]).concat(d.plotBands||[]),function(b){a.addPlotBandOrLine(b)}),a._addedPlotLB=!0;o([j,k,l],function(a){for(var b in a)a[b].isActive?a[b].isActive=!1:(a[b].destroy(),delete a[b])});
if(n)t=a.getLinePath(n),a.axisLine?a.axisLine.animate({d:t}):a.axisLine=c.path(t).attr({stroke:d.lineColor,"stroke-width":n,zIndex:7}).add(a.axisGroup),a.axisLine[u?"show":"hide"]();if(h&&u)h[h.isNew?"attr":"animate"](a.getTitlePosition()),h.isNew=!1;if(m&&m.enabled){var x,E,d=a.stackTotalGroup;if(!d)a.stackTotalGroup=d=c.g("stack-labels").attr({visibility:"visible",zIndex:6}).add();d.translate(b.plotLeft,b.plotTop);for(x in i)for(E in b=i[x],b)b[E].render(d)}a.isDirty=!1},removePlotBandOrLine:function(a){for(var b=
this.plotLinesAndBands,c=b.length;c--;)b[c].id===a&&b[c].destroy()},setTitle:function(a,b){var c=this.chart,d=this.options,e=this.axisTitle;d.title=B(d.title,a);this.axisTitle=e&&e.destroy();this.isDirty=!0;n(b,!0)&&c.redraw()},redraw:function(){var a=this.chart;a.tracker.resetTracker&&a.tracker.resetTracker(!0);this.render();o(this.plotLinesAndBands,function(a){a.render()});o(this.series,function(a){a.isDirty=!0})},setCategories:function(a,b){var c=this.chart;this.categories=this.userOptions.categories=
a;o(this.series,function(a){a.translate();a.setTooltipPoints(!0)});this.isDirty=!0;n(b,!0)&&c.redraw()},destroy:function(){var a=this,b=a.stacks,c;R(a);for(c in b)Ga(b[c]),b[c]=null;o([a.ticks,a.minorTicks,a.alternateBands,a.plotLinesAndBands],function(a){Ga(a)});o("stackTotalGroup,axisLine,axisGroup,gridGroup,labelGroup,axisTitle".split(","),function(b){a[b]&&(a[b]=a[b].destroy())})}};pb.prototype={destroy:function(){o(this.crosshairs,function(a){a&&a.destroy()});if(this.label)this.label=this.label.destroy()},
move:function(a,b,c,d){var e=this,f=e.now,g=e.options.animation!==!1&&!e.isHidden;x(f,{x:g?(2*f.x+a)/3:a,y:g?(f.y+b)/2:b,anchorX:g?(2*f.anchorX+c)/3:c,anchorY:g?(f.anchorY+d)/2:d});e.label.attr(f);if(g&&(M(a-f.x)>1||M(b-f.y)>1))clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){e&&e.move(a,b,c,d)},32)},hide:function(){if(!this.isHidden){var a=this.chart.hoverPoints;this.label.hide();a&&o(a,function(a){a.setState()});this.chart.hoverPoints=null;this.isHidden=!0}},hideCrosshairs:function(){o(this.crosshairs,
function(a){a&&a.hide()})},getAnchor:function(a,b){var c,d=this.chart,e=d.inverted,f=0,g=0,h,a=la(a);c=a[0].tooltipPos;c||(o(a,function(a){h=a.series.yAxis;f+=a.plotX;g+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!e&&h?h.top-d.plotTop:0)}),f/=a.length,g/=a.length,c=[e?d.plotWidth-g:f,this.shared&&!e&&a.length>1&&b?b.chartY-d.plotTop:e?d.plotHeight-f:g]);return Ta(c,u)},getPosition:function(a,b,c){var d=this.chart,e=d.plotLeft,f=d.plotTop,g=d.plotWidth,h=d.plotHeight,i=n(this.options.distance,12),
j=c.plotX,c=c.plotY,d=j+e+(d.inverted?i:-a-i),k=c-b+f+15,l;d<7&&(d=e+s(j,0)+i);d+a>e+g&&(d-=d+a-(e+g),k=c-b+f-i,l=!0);k<f+5&&(k=f+5,l&&c>=k&&c<=k+b&&(k=c+f+i));k+b>f+h&&(k=s(f,f+h-b-i));return{x:d,y:k}},refresh:function(a,b){function c(){var a=this.points||la(this),b=a[0].series,c;c=[b.tooltipHeaderFormatter(a[0].key)];o(a,function(a){b=a.series;c.push(b.tooltipFormatter&&b.tooltipFormatter(a)||a.point.tooltipFormatter(b.tooltipOptions.pointFormat))});c.push(f.footerFormat||"");return c.join("")}
var d=this.chart,e=this.label,f=this.options,g,h,i,j={},k,l=[];k=f.formatter||c;var j=d.hoverPoints,m,q=f.crosshairs;i=this.shared;h=this.getAnchor(a,b);g=h[0];h=h[1];i&&(!a.series||!a.series.noSharedTooltip)?(d.hoverPoints=a,j&&o(j,function(a){a.setState()}),o(a,function(a){a.setState("hover");l.push(a.getLabelConfig())}),j={x:a[0].category,y:a[0].y},j.points=l,a=a[0]):j=a.getLabelConfig();k=k.call(j);j=a.series;i=i||!j.isCartesian||j.tooltipOutsidePlot||d.isInsidePlot(g,h);k===!1||!i?this.hide():
(this.isHidden&&e.show(),e.attr({text:k}),m=f.borderColor||a.color||j.color||"#606060",e.attr({stroke:m}),e=(f.positioner||this.getPosition).call(this,e.width,e.height,{plotX:g,plotY:h}),this.move(u(e.x),u(e.y),g+d.plotLeft,h+d.plotTop),this.isHidden=!1);if(q){q=la(q);for(e=q.length;e--;)if(i=a.series[e?"yAxis":"xAxis"],q[e]&&i)if(i=i.getPlotLinePath(e?n(a.stackY,a.y):a.x,1),this.crosshairs[e])this.crosshairs[e].attr({d:i,visibility:"visible"});else{j={"stroke-width":q[e].width||1,stroke:q[e].color||
"#C0C0C0",zIndex:q[e].zIndex||2};if(q[e].dashStyle)j.dashstyle=q[e].dashStyle;this.crosshairs[e]=d.renderer.path(i).attr(j).add()}}F(d,"tooltipRefresh",{text:k,x:g+d.plotLeft,y:h+d.plotTop,borderColor:m})}};qb.prototype={normalizeMouseEvent:function(a){var b,c,d,a=a||L.event;if(!a.target)a.target=a.srcElement;a=Pb(a);d=a.touches?a.touches.item(0):a;this.chartPosition=b=Vb(this.chart.container);d.pageX===A?(c=a.x,b=a.y):(c=d.pageX-b.left,b=d.pageY-b.top);return x(a,{chartX:u(c),chartY:u(b)})},getMouseCoordinates:function(a){var b=
{xAxis:[],yAxis:[]},c=this.chart;o(c.axes,function(d){var e=d.isXAxis;b[e?"xAxis":"yAxis"].push({axis:d,value:d.translate(((c.inverted?!e:e)?a.chartX-c.plotLeft:d.top+d.len-a.chartY)-d.minPixelPadding,!0)})});return b},getIndex:function(a){var b=this.chart;return b.inverted?b.plotHeight+b.plotTop-a.chartY:a.chartX-b.plotLeft},onmousemove:function(a){var b=this.chart,c=b.series,d=b.tooltip,e,f=b.hoverPoint,g=b.hoverSeries,h,i,j=b.chartWidth,k=this.getIndex(a);if(d&&this.options.tooltip.shared&&(!g||
!g.noSharedTooltip)){e=[];h=c.length;for(i=0;i<h;i++)if(c[i].visible&&c[i].options.enableMouseTracking!==!1&&!c[i].noSharedTooltip&&c[i].tooltipPoints&&c[i].tooltipPoints.length)b=c[i].tooltipPoints[k],b._dist=M(k-b[c[i].xAxis.tooltipPosName||"plotX"]),j=O(j,b._dist),e.push(b);for(h=e.length;h--;)e[h]._dist>j&&e.splice(h,1);if(e.length&&e[0].plotX!==this.hoverX)d.refresh(e,a),this.hoverX=e[0].plotX}if(g&&g.tracker&&(b=g.tooltipPoints[k])&&b!==f)b.onMouseOver()},resetTracker:function(a){var b=this.chart,
c=b.hoverSeries,d=b.hoverPoint,e=b.tooltip,b=e&&e.shared?b.hoverPoints:d;(a=a&&e&&b)&&la(b)[0].plotX===A&&(a=!1);if(a)e.refresh(b);else{if(d)d.onMouseOut();if(c)c.onMouseOut();e&&(e.hide(),e.hideCrosshairs());this.hoverX=null}},setDOMEvents:function(){function a(){if(b.selectionMarker){var f={xAxis:[],yAxis:[]},g=b.selectionMarker.getBBox(),h=g.x-c.plotLeft,l=g.y-c.plotTop,m;e&&(o(c.axes,function(a){if(a.options.zoomEnabled!==!1){var b=a.isXAxis,d=c.inverted?!b:b,e=a.translate(d?h:c.plotHeight-l-
g.height,!0,0,0,1),d=a.translate((d?h+g.width:c.plotHeight-l)-2*a.minPixelPadding,!0,0,0,1);!isNaN(e)&&!isNaN(d)&&(f[b?"xAxis":"yAxis"].push({axis:a,min:O(e,d),max:s(e,d)}),m=!0)}}),m&&F(c,"selection",f,function(a){c.zoom(a)}));b.selectionMarker=b.selectionMarker.destroy()}if(c)I(d,{cursor:"auto"}),c.cancelClick=e,c.mouseIsDown=e=!1;R(C,"mouseup",a);Ba&&R(C,"touchend",a)}var b=this,c=b.chart,d=c.container,e,f=b.zoomX&&!c.inverted||b.zoomY&&c.inverted,g=b.zoomY&&!c.inverted||b.zoomX&&c.inverted;b.hideTooltipOnMouseMove=
function(a){a=Pb(a);b.chartPosition&&c.hoverSeries&&c.hoverSeries.isCartesian&&!c.isInsidePlot(a.pageX-b.chartPosition.left-c.plotLeft,a.pageY-b.chartPosition.top-c.plotTop)&&b.resetTracker()};b.hideTooltipOnMouseLeave=function(){b.resetTracker();b.chartPosition=null};d.onmousedown=function(d){d=b.normalizeMouseEvent(d);d.type.indexOf("touch")===-1&&d.preventDefault&&d.preventDefault();c.mouseIsDown=!0;c.cancelClick=!1;c.mouseDownX=b.mouseDownX=d.chartX;b.mouseDownY=d.chartY;J(C,"mouseup",a);Ba&&
J(C,"touchend",a)};var h=function(a){if(!a||!(a.touches&&a.touches.length>1)){var a=b.normalizeMouseEvent(a),d=a.type,h=a.chartX,l=a.chartY,m=!c.isInsidePlot(h-c.plotLeft,l-c.plotTop);if(d.indexOf("touch")===-1)a.returnValue=!1;d==="touchstart"&&(w(a.target,"isTracker")?c.runTrackerClick||a.preventDefault():!c.runChartClick&&!m&&a.preventDefault());if(m)h<c.plotLeft?h=c.plotLeft:h>c.plotLeft+c.plotWidth&&(h=c.plotLeft+c.plotWidth),l<c.plotTop?l=c.plotTop:l>c.plotTop+c.plotHeight&&(l=c.plotTop+c.plotHeight);
if(c.mouseIsDown&&d!=="touchstart"&&(e=Math.sqrt(Math.pow(b.mouseDownX-h,2)+Math.pow(b.mouseDownY-l,2)),e>10)){d=c.isInsidePlot(b.mouseDownX-c.plotLeft,b.mouseDownY-c.plotTop);if(c.hasCartesianSeries&&(b.zoomX||b.zoomY)&&d&&!b.selectionMarker)b.selectionMarker=c.renderer.rect(c.plotLeft,c.plotTop,f?1:c.plotWidth,g?1:c.plotHeight,0).attr({fill:b.options.chart.selectionMarkerFill||"rgba(69,114,167,0.25)",zIndex:7}).add();if(b.selectionMarker&&f){var q=h-b.mouseDownX;b.selectionMarker.attr({width:M(q),
x:(q>0?0:q)+b.mouseDownX})}b.selectionMarker&&g&&(l-=b.mouseDownY,b.selectionMarker.attr({height:M(l),y:(l>0?0:l)+b.mouseDownY}));d&&!b.selectionMarker&&b.options.chart.panning&&c.pan(h)}if(!m)b.onmousemove(a);return m||!c.hasCartesianSeries}};if(!/Android 4\.0/.test(na))d.onmousemove=h;J(d,"mouseleave",b.hideTooltipOnMouseLeave);Ba||J(C,"mousemove",b.hideTooltipOnMouseMove);d.ontouchstart=function(a){if(b.zoomX||b.zoomY)d.onmousedown(a);h(a)};d.ontouchmove=h;d.ontouchend=function(){e&&b.resetTracker()};
d.onclick=function(a){var d=c.hoverPoint,e,f,a=b.normalizeMouseEvent(a);a.cancelBubble=!0;if(!c.cancelClick)d&&(w(a.target,"isTracker")||w(a.target.parentNode,"isTracker"))?(e=d.plotX,f=d.plotY,x(d,{pageX:b.chartPosition.left+c.plotLeft+(c.inverted?c.plotWidth-f:e),pageY:b.chartPosition.top+c.plotTop+(c.inverted?c.plotHeight-e:f)}),F(d.series,"click",x(a,{point:d})),d.firePointEvent("click",a)):(x(a,b.getMouseCoordinates(a)),c.isInsidePlot(a.chartX-c.plotLeft,a.chartY-c.plotTop)&&F(c,"click",a))}},
destroy:function(){var a=this.chart,b=a.container;if(a.trackerGroup)a.trackerGroup=a.trackerGroup.destroy();R(b,"mouseleave",this.hideTooltipOnMouseLeave);R(C,"mousemove",this.hideTooltipOnMouseMove);b.onclick=b.onmousedown=b.onmousemove=b.ontouchstart=b.ontouchend=b.ontouchmove=null;clearInterval(this.tooltipTimeout)},init:function(a,b){if(!a.trackerGroup)a.trackerGroup=a.renderer.g("tracker").attr({zIndex:9}).add();if(b.enabled)a.tooltip=new pb(a,b);this.setDOMEvents()}};rb.prototype={init:function(a){var b=
this,c=b.options=a.options.legend;if(c.enabled){var d=c.itemStyle,e=n(c.padding,8),f=c.itemMarginTop||0;b.baseline=z(d.fontSize)+3+f;b.itemStyle=d;b.itemHiddenStyle=B(d,c.itemHiddenStyle);b.itemMarginTop=f;b.padding=e;b.initialItemX=e;b.initialItemY=e-5;b.maxItemWidth=0;b.chart=a;b.itemHeight=0;b.lastLineHeight=0;b.render();J(b.chart,"endResize",function(){b.positionCheckboxes()})}},colorizeItem:function(a,b){var c=this.options,d=a.legendItem,e=a.legendLine,f=a.legendSymbol,g=this.itemHiddenStyle.color,
c=b?c.itemStyle.color:g,h=b?a.color:g,g=a.options&&a.options.marker,i={stroke:h,fill:h},j;d&&d.css({fill:c});e&&e.attr({stroke:h});if(f){if(g)for(j in g=a.convertAttribs(g),g)d=g[j],d!==A&&(i[j]=d);f.attr(i)}},positionItem:function(a){var b=this.options,c=b.symbolPadding,b=!b.rtl,d=a._legendItemPos,e=d[0],d=d[1],f=a.checkbox;a.legendGroup&&a.legendGroup.translate(b?e:this.legendWidth-e-2*c-4,d);if(f)f.x=e,f.y=d},destroyItem:function(a){var b=a.checkbox;o(["legendItem","legendLine","legendSymbol",
"legendGroup"],function(b){a[b]&&a[b].destroy()});b&&Na(a.checkbox)},destroy:function(){var a=this.group,b=this.box;if(b)this.box=b.destroy();if(a)this.group=a.destroy()},positionCheckboxes:function(a){var b=this.group.alignAttr,c,d=this.clipHeight||this.legendHeight;if(b)c=b.translateY,o(this.allItems,function(e){var f=e.checkbox,g;f&&(g=c+f.y+(a||0)+3,I(f,{left:b.translateX+e.legendItemWidth+f.x-20+"px",top:g+"px",display:g>c-6&&g<c+d-6?"":Q}))})},renderItem:function(a){var p;var b=this,c=b.chart,
d=c.renderer,e=b.options,f=e.layout==="horizontal",g=e.symbolWidth,h=e.symbolPadding,i=b.itemStyle,j=b.itemHiddenStyle,k=b.padding,l=!e.rtl,m=e.width,q=e.itemMarginBottom||0,n=b.itemMarginTop,o=b.initialItemX,t=a.legendItem,r=a.series||a,u=r.options,v=u.showCheckbox,x=e.useHTML;if(!t&&(a.legendGroup=d.g("legend-item").attr({zIndex:1}).add(b.scrollGroup),r.drawLegendSymbol(b,a),a.legendItem=t=d.text(e.labelFormatter.call(a),l?g+h:-h,b.baseline,x).css(B(a.visible?i:j)).attr({align:l?"left":"right",
zIndex:2}).add(a.legendGroup),(x?t:a.legendGroup).on("mouseover",function(){a.setState("hover");t.css(b.options.itemHoverStyle)}).on("mouseout",function(){t.css(a.visible?i:j);a.setState()}).on("click",function(b){var c=function(){a.setVisible()},b={browserEvent:b};a.firePointEvent?a.firePointEvent("legendItemClick",b,c):F(a,"legendItemClick",b,c)}),b.colorizeItem(a,a.visible),u&&v))a.checkbox=T("input",{type:"checkbox",checked:a.selected,defaultChecked:a.selected},e.itemCheckboxStyle,c.container),
J(a.checkbox,"click",function(b){F(a,"checkboxClick",{checked:b.target.checked},function(){a.select()})});d=t.getBBox();p=a.legendItemWidth=e.itemWidth||g+h+d.width+k+(v?20:0),e=p;b.itemHeight=g=d.height;if(f&&b.itemX-o+e>(m||c.chartWidth-2*k-o))b.itemX=o,b.itemY+=n+b.lastLineHeight+q,b.lastLineHeight=0;b.maxItemWidth=s(b.maxItemWidth,e);b.lastItemY=n+b.itemY+q;b.lastLineHeight=s(g,b.lastLineHeight);a._legendItemPos=[b.itemX,b.itemY];f?b.itemX+=e:(b.itemY+=n+g+q,b.lastLineHeight=g);b.offsetWidth=
m||s(f?b.itemX-o:e,b.offsetWidth)},render:function(){var a=this,b=a.chart,c=b.renderer,d=a.group,e,f,g,h,i=a.box,j=a.options,k=a.padding,l=j.borderWidth,m=j.backgroundColor;a.itemX=a.initialItemX;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;if(!d)a.group=d=c.g("legend").attr({zIndex:7}).add(),a.contentGroup=c.g().attr({zIndex:1}).add(d),a.scrollGroup=c.g().add(a.contentGroup),a.clipRect=c.clipRect(0,0,9999,b.chartHeight),a.contentGroup.clip(a.clipRect);e=[];o(b.series,function(a){var b=a.options;
b.showInLegend&&(e=e.concat(a.legendItems||(b.legendType==="point"?a.data:a)))});Ib(e,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});j.reversed&&e.reverse();a.allItems=e;a.display=f=!!e.length;o(e,function(b){a.renderItem(b)});g=j.width||a.offsetWidth;h=a.lastItemY+a.lastLineHeight;h=a.handleOverflow(h);if(l||m){g+=k;h+=k;if(i){if(g>0&&h>0)i[i.isNew?"attr":"animate"](i.crisp(null,null,null,g,h)),i.isNew=!1}else a.box=i=c.rect(0,0,g,h,j.borderRadius,
l||0).attr({stroke:j.borderColor,"stroke-width":l||0,fill:m||Q}).add(d).shadow(j.shadow),i.isNew=!0;i[f?"show":"hide"]()}a.legendWidth=g;a.legendHeight=h;o(e,function(b){a.positionItem(b)});f&&d.align(x({width:g,height:h},j),!0,b.spacingBox);b.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,c=this.chart,d=c.renderer,e=this.options,f=e.y,f=c.spacingBox.height+(e.verticalAlign==="top"?-f:f)-this.padding,g=e.maxHeight,h=this.clipRect,i=e.navigation,j=n(i.animation,!0),k=
i.arrowSize||12,l=this.nav;e.layout==="horizontal"&&(f/=2);g&&(f=O(f,g));if(a>f){this.clipHeight=c=f-20;this.pageCount=za(a/c);this.currentPage=n(this.currentPage,1);this.fullHeight=a;h.attr({height:c});if(!l)this.nav=l=d.g().attr({zIndex:1}).add(this.group),this.up=d.symbol("triangle",0,0,k,k).on("click",function(){b.scroll(-1,j)}).add(l),this.pager=d.text("",15,10).css(i.style).add(l),this.down=d.symbol("triangle-down",0,0,k,k).on("click",function(){b.scroll(1,j)}).add(l);b.scroll(0);a=f}else if(l)h.attr({height:c.chartHeight}),
l.hide(),this.scrollGroup.attr({translateY:1}),this.clipHeight=0;return a},scroll:function(a,b){var c=this.pageCount,d=this.currentPage+a,e=this.clipHeight,f=this.options.navigation,g=f.activeColor,h=f.inactiveColor,f=this.pager,i=this.padding;d>c&&(d=c);if(d>0)b!==A&&xa(b,this.chart),this.nav.attr({translateX:i,translateY:e+7,visibility:"visible"}),this.up.attr({fill:d===1?h:g}).css({cursor:d===1?"default":"pointer"}),f.attr({text:d+"/"+this.pageCount}),this.down.attr({x:18+this.pager.getBBox().width,
fill:d===c?h:g}).css({cursor:d===c?"default":"pointer"}),e=-O(e*(d-1),this.fullHeight-e+i)+1,this.scrollGroup.animate({translateY:e}),f.attr({text:d+"/"+c}),this.currentPage=d,this.positionCheckboxes(e)}};sb.prototype={init:function(a,b){var c,d=a.series;a.series=null;c=B(N,a);c.series=a.series=d;var d=c.chart,e=d.margin,e=Y(e)?e:[e,e,e,e];this.optionsMarginTop=n(d.marginTop,e[0]);this.optionsMarginRight=n(d.marginRight,e[1]);this.optionsMarginBottom=n(d.marginBottom,e[2]);this.optionsMarginLeft=
n(d.marginLeft,e[3]);this.runChartClick=(e=d.events)&&!!e.click;this.callback=b;this.isResizing=0;this.options=c;this.axes=[];this.series=[];this.hasCartesianSeries=d.showAxes;var f;this.index=Ha.length;Ha.push(this);d.reflow!==!1&&J(this,"load",this.initReflow);if(e)for(f in e)J(this,f,e[f]);this.xAxis=[];this.yAxis=[];this.animation=V?!1:n(d.animation,!0);this.pointCount=0;this.counters=new Hb;this.firstRender()},initSeries:function(a){var b=this.options.chart,b=new $[a.type||b.type||b.defaultSeriesType];
b.init(this,a);return b},addSeries:function(a,b,c){var d,e=this;a&&(xa(c,e),b=n(b,!0),F(e,"addSeries",{options:a},function(){d=e.initSeries(a);e.isDirtyLegend=!0;b&&e.redraw()}));return d},isInsidePlot:function(a,b,c){var d=c?b:a,a=c?a:b;return d>=0&&d<=this.plotWidth&&a>=0&&a<=this.plotHeight},adjustTickAmounts:function(){this.options.chart.alignTicks!==!1&&o(this.axes,function(a){a.adjustTickAmount()});this.maxTicks=null},redraw:function(a){var b=this.axes,c=this.series,d=this.tracker,e=this.legend,
f=this.isDirtyLegend,g,h=this.isDirtyBox,i=c.length,j=i,k=this.renderer,l=k.isHidden(),m=[];xa(a,this);for(l&&this.cloneRenderTo();j--;)if(a=c[j],a.isDirty&&a.options.stacking){g=!0;break}if(g)for(j=i;j--;)if(a=c[j],a.options.stacking)a.isDirty=!0;o(c,function(a){a.isDirty&&a.options.legendType==="point"&&(f=!0)});if(f&&e.options.enabled)e.render(),this.isDirtyLegend=!1;if(this.hasCartesianSeries){if(!this.isResizing)this.maxTicks=null,o(b,function(a){a.setScale()});this.adjustTickAmounts();this.getMargins();
o(b,function(a){if(a.isDirtyExtremes)a.isDirtyExtremes=!1,m.push(function(){F(a,"afterSetExtremes",a.getExtremes())});if(a.isDirty||h||g)a.redraw(),h=!0})}h&&this.drawChartBox();o(c,function(a){a.isDirty&&a.visible&&(!a.isCartesian||a.xAxis)&&a.redraw()});d&&d.resetTracker&&d.resetTracker(!0);k.draw();F(this,"redraw");l&&this.cloneRenderTo(!0);o(m,function(a){a.call()})},showLoading:function(a){var b=this.options,c=this.loadingDiv,d=b.loading;if(!c)this.loadingDiv=c=T(ga,{className:"highcharts-loading"},
x(d.style,{left:this.plotLeft+"px",top:this.plotTop+"px",width:this.plotWidth+"px",height:this.plotHeight+"px",zIndex:10,display:Q}),this.container),this.loadingSpan=T("span",null,d.labelStyle,c);this.loadingSpan.innerHTML=a||b.lang.loading;if(!this.loadingShown)I(c,{opacity:0,display:""}),xb(c,{opacity:d.style.opacity},{duration:d.showDuration||0}),this.loadingShown=!0},hideLoading:function(){var a=this.options,b=this.loadingDiv;b&&xb(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){I(b,
{display:Q})}});this.loadingShown=!1},get:function(a){var b=this.axes,c=this.series,d,e;for(d=0;d<b.length;d++)if(b[d].options.id===a)return b[d];for(d=0;d<c.length;d++)if(c[d].options.id===a)return c[d];for(d=0;d<c.length;d++){e=c[d].points||[];for(b=0;b<e.length;b++)if(e[b].id===a)return e[b]}return null},getAxes:function(){var a=this,b=this.options,c=b.xAxis||{},b=b.yAxis||{},c=la(c);o(c,function(a,b){a.index=b;a.isX=!0});b=la(b);o(b,function(a,b){a.index=b});c=c.concat(b);o(c,function(b){new ob(a,
b)});a.adjustTickAmounts()},getSelectedPoints:function(){var a=[];o(this.series,function(b){a=a.concat(Ob(b.points,function(a){return a.selected}))});return a},getSelectedSeries:function(){return Ob(this.series,function(a){return a.selected})},showResetZoom:function(){var a=this,b=N.lang,c=a.options.chart.resetZoomButton,d=c.theme,e=d.states,f=c.relativeTo==="chart"?null:"plotBox";this.resetZoomButton=a.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},d,e&&e.hover).attr({align:c.position.align,
title:b.resetZoomTitle}).add().align(c.position,!1,a[f]);this.resetZoomButton.alignTo=f},zoomOut:function(){var a=this,b=a.resetZoomButton;F(a,"selection",{resetSelection:!0},function(){a.zoom()});if(b)a.resetZoomButton=b.destroy()},zoom:function(a){var b=this,c;!a||a.resetSelection?o(b.axes,function(a){c=a.zoom()}):o(a.xAxis.concat(a.yAxis),function(a){var e=a.axis;if(b.tracker[e.isXAxis?"zoomX":"zoomY"])c=e.zoom(a.min,a.max)});b.resetZoomButton||b.showResetZoom();c&&b.redraw(n(b.options.chart.animation,
b.pointCount<100))},pan:function(a){var b=this.xAxis[0],c=this.mouseDownX,d=b.pointRange/2,e=b.getExtremes(),f=b.translate(c-a,!0)+d,c=b.translate(c+this.plotWidth-a,!0)-d;(d=this.hoverPoints)&&o(d,function(a){a.setState()});b.series.length&&f>O(e.dataMin,e.min)&&c<s(e.dataMax,e.max)&&b.setExtremes(f,c,!0,!1,{trigger:"pan"});this.mouseDownX=a;I(this.container,{cursor:"move"})},setTitle:function(a,b){var c=this,d=c.options,e;c.chartTitleOptions=e=B(d.title,a);c.chartSubtitleOptions=d=B(d.subtitle,
b);o([["title",a,e],["subtitle",b,d]],function(a){var b=a[0],d=c[b],e=a[1],a=a[2];d&&e&&(c[b]=d=d.destroy());a&&a.text&&!d&&(c[b]=c.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,"class":"highcharts-"+b,zIndex:a.zIndex||4}).css(a.style).add().align(a,!1,c.spacingBox))})},getChartSize:function(){var a=this.options.chart,b=this.renderToClone||this.renderTo;this.containerWidth=eb(b,"width");this.containerHeight=eb(b,"height");this.chartWidth=s(0,a.width||this.containerWidth||600);this.chartHeight=
s(0,n(a.height,this.containerHeight>19?this.containerHeight:400))},cloneRenderTo:function(a){var b=this.renderToClone,c=this.container;a?b&&(this.renderTo.appendChild(c),Na(b),delete this.renderToClone):(c&&this.renderTo.removeChild(c),this.renderToClone=b=this.renderTo.cloneNode(0),I(b,{position:"absolute",top:"-9999px",display:"block"}),C.body.appendChild(b),c&&b.appendChild(c))},getContainer:function(){var a,b=this.options.chart,c,d,e;this.renderTo=a=b.renderTo;e="highcharts-"+tb++;if(ja(a))this.renderTo=
a=C.getElementById(a);a||Oa(13,!0);c=z(w(a,"data-highcharts-chart"));!isNaN(c)&&Ha[c]&&Ha[c].destroy();w(a,"data-highcharts-chart",this.index);a.innerHTML="";a.offsetWidth||this.cloneRenderTo();this.getChartSize();c=this.chartWidth;d=this.chartHeight;this.container=a=T(ga,{className:"highcharts-container"+(b.className?" "+b.className:""),id:e},x({position:"relative",overflow:"hidden",width:c+"px",height:d+"px",textAlign:"left",lineHeight:"normal",zIndex:0},b.style),this.renderToClone||a);this.renderer=
b.forExport?new sa(a,c,d,!0):new Sa(a,c,d);V&&this.renderer.create(this,a,c,d)},getMargins:function(){var a=this.options.chart,b=a.spacingTop,c=a.spacingRight,d=a.spacingBottom,a=a.spacingLeft,e,f=this.legend,g=this.optionsMarginTop,h=this.optionsMarginLeft,i=this.optionsMarginRight,j=this.optionsMarginBottom,k=this.chartTitleOptions,l=this.chartSubtitleOptions,m=this.options.legend,q=n(m.margin,10),p=m.x,y=m.y,t=m.align,u=m.verticalAlign;this.resetMargins();e=this.axisOffset;if((this.title||this.subtitle)&&
!r(this.optionsMarginTop))if(l=s(this.title&&!k.floating&&!k.verticalAlign&&k.y||0,this.subtitle&&!l.floating&&!l.verticalAlign&&l.y||0))this.plotTop=s(this.plotTop,l+n(k.margin,15)+b);if(f.display&&!m.floating)if(t==="right"){if(!r(i))this.marginRight=s(this.marginRight,f.legendWidth-p+q+c)}else if(t==="left"){if(!r(h))this.plotLeft=s(this.plotLeft,f.legendWidth+p+q+a)}else if(u==="top"){if(!r(g))this.plotTop=s(this.plotTop,f.legendHeight+y+q+b)}else if(u==="bottom"&&!r(j))this.marginBottom=s(this.marginBottom,
f.legendHeight-y+q+d);this.extraBottomMargin&&(this.marginBottom+=this.extraBottomMargin);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);this.hasCartesianSeries&&o(this.axes,function(a){a.getOffset()});r(h)||(this.plotLeft+=e[3]);r(g)||(this.plotTop+=e[0]);r(j)||(this.marginBottom+=e[2]);r(i)||(this.marginRight+=e[1]);this.setChartSize()},initReflow:function(){function a(a){var g=c.width||eb(d,"width"),h=c.height||eb(d,"height"),a=a?a.target:L;if(!b.hasUserSize&&g&&h&&(a===L||a===C)){if(g!==
b.containerWidth||h!==b.containerHeight)clearTimeout(e),b.reflowTimeout=e=setTimeout(function(){if(b.container)b.setSize(g,h,!1),b.hasUserSize=null},100);b.containerWidth=g;b.containerHeight=h}}var b=this,c=b.options.chart,d=b.renderTo,e;J(L,"resize",a);J(b,"destroy",function(){R(L,"resize",a)})},setSize:function(a,b,c){var d=this,e,f,g=d.resetZoomButton,h=d.title,i=d.subtitle,j;d.isResizing+=1;j=function(){d&&F(d,"endResize",null,function(){d.isResizing-=1})};xa(c,d);d.oldChartHeight=d.chartHeight;
d.oldChartWidth=d.chartWidth;if(r(a))d.chartWidth=e=s(0,u(a)),d.hasUserSize=!!e;if(r(b))d.chartHeight=f=s(0,u(b));I(d.container,{width:e+"px",height:f+"px"});d.renderer.setSize(e,f,c);d.plotWidth=e-d.plotLeft-d.marginRight;d.plotHeight=f-d.plotTop-d.marginBottom;d.maxTicks=null;o(d.axes,function(a){a.isDirty=!0;a.setScale()});o(d.series,function(a){a.isDirty=!0});d.isDirtyLegend=!0;d.isDirtyBox=!0;d.getMargins();a=d.spacingBox;h&&h.align(null,null,a);i&&i.align(null,null,a);g&&g.align&&g.align(null,
null,d[g.alignTo]);d.redraw(c);d.oldChartHeight=null;F(d,"resize");Pa===!1?j():setTimeout(j,Pa&&Pa.duration||500)},setChartSize:function(){var a=this.inverted,b=this.chartWidth,c=this.chartHeight,d=this.options.chart,e=d.spacingTop,f=d.spacingRight,g=d.spacingBottom,h=d.spacingLeft,i,j,k,l;this.plotLeft=i=u(this.plotLeft);this.plotTop=j=u(this.plotTop);this.plotWidth=k=s(0,u(b-i-this.marginRight));this.plotHeight=l=s(0,u(c-j-this.marginBottom));this.plotSizeX=a?l:k;this.plotSizeY=a?k:l;this.plotBorderWidth=
a=d.plotBorderWidth||0;this.spacingBox={x:h,y:e,width:b-h-f,height:c-e-g};this.plotBox={x:i,y:j,width:k,height:l};this.clipBox={x:a/2,y:a/2,width:this.plotSizeX-a,height:this.plotSizeY-a};o(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this.options.chart,b=a.spacingRight,c=a.spacingBottom,d=a.spacingLeft;this.plotTop=n(this.optionsMarginTop,a.spacingTop);this.marginRight=n(this.optionsMarginRight,b);this.marginBottom=n(this.optionsMarginBottom,c);this.plotLeft=
n(this.optionsMarginLeft,d);this.axisOffset=[0,0,0,0]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,c=this.chartWidth,d=this.chartHeight,e=this.chartBackground,f=this.plotBackground,g=this.plotBorder,h=this.plotBGImage,i=a.borderWidth||0,j=a.backgroundColor,k=a.plotBackgroundColor,l=a.plotBackgroundImage,m=a.plotBorderWidth||0,n,p=this.plotLeft,o=this.plotTop,t=this.plotWidth,r=this.plotHeight,u=this.plotBox,v=this.clipRect,s=this.clipBox;n=i+(a.shadow?8:0);if(i||j)if(e)e.animate(e.crisp(null,
null,null,c-n,d-n));else{e={fill:j||Q};if(i)e.stroke=a.borderColor,e["stroke-width"]=i;this.chartBackground=b.rect(n/2,n/2,c-n,d-n,a.borderRadius,i).attr(e).add().shadow(a.shadow)}if(k)f?f.animate(u):this.plotBackground=b.rect(p,o,t,r,0).attr({fill:k}).add().shadow(a.plotShadow);if(l)h?h.animate(u):this.plotBGImage=b.image(l,p,o,t,r).add();v?v.animate({width:s.width,height:s.height}):this.clipRect=b.clipRect(s);if(m)g?g.animate(g.crisp(null,p,o,t,r)):this.plotBorder=b.rect(p,o,t,r,0,m).attr({stroke:a.plotBorderColor,
"stroke-width":m,zIndex:1}).add();this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,c,d=a.options.series,e,f;o(["inverted","angular","polar"],function(g){c=$[b.type||b.defaultSeriesType];f=a[g]||b[g]||c&&c.prototype[g];for(e=d&&d.length;!f&&e--;)(c=$[d[e].type])&&c.prototype[g]&&(f=!0);a[g]=f})},render:function(){var a=this,b=a.axes,c=a.renderer,d=a.options,e=d.labels,d=d.credits,f;a.setTitle();a.legend=new rb(a);o(b,function(a){a.setScale()});a.getMargins();a.maxTicks=null;
o(b,function(a){a.setTickPositions(!0);a.setMaxTicks()});a.adjustTickAmounts();a.getMargins();a.drawChartBox();a.hasCartesianSeries&&o(b,function(a){a.render()});if(!a.seriesGroup)a.seriesGroup=c.g("series-group").attr({zIndex:3}).add();o(a.series,function(a){a.translate();a.setTooltipPoints();a.render()});e.items&&o(e.items,function(b){var d=x(e.style,b.style),f=z(d.left)+a.plotLeft,j=z(d.top)+a.plotTop+12;delete d.left;delete d.top;c.text(b.html,f,j).attr({zIndex:2}).css(d).add()});if(d.enabled&&
!a.credits)f=d.href,a.credits=c.text(d.text,0,0).on("click",function(){if(f)location.href=f}).attr({align:d.position.align,zIndex:8}).css(d.style).add().align(d.position);a.hasRendered=!0},destroy:function(){var a=this,b=a.axes,c=a.series,d=a.container,e,f=d&&d.parentNode;F(a,"destroy");Ha[a.index]=A;a.renderTo.removeAttribute("data-highcharts-chart");R(a);for(e=b.length;e--;)b[e]=b[e].destroy();for(e=c.length;e--;)c[e]=c[e].destroy();o("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,tracker,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","),
function(b){var c=a[b];c&&c.destroy&&(a[b]=c.destroy())});if(d)d.innerHTML="",R(d),f&&Na(d);for(e in a)delete a[e]},isReadyToRender:function(){var a=this;return!ca&&L==L.top&&C.readyState!=="complete"||V&&!L.canvg?(V?Rb.push(function(){a.firstRender()},a.options.global.canvasToolsURL):C.attachEvent("onreadystatechange",function(){C.detachEvent("onreadystatechange",a.firstRender);C.readyState==="complete"&&a.firstRender()}),!1):!0},firstRender:function(){var a=this,b=a.options,c=a.callback;if(a.isReadyToRender()){a.getContainer();
F(a,"init");if(Highcharts.RangeSelector&&b.rangeSelector.enabled)a.rangeSelector=new Highcharts.RangeSelector(a);a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();o(b.series||[],function(b){a.initSeries(b)});if(Highcharts.Scroller&&(b.navigator.enabled||b.scrollbar.enabled))a.scroller=new Highcharts.Scroller(a);a.tracker=new qb(a,b);a.render();a.renderer.draw();c&&c.apply(a,[a]);o(a.callbacks,function(b){b.apply(a,[a])});a.cloneRenderTo(!0);F(a,"load")}}};sb.prototype.callbacks=[];
var Ua=function(){};Ua.prototype={init:function(a,b,c){var d=a.chart.counters;this.series=a;this.applyOptions(b,c);this.pointAttr={};if(a.options.colorByPoint)b=a.chart.options.colors,this.color=this.color||b[d.color++],d.wrapColor(b.length);a.chart.pointCount++;return this},applyOptions:function(a,b){var c=this.series,d=typeof a;this.config=a;if(d==="number"||a===null)this.y=a;else if(typeof a[0]==="number")this.x=a[0],this.y=a[1];else if(d==="object"&&typeof a.length!=="number"){x(this,a);this.options=
a;if(a.dataLabels)c._hasPointLabels=!0;if(a.marker)c._hasPointMarkers=!0}else if(typeof a[0]==="string")this.name=a[0],this.y=a[1];if(this.x===A)this.x=b===A?c.autoIncrement():b},destroy:function(){var a=this.series.chart,b=a.hoverPoints,c;a.pointCount--;if(b&&(this.setState(),ta(b,this),!b.length))a.hoverPoints=null;if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)R(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);for(c in this)this[c]=null},destroyElements:function(){for(var a=
"graphic,tracker,dataLabel,dataLabelUpper,group,connector,shadowGroup".split(","),b,c=6;c--;)b=a[c],this[b]&&(this[b]=this[b].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},select:function(a,b){var c=this,d=c.series.chart,a=n(a,!c.selected);c.firePointEvent(a?"select":"unselect",{accumulate:b},function(){c.selected=a;c.setState(a&&"select");b||o(d.getSelectedPoints(),
function(a){if(a.selected&&a!==c)a.selected=!1,a.setState(""),a.firePointEvent("unselect")})})},onMouseOver:function(){var a=this.series,b=a.chart,c=b.tooltip,d=b.hoverPoint;if(d&&d!==this)d.onMouseOut();this.firePointEvent("mouseOver");c&&(!c.shared||a.noSharedTooltip)&&c.refresh(this);this.setState("hover");b.hoverPoint=this},onMouseOut:function(){var a=this.series.chart,b=a.hoverPoints;if(!b||Ub(this,b)===-1)this.firePointEvent("mouseOut"),this.setState(),a.hoverPoint=null},tooltipFormatter:function(a){var b=
this.series,c=b.tooltipOptions,d=a.match(/\{(series|point)\.[a-zA-Z]+\}/g),e=/[{\.}]/,f,g,h,i,j={y:0,open:0,high:0,low:0,close:0,percentage:1,total:1};c.valuePrefix=c.valuePrefix||c.yPrefix;c.valueDecimals=n(c.valueDecimals,c.yDecimals);c.valueSuffix=c.valueSuffix||c.ySuffix;for(i in d)g=d[i],ja(g)&&g!==a&&(h=(" "+g).split(e),f={point:this,series:b}[h[1]],h=h[2],f===this&&j.hasOwnProperty(h)?(f=j[h]?h:"value",f=(c[f+"Prefix"]||"")+Ja(this[h],n(c[f+"Decimals"],-1))+(c[f+"Suffix"]||"")):f=f[h],a=a.replace(g,
f));return a},update:function(a,b,c){var d=this,e=d.series,f=d.graphic,g,h=e.data,i=h.length,j=e.chart,b=n(b,!0);d.firePointEvent("update",{options:a},function(){d.applyOptions(a);Y(a)&&(e.getAttribs(),f&&f.attr(d.pointAttr[e.state]));for(g=0;g<i;g++)if(h[g]===d){e.xData[g]=d.x;e.yData[g]=d.toYData?d.toYData():d.y;e.options.data[g]=a;break}e.isDirty=!0;e.isDirtyData=!0;b&&j.redraw(c)})},remove:function(a,b){var c=this,d=c.series,e=d.chart,f,g=d.data,h=g.length;xa(b,e);a=n(a,!0);c.firePointEvent("remove",
null,function(){for(f=0;f<h;f++)if(g[f]===c){g.splice(f,1);d.options.data.splice(f,1);d.xData.splice(f,1);d.yData.splice(f,1);break}c.destroy();d.isDirty=!0;d.isDirtyData=!0;a&&e.redraw()})},firePointEvent:function(a,b,c){var d=this,e=this.series.options;(e.point.events[a]||d.options&&d.options.events&&d.options.events[a])&&this.importEvents();a==="click"&&e.allowPointSelect&&(c=function(a){d.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});F(this,a,b,c)},importEvents:function(){if(!this.hasImportedEvents){var a=
B(this.series.options.point,this.options).events,b;this.events=a;for(b in a)J(this,b,a[b]);this.hasImportedEvents=!0}},setState:function(a){var b=this.plotX,c=this.plotY,d=this.series,e=d.options.states,f=X[d.type].marker&&d.options.marker,g=f&&!f.enabled,h=f&&f.states[a],i=h&&h.enabled===!1,j=d.stateMarkerGraphic,k=d.chart,l=this.pointAttr,a=a||"";if(!(a===this.state||this.selected&&a!=="select"||e[a]&&e[a].enabled===!1||a&&(i||g&&!h.enabled))){if(this.graphic)e=f&&this.graphic.symbolName&&l[a].r,
this.graphic.attr(B(l[a],e?{x:b-e,y:c-e,width:2*e,height:2*e}:{}));else{if(a&&h)e=h.radius,j?j.attr({x:b-e,y:c-e}):d.stateMarkerGraphic=j=k.renderer.symbol(d.symbol,b-e,c-e,2*e,2*e).attr(l[a]).add(d.markerGroup);if(j)j[a&&k.isInsidePlot(b,c)?"show":"hide"]()}this.state=a}}};var P=function(){};P.prototype={isCartesian:!0,type:"line",pointClass:Ua,sorted:!0,requireSorting:!0,pointAttrToOptions:{stroke:"lineColor","stroke-width":"lineWidth",fill:"fillColor",r:"radius"},init:function(a,b){var c,d;this.chart=
a;this.options=b=this.setOptions(b);this.bindAxes();x(this,{name:b.name,state:"",pointAttr:{},visible:b.visible!==!1,selected:b.selected===!0});if(V)b.animation=!1;d=b.events;for(c in d)J(this,c,d[c]);if(d&&d.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;this.getColor();this.getSymbol();this.setData(b.data,!1);if(this.isCartesian)a.hasCartesianSeries=!0;a.series.push(this);Ib(a.series,function(a,b){return(a.options.index||0)-(b.options.index||0)});o(a.series,
function(a,b){a.index=b;a.name=a.name||"Series "+(b+1)})},bindAxes:function(){var a=this,b=a.options,c=a.chart,d;a.isCartesian&&o(["xAxis","yAxis"],function(e){o(c[e],function(c){d=c.options;if(b[e]===d.index||b[e]===A&&d.index===0)c.series.push(a),a[e]=c,c.isDirty=!0})})},autoIncrement:function(){var a=this.options,b=this.xIncrement,b=n(b,a.pointStart,0);this.pointInterval=n(this.pointInterval,a.pointInterval,1);this.xIncrement=b+this.pointInterval;return b},getSegments:function(){var a=-1,b=[],
c,d=this.points,e=d.length;if(e)if(this.options.connectNulls){for(c=e;c--;)d[c].y===null&&d.splice(c,1);d.length&&(b=[d])}else o(d,function(c,g){c.y===null?(g>a+1&&b.push(d.slice(a+1,g)),a=g):g===e-1&&b.push(d.slice(a+1,g+1))});this.segments=b},setOptions:function(a){var b=this.chart.options,c=b.plotOptions,d=c[this.type],e=a.data;a.data=null;c=B(d,c.series,a);c.data=a.data=e;this.tooltipOptions=B(b.tooltip,c.tooltip);d.marker===null&&delete c.marker;return c},getColor:function(){var a=this.options,
b=this.chart.options.colors,c=this.chart.counters;this.color=a.color||!a.colorByPoint&&b[c.color++]||"gray";c.wrapColor(b.length)},getSymbol:function(){var a=this.options.marker,b=this.chart,c=b.options.symbols,b=b.counters;this.symbol=a.symbol||c[b.symbol++];if(/^url/.test(this.symbol))a.radius=0;b.wrapSymbol(c.length)},drawLegendSymbol:function(a){var b=this.options,c=b.marker,d=a.options.symbolWidth,e=this.chart.renderer,f=this.legendGroup,a=a.baseline,g;if(b.lineWidth){g={"stroke-width":b.lineWidth};
if(b.dashStyle)g.dashstyle=b.dashStyle;this.legendLine=e.path(["M",0,a-4,"L",d,a-4]).attr(g).add(f)}if(c&&c.enabled)b=c.radius,this.legendSymbol=e.symbol(this.symbol,d/2-b,a-4-b,2*b,2*b).add(f)},addPoint:function(a,b,c,d){var e=this.options,f=this.data,g=this.graph,h=this.area,i=this.chart,j=this.xData,k=this.yData,l=g&&g.shift||0,m=e.data,q=this.pointClass.prototype;xa(d,i);if(g&&c)g.shift=l+1;if(h){if(c)h.shift=l+1;h.isArea=!0}b=n(b,!0);d={series:this};q.applyOptions.apply(d,[a]);j.push(d.x);k.push(q.toYData?
q.toYData.call(d):d.y);m.push(a);e.legendType==="point"&&this.generatePoints();c&&(f[0]&&f[0].remove?f[0].remove(!1):(f.shift(),j.shift(),k.shift(),m.shift()));this.getAttribs();this.isDirtyData=this.isDirty=!0;b&&i.redraw()},setData:function(a,b){var c=this.points,d=this.options,e=this.initialColor,f=this.chart,g=null,h=this.xAxis,i,j=this.pointClass.prototype;this.xIncrement=null;this.pointRange=h&&h.categories?1:d.pointRange;if(r(e))f.counters.color=e;var e=[],k=[],l=a?a.length:[],m=(i=this.pointArrayMap)&&
i.length;if(l>(d.turboThreshold||1E3)){for(i=0;g===null&&i<l;)g=a[i],i++;if(Da(g)){j=n(d.pointStart,0);d=n(d.pointInterval,1);for(i=0;i<l;i++)e[i]=j,k[i]=a[i],j+=d;this.xIncrement=j}else if(Ia(g))if(m)for(i=0;i<l;i++)d=a[i],e[i]=d[0],k[i]=d.slice(1,m+1);else for(i=0;i<l;i++)d=a[i],e[i]=d[0],k[i]=d[1]}else for(i=0;i<l;i++)d={series:this},j.applyOptions.apply(d,[a[i]]),e[i]=d.x,k[i]=j.toYData?j.toYData.call(d):d.y;this.requireSorting&&e.length>1&&e[1]<e[0]&&Oa(15);ja(k[0])&&Oa(14,!0);this.data=[];this.options.data=
a;this.xData=e;this.yData=k;for(i=c&&c.length||0;i--;)c[i]&&c[i].destroy&&c[i].destroy();if(h)h.minRange=h.userMinRange;this.isDirty=this.isDirtyData=f.isDirtyBox=!0;n(b,!0)&&f.redraw(!1)},remove:function(a,b){var c=this,d=c.chart,a=n(a,!0);if(!c.isRemoving)c.isRemoving=!0,F(c,"remove",null,function(){c.destroy();d.isDirtyLegend=d.isDirtyBox=!0;a&&d.redraw(b)});c.isRemoving=!1},processData:function(a){var b=this.xData,c=this.yData,d=b.length,e=0,f=d,g,h,i=this.xAxis,j=this.options,k=j.cropThreshold,
l=this.isCartesian;if(l&&!this.isDirty&&!i.isDirty&&!this.yAxis.isDirty&&!a)return!1;if(l&&this.sorted&&(!k||d>k||this.forceCrop))if(a=i.getExtremes(),i=a.min,k=a.max,b[d-1]<i||b[0]>k)b=[],c=[];else if(b[0]<i||b[d-1]>k){for(a=0;a<d;a++)if(b[a]>=i){e=s(0,a-1);break}for(;a<d;a++)if(b[a]>k){f=a+1;break}b=b.slice(e,f);c=c.slice(e,f);g=!0}for(a=b.length-1;a>0;a--)if(d=b[a]-b[a-1],d>0&&(h===A||d<h))h=d;this.cropped=g;this.cropStart=e;this.processedXData=b;this.processedYData=c;if(j.pointRange===null)this.pointRange=
h||1;this.closestPointRange=h},generatePoints:function(){var a=this.options.data,b=this.data,c,d=this.processedXData,e=this.processedYData,f=this.pointClass,g=d.length,h=this.cropStart||0,i,j=this.hasGroupedData,k,l=[],m;if(!b&&!j)b=[],b.length=a.length,b=this.data=b;for(m=0;m<g;m++)i=h+m,j?l[m]=(new f).init(this,[d[m]].concat(la(e[m]))):(b[i]?k=b[i]:a[i]!==A&&(b[i]=k=(new f).init(this,a[i],d[m])),l[m]=k);if(b&&(g!==(c=b.length)||j))for(m=0;m<c;m++)if(m===h&&!j&&(m+=g),b[m])b[m].destroyElements(),
b[m].plotX=A;this.data=b;this.points=l},translate:function(){this.processedXData||this.processData();this.generatePoints();for(var a=this.chart,b=this.options,c=b.stacking,d=this.xAxis,e=d.categories,f=this.yAxis,g=this.points,h=g.length,i=!!this.modifyValue,j,k=f.series,l=k.length,m=b.pointPlacement==="between";l--;)if(k[l].visible){k[l]===this&&(j=!0);break}for(l=0;l<h;l++){var k=g[l],q=k.x,p=k.y,o=k.low,t=f.stacks[(p<b.threshold?"-":"")+this.stackKey];k.plotX=d.translate(q,0,0,0,1,m);if(c&&this.visible&&
t&&t[q])o=t[q],q=o.total,o.cum=o=o.cum-p,p=o+p,j&&(o=n(b.threshold,f.min)),f.isLog&&o<=0&&(o=null),c==="percent"&&(o=q?o*100/q:0,p=q?p*100/q:0),k.percentage=q?k.y*100/q:0,k.total=k.stackTotal=q,k.stackY=p;k.yBottom=r(o)?f.translate(o,0,1,0,1):null;i&&(p=this.modifyValue(p,k));k.plotY=typeof p==="number"?u(f.translate(p,0,1,0,1)*10)/10:A;k.clientX=a.inverted?a.plotHeight-k.plotX:k.plotX;k.category=e&&e[k.x]!==A?e[k.x]:k.x}this.getSegments()},setTooltipPoints:function(a){var b=[],c,d,e=(c=this.xAxis)?
c.tooltipLen||c.len:this.chart.plotSizeX,f=c&&c.tooltipPosName||"plotX",g,h,i=[];if(this.options.enableMouseTracking!==!1){if(a)this.tooltipPoints=null;o(this.segments||this.points,function(a){b=b.concat(a)});c&&c.reversed&&(b=b.reverse());a=b.length;for(h=0;h<a;h++){g=b[h];c=b[h-1]?d+1:0;for(d=b[h+1]?s(0,U((g[f]+(b[h+1]?b[h+1][f]:e))/2)):e;c>=0&&c<=d;)i[c++]=g}this.tooltipPoints=i}},tooltipHeaderFormatter:function(a){var b=this.tooltipOptions,c=b.xDateFormat,d=this.xAxis,e=d&&d.options.type==="datetime",
f;if(e&&!c)for(f in D)if(D[f]>=d.closestPointRange){c=b.dateTimeLabelFormats[f];break}return b.headerFormat.replace("{point.key}",e&&Da(a)?db(c,a):a).replace("{series.name}",this.name).replace("{series.color}",this.color)},onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&F(this,"mouseOver");this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,c=b.tooltip,d=b.hoverPoint;if(d)d.onMouseOut();
this&&a.events.mouseOut&&F(this,"mouseOut");c&&!a.stickyTracking&&!c.shared&&c.hide();this.setState();b.hoverSeries=null},animate:function(a){var b=this,c=b.chart,d=c.renderer,e;e=b.options.animation;var f=c.clipBox,g=c.inverted,h;if(e&&!Y(e))e=X[b.type].animation;h="_sharedClip"+e.duration+e.easing;if(a)a=c[h],e=c[h+"m"],a||(c[h]=a=d.clipRect(x(f,{width:0})),c[h+"m"]=e=d.clipRect(-99,g?-c.plotLeft:-c.plotTop,99,g?c.chartWidth:c.chartHeight)),b.group.clip(a),b.markerGroup.clip(e),b.sharedClipKey=
h;else{if(a=c[h])a.animate({width:c.plotSizeX},e),c[h+"m"].animate({width:c.plotSizeX+99},e);b.animate=null;b.animationTimeout=setTimeout(function(){b.afterAnimate()},e.duration)}},afterAnimate:function(){var a=this.chart,b=this.sharedClipKey,c=this.group,d=this.trackerGroup;c&&this.options.clip!==!1&&(c.clip(a.clipRect),d&&d.clip(a.clipRect),this.markerGroup.clip());setTimeout(function(){b&&a[b]&&(a[b]=a[b].destroy(),a[b+"m"]=a[b+"m"].destroy())},100)},drawPoints:function(){var a,b=this.points,c=
this.chart,d,e,f,g,h,i,j,k,l=this.options.marker,m,o=this.markerGroup;if(l.enabled||this._hasPointMarkers)for(f=b.length;f--;)if(g=b[f],d=g.plotX,e=g.plotY,k=g.graphic,i=g.marker||{},a=l.enabled&&i.enabled===A||i.enabled,m=c.isInsidePlot(d,e,c.inverted),a&&e!==A&&!isNaN(e))if(a=g.pointAttr[g.selected?"select":""],h=a.r,i=n(i.symbol,this.symbol),j=i.indexOf("url")===0,k)k.attr({visibility:m?ca?"inherit":"visible":"hidden"}).animate(x({x:d-h,y:e-h},k.symbolName?{width:2*h,height:2*h}:{}));else{if(m&&
(h>0||j))g.graphic=c.renderer.symbol(i,d-h,e-h,2*h,2*h).attr(a).add(o)}else if(k)g.graphic=k.destroy()},convertAttribs:function(a,b,c,d){var e=this.pointAttrToOptions,f,g,h={},a=a||{},b=b||{},c=c||{},d=d||{};for(f in e)g=e[f],h[f]=n(a[g],b[f],c[f],d[f]);return h},getAttribs:function(){var a=this,b=X[a.type].marker?a.options.marker:a.options,c=b.states,d=c.hover,e,f=a.color,g={stroke:f,fill:f},h=a.points||[],i=[],j,k=a.pointAttrToOptions,l;a.options.marker?(d.radius=d.radius||b.radius+2,d.lineWidth=
d.lineWidth||b.lineWidth+1):d.color=d.color||qa(d.color||f).brighten(d.brightness).get();i[""]=a.convertAttribs(b,g);o(["hover","select"],function(b){i[b]=a.convertAttribs(c[b],i[""])});a.pointAttr=i;for(f=h.length;f--;){g=h[f];if((b=g.options&&g.options.marker||g.options)&&b.enabled===!1)b.radius=0;e=a.options.colorByPoint;if(g.options)for(l in k)r(b[k[l]])&&(e=!0);if(e){b=b||{};j=[];c=b.states||{};e=c.hover=c.hover||{};if(!a.options.marker)e.color=qa(e.color||g.color).brighten(e.brightness||d.brightness).get();
j[""]=a.convertAttribs(x({color:g.color},b),i[""]);j.hover=a.convertAttribs(c.hover,i.hover,j[""]);j.select=a.convertAttribs(c.select,i.select,j[""])}else j=i;g.pointAttr=j}},destroy:function(){var a=this,b=a.chart,c=/AppleWebKit\/533/.test(na),d,e,f=a.data||[],g,h,i;F(a,"destroy");R(a);o(["xAxis","yAxis"],function(b){if(i=a[b])ta(i.series,a),i.isDirty=!0});a.legendItem&&a.chart.legend.destroyItem(a);for(e=f.length;e--;)(g=f[e])&&g.destroy&&g.destroy();a.points=null;clearTimeout(a.animationTimeout);
o("area,graph,dataLabelsGroup,group,markerGroup,tracker,trackerGroup".split(","),function(b){a[b]&&(d=c&&b==="group"?"hide":"destroy",a[b][d]())});if(b.hoverSeries===a)b.hoverSeries=null;ta(b.series,a);for(h in a)delete a[h]},drawDataLabels:function(){var a=this,b=a.options.dataLabels,c=a.points,d,e,f,g;if(b.enabled||a._hasPointLabels)a.dlProcessOptions&&a.dlProcessOptions(b),g=a.plotGroup("dataLabelsGroup","data-labels",a.visible?"visible":"hidden",b.zIndex||6),e=b,o(c,function(c){var i,j=c.dataLabel,
k,l=!0;d=c.options&&c.options.dataLabels;i=e.enabled||d&&d.enabled;if(j&&!i)c.dataLabel=j.destroy();else if(i){i=b.rotation;b=B(e,d);f=b.formatter.call(c.getLabelConfig(),b);b.style.color=n(b.color,b.style.color,a.color,"black");if(j)j.attr({text:f}),l=!1;else if(r(f)){j={fill:b.backgroundColor,stroke:b.borderColor,"stroke-width":b.borderWidth,r:b.borderRadius||0,rotation:i,padding:b.padding,zIndex:1};for(k in j)j[k]===A&&delete j[k];j=c.dataLabel=a.chart.renderer[i?"text":"label"](f,0,-999,null,
null,null,b.useHTML).attr(j).css(b.style).add(g).shadow(b.shadow)}j&&a.alignDataLabel(c,j,b,null,l)}})},alignDataLabel:function(a,b,c,d,e){var f=this.chart,g=f.inverted,h=n(a.plotX,-999),a=n(a.plotY,-999),i=b.getBBox(),d=x({x:g?f.plotWidth-a:h,y:u(g?f.plotHeight-h:a),width:0,height:0},d);x(c,{width:i.width,height:i.height});c.rotation?(d={align:c.align,x:d.x+c.x+d.width/2,y:d.y+c.y+d.height/2},b[e?"attr":"animate"](d)):(b.align(c,null,d),d=b.alignAttr);b.attr({visibility:c.crop===!1||f.isInsidePlot(d.x,
d.y)||f.isInsidePlot(h,a,g)?f.renderer.isSVG?"inherit":"visible":"hidden"})},getSegmentPath:function(a){var b=this,c=[],d=b.options.step;o(a,function(e,f){var g=e.plotX,h=e.plotY,i;b.getPointSpline?c.push.apply(c,b.getPointSpline(a,e,f)):(c.push(f?"L":"M"),d&&f&&(i=a[f-1],d==="right"?c.push(i.plotX,h):d==="center"?c.push((i.plotX+g)/2,i.plotY,(i.plotX+g)/2,h):c.push(g,i.plotY)),c.push(e.plotX,e.plotY))});return c},getGraphPath:function(){var a=this,b=[],c,d=[];o(a.segments,function(e){c=a.getSegmentPath(e);
e.length>1?b=b.concat(c):d.push(e[0])});a.singlePoints=d;return a.graphPath=b},drawGraph:function(){var a=this.options,b=this.graph,c=this.group,d=a.lineColor||this.color,e=a.lineWidth,f=a.dashStyle,g=this.getGraphPath();if(b)fb(b),b.animate({d:g});else if(e){b={stroke:d,"stroke-width":e,zIndex:1};if(f)b.dashstyle=f;this.graph=this.chart.renderer.path(g).attr(b).add(c).shadow(a.shadow)}},invertGroups:function(){function a(){var a={width:b.yAxis.len,height:b.xAxis.len};o(["group","trackerGroup","markerGroup"],
function(c){b[c]&&b[c].attr(a).invert()})}var b=this,c=b.chart;J(c,"resize",a);J(b,"destroy",function(){R(c,"resize",a)});a();b.invertGroups=a},plotGroup:function(a,b,c,d,e){var f=this[a],g=this.chart,h=this.xAxis,i=this.yAxis;f||(this[a]=f=g.renderer.g(b).attr({visibility:c,zIndex:d||0.1}).add(e));f.translate(h?h.left:g.plotLeft,i?i.top:g.plotTop);return f},render:function(){var a=this.chart,b,c=this.options,d=c.animation&&!!this.animate,e=this.visible?"visible":"hidden",f=c.zIndex,g=this.hasRendered,
h=a.seriesGroup;b=this.plotGroup("group","series",e,f,h);this.markerGroup=this.plotGroup("markerGroup","markers",e,f,h);d&&this.animate(!0);this.getAttribs();b.inverted=a.inverted;this.drawGraph&&this.drawGraph();this.drawPoints();this.drawDataLabels();this.options.enableMouseTracking!==!1&&this.drawTracker();a.inverted&&this.invertGroups();c.clip!==!1&&!this.sharedClipKey&&!g&&(b.clip(a.clipRect),this.trackerGroup&&this.trackerGroup.clip(a.clipRect));d?this.animate():g||this.afterAnimate();this.isDirty=
this.isDirtyData=!1;this.hasRendered=!0},redraw:function(){var a=this.chart,b=this.isDirtyData,c=this.group;c&&(a.inverted&&c.attr({width:a.plotWidth,height:a.plotHeight}),c.animate({translateX:this.xAxis.left,translateY:this.yAxis.top}));this.translate();this.setTooltipPoints(!0);this.render();b&&F(this,"updatedData")},setState:function(a){var b=this.options,c=this.graph,d=b.states,b=b.lineWidth,a=a||"";if(this.state!==a)this.state=a,d[a]&&d[a].enabled===!1||(a&&(b=d[a].lineWidth||b+1),c&&!c.dashstyle&&
c.attr({"stroke-width":b},a?0:500))},setVisible:function(a,b){var c=this.chart,d=this.legendItem,e=this.group,f=this.tracker,g=this.dataLabelsGroup,h=this.markerGroup,i,j=this.points,k=c.options.chart.ignoreHiddenSeries;i=this.visible;i=(this.visible=a=a===A?!i:a)?"show":"hide";if(e)e[i]();if(h)h[i]();if(f)f[i]();else if(j)for(e=j.length;e--;)if(f=j[e],f.tracker)f.tracker[i]();if(c.hoverSeries===this)this.onMouseOut();if(g)g[i]();d&&c.legend.colorizeItem(this,a);this.isDirty=!0;this.options.stacking&&
o(c.series,function(a){if(a.options.stacking&&a.visible)a.isDirty=!0});if(k)c.isDirtyBox=!0;b!==!1&&c.redraw();F(this,i)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=a===A?!this.selected:a;if(this.checkbox)this.checkbox.checked=a;F(this,a?"select":"unselect")},drawTracker:function(){var a=this,b=a.options,c=b.trackByArea,d=[].concat(c?a.areaPath:a.graphPath),e=d.length,f=a.chart,g=f.renderer,h=f.options.tooltip.snap,i=a.tracker,j=b.cursor,
j=j&&{cursor:j},k=a.singlePoints,l=this.isCartesian&&this.plotGroup("trackerGroup",null,"visible",b.zIndex||1,f.trackerGroup),m,n=function(){if(f.hoverSeries!==a)a.onMouseOver()},o=function(){if(!b.stickyTracking)a.onMouseOut()};if(e&&!c)for(m=e+1;m--;)d[m]==="M"&&d.splice(m+1,0,d[m+1]-h,d[m+2],"L"),(m&&d[m]==="M"||m===e)&&d.splice(m,0,"L",d[m-2]+h,d[m-1]);for(m=0;m<k.length;m++)e=k[m],d.push("M",e.plotX-h,e.plotY,"L",e.plotX+h,e.plotY);if(i)i.attr({d:d});else if(a.tracker=i=g.path(d).attr({isTracker:!0,
"stroke-linejoin":"round",visibility:a.visible?"visible":"hidden",stroke:vb,fill:c?vb:Q,"stroke-width":b.lineWidth+(c?0:2*h)}).on("mouseover",n).on("mouseout",o).css(j).add(l),Ba)i.on("touchstart",n)}};G=ba(P);$.line=G;X.area=B(ea,{threshold:0});G=ba(P,{type:"area",getSegmentPath:function(a){var b=P.prototype.getSegmentPath.call(this,a),c=[].concat(b),d,e=this.options;b.length===3&&c.push("L",b[1],b[2]);if(e.stacking&&!this.closedStacks)for(d=a.length-1;d>=0;d--)d<a.length-1&&e.step&&c.push(a[d+1].plotX,
a[d].yBottom),c.push(a[d].plotX,a[d].yBottom);else this.closeSegment(c,a);this.areaPath=this.areaPath.concat(c);return b},closeSegment:function(a,b){var c=this.yAxis.getThreshold(this.options.threshold);a.push("L",b[b.length-1].plotX,c,"L",b[0].plotX,c)},drawGraph:function(){this.areaPath=[];P.prototype.drawGraph.apply(this);var a=this.areaPath,b=this.options,c=this.area;c?c.animate({d:a}):this.area=this.chart.renderer.path(a).attr({fill:n(b.fillColor,qa(this.color).setOpacity(b.fillOpacity||0.75).get()),
zIndex:0}).add(this.group)},drawLegendSymbol:function(a,b){b.legendSymbol=this.chart.renderer.rect(0,a.baseline-11,a.options.symbolWidth,12,2).attr({zIndex:3}).add(b.legendGroup)}});$.area=G;X.spline=B(ea);fa=ba(P,{type:"spline",getPointSpline:function(a,b,c){var d=b.plotX,e=b.plotY,f=a[c-1],g=a[c+1],h,i,j,k;if(f&&g){a=f.plotY;j=g.plotX;var g=g.plotY,l;h=(1.5*d+f.plotX)/2.5;i=(1.5*e+a)/2.5;j=(1.5*d+j)/2.5;k=(1.5*e+g)/2.5;l=(k-i)*(j-d)/(j-h)+e-k;i+=l;k+=l;i>a&&i>e?(i=s(a,e),k=2*e-i):i<a&&i<e&&(i=O(a,
e),k=2*e-i);k>g&&k>e?(k=s(g,e),i=2*e-k):k<g&&k<e&&(k=O(g,e),i=2*e-k);b.rightContX=j;b.rightContY=k}c?(b=["C",f.rightContX||f.plotX,f.rightContY||f.plotY,h||d,i||e,d,e],f.rightContX=f.rightContY=null):b=["M",d,e];return b}});$.spline=fa;X.areaspline=B(X.area);var Ca=G.prototype,fa=ba(fa,{type:"areaspline",closedStacks:!0,getSegmentPath:Ca.getSegmentPath,closeSegment:Ca.closeSegment,drawGraph:Ca.drawGraph});$.areaspline=fa;X.column=B(ea,{borderColor:"#FFFFFF",borderWidth:1,borderRadius:0,groupPadding:0.2,
marker:null,pointPadding:0.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{brightness:0.1,shadow:!1},select:{color:"#C0C0C0",borderColor:"#000000",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},threshold:0});fa=ba(P,{type:"column",tooltipOutsidePlot:!0,pointAttrToOptions:{stroke:"borderColor","stroke-width":"borderWidth",fill:"color",r:"borderRadius"},init:function(){P.prototype.init.apply(this,arguments);var a=this,b=a.chart;b.hasRendered&&o(b.series,function(b){if(b.type===
a.type)b.isDirty=!0})},translate:function(){var a=this,b=a.chart,c=a.options,d=c.stacking,e=c.borderWidth,f=0,g=a.xAxis,h=a.yAxis,i=g.reversed,j={},k,l;P.prototype.translate.apply(a);c.grouping===!1?f=1:o(b.series,function(b){var c=b.options;if(b.type===a.type&&b.visible&&a.options.group===c.group)c.stacking?(k=b.stackKey,j[k]===A&&(j[k]=f++),l=j[k]):c.grouping!==!1&&(l=f++),b.columnIndex=l});var m=a.points,g=M(g.transA)*(g.ordinalSlope||c.pointRange||g.closestPointRange||1),q=g*c.groupPadding,p=
(g-2*q)/f,y=c.pointWidth,t=r(y)?(p-y)/2:p*c.pointPadding,u=n(y,p-2*t),x=za(s(u,1+2*e)),v=t+(q+((i?f-(a.columnIndex||0):a.columnIndex)||0)*p-g/2)*(i?-1:1),z=a.translatedThreshold=h.getThreshold(c.threshold),w=n(c.minPointLength,5);o(m,function(c){var f=O(s(-999,c.plotY),h.len+999),g=n(c.yBottom,z),i=c.plotX+v,j=za(O(f,g)),k=za(s(f,g)-j),l=h.stacks[(c.y<0?"-":"")+a.stackKey];d&&a.visible&&l&&l[c.x]&&l[c.x].setOffset(v,x);M(k)<w&&w&&(k=w,j=M(j-z)>w?g-w:z-(f<=z?w:0));c.barX=i;c.pointWidth=u;c.shapeType=
"rect";c.shapeArgs=f=b.renderer.Element.prototype.crisp.call(0,e,i,j,x,k);e%2&&(f.y-=1,f.height+=1);c.trackerArgs=M(k)<3&&B(c.shapeArgs,{height:6,y:j-3})})},getSymbol:pa,drawLegendSymbol:G.prototype.drawLegendSymbol,drawGraph:pa,drawPoints:function(){var a=this,b=a.options,c=a.chart.renderer,d;o(a.points,function(e){var f=e.plotY,g=e.graphic;if(f!==A&&!isNaN(f)&&e.y!==null)d=e.shapeArgs,g?(fb(g),g.animate(B(d))):e.graphic=c[e.shapeType](d).attr(e.pointAttr[e.selected?"select":""]).add(a.group).shadow(b.shadow,
null,b.stacking&&!b.borderRadius);else if(g)e.graphic=g.destroy()})},drawTracker:function(){for(var a=this,b=a.chart,c=b.renderer,d,e,f=+new Date,g=a.options,h=(d=g.cursor)&&{cursor:d},i=a.isCartesian&&a.plotGroup("trackerGroup",null,"visible",g.zIndex||1,b.trackerGroup),j,k,l=a.points,m,n=l.length,o=function(c){j=c.relatedTarget||c.fromElement;if(b.hoverSeries!==a&&w(j,"isTracker")!==f)a.onMouseOver();l[c.target._i].onMouseOver()},r=function(b){if(!g.stickyTracking&&(j=b.relatedTarget||b.toElement,
w(j,"isTracker")!==f))a.onMouseOut()};n--;)if(m=l[n],e=m.tracker,d=m.trackerArgs||m.shapeArgs,k=m.plotY,k=!a.isCartesian||k!==A&&!isNaN(k),delete d.strokeWidth,m.y!==null&&k){if(e)e.attr(d);else if(m.tracker=e=c[m.shapeType](d).attr({isTracker:f,fill:vb,visibility:a.visible?"visible":"hidden"}).on("mouseover",o).on("mouseout",r).css(h).add(m.group||i),Ba)e.on("touchstart",o);e.element._i=n}},alignDataLabel:function(a,b,c,d,e){var f=this.chart,g=f.inverted,h=a.below||a.plotY>n(this.translatedThreshold,
f.plotSizeY),i=this.options.stacking||c.inside;if(a.shapeArgs&&(d=B(a.shapeArgs),g&&(d={x:f.plotWidth-d.y-d.height,y:f.plotHeight-d.x-d.width,width:d.height,height:d.width}),!i))g?(d.x+=h?0:d.width,d.width=0):(d.y+=h?d.height:0,d.height=0);c.align=n(c.align,!g||i?"center":h?"right":"left");c.verticalAlign=n(c.verticalAlign,g||i?"middle":h?"top":"bottom");P.prototype.alignDataLabel.call(this,a,b,c,d,e)},animate:function(a){var b=this,c=b.points,d=b.options;if(!a)o(c,function(a){var c=a.graphic,a=a.shapeArgs,
g=b.yAxis,h=d.threshold;c&&(c.attr({height:0,y:r(h)?g.getThreshold(h):g.translate(g.getExtremes().min,0,1,0,1)}),c.animate({height:a.height,y:a.y},d.animation))}),b.animate=null},remove:function(){var a=this,b=a.chart;b.hasRendered&&o(b.series,function(b){if(b.type===a.type)b.isDirty=!0});P.prototype.remove.apply(a,arguments)}});$.column=fa;X.bar=B(X.column);Ca=ba(fa,{type:"bar",inverted:!0});$.bar=Ca;X.scatter=B(ea,{lineWidth:0,states:{hover:{lineWidth:0}},tooltip:{headerFormat:'<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
pointFormat:"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}});Ca=ba(P,{type:"scatter",sorted:!1,requireSorting:!1,translate:function(){var a=this;P.prototype.translate.apply(a);o(a.points,function(b){b.shapeType="circle";b.shapeArgs={x:b.plotX,y:b.plotY,r:a.chart.options.tooltip.snap}})},drawTracker:function(){for(var a=this,b=a.options.cursor,b=b&&{cursor:b},c=a.points,d=c.length,e,f=a.markerGroup,g=function(b){a.onMouseOver();if(b.target._i!==A)c[b.target._i].onMouseOver()};d--;)if(e=c[d].graphic)e.element._i=
d;if(a._hasTracking)a._hasTracking=!0;else if(f.attr({isTracker:!0}).on("mouseover",g).on("mouseout",function(){if(!a.options.stickyTracking)a.onMouseOut()}).css(b),Ba)f.on("touchstart",g)},setTooltipPoints:pa});$.scatter=Ca;X.pie=B(ea,{borderColor:"#FFFFFF",borderWidth:1,center:["50%","50%"],colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return this.point.name}},legendType:"point",marker:null,size:"75%",showInLegend:!1,slicedOffset:10,states:{hover:{brightness:0.1,shadow:!1}}});
pa={type:"pie",isCartesian:!1,pointClass:ba(Ua,{init:function(){Ua.prototype.init.apply(this,arguments);var a=this,b;x(a,{visible:a.visible!==!1,name:n(a.name,"Slice")});b=function(){a.slice()};J(a,"select",b);J(a,"unselect",b);return a},setVisible:function(a){var b=this.series,c=b.chart,d=this.tracker,e=this.dataLabel,f=this.connector,g=this.shadowGroup,h;h=(this.visible=a=a===A?!this.visible:a)?"show":"hide";this.group[h]();if(d)d[h]();if(e)e[h]();if(f)f[h]();if(g)g[h]();this.legendItem&&c.legend.colorizeItem(this,
a);if(!b.isDirty&&b.options.ignoreHiddenPoint)b.isDirty=!0,c.redraw()},slice:function(a,b,c){var d=this.series.chart,e=this.slicedTranslation;xa(c,d);n(b,!0);a=this.sliced=r(a)?a:!this.sliced;a={translateX:a?e[0]:d.plotLeft,translateY:a?e[1]:d.plotTop};this.group.animate(a);this.shadowGroup&&this.shadowGroup.animate(a)}}),requireSorting:!1,pointAttrToOptions:{stroke:"borderColor","stroke-width":"borderWidth",fill:"color"},getColor:function(){this.initialColor=this.chart.counters.color},animate:function(){var a=
this,b=a.startAngleRad;o(a.points,function(c){var d=c.graphic,c=c.shapeArgs;d&&(d.attr({r:a.center[3]/2,start:b,end:b}),d.animate({r:c.r,start:c.start,end:c.end},a.options.animation))});a.animate=null},setData:function(a,b){P.prototype.setData.call(this,a,!1);this.processData();this.generatePoints();n(b,!0)&&this.chart.redraw()},getCenter:function(){var a=this.options,b=this.chart,c=b.plotWidth,d=b.plotHeight,a=a.center.concat([a.size,a.innerSize||0]),e=O(c,d),f;return Ta(a,function(a,b){return(f=
/%$/.test(a))?[c,d,e,e][b]*z(a)/100:a})},translate:function(){this.generatePoints();var a=0,b=0,c=this.options,d=c.slicedOffset,e=d+c.borderWidth,f,g=this.chart,h,i,j,k=this.startAngleRad=Aa/180*((c.startAngle||0)%360-90),l=this.points,m=2*Aa,n=c.dataLabels.distance,o=c.ignoreHiddenPoint,r,t=l.length,s;this.center=f=this.getCenter();this.getX=function(a,b){j=K.asin((a-f[1])/(f[2]/2+n));return f[0]+(b?-1:1)*W(j)*(f[2]/2+n)};for(r=0;r<t;r++)s=l[r],a+=o&&!s.visible?0:s.y;for(r=0;r<t;r++){s=l[r];c=a?
s.y/a:0;h=u((k+b*m)*1E3)/1E3;if(!o||s.visible)b+=c;i=u((k+b*m)*1E3)/1E3;s.shapeType="arc";s.shapeArgs={x:f[0],y:f[1],r:f[2]/2,innerR:f[3]/2,start:h,end:i};j=(i+h)/2;j>0.75*m&&(j-=2*Aa);s.slicedTranslation=Ta([W(j)*d+g.plotLeft,Z(j)*d+g.plotTop],u);h=W(j)*f[2]/2;i=Z(j)*f[2]/2;s.tooltipPos=[f[0]+h*0.7,f[1]+i*0.7];s.half=j<m/4?0:1;s.angle=j;s.labelPos=[f[0]+h+W(j)*n,f[1]+i+Z(j)*n,f[0]+h+W(j)*e,f[1]+i+Z(j)*e,f[0]+h,f[1]+i,n<0?"center":s.half?"right":"left",j];s.percentage=c*100;s.total=a}this.setTooltipPoints()},
render:function(){this.getAttribs();this.drawPoints();this.options.enableMouseTracking!==!1&&this.drawTracker();this.drawDataLabels();this.options.animation&&this.animate&&this.animate();this.isDirty=!1},drawPoints:function(){var a=this,b=a.chart,c=b.renderer,d,e,f,g=a.options.shadow,h,i;o(a.points,function(j){e=j.graphic;i=j.shapeArgs;f=j.group;h=j.shadowGroup;if(g&&!h)h=j.shadowGroup=c.g("shadow").attr({zIndex:4}).add();if(!f)f=j.group=c.g("point").attr({zIndex:5}).add();d=j.sliced?j.slicedTranslation:
[b.plotLeft,b.plotTop];f.translate(d[0],d[1]);h&&h.translate(d[0],d[1]);e?e.animate(i):j.graphic=e=c.arc(i).setRadialReference(a.center).attr(x(j.pointAttr[""],{"stroke-linejoin":"round"})).add(j.group).shadow(g,h);j.visible===!1&&j.setVisible(!1)})},drawDataLabels:function(){var a=this.data,b,c=this.chart,d=this.options.dataLabels,e=n(d.connectorPadding,10),f=n(d.connectorWidth,1),g,h,i=n(d.softConnector,!0),j=d.distance,k=this.center,l=k[2]/2,m=k[1],q=j>0,p=[[],[]],r,t,s,u=2,v,x=function(a,b){return b.y-
a.y},z=function(a,b){a.sort(function(a,c){return(c.angle-a.angle)*b})};if(d.enabled||this._hasPointLabels){P.prototype.drawDataLabels.apply(this);o(a,function(a){a.dataLabel&&p[a.half].push(a)});for(a=p[0][0]&&p[0][0].dataLabel&&(p[0][0].dataLabel.getBBox().height||21);u--;){var w=[],A=[],B=p[u],C=B.length,D;z(B,u-0.5);if(j>0){for(v=m-l-j;v<=m+l+j;v+=a)w.push(v);s=w.length;if(C>s){h=[].concat(B);h.sort(x);for(v=C;v--;)h[v].rank=v;for(v=C;v--;)B[v].rank>=s&&B.splice(v,1);C=B.length}for(v=0;v<C;v++){b=
B[v];h=b.labelPos;b=9999;for(t=0;t<s;t++)g=M(w[t]-h[1]),g<b&&(b=g,D=t);if(D<v&&w[v]!==null)D=v;else for(s<C-v+D&&w[v]!==null&&(D=s-C+v);w[D]===null;)D++;A.push({i:D,y:w[D]});w[D]=null}A.sort(x)}for(v=0;v<C;v++){b=B[v];h=b.labelPos;g=b.dataLabel;s=b.visible===!1?"hidden":"visible";r=h[1];if(j>0){if(t=A.pop(),D=t.i,t=t.y,r>t&&w[D+1]!==null||r<t&&w[D-1]!==null)t=r}else t=r;r=d.justify?k[0]+(u?-1:1)*(l+j):this.getX(D===0||D===w.length-1?r:t,u);g.attr({visibility:s,align:h[6]})[g.moved?"animate":"attr"]({x:r+
d.x+({left:e,right:-e}[h[6]]||0),y:t+d.y-10});g.moved=!0;if(q&&f)g=b.connector,h=i?["M",r+(h[6]==="left"?5:-5),t,"C",r,t,2*h[2]-h[4],2*h[3]-h[5],h[2],h[3],"L",h[4],h[5]]:["M",r+(h[6]==="left"?5:-5),t,"L",h[2],h[3],"L",h[4],h[5]],g?(g.animate({d:h}),g.attr("visibility",s)):b.connector=g=this.chart.renderer.path(h).attr({"stroke-width":f,stroke:d.connectorColor||b.color||"#606060",visibility:s,zIndex:3}).translate(c.plotLeft,c.plotTop).add()}}}},alignDataLabel:pa,drawTracker:fa.prototype.drawTracker,
drawLegendSymbol:G.prototype.drawLegendSymbol,getSymbol:function(){}};pa=ba(P,pa);$.pie=pa;x(Highcharts,{Axis:ob,CanVGRenderer:gb,Chart:sb,Color:qa,Legend:rb,MouseTracker:qb,Point:Ua,Tick:Qa,Tooltip:pb,Renderer:Sa,Series:P,SVGRenderer:sa,VMLRenderer:ha,arrayMin:Fa,arrayMax:wa,charts:Ha,dateFormat:db,pathAnim:ub,getOptions:function(){return N},hasBidiBug:Sb,isTouchDevice:Mb,numberFormat:Ja,seriesTypes:$,setOptions:function(a){N=B(N,a);Jb();return N},addEvent:J,removeEvent:R,createElement:T,discardElement:Na,
css:I,each:o,extend:x,map:Ta,merge:B,pick:n,splat:la,extendClass:ba,pInt:z,wrap:function(a,b,c){var d=a[b];a[b]=function(){var a=Array.prototype.slice.call(arguments);a.unshift(d);return c.apply(this,a)}},svg:ca,canvas:V,vml:!ca&&!V,product:"Highcharts",version:"2.3.5"})})();

/*
 Highcharts JS v2.3.5 (2012-12-19)
 Exporting module

 (c) 2010-2011 Torstein Hønsi

 License: www.highcharts.com/license
*/
(function(e){function y(a){for(var b=a.length;b--;)typeof a[b]==="number"&&(a[b]=Math.round(a[b])-0.5);return a}var z=e.Chart,u=e.addEvent,B=e.removeEvent,j=e.createElement,v=e.discardElement,t=e.css,l=e.merge,k=e.each,o=e.extend,C=Math.max,i=document,D=window,E=e.isTouchDevice,A=e.Renderer.prototype.symbols,w=e.getOptions();o(w.lang,{downloadPNG:"Download PNG image",downloadJPEG:"Download JPEG image",downloadPDF:"Download PDF document",downloadSVG:"Download SVG vector image",exportButtonTitle:"Export to raster or vector image",
printButtonTitle:"Print the chart"});w.navigation={menuStyle:{border:"1px solid #A0A0A0",background:"#FFFFFF"},menuItemStyle:{padding:"0 5px",background:"none",color:"#303030",fontSize:E?"14px":"11px"},menuItemHoverStyle:{background:"#4572A5",color:"#FFFFFF"},buttonOptions:{align:"right",backgroundColor:{linearGradient:[0,0,0,20],stops:[[0.4,"#F7F7F7"],[0.6,"#E3E3E3"]]},borderColor:"#B0B0B0",borderRadius:3,borderWidth:1,height:20,hoverBorderColor:"#909090",hoverSymbolFill:"#81A7CF",hoverSymbolStroke:"#4572A5",
symbolFill:"#E0E0E0",symbolStroke:"#A0A0A0",symbolX:11.5,symbolY:10.5,verticalAlign:"top",width:24,y:10}};w.exporting={type:"image/png",url:"http://export.highcharts.com/",width:800,buttons:{exportButton:{symbol:"exportIcon",x:-10,symbolFill:"#A8BF77",hoverSymbolFill:"#768F3E",_id:"exportButton",_titleKey:"exportButtonTitle",menuItems:[{textKey:"downloadPNG",onclick:function(){this.exportChart()}},{textKey:"downloadJPEG",onclick:function(){this.exportChart({type:"image/jpeg"})}},{textKey:"downloadPDF",
onclick:function(){this.exportChart({type:"application/pdf"})}},{textKey:"downloadSVG",onclick:function(){this.exportChart({type:"image/svg+xml"})}}]},printButton:{symbol:"printIcon",x:-36,symbolFill:"#B5C9DF",hoverSymbolFill:"#779ABF",_id:"printButton",_titleKey:"printButtonTitle",onclick:function(){this.print()}}}};e.post=function(a,b){var c,d;d=j("form",{method:"post",action:a,enctype:"multipart/form-data"},{display:"none"},i.body);for(c in b)j("input",{type:"hidden",name:c,value:b[c]},null,d);
d.submit();v(d)};o(z.prototype,{getSVG:function(a){var b=this,c,d,f,g=l(b.options,a);if(!i.createElementNS)i.createElementNS=function(a,b){return i.createElement(b)};a=j("div",null,{position:"absolute",top:"-9999em",width:b.chartWidth+"px",height:b.chartHeight+"px"},i.body);o(g.chart,{renderTo:a,forExport:!0});g.exporting.enabled=!1;g.chart.plotBackgroundImage=null;g.series=[];k(b.series,function(a){f=l(a.options,{animation:!1,showCheckbox:!1,visible:a.visible});f.isInternal||g.series.push(f)});c=
new e.Chart(g);k(["xAxis","yAxis"],function(a){k(b[a],function(b,d){var f=c[a][d],g=b.getExtremes(),e=g.userMin,g=g.userMax;(e!==void 0||g!==void 0)&&f.setExtremes(e,g,!0,!1)})});d=c.container.innerHTML;g=null;c.destroy();v(a);d=d.replace(/zIndex="[^"]+"/g,"").replace(/isShadow="[^"]+"/g,"").replace(/symbolName="[^"]+"/g,"").replace(/jQuery[0-9]+="[^"]+"/g,"").replace(/isTracker="[^"]+"/g,"").replace(/url\([^#]+#/g,"url(#").replace(/<svg /,'<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ href=/g,
" xlink:href=").replace(/\n/," ").replace(/<\/svg>.*?$/,"</svg>").replace(/&nbsp;/g," ").replace(/&shy;/g,"­").replace(/<IMG /g,"<image ").replace(/height=([^" ]+)/g,'height="$1"').replace(/width=([^" ]+)/g,'width="$1"').replace(/hc-svg-href="([^"]+)">/g,'xlink:href="$1"/>').replace(/id=([^" >]+)/g,'id="$1"').replace(/class=([^" ]+)/g,'class="$1"').replace(/ transform /g," ").replace(/:(path|rect)/g,"$1").replace(/style="([^"]+)"/g,function(a){return a.toLowerCase()});d=d.replace(/(url\(#highcharts-[0-9]+)&quot;/g,
"$1").replace(/&quot;/g,"'");d.match(/ xmlns="/g).length===2&&(d=d.replace(/xmlns="[^"]+"/,""));return d},exportChart:function(a,b){var c=this.options.exporting,d=this.getSVG(l(c.chartOptions,b)),a=l(c,a);e.post(a.url,{filename:a.filename||"chart",type:a.type,width:a.width,scale:a.scale||2,svg:d})},print:function(){var a=this,b=a.container,c=[],d=b.parentNode,f=i.body,g=f.childNodes;if(!a.isPrinting)a.isPrinting=!0,k(g,function(a,b){if(a.nodeType===1)c[b]=a.style.display,a.style.display="none"}),
f.appendChild(b),D.print(),setTimeout(function(){d.appendChild(b);k(g,function(a,b){if(a.nodeType===1)a.style.display=c[b]});a.isPrinting=!1},1E3)},contextMenu:function(a,b,c,d,f,g){var e=this,p=e.options.navigation,i=p.menuItemStyle,q=e.chartWidth,r=e.chartHeight,s="cache-"+a,h=e[s],m=C(f,g),x,n,l;if(!h)e[s]=h=j("div",{className:"highcharts-"+a},{position:"absolute",zIndex:1E3,padding:m+"px"},e.container),x=j("div",null,o({MozBoxShadow:"3px 3px 10px #888",WebkitBoxShadow:"3px 3px 10px #888",boxShadow:"3px 3px 10px #888"},
p.menuStyle),h),n=function(){t(h,{display:"none"})},u(h,"mouseleave",function(){l=setTimeout(n,500)}),u(h,"mouseenter",function(){clearTimeout(l)}),k(b,function(a){if(a){var b=j("div",{onmouseover:function(){t(this,p.menuItemHoverStyle)},onmouseout:function(){t(this,i)},innerHTML:a.text||e.options.lang[a.textKey]},o({cursor:"pointer"},i),x);b.onclick=function(){n();a.onclick.apply(e,arguments)};e.exportDivElements.push(b)}}),e.exportDivElements.push(x,h),e.exportMenuWidth=h.offsetWidth,e.exportMenuHeight=
h.offsetHeight;a={display:"block"};c+e.exportMenuWidth>q?a.right=q-c-f-m+"px":a.left=c-m+"px";d+g+e.exportMenuHeight>r?a.bottom=r-d-m+"px":a.top=d+g-m+"px";t(h,a)},addButton:function(a){function b(){r.attr(k);q.attr(m)}var c=this,d=c.renderer,f=l(c.options.navigation.buttonOptions,a),e=f.onclick,i=f.menuItems,p=f.width,j=f.height,q,r,s,h,a=f.borderWidth,m={stroke:f.borderColor},k={stroke:f.symbolStroke,fill:f.symbolFill},n=f.symbolSize||12;if(!c.btnCount)c.btnCount=0;h=c.btnCount++;if(!c.exportDivElements)c.exportDivElements=
[],c.exportSVGElements=[];f.enabled!==!1&&(q=d.rect(0,0,p,j,f.borderRadius,a).align(f,!0).attr(o({fill:f.backgroundColor,"stroke-width":a,zIndex:19},m)).add(),s=d.rect(0,0,p,j,0).align(f).attr({id:f._id,fill:"rgba(255, 255, 255, 0.001)",title:c.options.lang[f._titleKey],zIndex:21}).css({cursor:"pointer"}).on("mouseover",function(){r.attr({stroke:f.hoverSymbolStroke,fill:f.hoverSymbolFill});q.attr({stroke:f.hoverBorderColor})}).on("mouseout",b).on("click",b).add(),i&&(e=function(){b();var a=s.getBBox();
c.contextMenu("menu"+h,i,a.x,a.y,p,j)}),s.on("click",function(){e.apply(c,arguments)}),r=d.symbol(f.symbol,f.symbolX-n/2,f.symbolY-n/2,n,n).align(f,!0).attr(o(k,{"stroke-width":f.symbolStrokeWidth||1,zIndex:20})).add(),c.exportSVGElements.push(q,s,r))},destroyExport:function(){var a,b;for(a=0;a<this.exportSVGElements.length;a++)b=this.exportSVGElements[a],b.onclick=b.ontouchstart=null,this.exportSVGElements[a]=b.destroy();for(a=0;a<this.exportDivElements.length;a++)b=this.exportDivElements[a],B(b,
"mouseleave"),this.exportDivElements[a]=b.onmouseout=b.onmouseover=b.ontouchstart=b.onclick=null,v(b)}});A.exportIcon=function(a,b,c,d){return y(["M",a,b+c,"L",a+c,b+d,a+c,b+d*0.8,a,b+d*0.8,"Z","M",a+c*0.5,b+d*0.8,"L",a+c*0.8,b+d*0.4,a+c*0.4,b+d*0.4,a+c*0.4,b,a+c*0.6,b,a+c*0.6,b+d*0.4,a+c*0.2,b+d*0.4,"Z"])};A.printIcon=function(a,b,c,d){return y(["M",a,b+d*0.7,"L",a+c,b+d*0.7,a+c,b+d*0.4,a,b+d*0.4,"Z","M",a+c*0.2,b+d*0.4,"L",a+c*0.2,b,a+c*0.8,b,a+c*0.8,b+d*0.4,"Z","M",a+c*0.2,b+d*0.7,"L",a,b+d,a+
c,b+d,a+c*0.8,b+d*0.7,"Z"])};z.prototype.callbacks.push(function(a){var b,c=a.options.exporting,d=c.buttons;if(c.enabled!==!1){for(b in d)a.addButton(d[b]);u(a,"destroy",a.destroyExport)}})})(Highcharts);

/**
 * SWFObject v1.5: Flash Player detection and embed - http://blog.deconcept.com/swfobject/
 *
 * SWFObject is (c) 2007 Geoff Stearns and is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */
if(typeof deconcept=="undefined"){var deconcept=new Object();}if(typeof deconcept.util=="undefined"){deconcept.util=new Object();}if(typeof deconcept.SWFObjectUtil=="undefined"){deconcept.SWFObjectUtil=new Object();}deconcept.SWFObject=function(_1,id,w,h,_5,c,_7,_8,_9,_a){if(!document.getElementById){return;}this.DETECT_KEY=_a?_a:"detectflash";this.skipDetect=deconcept.util.getRequestParameter(this.DETECT_KEY);this.params=new Object();this.variables=new Object();this.attributes=new Array();if(_1){this.setAttribute("swf",_1);}if(id){this.setAttribute("id",id);}if(w){this.setAttribute("width",w);}if(h){this.setAttribute("height",h);}if(_5){this.setAttribute("version",new deconcept.PlayerVersion(_5.toString().split(".")));}this.installedVer=deconcept.SWFObjectUtil.getPlayerVersion();if(!window.opera&&document.all&&this.installedVer.major>7){deconcept.SWFObject.doPrepUnload=true;}if(c){this.addParam("bgcolor",c);}var q=_7?_7:"high";this.addParam("quality",q);this.setAttribute("useExpressInstall",false);this.setAttribute("doExpressInstall",false);var _c=(_8)?_8:window.location;this.setAttribute("xiRedirectUrl",_c);this.setAttribute("redirectUrl","");if(_9){this.setAttribute("redirectUrl",_9);}};deconcept.SWFObject.prototype={useExpressInstall:function(_d){this.xiSWFPath=!_d?"expressinstall.swf":_d;this.setAttribute("useExpressInstall",true);},setAttribute:function(_e,_f){this.attributes[_e]=_f;},getAttribute:function(_10){return this.attributes[_10];},addParam:function(_11,_12){this.params[_11]=_12;},getParams:function(){return this.params;},addVariable:function(_13,_14){this.variables[_13]=_14;},getVariable:function(_15){return this.variables[_15];},getVariables:function(){return this.variables;},getVariablePairs:function(){var _16=new Array();var key;var _18=this.getVariables();for(key in _18){_16[_16.length]=key+"="+_18[key];}return _16;},getSWFHTML:function(){var _19="";if(navigator.plugins&&navigator.mimeTypes&&navigator.mimeTypes.length){if(this.getAttribute("doExpressInstall")){this.addVariable("MMplayerType","PlugIn");this.setAttribute("swf",this.xiSWFPath);}_19="<embed type=\"application/x-shockwave-flash\" src=\""+this.getAttribute("swf")+"\" width=\""+this.getAttribute("width")+"\" height=\""+this.getAttribute("height")+"\" style=\""+this.getAttribute("style")+"\"";_19+=" id=\""+this.getAttribute("id")+"\" name=\""+this.getAttribute("id")+"\" ";var _1a=this.getParams();for(var key in _1a){_19+=[key]+"=\""+_1a[key]+"\" ";}var _1c=this.getVariablePairs().join("&");if(_1c.length>0){_19+="flashvars=\""+_1c+"\"";}_19+="/>";}else{if(this.getAttribute("doExpressInstall")){this.addVariable("MMplayerType","ActiveX");this.setAttribute("swf",this.xiSWFPath);}_19="<object id=\""+this.getAttribute("id")+"\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" width=\""+this.getAttribute("width")+"\" height=\""+this.getAttribute("height")+"\" style=\""+this.getAttribute("style")+"\">";_19+="<param name=\"movie\" value=\""+this.getAttribute("swf")+"\" />";var _1d=this.getParams();for(var key in _1d){_19+="<param name=\""+key+"\" value=\""+_1d[key]+"\" />";}var _1f=this.getVariablePairs().join("&");if(_1f.length>0){_19+="<param name=\"flashvars\" value=\""+_1f+"\" />";}_19+="</object>";}return _19;},write:function(_20){if(this.getAttribute("useExpressInstall")){var _21=new deconcept.PlayerVersion([6,0,65]);if(this.installedVer.versionIsValid(_21)&&!this.installedVer.versionIsValid(this.getAttribute("version"))){this.setAttribute("doExpressInstall",true);this.addVariable("MMredirectURL",encodeURIComponent(this.getAttribute("xiRedirectUrl")));document.title=document.title.slice(0,47)+" - Flash Player Installation";this.addVariable("MMdoctitle",document.title);}}if(this.skipDetect||this.getAttribute("doExpressInstall")||this.installedVer.versionIsValid(this.getAttribute("version"))){var n=(typeof _20=="string")?document.getElementById(_20):_20;n.innerHTML=this.getSWFHTML();if(!(navigator.plugins && navigator.mimeTypes.length)) window[this.getAttribute('id')] = document.getElementById(this.getAttribute('id'));return true;}else{if(this.getAttribute("redirectUrl")!=""){document.location.replace(this.getAttribute("redirectUrl"));}}return false;}};deconcept.SWFObjectUtil.getPlayerVersion=function(){var _23=new deconcept.PlayerVersion([0,0,0]);if(navigator.plugins&&navigator.mimeTypes.length){var x=navigator.plugins["Shockwave Flash"];if(x&&x.description){_23=new deconcept.PlayerVersion(x.description.replace(/([a-zA-Z]|\s)+/,"").replace(/(\s+r|\s+b[0-9]+)/,".").split("."));}}else{if(navigator.userAgent&&navigator.userAgent.indexOf("Windows CE")>=0){var axo=1;var _26=3;while(axo){try{_26++;axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash."+_26);_23=new deconcept.PlayerVersion([_26,0,0]);}catch(e){axo=null;}}}else{try{var axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");}catch(e){try{var axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");_23=new deconcept.PlayerVersion([6,0,21]);axo.AllowScriptAccess="always";}catch(e){if(_23.major==6){return _23;}}try{axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash");}catch(e){}}if(axo!=null){_23=new deconcept.PlayerVersion(axo.GetVariable("$version").split(" ")[1].split(","));}}}return _23;};deconcept.PlayerVersion=function(_29){this.major=_29[0]!=null?parseInt(_29[0]):0;this.minor=_29[1]!=null?parseInt(_29[1]):0;this.rev=_29[2]!=null?parseInt(_29[2]):0;};deconcept.PlayerVersion.prototype.versionIsValid=function(fv){if(this.major<fv.major){return false;}if(this.major>fv.major){return true;}if(this.minor<fv.minor){return false;}if(this.minor>fv.minor){return true;}if(this.rev<fv.rev){return false;}return true;};deconcept.util={getRequestParameter:function(_2b){var q=document.location.search||document.location.hash;if(_2b==null){return q;}if(q){var _2d=q.substring(1).split("&");for(var i=0;i<_2d.length;i++){if(_2d[i].substring(0,_2d[i].indexOf("="))==_2b){return _2d[i].substring((_2d[i].indexOf("=")+1));}}}return "";}};deconcept.SWFObjectUtil.cleanupSWFs=function(){var _2f=document.getElementsByTagName("OBJECT");for(var i=_2f.length-1;i>=0;i--){_2f[i].style.display="none";for(var x in _2f[i]){if(typeof _2f[i][x]=="function"){_2f[i][x]=function(){};}}}};if(deconcept.SWFObject.doPrepUnload){if(!deconcept.unloadSet){deconcept.SWFObjectUtil.prepUnload=function(){__flash_unloadHandler=function(){};__flash_savedUnloadHandler=function(){};window.attachEvent("onunload",deconcept.SWFObjectUtil.cleanupSWFs);};window.attachEvent("onbeforeunload",deconcept.SWFObjectUtil.prepUnload);deconcept.unloadSet=true;}}if(!document.getElementById&&document.all){document.getElementById=function(id){return document.all[id];};}var getQueryParamValue=deconcept.util.getRequestParameter;var FlashObject=deconcept.SWFObject;var SWFObject=deconcept.SWFObject;

/*
 * jQuery clueTip plugin
 * Version 0.9.8  (05/22/2008)
 * @requires jQuery v1.1.4+
 * @requires Dimensions plugin (for jQuery versions < 1.2.5)
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
;(function(jQuery) { 
/*
 * @name clueTip
 * @type jQuery
 * @cat Plugins/tooltip
 * @return jQuery
 * @author Karl Swedberg
 *
 * @credit Inspired by Cody Lindley's jTip (http://www.codylindley.com)
 * @credit Thanks to the following people for their many and varied contributions:
      Shelane Enos, Glen Lipka, Hector Santos, Torben Schreiter, Dan G. Switzer, Jörn Zaefferer 
 * @credit Thanks to Jonathan Chaffer, as always, for help with the hard parts. :-)
 */

 /**
 * 
 * Displays a highly customizable tooltip when the user hovers (default) or clicks (optional) the matched element. 
 * By default, the clueTip plugin loads a page indicated by the "rel" attribute via ajax and displays its contents.
 * If a "title" attribute is specified, its value is used as the clueTip's heading.
 * The attribute to be used for both the body and the heading of the clueTip is user-configurable. 
 * Optionally, the clueTip's body can display content from an element on the same page.
 * * Just indicate the element's id (e.g. "#some-id") in the rel attribute.
 * Optionally, the clueTip's body can display content from the title attribute, when a delimiter is indicated. 
 * * The string before the first instance of the delimiter is set as the clueTip's heading.
 * * All subsequent strings are wrapped in separate DIVs and placed in the clueTip's body.
 * The clueTip plugin allows for many, many more options. Pleasee see the examples and the option descriptions below...
 * 
 * 
 * @example jQuery('#tip).cluetip();
 * @desc This is the most basic clueTip. It displays a 275px-wide clueTip on mouseover of the element with an ID of "tip." On mouseout of the element, the clueTip is hidden.
 *
 *
 * @example jQuery('a.clue').cluetip({
 *  hoverClass: 'highlight',
 *  sticky: true,
 *  closePosition: 'bottom',
 *  closeText: '<img src="cross.png" alt="close" />',
 *  truncate: 60,
 *  ajaxSettings: {
 *    type: 'POST'
 *  }
 * });
 * @desc Displays a clueTip on mouseover of all <a> elements with class="clue". The hovered element gets a class of "highlight" added to it (so that it can be styled appropriately. This is esp. useful for non-anchor elements.). The clueTip is "sticky," which means that it will not be hidden until the user either clicks on its "close" text/graphic or displays another clueTip. The "close" text/graphic is set to diplay at the bottom of the clueTip (default is top) and display an image rather than the default "Close" text. Moreover, the body of the clueTip is truncated to the first 60 characters, which are followed by an ellipsis (...). Finally, the clueTip retrieves the content using POST rather than the jQuery.ajax method's default "GET."
 * 
 * More examples can be found at http://plugins.learningjquery.com/cluetip/demo/
 * 
 * Full list of options/settings can be found at the bottom of this file and at http://plugins.learningjquery.com/cluetip/
 */

  var $cluetip, $cluetipInner, $cluetipOuter, $cluetipTitle, $cluetipArrows, $dropShadow, imgCount;
  jQuery.fn.cluetip = function(js, options) {
    if (typeof js == 'object') {
      options = js;
      js = null;
    }
    return this.each(function(index) {
      var $this = jQuery(this);      
      
      // support metadata plugin (v1.0 and 2.0)
      var opts = jQuery.extend(false, {}, jQuery.fn.cluetip.defaults, options || {}, jQuery.metadata ? $this.metadata() : jQuery.meta ? $this.data() : {});

      // start out with no contents (for ajax activation)
      var cluetipContents = false;
      var cluezIndex = parseInt(opts.cluezIndex, 10)-1;
      var isActive = false, closeOnDelay = 0;

      // create the cluetip divs
      if (!jQuery('#cluetip').length) {
        $cluetipInner = jQuery('<div id="cluetip-inner"></div>');
        $cluetipTitle = jQuery('<h3 id="cluetip-title"></h3>');        
        $cluetipOuter = jQuery('<div id="cluetip-outer"></div>').append($cluetipInner).prepend($cluetipTitle);
        $cluetip = jQuery('<div id="cluetip"></div>').css({zIndex: opts.cluezIndex})
        .append($cluetipOuter).append('<div id="cluetip-extra"></div>')[insertionType](insertionElement).hide();
        jQuery('<div id="cluetip-waitimage"></div>').css({position: 'absolute', zIndex: cluezIndex-1})
        .insertBefore('#cluetip').hide();
        $cluetip.css({position: 'absolute', zIndex: cluezIndex});
        $cluetipOuter.css({position: 'relative', zIndex: cluezIndex+1});
        $cluetipArrows = jQuery('<div id="cluetip-arrows" class="cluetip-arrows"></div>').css({zIndex: cluezIndex+1}).appendTo('#cluetip');
      }
      var dropShadowSteps = (opts.dropShadow) ? +opts.dropShadowSteps : 0;
      if (!$dropShadow) {
        $dropShadow = jQuery([]);
        for (var i=0; i < dropShadowSteps; i++) {
          $dropShadow = $dropShadow.add(jQuery('<div></div>').css({zIndex: cluezIndex-i-1, opacity:.1, top: 1+i, left: 1+i}));
        };
        $dropShadow.css({position: 'absolute', backgroundColor: '#000'})
        .prependTo($cluetip);
      }
      var tipAttribute = $this.attr(opts.attribute), ctClass = opts.cluetipClass;
      if (!tipAttribute && !opts.splitTitle && !js) return true;
      // if hideLocal is set to true, on DOM ready hide the local content that will be displayed in the clueTip      
      if (opts.local && opts.hideLocal) { jQuery(tipAttribute + ':first').hide(); }
      var tOffset = parseInt(opts.topOffset, 10), lOffset = parseInt(opts.leftOffset, 10);
      // vertical measurement variables
      var tipHeight, wHeight;
      var defHeight = isNaN(parseInt(opts.height, 10)) ? 'auto' : (/\D/g).test(opts.height) ? opts.height : opts.height + 'px';
      var sTop, linkTop, posY, tipY, mouseY, baseline;
      // horizontal measurement variables
      var tipInnerWidth = isNaN(parseInt(opts.width, 10)) ? 275 : parseInt(opts.width, 10);
      var tipWidth = tipInnerWidth + (parseInt($cluetip.css('paddingLeft'))||0) + (parseInt($cluetip.css('paddingRight'))||0) + dropShadowSteps;
      var linkWidth = this.offsetWidth;
      var linkLeft, posX, tipX, mouseX, winWidth;
            
      // parse the title
      var tipParts;
      var tipTitle = (opts.attribute != 'title') ? $this.attr(opts.titleAttribute) : '';
      if (opts.splitTitle) {
        if(tipTitle == undefined) {tipTitle = '';}
        tipParts = tipTitle.split(opts.splitTitle);
        tipTitle = tipParts.shift();
      }
      var localContent;

/***************************************      
* ACTIVATION
****************************************/
    
//activate clueTip
    var activate = function(event) {
      if (!opts.onActivate($this)) {
        return false;
      }
      isActive = true;
      $cluetip.removeClass().css({width: tipInnerWidth});
      if (tipAttribute == $this.attr('href')) {
        $this.css('cursor', opts.cursor);
      }
      $this.attr('title','');
      if (opts.hoverClass) {
        $this.addClass(opts.hoverClass);
      }
      linkTop = posY = $this.offset().top;
      linkLeft = $this.offset().left;
      mouseX = event.pageX;
      mouseY = event.pageY;
      if ($this[0].tagName.toLowerCase() != 'area') {
        sTop = jQuery(document).scrollTop();
        winWidth = jQuery(window).width();
      }
// position clueTip horizontally
      if (opts.positionBy == 'fixed') {
        posX = linkWidth + linkLeft + lOffset;
        $cluetip.css({left: posX});
      } else {
        posX = (linkWidth > linkLeft && linkLeft > tipWidth)
          || linkLeft + linkWidth + tipWidth + lOffset > winWidth 
          ? linkLeft - tipWidth - lOffset 
          : linkWidth + linkLeft + lOffset;
        if ($this[0].tagName.toLowerCase() == 'area' || opts.positionBy == 'mouse' || linkWidth + tipWidth > winWidth) { // position by mouse
          if (mouseX + 20 + tipWidth > winWidth) {  
            $cluetip.addClass(' cluetip-' + ctClass);
            posX = (mouseX - tipWidth - lOffset) >= 0 ? mouseX - tipWidth - lOffset - parseInt($cluetip.css('marginLeft'),10) + parseInt($cluetipInner.css('marginRight'),10) :  mouseX - (tipWidth/2);
          } else {
            posX = mouseX + lOffset;
          }
        }
        var pY = posX < 0 ? event.pageY + tOffset : event.pageY;
        $cluetip.css({left: (posX > 0 && opts.positionBy != 'bottomTop') ? posX : (mouseX + (tipWidth/2) > winWidth) ? winWidth/2 - tipWidth/2 : Math.max(mouseX - (tipWidth/2),0)});
      }
        wHeight = jQuery(window).height();

/***************************************
* load a string from cluetip method's first argument
***************************************/
      if (js) {
        $cluetipInner.html(js);
        cluetipShow(pY);
      }
/***************************************
* load the title attribute only (or user-selected attribute). 
* clueTip title is the string before the first delimiter
* subsequent delimiters place clueTip body text on separate lines
***************************************/

      else if (tipParts) {
        var tpl = tipParts.length;
        for (var i=0; i < tpl; i++){
          if (i == 0) {
            $cluetipInner.html(tipParts[i]);
          } else { 
            $cluetipInner.append('<div class="split-body">' + tipParts[i] + '</div>');
          }            
        };
        cluetipShow(pY);
      }
/***************************************
* load external file via ajax          
***************************************/

      else if (!opts.local && tipAttribute.indexOf('#') != 0) {
        if (cluetipContents && opts.ajaxCache) {
          $cluetipInner.html(cluetipContents);
          cluetipShow(pY);
        }
        else {
          var ajaxSettings = opts.ajaxSettings;
          ajaxSettings.url = tipAttribute;
          ajaxSettings.beforeSend = function() {
            $cluetipOuter.children().empty();
            if (opts.waitImage) {
              jQuery('#cluetip-waitimage')
              .css({top: mouseY+20, left: mouseX+20})
              .show();
            }
          };
         ajaxSettings.error = function() {
            if (isActive) {
              $cluetipInner.html('<i>sorry, the contents could not be loaded</i>');
            }
          };
          ajaxSettings.success = function(data) {
            cluetipContents = opts.ajaxProcess(data);
            if (isActive) {
              $cluetipInner.html(cluetipContents);
            }
          };
          ajaxSettings.complete = function() {
          	imgCount = jQuery('#cluetip-inner img').length;
        		if (imgCount && !jQuery.browser.opera) {
        		  jQuery('#cluetip-inner img').load(function() {
          			imgCount--;
          			if (imgCount<1) {
          				jQuery('#cluetip-waitimage').hide();
          			  if (isActive) cluetipShow(pY);
          			}
        		  }); 
        		} else {
      				jQuery('#cluetip-waitimage').hide();
        		  if (isActive) cluetipShow(pY);    
        		} 
          };
          jQuery.ajax(ajaxSettings);
        }

/***************************************
* load an element from the same page
***************************************/
      } else if (opts.local){
        var $localContent = jQuery(tipAttribute + ':first');
        var localCluetip = jQuery.fn.wrapInner ? $localContent.wrapInner('<div></div>').children().clone(true) : $localContent.html();
        jQuery.fn.wrapInner ? $cluetipInner.empty().append(localCluetip) : $cluetipInner.html(localCluetip);
        cluetipShow(pY);
      }
    };

// get dimensions and options for cluetip and prepare it to be shown
    var cluetipShow = function(bpY) {
      $cluetip.addClass('cluetip-' + ctClass);
      
      if (opts.truncate) { 
        var $truncloaded = $cluetipInner.text().slice(0,opts.truncate) + '...';
        $cluetipInner.html($truncloaded);
      }
      function doNothing() {}; //empty function
      tipTitle ? $cluetipTitle.show().html(tipTitle) : (opts.showTitle) ? $cluetipTitle.show().html('&nbsp;') : $cluetipTitle.hide();
      if (opts.sticky) {
        var $closeLink = jQuery('<div id="cluetip-close"><a href="#">' + opts.closeText + '</a></div>');
        (opts.closePosition == 'bottom') ? $closeLink.appendTo($cluetipInner) : (opts.closePosition == 'title') ? $closeLink.prependTo($cluetipTitle) : $closeLink.prependTo($cluetipInner);
        $closeLink.click(function() {
          cluetipClose();
          return false;
        });
        if (opts.mouseOutClose) {
          if (jQuery.fn.hoverIntent && opts.hoverIntent) { 
            $cluetip.hoverIntent({
              over: doNothing, 
              timeout: opts.hoverIntent.timeout,  
              out: function() { $closeLink.trigger('click'); }
            });
          } else {
            $cluetip.hover(doNothing, 
            function() {$closeLink.trigger('click'); });
          }
        } else {
          $cluetip.unbind('mouseout');
        }
      }
// now that content is loaded, finish the positioning 
      var direction = '';
      $cluetipOuter.css({overflow: defHeight == 'auto' ? 'visible' : 'auto', height: defHeight});
      tipHeight = defHeight == 'auto' ? Math.max($cluetip.outerHeight(),$cluetip.height()) : parseInt(defHeight,10);   
      tipY = posY;
      baseline = sTop + wHeight;
      if (opts.positionBy == 'fixed') {
        tipY = posY - opts.dropShadowSteps + tOffset;
      } else if ( (posX < mouseX && Math.max(posX, 0) + tipWidth > mouseX) || opts.positionBy == 'bottomTop') {
        if (posY + tipHeight + tOffset > baseline && mouseY - sTop > tipHeight + tOffset) { 
          tipY = mouseY - tipHeight - tOffset;
          direction = 'top';
        } else { 
          tipY = mouseY + tOffset;
          direction = 'bottom';
        }
      } else if ( posY + tipHeight + tOffset > baseline ) {
        tipY = (tipHeight >= wHeight) ? sTop : baseline - tipHeight - tOffset;
      } else if ($this.css('display') == 'block' || $this[0].tagName.toLowerCase() == 'area' || opts.positionBy == "mouse") {
        tipY = bpY - tOffset;
      } else {
        tipY = posY - opts.dropShadowSteps;
      }
      if (direction == '') {
        posX < linkLeft ? direction = 'left' : direction = 'right';
      }
      $cluetip.css({top: tipY + 'px'}).removeClass().addClass('clue-' + direction + '-' + ctClass).addClass(' cluetip-' + ctClass);
      if (opts.arrows) { // set up arrow positioning to align with element
        var bgY = (posY - tipY - opts.dropShadowSteps);
        $cluetipArrows.css({top: (/(left|right)/.test(direction) && posX >=0 && bgY > 0) ? bgY + 'px' : /(left|right)/.test(direction) ? 0 : ''}).show();
      } else {
        $cluetipArrows.hide();
      }

// (first hide, then) ***SHOW THE CLUETIP***
      $dropShadow.hide();
      $cluetip.hide()[opts.fx.open](opts.fx.open != 'show' && opts.fx.openSpeed);
      if (opts.dropShadow) $dropShadow.css({height: tipHeight, width: tipInnerWidth}).show();
      if (jQuery.fn.bgiframe) { $cluetip.bgiframe(); }
      // trigger the optional onShow function
      if (opts.delayedClose > 0) {
        closeOnDelay = setTimeout(cluetipClose, opts.delayedClose);
      }
      opts.onShow($cluetip, $cluetipInner);
      
    };

/***************************************
   =INACTIVATION
-------------------------------------- */
    var inactivate = function() {
      isActive = false;
      jQuery('#cluetip-waitimage').hide();
      if (!opts.sticky || (/click|toggle/).test(opts.activation) ) {
        cluetipClose();
clearTimeout(closeOnDelay);        
      };
      if (opts.hoverClass) {
        $this.removeClass(opts.hoverClass);
      }
      jQuery('.cluetip-clicked').removeClass('cluetip-clicked');
    };
// close cluetip and reset some things
    var cluetipClose = function() {
      $cluetipOuter 
      .parent().hide().removeClass().end()
      .children().empty();
      if (tipTitle) {
        $this.attr(opts.titleAttribute, tipTitle);
      }
      $this.css('cursor','');
      if (opts.arrows) $cluetipArrows.css({top: ''});
    };

/***************************************
   =BIND EVENTS
-------------------------------------- */
  // activate by click
      if ( (/click|toggle/).test(opts.activation) ) {
        $this.click(function(event) {
          if ($cluetip.is(':hidden') || !$this.is('.cluetip-clicked')) {
            activate(event);
            jQuery('.cluetip-clicked').removeClass('cluetip-clicked');
            $this.addClass('cluetip-clicked');

          } else {
            inactivate(event);

          }
          this.blur();
          return false;
        });
  // activate by focus; inactivate by blur    
      } else if (opts.activation == 'focus') {
        $this.focus(function(event) {
          activate(event);
        });
        $this.blur(function(event) {
          inactivate(event);
        });
  // activate by hover
    // clicking is returned false if cluetip url is same as href url
      } else {
        $this.click(function() {
          if ($this.attr('href') && $this.attr('href') == tipAttribute && !opts.clickThrough) {
            return false;
          }
        });
        //set up mouse tracking
        var mouseTracks = function(evt) {
          if (opts.tracking == true) {
            var trackX = posX - evt.pageX;
            var trackY = tipY ? tipY - evt.pageY : posY - evt.pageY;
            $this.mousemove(function(evt) {
              $cluetip.css({left: evt.pageX + trackX, top: evt.pageY + trackY });
            });
          }
        };
        if (jQuery.fn.hoverIntent && opts.hoverIntent) {
          $this.mouseover(function() {$this.attr('title',''); })
          .hoverIntent({
            sensitivity: opts.hoverIntent.sensitivity,
            interval: opts.hoverIntent.interval,  
            over: function(event) {
              activate(event);
              mouseTracks(event);
            }, 
            timeout: opts.hoverIntent.timeout,  
            out: function(event) {inactivate(event); $this.unbind('mousemove');}
          });           
        } else {
          $this.hover(function(event) {
            activate(event);
            mouseTracks(event);
          }, function(event) {
            inactivate(event);
            $this.unbind('mousemove');
          });
        }
      }
    });
  };
  
/*
 * options for clueTip
 *
 * each one can be explicitly overridden by changing its value. 
 * for example: jQuery.fn.cluetip.defaults.width = 200; 
 * would change the default width for all clueTips to 200. 
 *
 * each one can also be overridden by passing an options map to the cluetip method.
 * for example: jQuery('a.example').cluetip({width: 200}); 
 * would change the default width to 200 for clueTips invoked by a link with class of "example"
 *
 */
  
  jQuery.fn.cluetip.defaults = {  // set up default options
    width:            275,      // The width of the clueTip
    height:           'auto',   // The height of the clueTip
    cluezIndex:       97,       // Sets the z-index style property of the clueTip
    positionBy:       'auto',   // Sets the type of positioning: 'auto', 'mouse','bottomTop', 'fixed'
    topOffset:        15,       // Number of px to offset clueTip from top of invoking element
    leftOffset:       15,       // Number of px to offset clueTip from left of invoking element
    local:            false,    // Whether to use content from the same page for the clueTip's body
    hideLocal:        true,     // If local option is set to true, this determines whether local content
                                // to be shown in clueTip should be hidden at its original location
    attribute:        'rel',    // the attribute to be used for fetching the clueTip's body content
    titleAttribute:   'title',  // the attribute to be used for fetching the clueTip's title
    splitTitle:       '',       // A character used to split the title attribute into the clueTip title and divs
                                // within the clueTip body. more info below [6]
    showTitle:        true,     // show title bar of the clueTip, even if title attribute not set
    cluetipClass:     'default',// class added to outermost clueTip div in the form of 'cluetip-' + clueTipClass.
    hoverClass:       '',       // class applied to the invoking element onmouseover and removed onmouseout
    waitImage:        true,     // whether to show a "loading" img, which is set in jquery.cluetip.css
    cursor:           'help',
    arrows:           false,    // if true, displays arrow on appropriate side of clueTip
    dropShadow:       true,     // set to false if you don't want the drop-shadow effect on the clueTip
    dropShadowSteps:  6,        // adjusts the size of the drop shadow
    sticky:           false,    // keep visible until manually closed
    mouseOutClose:    false,    // close when clueTip is moused out
    activation:       'hover',  // set to 'click' to force user to click to show clueTip
                                // set to 'focus' to show on focus of a form element and hide on blur
    clickThrough:     false,    // if true, and activation is not 'click', then clicking on link will take user to the link's href,
                                // even if href and tipAttribute are equal
    tracking:         false,    // if true, clueTip will track mouse movement (experimental)
    delayedClose:     0,        // close clueTip on a timed delay (experimental)
    closePosition:    'top',    // location of close text for sticky cluetips; can be 'top' or 'bottom' or 'title'
    closeText:        'Close',  // text (or HTML) to to be clicked to close sticky clueTips
    truncate:         0,        // number of characters to truncate clueTip's contents. if 0, no truncation occurs

    // effect and speed for opening clueTips
    fx: {             
                      open:       'show', // can be 'show' or 'slideDown' or 'fadeIn'
                      openSpeed:  ''
    },     

    // settings for when hoverIntent plugin is used             
    hoverIntent: {    
                      sensitivity:  3,
              			  interval:     50,
              			  timeout:      0
    },

    // function to run just before clueTip is shown.           
    onActivate:       function(e) {return true;},

    // function to run just after clueTip is shown.
    onShow:           function(ct, c){},
    
    // whether to cache results of ajax request to avoid unnecessary hits to server    
    ajaxCache:        true,  

    // process data retrieved via xhr before it's displayed
    ajaxProcess:      function(data) {
                        data = data.replace(/<s(cript|tyle)(.|\s)*?\/s(cript|tyle)>/g, '').replace(/<(link|title)(.|\s)*?\/(link|title)>/g,'');
                        return data;
    },                

    // can pass in standard jQuery.ajax() parameters, not including error, complete, success, and url
    ajaxSettings: {   
                      dataType: 'html'
    },
    debug: false
  };


/*
 * Global defaults for clueTips. Apply to all calls to the clueTip plugin.
 *
 * @example jQuery.cluetip.setup({
 *   insertionType: 'prependTo',
 *   insertionElement: '#container'
 * });
 * 
 * @property
 * @name jQuery.cluetip.setup
 * @type Map
 * @cat Plugins/tooltip
 * @option String insertionType: Default is 'appendTo'. Determines the method to be used for inserting the clueTip into the DOM. Permitted values are 'appendTo', 'prependTo', 'insertBefore', and 'insertAfter'
 * @option String insertionElement: Default is 'body'. Determines which element in the DOM the plugin will reference when inserting the clueTip.
 *
 */
   
  var insertionType = 'appendTo', insertionElement = 'body';
  jQuery.cluetip = {};
  jQuery.cluetip.setup = function(options) {
    if (options && options.insertionType && (options.insertionType).match(/appendTo|prependTo|insertBefore|insertAfter/)) {
      insertionType = options.insertionType;
    }
    if (options && options.insertionElement) {
      insertionElement = options.insertionElement;
    }
  };
  
})(jQuery);


(function($){$.extend({tablesorter:new function(){var parsers=[],widgets=[];this.defaults={cssHeader:"header",cssAsc:"headerSortUp",cssDesc:"headerSortDown",sortInitialOrder:"asc",sortMultiSortKey:"shiftKey",sortForce:null,sortAppend:null,textExtraction:"simple",parsers:{},widgets:[],widgetZebra:{css:["even","odd"]},headers:{},widthFixed:false,cancelSelection:true,sortList:[],headerList:[],dateFormat:"us",decimal:'.',debug:false};function benchmark(s,d){log(s+","+(new Date().getTime()-d.getTime())+"ms");}this.benchmark=benchmark;function log(s){if(typeof console!="undefined"&&typeof console.debug!="undefined"){console.log(s);}else{alert(s);}}function buildParserCache(table,$headers){if(table.config.debug){var parsersDebug="";}var rows=table.tBodies[0].rows;if(table.tBodies[0].rows[0]){var list=[],cells=rows[0].cells,l=cells.length;for(var i=0;i<l;i++){var p=false;if($.metadata&&($($headers[i]).metadata()&&$($headers[i]).metadata().sorter)){p=getParserById($($headers[i]).metadata().sorter);}else if((table.config.headers[i]&&table.config.headers[i].sorter)){p=getParserById(table.config.headers[i].sorter);}if(!p){p=detectParserForColumn(table,cells[i]);}if(table.config.debug){parsersDebug+="column:"+i+" parser:"+p.id+"\n";}list.push(p);}}if(table.config.debug){log(parsersDebug);}return list;};function detectParserForColumn(table,node){var l=parsers.length;for(var i=1;i<l;i++){if(parsers[i].is($.trim(getElementText(table.config,node)),table,node)){return parsers[i];}}return parsers[0];}function getParserById(name){var l=parsers.length;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==name.toLowerCase()){return parsers[i];}}return false;}function buildCache(table){if(table.config.debug){var cacheTime=new Date();}var totalRows=(table.tBodies[0]&&table.tBodies[0].rows.length)||0,totalCells=(table.tBodies[0].rows[0]&&table.tBodies[0].rows[0].cells.length)||0,parsers=table.config.parsers,cache={row:[],normalized:[]};for(var i=0;i<totalRows;++i){var c=table.tBodies[0].rows[i],cols=[];cache.row.push($(c));for(var j=0;j<totalCells;++j){cols.push(parsers[j].format(getElementText(table.config,c.cells[j]),table,c.cells[j]));}cols.push(i);cache.normalized.push(cols);cols=null;};if(table.config.debug){benchmark("Building cache for "+totalRows+" rows:",cacheTime);}return cache;};function getElementText(config,node){if(!node)return"";var t="";if(config.textExtraction=="simple"){if(node.childNodes[0]&&node.childNodes[0].hasChildNodes()){t=node.childNodes[0].innerHTML;}else{t=node.innerHTML;}}else{if(typeof(config.textExtraction)=="function"){t=config.textExtraction(node);}else{t=$(node).text();}}return t;}function appendToTable(table,cache){if(table.config.debug){var appendTime=new Date()}var c=cache,r=c.row,n=c.normalized,totalRows=n.length,checkCell=(n[0].length-1),tableBody=$(table.tBodies[0]),rows=[];for(var i=0;i<totalRows;i++){rows.push(r[n[i][checkCell]]);if(!table.config.appender){var o=r[n[i][checkCell]];var l=o.length;for(var j=0;j<l;j++){tableBody[0].appendChild(o[j]);}}}if(table.config.appender){table.config.appender(table,rows);}rows=null;if(table.config.debug){benchmark("Rebuilt table:",appendTime);}applyWidget(table);setTimeout(function(){$(table).trigger("sortEnd");},0);};function buildHeaders(table){if(table.config.debug){var time=new Date();}var meta=($.metadata)?true:false,tableHeadersRows=[];for(var i=0;i<table.tHead.rows.length;i++){tableHeadersRows[i]=0;};$tableHeaders=$("thead th",table);$tableHeaders.each(function(index){this.count=0;this.column=index;this.order=formatSortingOrder(table.config.sortInitialOrder);if(checkHeaderMetadata(this)||checkHeaderOptions(table,index))this.sortDisabled=true;if(!this.sortDisabled){$(this).addClass(table.config.cssHeader);}table.config.headerList[index]=this;});if(table.config.debug){benchmark("Built headers:",time);log($tableHeaders);}return $tableHeaders;};function checkCellColSpan(table,rows,row){var arr=[],r=table.tHead.rows,c=r[row].cells;for(var i=0;i<c.length;i++){var cell=c[i];if(cell.colSpan>1){arr=arr.concat(checkCellColSpan(table,headerArr,row++));}else{if(table.tHead.length==1||(cell.rowSpan>1||!r[row+1])){arr.push(cell);}}}return arr;};function checkHeaderMetadata(cell){if(($.metadata)&&($(cell).metadata().sorter===false)){return true;};return false;}function checkHeaderOptions(table,i){if((table.config.headers[i])&&(table.config.headers[i].sorter===false)){return true;};return false;}function applyWidget(table){var c=table.config.widgets;var l=c.length;for(var i=0;i<l;i++){getWidgetById(c[i]).format(table);}}function getWidgetById(name){var l=widgets.length;for(var i=0;i<l;i++){if(widgets[i].id.toLowerCase()==name.toLowerCase()){return widgets[i];}}};function formatSortingOrder(v){if(typeof(v)!="Number"){i=(v.toLowerCase()=="desc")?1:0;}else{i=(v==(0||1))?v:0;}return i;}function isValueInArray(v,a){var l=a.length;for(var i=0;i<l;i++){if(a[i][0]==v){return true;}}return false;}function setHeadersCss(table,$headers,list,css){$headers.removeClass(css[0]).removeClass(css[1]);var h=[];$headers.each(function(offset){if(!this.sortDisabled){h[this.column]=$(this);}});var l=list.length;for(var i=0;i<l;i++){h[list[i][0]].addClass(css[list[i][1]]);}}function fixColumnWidth(table,$headers){var c=table.config;if(c.widthFixed){var colgroup=$('<colgroup>');$("tr:first td",table.tBodies[0]).each(function(){colgroup.append($('<col>').css('width',$(this).width()));});$(table).prepend(colgroup);};}function updateHeaderSortCount(table,sortList){var c=table.config,l=sortList.length;for(var i=0;i<l;i++){var s=sortList[i],o=c.headerList[s[0]];o.count=s[1];o.count++;}}function multisort(table,sortList,cache){if(table.config.debug){var sortTime=new Date();}var dynamicExp="var sortWrapper = function(a,b) {",l=sortList.length;for(var i=0;i<l;i++){var c=sortList[i][0];var order=sortList[i][1];var s=(getCachedSortType(table.config.parsers,c)=="text")?((order==0)?"sortText":"sortTextDesc"):((order==0)?"sortNumeric":"sortNumericDesc");var e="e"+i;dynamicExp+="var "+e+" = "+s+"(a["+c+"],b["+c+"]); ";dynamicExp+="if("+e+") { return "+e+"; } ";dynamicExp+="else { ";}var orgOrderCol=cache.normalized[0].length-1;dynamicExp+="return a["+orgOrderCol+"]-b["+orgOrderCol+"];";for(var i=0;i<l;i++){dynamicExp+="}; ";}dynamicExp+="return 0; ";dynamicExp+="}; ";eval(dynamicExp);cache.normalized.sort(sortWrapper);if(table.config.debug){benchmark("Sorting on "+sortList.toString()+" and dir "+order+" time:",sortTime);}return cache;};function sortText(a,b){return((a<b)?-1:((a>b)?1:0));};function sortTextDesc(a,b){return((b<a)?-1:((b>a)?1:0));};function sortNumeric(a,b){return a-b;};function sortNumericDesc(a,b){return b-a;};function getCachedSortType(parsers,i){return parsers[i].type;};this.construct=function(settings){return this.each(function(){if(!this.tHead||!this.tBodies)return;var $this,$document,$headers,cache,config,shiftDown=0,sortOrder;this.config={};config=$.extend(this.config,$.tablesorter.defaults,settings);$this=$(this);$headers=buildHeaders(this);this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);var sortCSS=[config.cssDesc,config.cssAsc];fixColumnWidth(this);$headers.click(function(e){$this.trigger("sortStart");var totalRows=($this[0].tBodies[0]&&$this[0].tBodies[0].rows.length)||0;if(!this.sortDisabled&&totalRows>0){var $cell=$(this);var i=this.column;this.order=this.count++%2;if(!e[config.sortMultiSortKey]){config.sortList=[];if(config.sortForce!=null){var a=config.sortForce;for(var j=0;j<a.length;j++){if(a[j][0]!=i){config.sortList.push(a[j]);}}}config.sortList.push([i,this.order]);}else{if(isValueInArray(i,config.sortList)){for(var j=0;j<config.sortList.length;j++){var s=config.sortList[j],o=config.headerList[s[0]];if(s[0]==i){o.count=s[1];o.count++;s[1]=o.count%2;}}}else{config.sortList.push([i,this.order]);}};setTimeout(function(){setHeadersCss($this[0],$headers,config.sortList,sortCSS);appendToTable($this[0],multisort($this[0],config.sortList,cache));},1);return false;}}).mousedown(function(){if(config.cancelSelection){this.onselectstart=function(){return false};return false;}});$this.bind("update",function(){this.config.parsers=buildParserCache(this,$headers);cache=buildCache(this);}).bind("sorton",function(e,list){$(this).trigger("sortStart");config.sortList=list;var sortList=config.sortList;updateHeaderSortCount(this,sortList);setHeadersCss(this,$headers,sortList,sortCSS);appendToTable(this,multisort(this,sortList,cache));}).bind("appendCache",function(){appendToTable(this,cache);}).bind("applyWidgetId",function(e,id){getWidgetById(id).format(this);}).bind("applyWidgets",function(){applyWidget(this);});if($.metadata&&($(this).metadata()&&$(this).metadata().sortlist)){config.sortList=$(this).metadata().sortlist;}if(config.sortList.length>0){$this.trigger("sorton",[config.sortList]);}applyWidget(this);});};this.addParser=function(parser){var l=parsers.length,a=true;for(var i=0;i<l;i++){if(parsers[i].id.toLowerCase()==parser.id.toLowerCase()){a=false;}}if(a){parsers.push(parser);};};this.addWidget=function(widget){widgets.push(widget);};this.formatFloat=function(s){var i=parseFloat(s);return(isNaN(i))?0:i;};this.formatInt=function(s){var i=parseInt(s);return(isNaN(i))?0:i;};this.isDigit=function(s,config){var DECIMAL='\\'+config.decimal;var exp='/(^[+]?0('+DECIMAL+'0+)?$)|(^([-+]?[1-9][0-9]*)$)|(^([-+]?((0?|[1-9][0-9]*)'+DECIMAL+'(0*[1-9][0-9]*)))$)|(^[-+]?[1-9]+[0-9]*'+DECIMAL+'0+$)/';return RegExp(exp).test($.trim(s));};this.clearTableBody=function(table){if($.browser.msie){function empty(){while(this.firstChild)this.removeChild(this.firstChild);}empty.apply(table.tBodies[0]);}else{table.tBodies[0].innerHTML="";}};}});$.fn.extend({tablesorter:$.tablesorter.construct});var ts=$.tablesorter;ts.addParser({id:"text",is:function(s){return true;},format:function(s){return $.trim(s.toLowerCase());},type:"text"});ts.addParser({id:"digit",is:function(s,table){var c=table.config;return $.tablesorter.isDigit(s,c);},format:function(s){return $.tablesorter.formatFloat(s);},type:"numeric"});ts.addParser({id:"currency",is:function(s){return/^[£$€?.]/.test(s);},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/[^0-9.]/g),""));},type:"numeric"});ts.addParser({id:"ipAddress",is:function(s){return/^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);},format:function(s){var a=s.split("."),r="",l=a.length;for(var i=0;i<l;i++){var item=a[i];if(item.length==2){r+="0"+item;}else{r+=item;}}return $.tablesorter.formatFloat(r);},type:"numeric"});ts.addParser({id:"url",is:function(s){return/^(https?|ftp|file):\/\/$/.test(s);},format:function(s){return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//),''));},type:"text"});ts.addParser({id:"isoDate",is:function(s){return/^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);},format:function(s){return $.tablesorter.formatFloat((s!="")?new Date(s.replace(new RegExp(/-/g),"/")).getTime():"0");},type:"numeric"});ts.addParser({id:"percent",is:function(s){return/\%$/.test($.trim(s));},format:function(s){return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g),""));},type:"numeric"});ts.addParser({id:"usLongDate",is:function(s){return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));},format:function(s){return $.tablesorter.formatFloat(new Date(s).getTime());},type:"numeric"});ts.addParser({id:"shortDate",is:function(s){return/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);},format:function(s,table){var c=table.config;s=s.replace(/\-/g,"/");if(c.dateFormat=="us"){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,"$3/$1/$2");}else if(c.dateFormat=="uk"){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/,"$3/$2/$1");}else if(c.dateFormat=="dd/mm/yy"||c.dateFormat=="dd-mm-yy"){s=s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/,"$1/$2/$3");}return $.tablesorter.formatFloat(new Date(s).getTime());},type:"numeric"});ts.addParser({id:"time",is:function(s){return/^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);},format:function(s){return $.tablesorter.formatFloat(new Date("2000/01/01 "+s).getTime());},type:"numeric"});ts.addParser({id:"metadata",is:function(s){return false;},format:function(s,table,cell){var c=table.config,p=(!c.parserMetadataName)?'sortValue':c.parserMetadataName;return $(cell).metadata()[p];},type:"numeric"});ts.addWidget({id:"zebra",format:function(table){if(table.config.debug){var time=new Date();}$("tr:visible",table.tBodies[0]).filter(':even').removeClass(table.config.widgetZebra.css[1]).addClass(table.config.widgetZebra.css[0]).end().filter(':odd').removeClass(table.config.widgetZebra.css[0]).addClass(table.config.widgetZebra.css[1]);if(table.config.debug){$.tablesorter.benchmark("Applying Zebra widget",time);}}});})(jQuery);
/**
 * Boxy 0.1.4 - Facebook-style dialog, with frills
 *
 * (c) 2008 Jason Frame
 * Licensed under the MIT License (LICENSE)
 */
 
/*
 * jQuery plugin
 *
 * Options:
 *   message: confirmation message for form submit hook (default: "Please confirm:")
 * 
 * Any other options - e.g. 'clone' - will be passed onto the boxy constructor (or
 * Boxy.load for AJAX operations)
 */
jQuery.fn.boxy = function(options) {
    options = options || {};
    return this.each(function() {      
        var node = this.nodeName.toLowerCase(), self = this;
        if (node == 'a') {
            jQuery(this).click(function() {
                var active = Boxy.linkedTo(this),
                    href = this.getAttribute('href'),
                    localOptions = jQuery.extend({actuator: this, title: this.title}, options);
                    
                if (active) {
                    active.show();
                } else if (href.indexOf('#') >= 0) {
                    var content = jQuery(href.substr(href.indexOf('#'))),
                        newContent = content.clone(true);
                    content.remove();
                    localOptions.unloadOnHide = false;
                    new Boxy(newContent, localOptions);
                } else { // fall back to AJAX; could do with a same-origin check
                    if (!localOptions.cache) localOptions.unloadOnHide = true;
                    Boxy.load(this.href, localOptions);
                }
                
                return false;
            });
        } else if (node == 'form') {
            jQuery(this).bind('submit.boxy', function() {
                Boxy.confirm(options.message || 'Please confirm:', function() {
                    jQuery(self).unbind('submit.boxy').submit();
                });
                return false;
            });
        }
    });
};

//
// Boxy Class

function Boxy(element, options) {
    
    this.boxy = jQuery(Boxy.WRAPPER);
    jQuery.data(this.boxy[0], 'boxy', this);
    
    this.visible = false;
    this.options = jQuery.extend({}, Boxy.DEFAULTS, options || {});
    
    // patched from http://groups.google.com/group/boxy-plugin/browse_thread/thread/5e57c0173ae79a34/e5de7944781cd266
    // to allow modal dialogs to be draggable
    if (this.options.modal) {
         if (!'center' in options) this.options.center = true;
         if (!'draggable' in options) this.options.draggable = false;
    }
    
    // options.actuator == DOM element that opened this boxy
    // association will be automatically deleted when this boxy is remove()d
    if (this.options.actuator) {
        jQuery.data(this.options.actuator, 'active.boxy', this);
    }
    
    this.setContent(element || "<div></div>");
    this._setupTitleBar();
    
    this.boxy.css('display', 'none').appendTo(document.body);
    this.toTop();

    if (this.options.fixed) {
        if (jQuery.browser.msie && jQuery.browser.version < 7) {
            this.options.fixed = false; // IE6 doesn't support fixed positioning
        } else {
            this.boxy.addClass('fixed');
        }
    }
    
    if (this.options.center && Boxy._u(this.options.x, this.options.y)) {
        this.center();
    } else {
        this.moveTo(
            Boxy._u(this.options.x) ? this.options.x : Boxy.DEFAULT_X,
            Boxy._u(this.options.y) ? this.options.y : Boxy.DEFAULT_Y
        );
    }
    
    if (this.options.show) this.show();

};

Boxy.EF = function() {};

jQuery.extend(Boxy, {
    
    WRAPPER:    "<table cellspacing='0' cellpadding='0' border='0' class='boxy-wrapper'>" +
                "<tr><td class='top-left'></td><td class='top'></td><td class='top-right'></td></tr>" +
                "<tr><td class='left'></td><td class='boxy-inner'></td><td class='right'></td></tr>" +
                "<tr><td class='bottom-left'></td><td class='bottom'></td><td class='bottom-right'></td></tr>" +
                "</table>",
    
    DEFAULTS: {
        title:                  null,           // titlebar text. titlebar will not be visible if not set.
        closeable:              true,           // display close link in titlebar?
        draggable:              true,           // can this dialog be dragged?
        clone:                  false,          // clone content prior to insertion into dialog?
        actuator:               null,           // element which opened this dialog
        center:                 true,           // center dialog in viewport?
        show:                   true,           // show dialog immediately?
        modal:                  false,          // make dialog modal?
        fixed:                  true,           // use fixed positioning, if supported? absolute positioning used otherwise
        closeText:              '<div class="hide-icon"></div>',      // text to use for default close link
        unloadOnHide:           false,          // should this dialog be removed from the DOM after being hidden?
        clickToFront:           false,          // bring dialog to foreground on any click (not just titlebar)?
        behaviours:             Boxy.EF,        // function used to apply behaviours to all content embedded in dialog.
        afterDrop:              Boxy.EF,        // callback fired after dialog is dropped. executes in context of Boxy instance.
        afterShow:              Boxy.EF,        // callback fired after dialog becomes visible. executes in context of Boxy instance.
        afterHide:              Boxy.EF,        // callback fired after dialog is hidden. executed in context of Boxy instance.
        beforeUnload:           Boxy.EF         // callback fired after dialog is unloaded. executed in context of Boxy instance.
    },
    
    DEFAULT_X:          50,
    DEFAULT_Y:          50,
    zIndex:             1337,
    dragConfigured:     false, // only set up one drag handler for all boxys
    resizeConfigured:   false,
    dragging:           null,
    
    // load a URL and display in boxy
    // url - url to load
    // options keys (any not listed below are passed to boxy constructor)
    //   type: HTTP method, default: GET
    //   cache: cache retrieved content? default: false
    //   filter: jQuery selector used to filter remote content
    load: function(url, options) {
        
        options = options || {};
        
        var ajax = {
            url: url, type: 'GET', dataType: 'html', cache: false, success: function(html) {
                html = jQuery(html);
                if (options.filter) html = jQuery(options.filter, html);
                new Boxy(html, options);
            }
        };
        
        jQuery.each(['type', 'cache'], function() {
            if (this in options) {
                ajax[this] = options[this];
                delete options[this];
            }
        });
        
        jQuery.ajax(ajax);
        
    },
    
    // allows you to get a handle to the containing boxy instance of any element
    // e.g. <a href='#' onclick='alert(Boxy.get(this));'>inspect!</a>.
    // this returns the actual instance of the boxy 'class', not just a DOM element.
    // Boxy.get(this).hide() would be valid, for instance.
    get: function(ele) {
        var p = jQuery(ele).parents('.boxy-wrapper');
        return p.length ? jQuery.data(p[0], 'boxy') : null;
    },
    
    // returns the boxy instance which has been linked to a given element via the
    // 'actuator' constructor option.
    linkedTo: function(ele) {
        return jQuery.data(ele, 'active.boxy');
    },
    
    // displays an alert box with a given message, calling optional callback
    // after dismissal.
    alert: function(message, callback, options) {
        return Boxy.ask(message, ['OK'], callback, options);
    },
    
    // displays an alert box with a given message, calling after callback iff
    // user selects OK.
    confirm: function(message, after, options) {
        return Boxy.ask(message, ['OK', 'Cancel'], function(response) {
            if (response == 'OK') after();
        }, options);
    },
    
    // asks a question with multiple responses presented as buttons
    // selected item is returned to a callback method.
    // answers may be either an array or a hash. if it's an array, the
    // the callback will received the selected value. if it's a hash,
    // you'll get the corresponding key.
    ask: function(question, answers, callback, options) {
        
        options = jQuery.extend({modal: true, closeable: true},
                                options || {},
                                {show: true, unloadOnHide: true});
        
        var body = jQuery('<div></div>').append(jQuery('<div class="question"></div>').html(question));
        
        // ick
        var map = {}, answerStrings = [];
        if (answers instanceof Array) {
            for (var i = 0; i < answers.length; i++) {
                map[answers[i]] = answers[i];
                answerStrings.push(answers[i]);
            }
        } else {
            for (var k in answers) {
                map[answers[k]] = k;
                answerStrings.push(answers[k]);
            }
        }
        
        var buttons = jQuery('<form class="answers"></form>');
        buttons.html(jQuery.map(answerStrings, function(v) {
            return "<input type='button' value='" + v + "' />";
        }).join(' '));
        
        jQuery('input[type=button]', buttons).click(function() {
            var clicked = this;
            Boxy.get(this).hide(function() {
                if (callback) callback(map[clicked.value]);
            });
        });
        
        body.append(buttons);
        
        new Boxy(body, options);
        
    },
    
    // returns true if a modal boxy is visible, false otherwise
    isModalVisible: function() {
        return jQuery('.boxy-modal-blackout').length > 0;
    },
    
    _u: function() {
        for (var i = 0; i < arguments.length; i++)
            if (typeof arguments[i] != 'undefined') return false;
        return true;
    },
    
    _handleResize: function(evt) {
        var d = jQuery(document);
        jQuery('.boxy-modal-blackout').css('display', 'none').css({
            width: d.width(), height: d.height()
        }).css('display', 'block');
    },
    
    _handleDrag: function(evt) {
        var d;
        if (d = Boxy.dragging) {
            d[0].boxy.css({left: evt.pageX - d[1], top: evt.pageY - d[2]});
        }
    },
    
    _nextZ: function() {
        return Boxy.zIndex++;
    },
    
    _viewport: function() {
        var d = document.documentElement, b = document.body, w = window;
        return jQuery.extend(
            jQuery.browser.msie ?
                { left: b.scrollLeft || d.scrollLeft, top: b.scrollTop || d.scrollTop } :
                { left: w.pageXOffset, top: w.pageYOffset },
            !Boxy._u(w.innerWidth) ?
                { width: w.innerWidth, height: w.innerHeight } :
                (!Boxy._u(d) && !Boxy._u(d.clientWidth) && d.clientWidth != 0 ?
                    { width: d.clientWidth, height: d.clientHeight } :
                    { width: b.clientWidth, height: b.clientHeight }) );
    }

});

Boxy.prototype = {
    // Returns the size of this boxy instance without displaying it.
    // Do not use this method if boxy is already visible, use getSize() instead.
    estimateSize: function() {
        this.boxy.css({visibility: 'hidden', display: 'block'});
        var dims = this.getSize();
        this.boxy.css('display', 'none').css('visibility', 'visible');
        return dims;
    },
                
    // Returns the dimensions of the entire boxy dialog as [width,height]
    getSize: function() {
        return [this.boxy.width(), this.boxy.height()];
    },
    
    // Returns the dimensions of the content region as [width,height]
    getContentSize: function() {
        var c = this.getContent();
        return [c.width(), c.height()];
    },
    
    // Returns the position of this dialog as [x,y]
    getPosition: function() {
        var b = this.boxy[0];
        return [b.offsetLeft, b.offsetTop];
    },
    
    // Returns the center point of this dialog as [x,y]
    getCenter: function() {
        var p = this.getPosition();
        var s = this.getSize();
        return [Math.floor(p[0] + s[0] / 2), Math.floor(p[1] + s[1] / 2)];
    },
                
    // Returns a jQuery object wrapping the inner boxy region.
    // Not much reason to use this, you're probably more interested in getContent()
    getInner: function() {
        return jQuery('.boxy-inner', this.boxy);
    },
    
    // Returns a jQuery object wrapping the boxy content region.
    // This is the user-editable content area (i.e. excludes titlebar)
    getContent: function() {
        return jQuery('.boxy-content', this.boxy);
    },
    
    // Replace dialog content
    setContent: function(newContent) {
        newContent = jQuery(newContent).css({display: 'block'}).addClass('boxy-content');
        if (this.options.clone) newContent = newContent.clone(true);
        this.getContent().remove();
        this.getInner().append(newContent);
        this._setupDefaultBehaviours(newContent);
        this.options.behaviours.call(this, newContent);
        return this;
    },
    
    // Move this dialog to some position, funnily enough
    moveTo: function(x, y) {
        this.moveToX(x).moveToY(y);
        return this;
    },
    
    // Move this dialog (x-coord only)
    moveToX: function(x) {
        if (typeof x == 'number') this.boxy.css({left: x});
        else this.centerX();
        return this;
    },
    
    // Move this dialog (y-coord only)
    moveToY: function(y) {
        if (typeof y == 'number') this.boxy.css({top: y});
        else this.centerY();
        return this;
    },
    
    // Move this dialog so that it is centered at (x,y)
    centerAt: function(x, y) {
        var s = this[this.visible ? 'getSize' : 'estimateSize']();
        if (typeof x == 'number') this.moveToX(x - s[0] / 2);
        if (typeof y == 'number') this.moveToY(y - s[1] / 2);
        return this;
    },
    
    centerAtX: function(x) {
        return this.centerAt(x, null);
    },
    
    centerAtY: function(y) {
        return this.centerAt(null, y);
    },
    
    // Center this dialog in the viewport
    // axis is optional, can be 'x', 'y'.
    center: function(axis) {
        var v = Boxy._viewport();
        var o = this.options.fixed ? [0, 0] : [v.left, v.top];
        if (!axis || axis == 'x') this.centerAt(o[0] + v.width / 2, null);
        if (!axis || axis == 'y') this.centerAt(null, o[1] + v.height / 2);
        return this;
    },
    
    // Center this dialog in the viewport (x-coord only)
    centerX: function() {
        return this.center('x');
    },
    
    // Center this dialog in the viewport (y-coord only)
    centerY: function() {
        return this.center('y');
    },
    
    // Resize the content region to a specific size
    resize: function(width, height, after) {
        if (!this.visible) return;
        var bounds = this._getBoundsForResize(width, height);
        this.boxy.css({left: bounds[0], top: bounds[1]});
        this.getContent().css({width: bounds[2], height: bounds[3]});
        if (after) after(this);
        return this;
    },
    
    // Tween the content region to a specific size
    tween: function(width, height, after) {
        if (!this.visible) return;
        var bounds = this._getBoundsForResize(width, height);
        var self = this;
        this.boxy.stop().animate({left: bounds[0], top: bounds[1]});
        this.getContent().stop().animate({width: bounds[2], height: bounds[3]}, function() {
            if (after) after(self);
        });
        return this;
    },
    
    // Returns true if this dialog is visible, false otherwise
    isVisible: function() {
        return this.visible;    
    },
    
    // Make this boxy instance visible
    show: function() {
        if (this.visible) return;
        if (this.options.modal) {
            var self = this;
            if (!Boxy.resizeConfigured) {
                Boxy.resizeConfigured = true;
                jQuery(window).resize(function() { Boxy._handleResize(); });
            }
            this.modalBlackout = jQuery('<div class="boxy-modal-blackout"></div>')
                .css({zIndex: Boxy._nextZ(),
                      opacity: 0.7,
                      width: jQuery(document).width(),
                      height: jQuery(document).height()})
                .appendTo(document.body);
            this.toTop();
            if (this.options.closeable) {
                $(document).keyup(function(evt) {
                    var key = evt.which || evt.keyCode;
                    if (key === 27) {
                        self.hide();
                    }
                });
            }
        }
        this.boxy.stop().css({opacity: 1}).show();
        this.visible = true;
        this._fire('afterShow');
        return this;
    },
    
    // Hide this boxy instance
    hide: function(after) {
        if (!this.visible) return;
        var self = this;
        if (this.options.modal) {
            this.modalBlackout.animate({opacity: 0}, function() {
                $(this).remove();
            });
        }
        this.boxy.stop().animate({opacity: 0}, 300, function() {
            self.boxy.css({display: 'none'});
            self.visible = false;
            self._fire('afterHide');
            if (after) after(self);
            if (self.options.unloadOnHide) self.unload();
        });
        return this;
    },

    toggle: function() {
        this[this.visible ? 'hide' : 'show']();
        return this;
    },
    
    hideAndUnload: function(after) {
        this.options.unloadOnHide = true;
        this.hide(after);
        return this;
    },
    
    unload: function() {
        this._fire('beforeUnload');
        this.boxy.remove();
        if (this.options.actuator) {
            jQuery.data(this.options.actuator, 'active.boxy', false);
        }
    },
    
    // Move this dialog box above all other boxy instances
    toTop: function() {
        this.boxy.css({zIndex: Boxy._nextZ()});
        return this;
    },
    
    // Returns the title of this dialog
    getTitle: function() {
        return jQuery('> .title-bar h2', this.getInner()).html();
    },
    
    // Sets the title of this dialog
    setTitle: function(t) {
        jQuery('> .title-bar h2', this.getInner()).html(t);
        return this;
    },
    
    //
    // Don't touch these privates
    
    _getBoundsForResize: function(width, height) {
        var csize = this.getContentSize();
        var delta = [width - csize[0], height - csize[1]];
        var p = this.getPosition();
        return [Math.max(p[0] - delta[0] / 2, 0),
                Math.max(p[1] - delta[1] / 2, 0), width, height];
    },
    
    _setupTitleBar: function() {
        if (this.options.title) {
            var self = this;
            var tb = jQuery("<div class='title-bar'></div>").html("<h2>" + this.options.title + "</h2>");
            if (this.options.closeable) {
                tb.append(jQuery("<a href='#' class='close'></a>").html(this.options.closeText));
            }
            if (this.options.draggable) {
                tb[0].onselectstart = function() { return false; }
                tb[0].unselectable = 'on';
                tb[0].style.MozUserSelect = 'none';
                if (!Boxy.dragConfigured) {
                    jQuery(document).mousemove(Boxy._handleDrag);
                    Boxy.dragConfigured = true;
                }
                tb.mousedown(function(evt) {
                    self.toTop();
                    Boxy.dragging = [self, evt.pageX - self.boxy[0].offsetLeft, evt.pageY - self.boxy[0].offsetTop];
                    jQuery(this).addClass('dragging');
                }).mouseup(function() {
                    jQuery(this).removeClass('dragging');
                    Boxy.dragging = null;
                    self._fire('afterDrop');
                });
            }
            this.getInner().prepend(tb);
            this._setupDefaultBehaviours(tb);
        }
    },
    
    _setupDefaultBehaviours: function(root) {
        var self = this;
        if (this.options.clickToFront) {
            root.click(function() { self.toTop(); });
        }
        jQuery('.close', root).click(function() {
            self.hide();
            return false;
        }).mousedown(function(evt) { evt.stopPropagation(); });
    },
    
    _fire: function(event) {
        this.options[event].call(this);
    }
    
};

/*!
 * jQuery Form Plugin
 * version: 2.64 (25-FEB-2011)
 * @requires jQuery v1.3.2 or later
 *
 * Examples and documentation at: http://malsup.com/jquery/form/
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
;(function($) {

/*
	Usage Note:
	-----------
	Do not use both ajaxSubmit and ajaxForm on the same form.  These
	functions are intended to be exclusive.  Use ajaxSubmit if you want
	to bind your own submit handler to the form.  For example,

	$(document).ready(function() {
		$('#myForm').bind('submit', function(e) {
			e.preventDefault(); // <-- important
			$(this).ajaxSubmit({
				target: '#output'
			});
		});
	});

	Use ajaxForm when you want the plugin to manage all the event binding
	for you.  For example,

	$(document).ready(function() {
		$('#myForm').ajaxForm({
			target: '#output'
		});
	});

	When using ajaxForm, the ajaxSubmit function will be invoked for you
	at the appropriate time.
*/

/**
 * ajaxSubmit() provides a mechanism for immediately submitting
 * an HTML form using AJAX.
 */
$.fn.ajaxSubmit = function(options) {
	// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)
	if (!this.length) {
		log('ajaxSubmit: skipping submit process - no element selected');
		return this;
	}

	if (typeof options == 'function') {
		options = { success: options };
	}

	var action = this.attr('action');
	var url = (typeof action === 'string') ? $.trim(action) : '';
	if (url) {
		// clean url (don't include hash vaue)
		url = (url.match(/^([^#]+)/)||[])[1];
	}
	url = url || window.location.href || '';

	options = $.extend(true, {
		url:  url,
		type: this[0].getAttribute('method') || 'GET', // IE7 massage (see issue 57)
		iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
	}, options);

	// hook for manipulating the form data before it is extracted;
	// convenient for use with rich editors like tinyMCE or FCKEditor
	var veto = {};
	this.trigger('form-pre-serialize', [this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');
		return this;
	}

	// provide opportunity to alter form data before it is serialized
	if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSerialize callback');
		return this;
	}

	var n,v,a = this.formToArray(options.semantic);
	if (options.data) {
		options.extraData = options.data;
		for (n in options.data) {
			if(options.data[n] instanceof Array) {
				for (var k in options.data[n]) {
					a.push( { name: n, value: options.data[n][k] } );
				}
			}
			else {
				v = options.data[n];
				v = $.isFunction(v) ? v() : v; // if value is fn, invoke it
				a.push( { name: n, value: v } );
			}
		}
	}

	// give pre-submit callback an opportunity to abort the submit
	if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {
		log('ajaxSubmit: submit aborted via beforeSubmit callback');
		return this;
	}

	// fire vetoable 'validate' event
	this.trigger('form-submit-validate', [a, this, options, veto]);
	if (veto.veto) {
		log('ajaxSubmit: submit vetoed via form-submit-validate trigger');
		return this;
	}

	var q = $.param(a);

	if (options.type.toUpperCase() == 'GET') {
		options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
		options.data = null;  // data is null for 'get'
	}
	else {
		options.data = q; // data is the query string for 'post'
	}

	var $form = this, callbacks = [];
	if (options.resetForm) {
		callbacks.push(function() { $form.resetForm(); });
	}
	if (options.clearForm) {
		callbacks.push(function() { $form.clearForm(); });
	}

	// perform a load on the target only if dataType is not provided
	if (!options.dataType && options.target) {
		var oldSuccess = options.success || function(){};
		callbacks.push(function(data) {
			var fn = options.replaceTarget ? 'replaceWith' : 'html';
			$(options.target)[fn](data).each(oldSuccess, arguments);
		});
	}
	else if (options.success) {
		callbacks.push(options.success);
	}

	options.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
		var context = options.context || options;   // jQuery 1.4+ supports scope context
		for (var i=0, max=callbacks.length; i < max; i++) {
			callbacks[i].apply(context, [data, status, xhr || $form, $form]);
		}
	};

	// are there files to upload?
	var fileInputs = $('input:file', this).length > 0;
	var mp = 'multipart/form-data';
	var multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);

	// options.iframe allows user to force iframe mode
	// 06-NOV-09: now defaulting to iframe mode if file input is detected
   if (options.iframe !== false && (fileInputs || options.iframe || multipart)) {
	   // hack to fix Safari hang (thanks to Tim Molendijk for this)
	   // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
	   if (options.closeKeepAlive) {
		   $.get(options.closeKeepAlive, fileUpload);
		}
	   else {
		   fileUpload();
		}
   }
   else {
		$.ajax(options);
   }

	// fire 'notify' event
	this.trigger('form-submit-notify', [this, options]);
	return this;


	// private function for handling file uploads (hat tip to YAHOO!)
	function fileUpload() {
		var form = $form[0];

		if ($(':input[name=submit],:input[id=submit]', form).length) {
			// if there is an input with a name or id of 'submit' then we won't be
			// able to invoke the submit fn on the form (at least not x-browser)
			alert('Error: Form elements must not have name or id of "submit".');
			return;
		}

		var s = $.extend(true, {}, $.ajaxSettings, options);
		s.context = s.context || s;
		var id = 'jqFormIO' + (new Date().getTime()), fn = '_'+id;
		var $io = $('<iframe id="' + id + '" name="' + id + '" src="'+ s.iframeSrc +'" />');
		var io = $io[0];

		$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });

		var xhr = { // mock object
			aborted: 0,
			responseText: null,
			responseXML: null,
			status: 0,
			statusText: 'n/a',
			getAllResponseHeaders: function() {},
			getResponseHeader: function() {},
			setRequestHeader: function() {},
			abort: function() {
				this.aborted = 1;
				$io.attr('src', s.iframeSrc); // abort op in progress
			}
		};

		var g = s.global;
		// trigger ajax global events so that activity/block indicators work like normal
		if (g && ! $.active++) {
			$.event.trigger("ajaxStart");
		}
		if (g) {
			$.event.trigger("ajaxSend", [xhr, s]);
		}

		if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {
			if (s.global) {
				$.active--;
			}
			return;
		}
		if (xhr.aborted) {
			return;
		}

		var timedOut = 0;

		// add submitting element to data if we know it
		var sub = form.clk;
		if (sub) {
			var n = sub.name;
			if (n && !sub.disabled) {
				s.extraData = s.extraData || {};
				s.extraData[n] = sub.value;
				if (sub.type == "image") {
					s.extraData[n+'.x'] = form.clk_x;
					s.extraData[n+'.y'] = form.clk_y;
				}
			}
		}

		// take a breath so that pending repaints get some cpu time before the upload starts
		function doSubmit() {
			// make sure form attrs are set
			var t = $form.attr('target'), a = $form.attr('action');

			// update form attrs in IE friendly way
			form.setAttribute('target',id);
			if (form.getAttribute('method') != 'POST') {
				form.setAttribute('method', 'POST');
			}
			if (form.getAttribute('action') != s.url) {
				form.setAttribute('action', s.url);
			}

			// ie borks in some cases when setting encoding
			if (! s.skipEncodingOverride) {
				$form.attr({
					encoding: 'multipart/form-data',
					enctype:  'multipart/form-data'
				});
			}

			// support timout
			if (s.timeout) {
				setTimeout(function() { timedOut = true; cb(); }, s.timeout);
			}

			// add "extra" data to form if provided in options
			var extraInputs = [];
			try {
				if (s.extraData) {
					for (var n in s.extraData) {
						extraInputs.push(
							$('<input type="hidden" name="'+n+'" value="'+s.extraData[n]+'" />')
								.appendTo(form)[0]);
					}
				}

				// add iframe to doc and submit the form
				$io.appendTo('body');
                io.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);
				form.submit();
			}
			finally {
				// reset attrs and remove "extra" input elements
				form.setAttribute('action',a);
				if(t) {
					form.setAttribute('target', t);
				} else {
					$form.removeAttr('target');
				}
				$(extraInputs).remove();
			}
		}

		if (s.forceSync) {
			doSubmit();
		}
		else {
			setTimeout(doSubmit, 10); // this lets dom updates render
		}

		var data, doc, domCheckCount = 50;

		function cb() {
			doc = io.contentWindow ? io.contentWindow.document : io.contentDocument ? io.contentDocument : io.document;
			if (!doc || doc.location.href == s.iframeSrc) {
				// response not received yet
				return;
			}
            io.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);

			var ok = true;
			try {
				if (timedOut) {
					throw 'timeout';
				}

				var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);
				log('isXml='+isXml);
				if (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {
					if (--domCheckCount) {
						// in some browsers (Opera) the iframe DOM is not always traversable when
						// the onload callback fires, so we loop a bit to accommodate
						log('requeing onLoad callback, DOM not available');
						setTimeout(cb, 250);
						return;
					}
					// let this fall through because server response could be an empty document
					//log('Could not access iframe DOM after mutiple tries.');
					//throw 'DOMException: not available';
				}

				//log('response detected');
				xhr.responseText = doc.body ? doc.body.innerHTML : doc.documentElement ? doc.documentElement.innerHTML : null;
				xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;
				xhr.getResponseHeader = function(header){
					var headers = {'content-type': s.dataType};
					return headers[header];
				};

				var scr = /(json|script)/.test(s.dataType);
				if (scr || s.textarea) {
					// see if user embedded response in textarea
					var ta = doc.getElementsByTagName('textarea')[0];
					if (ta) {
						xhr.responseText = ta.value;
					}
					else if (scr) {
						// account for browsers injecting pre around json response
						var pre = doc.getElementsByTagName('pre')[0];
						var b = doc.getElementsByTagName('body')[0];
						if (pre) {
							xhr.responseText = pre.textContent;
						}
						else if (b) {
							xhr.responseText = b.innerHTML;
						}
					}
				}
				else if (s.dataType == 'xml' && !xhr.responseXML && xhr.responseText != null) {
					xhr.responseXML = toXml(xhr.responseText);
				}

				data = httpData(xhr, s.dataType, s);
			}
			catch(e){
				log('error caught:',e);
				ok = false;
				xhr.error = e;
				s.error && s.error.call(s.context, xhr, 'error', e);
				g && $.event.trigger("ajaxError", [xhr, s, e]);
			}

			if (xhr.aborted) {
				log('upload aborted');
				ok = false;
			}

			// ordering of these callbacks/triggers is odd, but that's how $.ajax does it
			if (ok) {
				s.success && s.success.call(s.context, data, 'success', xhr);
				g && $.event.trigger("ajaxSuccess", [xhr, s]);
			}

			g && $.event.trigger("ajaxComplete", [xhr, s]);

			if (g && ! --$.active) {
				$.event.trigger("ajaxStop");
			}

			s.complete && s.complete.call(s.context, xhr, ok ? 'success' : 'error');

			// clean up
			setTimeout(function() {
				$io.removeData('form-plugin-onload');
				$io.remove();
				xhr.responseXML = null;
			}, 100);
		}

		var toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)
			if (window.ActiveXObject) {
				doc = new ActiveXObject('Microsoft.XMLDOM');
				doc.async = 'false';
				doc.loadXML(s);
			}
			else {
				doc = (new DOMParser()).parseFromString(s, 'text/xml');
			}
			return (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;
		};
		var parseJSON = $.parseJSON || function(s) {
			return window['eval']('(' + s + ')');
		};

		var httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4
			var ct = xhr.getResponseHeader('content-type') || '',
				xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,
				data = xml ? xhr.responseXML : xhr.responseText;

			if (xml && data.documentElement.nodeName === 'parsererror') {
				$.error && $.error('parsererror');
			}
			if (s && s.dataFilter) {
				data = s.dataFilter(data, type);
			}
			if (typeof data === 'string') {
				if (type === 'json' || !type && ct.indexOf('json') >= 0) {
					data = parseJSON(data);
				} else if (type === "script" || !type && ct.indexOf("javascript") >= 0) {
					$.globalEval(data);
				}
			}
			return data;
		};
	}
};

/**
 * ajaxForm() provides a mechanism for fully automating form submission.
 *
 * The advantages of using this method instead of ajaxSubmit() are:
 *
 * 1: This method will include coordinates for <input type="image" /> elements (if the element
 *	is used to submit the form).
 * 2. This method will include the submit element's name/value data (for the element that was
 *	used to submit the form).
 * 3. This method binds the submit() method to the form for you.
 *
 * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely
 * passes the options argument along after properly binding events for submit elements and
 * the form itself.
 */
$.fn.ajaxForm = function(options) {
	// in jQuery 1.3+ we can fix mistakes with the ready state
	if (this.length === 0) {
		var o = { s: this.selector, c: this.context };
		if (!$.isReady && o.s) {
			log('DOM not ready, queuing ajaxForm');
			$(function() {
				$(o.s,o.c).ajaxForm(options);
			});
			return this;
		}
		// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()
		log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));
		return this;
	}

	return this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {
		if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
			e.preventDefault();
			$(this).ajaxSubmit(options);
		}
	}).bind('click.form-plugin', function(e) {
		var target = e.target;
		var $el = $(target);
		if (!($el.is(":submit,input:image"))) {
			// is this a child element of the submit el?  (ex: a span within a button)
			var t = $el.closest(':submit');
			if (t.length == 0) {
				return;
			}
			target = t[0];
		}
		var form = this;
		form.clk = target;
		if (target.type == 'image') {
			if (e.offsetX != undefined) {
				form.clk_x = e.offsetX;
				form.clk_y = e.offsetY;
			} else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin
				var offset = $el.offset();
				form.clk_x = e.pageX - offset.left;
				form.clk_y = e.pageY - offset.top;
			} else {
				form.clk_x = e.pageX - target.offsetLeft;
				form.clk_y = e.pageY - target.offsetTop;
			}
		}
		// clear form vars
		setTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);
	});
};

// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm
$.fn.ajaxFormUnbind = function() {
	return this.unbind('submit.form-plugin click.form-plugin');
};

/**
 * formToArray() gathers form element data into an array of objects that can
 * be passed to any of the following ajax functions: $.get, $.post, or load.
 * Each object in the array has both a 'name' and 'value' property.  An example of
 * an array for a simple login form might be:
 *
 * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]
 *
 * It is this array that is passed to pre-submit callback functions provided to the
 * ajaxSubmit() and ajaxForm() methods.
 */
$.fn.formToArray = function(semantic) {
	var a = [];
	if (this.length === 0) {
		return a;
	}

	var form = this[0];
	var els = semantic ? form.getElementsByTagName('*') : form.elements;
	if (!els) {
		return a;
	}

	var i,j,n,v,el,max,jmax;
	for(i=0, max=els.length; i < max; i++) {
		el = els[i];
		n = el.name;
		if (!n) {
			continue;
		}

		if (semantic && form.clk && el.type == "image") {
			// handle image inputs on the fly when semantic == true
			if(!el.disabled && form.clk == el) {
				a.push({name: n, value: $(el).val()});
				a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
			}
			continue;
		}

		v = $.fieldValue(el, true);
		if (v && v.constructor == Array) {
			for(j=0, jmax=v.length; j < jmax; j++) {
				a.push({name: n, value: v[j]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: n, value: v});
		}
	}

	if (!semantic && form.clk) {
		// input type=='image' are not found in elements array! handle it here
		var $input = $(form.clk), input = $input[0];
		n = input.name;
		if (n && !input.disabled && input.type == 'image') {
			a.push({name: n, value: $input.val()});
			a.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});
		}
	}
	return a;
};

/**
 * Serializes form data into a 'submittable' string. This method will return a string
 * in the format: name1=value1&amp;name2=value2
 */
$.fn.formSerialize = function(semantic) {
	//hand off to jQuery.param for proper encoding
	return $.param(this.formToArray(semantic));
};

/**
 * Serializes all field elements in the jQuery object into a query string.
 * This method will return a string in the format: name1=value1&amp;name2=value2
 */
$.fn.fieldSerialize = function(successful) {
	var a = [];
	this.each(function() {
		var n = this.name;
		if (!n) {
			return;
		}
		var v = $.fieldValue(this, successful);
		if (v && v.constructor == Array) {
			for (var i=0,max=v.length; i < max; i++) {
				a.push({name: n, value: v[i]});
			}
		}
		else if (v !== null && typeof v != 'undefined') {
			a.push({name: this.name, value: v});
		}
	});
	//hand off to jQuery.param for proper encoding
	return $.param(a);
};

/**
 * Returns the value(s) of the element in the matched set.  For example, consider the following form:
 *
 *  <form><fieldset>
 *	  <input name="A" type="text" />
 *	  <input name="A" type="text" />
 *	  <input name="B" type="checkbox" value="B1" />
 *	  <input name="B" type="checkbox" value="B2"/>
 *	  <input name="C" type="radio" value="C1" />
 *	  <input name="C" type="radio" value="C2" />
 *  </fieldset></form>
 *
 *  var v = $(':text').fieldValue();
 *  // if no values are entered into the text inputs
 *  v == ['','']
 *  // if values entered into the text inputs are 'foo' and 'bar'
 *  v == ['foo','bar']
 *
 *  var v = $(':checkbox').fieldValue();
 *  // if neither checkbox is checked
 *  v === undefined
 *  // if both checkboxes are checked
 *  v == ['B1', 'B2']
 *
 *  var v = $(':radio').fieldValue();
 *  // if neither radio is checked
 *  v === undefined
 *  // if first radio is checked
 *  v == ['C1']
 *
 * The successful argument controls whether or not the field element must be 'successful'
 * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).
 * The default value of the successful argument is true.  If this value is false the value(s)
 * for each element is returned.
 *
 * Note: This method *always* returns an array.  If no valid value can be determined the
 *	   array will be empty, otherwise it will contain one or more values.
 */
$.fn.fieldValue = function(successful) {
	for (var val=[], i=0, max=this.length; i < max; i++) {
		var el = this[i];
		var v = $.fieldValue(el, successful);
		if (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {
			continue;
		}
		v.constructor == Array ? $.merge(val, v) : val.push(v);
	}
	return val;
};

/**
 * Returns the value of the field element.
 */
$.fieldValue = function(el, successful) {
	var n = el.name, t = el.type, tag = el.tagName.toLowerCase();
	if (successful === undefined) {
		successful = true;
	}

	if (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||
		(t == 'checkbox' || t == 'radio') && !el.checked ||
		(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
		tag == 'select' && el.selectedIndex == -1)) {
			return null;
	}

	if (tag == 'select') {
		var index = el.selectedIndex;
		if (index < 0) {
			return null;
		}
		var a = [], ops = el.options;
		var one = (t == 'select-one');
		var max = (one ? index+1 : ops.length);
		for(var i=(one ? index : 0); i < max; i++) {
			var op = ops[i];
			if (op.selected) {
				var v = op.value;
				if (!v) { // extra pain for IE...
					v = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;
				}
				if (one) {
					return v;
				}
				a.push(v);
			}
		}
		return a;
	}
	return $(el).val();
};

/**
 * Clears the form data.  Takes the following actions on the form's input fields:
 *  - input text fields will have their 'value' property set to the empty string
 *  - select elements will have their 'selectedIndex' property set to -1
 *  - checkbox and radio inputs will have their 'checked' property set to false
 *  - inputs of type submit, button, reset, and hidden will *not* be effected
 *  - button elements will *not* be effected
 */
$.fn.clearForm = function() {
	return this.each(function() {
		$('input,select,textarea', this).clearFields();
	});
};

/**
 * Clears the selected form elements.
 */
$.fn.clearFields = $.fn.clearInputs = function() {
	return this.each(function() {
		var t = this.type, tag = this.tagName.toLowerCase();
		if (t == 'text' || t == 'password' || tag == 'textarea') {
			this.value = '';
		}
		else if (t == 'checkbox' || t == 'radio') {
			this.checked = false;
		}
		else if (tag == 'select') {
			this.selectedIndex = -1;
		}
	});
};

/**
 * Resets the form data.  Causes all form elements to be reset to their original value.
 */
$.fn.resetForm = function() {
	return this.each(function() {
		// guard against an input with the name of 'reset'
		// note that IE reports the reset function as an 'object'
		if (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {
			this.reset();
		}
	});
};

/**
 * Enables or disables any matching elements.
 */
$.fn.enable = function(b) {
	if (b === undefined) {
		b = true;
	}
	return this.each(function() {
		this.disabled = !b;
	});
};

/**
 * Checks/unchecks any matching checkboxes or radio buttons and
 * selects/deselects and matching option elements.
 */
$.fn.selected = function(select) {
	if (select === undefined) {
		select = true;
	}
	return this.each(function() {
		var t = this.type;
		if (t == 'checkbox' || t == 'radio') {
			this.checked = select;
		}
		else if (this.tagName.toLowerCase() == 'option') {
			var $sel = $(this).parent('select');
			if (select && $sel[0] && $sel[0].type == 'select-one') {
				// deselect all other options
				$sel.find('option').selected(false);
			}
			this.selected = select;
		}
	});
};

// helper fn for console logging
// set $.fn.ajaxSubmit.debug to true to enable debug logging
function log() {
	if ($.fn.ajaxSubmit.debug) {
		var msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');
		if (window.console && window.console.log) {
			window.console.log(msg);
		}
		else if (window.opera && window.opera.postError) {
			window.opera.postError(msg);
		}
	}
};

})(jQuery);

/*
 * jQuery history plugin
 *
 * The MIT License
 *
 * Copyright (c) 2006-2009 Taku Sano (Mikage Sawatari)
 * Copyright (c) 2010 Takayuki Miwa
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function($) {
    var locationWrapper = {
        put: function(hash, win) {
            (win || window).location.hash = this.encoder(hash);
        },
        get: function(win) {
            var hash = ((win || window).location.hash).replace(/^#/, '');
            try {
                return $.browser.mozilla ? hash : decodeURIComponent(hash);
            }
            catch (error) {
                return hash;
            }
        },
        encoder: encodeURIComponent
    };

    var iframeWrapper = {
        id: "__jQuery_history",
        init: function() {
            var html = '<iframe id="'+ this.id +'" style="display:none" src="javascript:false;" />';
            $("body").prepend(html);
            return this;
        },
        _document: function() {
            return $("#"+ this.id)[0].contentWindow.document;
        },
        put: function(hash) {
            var doc = this._document();
            doc.open();
            doc.close();
            locationWrapper.put(hash, doc);
        },
        get: function() {
            return locationWrapper.get(this._document());
        }
    };

    function initObjects(options) {
        options = $.extend({
                unescape: false
            }, options || {});

        locationWrapper.encoder = encoder(options.unescape);

        function encoder(unescape_) {
            if(unescape_ === true) {
                return function(hash){ return hash; };
            }
            if(typeof unescape_ == "string" &&
               (unescape_ = partialDecoder(unescape_.split("")))
               || typeof unescape_ == "function") {
                return function(hash) { return unescape_(encodeURIComponent(hash)); };
            }
            return encodeURIComponent;
        }

        function partialDecoder(chars) {
            var re = new RegExp($.map(chars, encodeURIComponent).join("|"), "ig");
            return function(enc) { return enc.replace(re, decodeURIComponent); };
        }
    }

    var implementations = {};

    implementations.base = {
        callback: undefined,
        type: undefined,

        check: function() {},
        load:  function(hash) {},
        init:  function(callback, options) {
            initObjects(options);
            self.callback = callback;
            self._options = options;
            self._init();
        },

        _init: function() {},
        _options: {}
    };

    implementations.timer = {
        _appState: undefined,
        _init: function() {
            var current_hash = locationWrapper.get();
            self._appState = current_hash;
            self.callback(current_hash);
            setInterval(self.check, 100);
        },
        check: function() {
            var current_hash = locationWrapper.get();
            if(current_hash != self._appState) {
                self._appState = current_hash;
                self.callback(current_hash);
            }
        },
        load: function(hash) {
            if(hash != self._appState) {
                locationWrapper.put(hash);
                self._appState = hash;
                self.callback(hash);
            }
        }
    };

    implementations.iframeTimer = {
        _appState: undefined,
        _init: function() {
            var current_hash = locationWrapper.get();
            self._appState = current_hash;
            iframeWrapper.init().put(current_hash);
            self.callback(current_hash);
            setInterval(self.check, 100);
        },
        check: function() {
            var iframe_hash = iframeWrapper.get(),
                location_hash = locationWrapper.get();

            if (location_hash != iframe_hash) {
                if (location_hash == self._appState) {    // user used Back or Forward button
                    self._appState = iframe_hash;
                    locationWrapper.put(iframe_hash);
                    self.callback(iframe_hash);
                } else {                              // user loaded new bookmark
                    self._appState = location_hash;
                    iframeWrapper.put(location_hash);
                    self.callback(location_hash);
                }
            }
        },
        load: function(hash) {
            if(hash != self._appState) {
                locationWrapper.put(hash);
                iframeWrapper.put(hash);
                self._appState = hash;
                self.callback(hash);
            }
        }
    };

    implementations.hashchangeEvent = {
        _init: function() {
            self.callback(locationWrapper.get());
            $(window).bind('hashchange', self.check);
        },
        check: function() {
            self.callback(locationWrapper.get());
        },
        load: function(hash) {
            locationWrapper.put(hash);
        }
    };

    var self = $.extend({}, implementations.base);

    if($.browser.msie && ($.browser.version < 8 || document.documentMode < 8)) {
        self.type = 'iframeTimer';
    } else if("onhashchange" in window) {
        self.type = 'hashchangeEvent';
    } else {
        self.type = 'timer';
    }

    $.extend(self, implementations[self.type]);
    $.history = self;
})(jQuery);
/*
 * 	Easy Paginate 1.0 - jQuery plugin
 *	written by Alen Grakalic	
 *	http://cssglobe.com/
 *
 *	Copyright (c) 2011 Alen Grakalic (http://cssglobe.com)
 *	Dual licensed under the MIT (MIT-LICENSE.txt)
 *	and GPL (GPL-LICENSE.txt) licenses.
 *
 *	Built for jQuery library
 *	http://jquery.com
 *
 */

(function($) {
		  
	$.fn.easyPaginate = function(options){

		var defaults = {				
			step: 4,
			delay: 100,
			numeric: true,
			nextprev: true,
			auto:false,
			loop:false,
			pause:4000,
			clickstop:true,
			controls: 'pagination',
			current: 'current',
			randomstart: false
		}; 
		
		var options = $.extend(defaults, options); 
		var step = options.step;
		var lower, upper;
		var children = $(this).children();
		var count = children.length;
		var obj, next, prev;		
		var pages = Math.floor(count/step);
		var page = (options.randomstart) ? Math.floor(Math.random()*pages)+1 : 1;
		var timeout;
		var clicked = false;
		
		function show(){
			clearTimeout(timeout);
			lower = ((page-1) * step);
			upper = lower+step;
			$(children).each(function(i){
				var child = $(this);
				child.hide();
				if(i>=lower && i<upper){ setTimeout(function(){ child.fadeIn('fast') }, ( i-( Math.floor(i/step) * step) )*options.delay ); }
				if(options.nextprev){
					if(upper >= count) { next.fadeOut('fast'); } else { next.fadeIn('fast'); };
					if(lower >= 1) { prev.fadeIn('fast'); } else { prev.fadeOut('fast'); };
				};
			});	
			$('li','#'+ options.controls).removeClass(options.current);
			$('li[data-index="'+page+'"]','#'+ options.controls).addClass(options.current);
			
			if(options.auto){
				if(options.clickstop && clicked){}else{ timeout = setTimeout(auto,options.pause); };
			};
		};
		
		function auto(){
			if(options.loop) if(upper >= count){ page=0; show(); }
			if(upper < count){ page++; show(); }				
		};
		
		this.each(function(){ 
			
			obj = this;
			
			if(count>step){
								
				if((count/step) > pages) pages++;
				
				var ol = $('<ol id="'+ options.controls +'"></ol>').insertAfter(obj);
				
				if(options.nextprev){
					prev = $('<li class="prev">Previous</li>')
						.hide()
						.appendTo(ol)
						.click(function(){
							clicked = true;
							page--;
							show();
						});
				};
				
				if(options.numeric){
					for(var i=1;i<=pages;i++){
					$('<li data-index="'+ i +'">'+ i +'</li>')
						.appendTo(ol)
						.click(function(){	
							clicked = true;
							page = $(this).data('index');
							show();
						});					
					};				
				};
				
				if(options.nextprev){
					next = $('<li class="next">Next</li>')
						.hide()
						.appendTo(ol)
						.click(function(){
							clicked = true;			
							page++;
							show();
						});
				};
			
				show();
			};
		});	
		
	};	

})(jQuery);
/*
Copyright (c) 2009, Pim Jager
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
* The name Pim Jager may not be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Pim Jager ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Pim Jager BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function($){
	//We use a small helper function that will return true when 'a' is undefined (so we can do if(checkUndefined(data)) return false;
	//If we would continue with undefined data we would piss javascript off as we would be getting properties of an
	//non-exsitent object (ie typeof data === 'undefined'; data.fooBar; //throws error
	var checkUndefined = function(a) {
		return typeof a === 'undefined';
	}
	$.expr[':'].data = function(elem, counter, params){
		if(checkUndefined(elem) || checkUndefined(params)) return false;
		//:data(__) accepts 'dataKey', 'dataKey=Value', 'dataKey.InnerdataKey', 'dataKey.InnerdataKey=Value'
		//Also instead of = we accept: != (does not equal Value), ^= (starts with Value), 
		//		$= (ends with Value), *=Value (contains Value);
		//$(elem).data(dataKey) or $(elem).data(dataKey)[innerDataKey] (optional more innerDataKeys)
		//When no value is speciefied we return all elements that have the dataKey specified, similar to [attribute]
		var query = params[3]; //The part in the parenthesis, thus: selector:data( query )
		if(!query) return false; //query can not be anything that evaluates to false, it has to be string
		var querySplitted = query.split('='); //for dataKey=Value/dataKey.innerDataKey=Value
		//We check if the condition was an =, an !=, an $= or an *=
		var selectType = querySplitted[0].charAt( querySplitted[0].length-1 );
		if(selectType == '^' || selectType == '$' || selectType == '!' || selectType == '*'){
			querySplitted[0] = querySplitted[0].substring(0, querySplitted[0].length-1);
			//the ^=, *= and $= are only available when the $.stringQuery plugin is loaded, if it is not and any of these are used we return false
			if(!$.stringQuery && selectType != '!'){
				return false;
			}
		}
		else selectType = '=';
		var dataName = querySplitted[0]; //dataKey or dataKey.innerDataKey
		//Now we go check if we need dataKey or dataKey.innerDataKey
		var dataNameSplitted = dataName.split('.');
		var data = $(elem).data(dataNameSplitted[0]);
		if(checkUndefined(data)) return false;
		if(dataNameSplitted[1]){//We have innerDataKeys
			for(i=1, x=dataNameSplitted.length; i<x; i++){ //we start counting at 1 since we ignore the first value because that is the dataKey
				data = data[dataNameSplitted[i]];
				if(checkUndefined(data)) return false;
			}
		}
		if(querySplitted[1]){ //should the data be of a specified value?
			var checkAgainst = (data+'');
				//We cast to string as the query will always be a string, otherwise boolean comparison may fail
				//beacuse in javaScript true!='true' but (true+'')=='true'
			//We use this switch to check if we chould check for =, $=, ^=, !=, *=
			switch(selectType){
				case '=': //equals
					return checkAgainst == querySplitted[1]; 
				break;
				case '!': //does not equeal
					return checkAgainst != querySplitted[1];
				break;
				case '^': //starts with
					return $.stringQuery.startsWith(checkAgainst, querySplitted[1]);
				break;
				case '$': //ends with
					return $.stringQuery.endsWith(checkAgainst, querySplitted[1]);
				break;
				case '*': //contains
					return $.stringQuery.contains(checkAgainst, querySplitted[1]);
				break;
				default: //default should never happen
					return false;
				break;
			}			
		}
		else{ //the data does not have to be a speciefied value
				//, just return true (we are here so the data is specified, otherwise false would have been returned by now)
			return true;
		}
	}
})(jQuery);
/**
 * @summary     DataTables
 * @description Paginate, search and sort HTML tables
 * @version     1.9.4
 * @file        jquery.dataTables.js
 * @author      Allan Jardine (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 *
 * @copyright Copyright 2008-2012 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, available at:
 *   http://datatables.net/license_gpl2
 *   http://datatables.net/license_bsd
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $, jQuery,define,_fnExternApiFunc,_fnInitialise,_fnInitComplete,_fnLanguageCompat,_fnAddColumn,_fnColumnOptions,_fnAddData,_fnCreateTr,_fnGatherData,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnServerParams,_fnAddOptionsHtml,_fnFeatureHtmlTable,_fnScrollDraw,_fnAdjustColumnSizing,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnBuildSearchArray,_fnBuildSearchRow,_fnFilterCreateSearch,_fnDataToSearch,_fnSort,_fnSortAttachListener,_fnSortingClasses,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnFeatureHtmlLength,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnNodeToDataIndex,_fnVisbleColumns,_fnCalculateEnd,_fnConvertToWidth,_fnCalculateColumnWidths,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnDetectType,_fnSettingsFromNode,_fnGetDataMaster,_fnGetTrNodes,_fnGetTdNodes,_fnEscapeRegex,_fnDeleteIndex,_fnReOrderIndex,_fnColumnOrdering,_fnLog,_fnClearTable,_fnSaveState,_fnLoadState,_fnCreateCookie,_fnReadCookie,_fnDetectHeader,_fnGetUniqueThs,_fnScrollBarWidth,_fnApplyToChildren,_fnMap,_fnGetRowData,_fnGetCellData,_fnSetCellData,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnApplyColumnDefs,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnJsonString,_fnRender,_fnNodeToColumnIndex,_fnInfoMacros,_fnBrowserDetect,_fnGetColumns*/

(/** @lends <global> */function( window, document, undefined ) {

(function( factory ) {
    "use strict";

    // Define as an AMD module if possible
    if ( typeof define === 'function' && define.amd )
    {
        define( ['jquery'], factory );
    }
    /* Define using browser globals otherwise
     * Prevent multiple instantiations if the script is loaded twice
     */
    else if ( jQuery && !jQuery.fn.dataTable )
    {
        factory( jQuery );
    }
}
(/** @lends <global> */function( $ ) {
    "use strict";
    /**
     * DataTables is a plug-in for the jQuery Javascript library. It is a
     * highly flexible tool, based upon the foundations of progressive
     * enhancement, which will add advanced interaction controls to any
     * HTML table. For a full list of features please refer to
     * <a href="http://datatables.net">DataTables.net</a>.
     *
     * Note that the <i>DataTable</i> object is not a global variable but is
     * aliased to <i>jQuery.fn.DataTable</i> and <i>jQuery.fn.dataTable</i> through which
     * it may be  accessed.
     *
     *  @class
     *  @param {object} [oInit={}] Configuration object for DataTables. Options
     *    are defined by {@link DataTable.defaults}
     *  @requires jQuery 1.3+
     *
     *  @example
     *    // Basic initialisation
     *    $(document).ready( function {
     *      $('#example').dataTable();
     *    } );
     *
     *  @example
     *    // Initialisation with configuration options - in this case, disable
     *    // pagination and sorting.
     *    $(document).ready( function {
     *      $('#example').dataTable( {
     *        "bPaginate": false,
     *        "bSort": false
     *      } );
     *    } );
     */
    var DataTable = function( oInit )
    {


        /**
         * Add a column to the list used for the table with default values
         *  @param {object} oSettings dataTables settings object
         *  @param {node} nTh The th element for this column
         *  @memberof DataTable#oApi
         */
        function _fnAddColumn( oSettings, nTh )
        {
            var oDefaults = DataTable.defaults.columns;
            var iCol = oSettings.aoColumns.length;
            var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
                "sSortingClass": oSettings.oClasses.sSortable,
                "sSortingClassJUI": oSettings.oClasses.sSortJUI,
                "nTh": nTh ? nTh : document.createElement('th'),
                "sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
                "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
                "mData": oDefaults.mData ? oDefaults.oDefaults : iCol
            } );
            oSettings.aoColumns.push( oCol );

            /* Add a column specific filter */
            if ( oSettings.aoPreSearchCols[ iCol ] === undefined || oSettings.aoPreSearchCols[ iCol ] === null )
            {
                oSettings.aoPreSearchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch );
            }
            else
            {
                var oPre = oSettings.aoPreSearchCols[ iCol ];

                /* Don't require that the user must specify bRegex, bSmart or bCaseInsensitive */
                if ( oPre.bRegex === undefined )
                {
                    oPre.bRegex = true;
                }

                if ( oPre.bSmart === undefined )
                {
                    oPre.bSmart = true;
                }

                if ( oPre.bCaseInsensitive === undefined )
                {
                    oPre.bCaseInsensitive = true;
                }
            }

            /* Use the column options function to initialise classes etc */
            _fnColumnOptions( oSettings, iCol, null );
        }


        /**
         * Apply options for a column
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iCol column index to consider
         *  @param {object} oOptions object with sType, bVisible and bSearchable etc
         *  @memberof DataTable#oApi
         */
        function _fnColumnOptions( oSettings, iCol, oOptions )
        {
            var oCol = oSettings.aoColumns[ iCol ];

            /* User specified column options */
            if ( oOptions !== undefined && oOptions !== null )
            {
                /* Backwards compatibility for mDataProp */
                if ( oOptions.mDataProp && !oOptions.mData )
                {
                    oOptions.mData = oOptions.mDataProp;
                }

                if ( oOptions.sType !== undefined )
                {
                    oCol.sType = oOptions.sType;
                    oCol._bAutoType = false;
                }

                $.extend( oCol, oOptions );
                _fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );

                /* iDataSort to be applied (backwards compatibility), but aDataSort will take
                 * priority if defined
                 */
                if ( oOptions.iDataSort !== undefined )
                {
                    oCol.aDataSort = [ oOptions.iDataSort ];
                }
                _fnMap( oCol, oOptions, "aDataSort" );
            }

            /* Cache the data get and set functions for speed */
            var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
            var mData = _fnGetObjectDataFn( oCol.mData );

            oCol.fnGetData = function (oData, sSpecific) {
                var innerData = mData( oData, sSpecific );

                if ( oCol.mRender && (sSpecific && sSpecific !== '') )
                {
                    return mRender( innerData, sSpecific, oData );
                }
                return innerData;
            };
            oCol.fnSetData = _fnSetObjectDataFn( oCol.mData );

            /* Feature sorting overrides column specific when off */
            if ( !oSettings.oFeatures.bSort )
            {
                oCol.bSortable = false;
            }

            /* Check that the class assignment is correct for sorting */
            if ( !oCol.bSortable ||
                 ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) )
            {
                oCol.sSortingClass = oSettings.oClasses.sSortableNone;
                oCol.sSortingClassJUI = "";
            }
            else if ( $.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1 )
            {
                oCol.sSortingClass = oSettings.oClasses.sSortable;
                oCol.sSortingClassJUI = oSettings.oClasses.sSortJUI;
            }
            else if ( $.inArray('asc', oCol.asSorting) != -1 && $.inArray('desc', oCol.asSorting) == -1 )
            {
                oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
                oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed;
            }
            else if ( $.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) != -1 )
            {
                oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
                oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed;
            }
        }


        /**
         * Adjust the table column widths for new data. Note: you would probably want to
         * do a redraw after calling this function!
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnAdjustColumnSizing ( oSettings )
        {
            /* Not interested in doing column width calculation if auto-width is disabled */
            if ( oSettings.oFeatures.bAutoWidth === false )
            {
                return false;
            }

            _fnCalculateColumnWidths( oSettings );
            for ( var i=0 , iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth;
            }
        }


        /**
         * Covert the index of a visible column to the index in the data array (take account
         * of hidden columns)
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iMatch Visible column index to lookup
         *  @returns {int} i the data index
         *  @memberof DataTable#oApi
         */
        function _fnVisibleToColumnIndex( oSettings, iMatch )
        {
            var aiVis = _fnGetColumns( oSettings, 'bVisible' );

            return typeof aiVis[iMatch] === 'number' ?
                aiVis[iMatch] :
                null;
        }


        /**
         * Covert the index of an index in the data array and convert it to the visible
         *   column index (take account of hidden columns)
         *  @param {int} iMatch Column index to lookup
         *  @param {object} oSettings dataTables settings object
         *  @returns {int} i the data index
         *  @memberof DataTable#oApi
         */
        function _fnColumnIndexToVisible( oSettings, iMatch )
        {
            var aiVis = _fnGetColumns( oSettings, 'bVisible' );
            var iPos = $.inArray( iMatch, aiVis );

            return iPos !== -1 ? iPos : null;
        }


        /**
         * Get the number of visible columns
         *  @param {object} oSettings dataTables settings object
         *  @returns {int} i the number of visible columns
         *  @memberof DataTable#oApi
         */
        function _fnVisbleColumns( oSettings )
        {
            return _fnGetColumns( oSettings, 'bVisible' ).length;
        }


        /**
         * Get an array of column indexes that match a given property
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sParam Parameter in aoColumns to look for - typically
         *    bVisible or bSearchable
         *  @returns {array} Array of indexes with matched properties
         *  @memberof DataTable#oApi
         */
        function _fnGetColumns( oSettings, sParam )
        {
            var a = [];

            $.map( oSettings.aoColumns, function(val, i) {
                if ( val[sParam] ) {
                    a.push( i );
                }
            } );

            return a;
        }


        /**
         * Get the sort type based on an input string
         *  @param {string} sData data we wish to know the type of
         *  @returns {string} type (defaults to 'string' if no type can be detected)
         *  @memberof DataTable#oApi
         */
        function _fnDetectType( sData )
        {
            var aTypes = DataTable.ext.aTypes;
            var iLen = aTypes.length;

            for ( var i=0 ; i<iLen ; i++ )
            {
                var sType = aTypes[i]( sData );
                if ( sType !== null )
                {
                    return sType;
                }
            }

            return 'string';
        }


        /**
         * Figure out how to reorder a display list
         *  @param {object} oSettings dataTables settings object
         *  @returns array {int} aiReturn index list for reordering
         *  @memberof DataTable#oApi
         */
        function _fnReOrderIndex ( oSettings, sColumns )
        {
            var aColumns = sColumns.split(',');
            var aiReturn = [];

            for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                for ( var j=0 ; j<iLen ; j++ )
                {
                    if ( oSettings.aoColumns[i].sName == aColumns[j] )
                    {
                        aiReturn.push( j );
                        break;
                    }
                }
            }

            return aiReturn;
        }


        /**
         * Get the column ordering that DataTables expects
         *  @param {object} oSettings dataTables settings object
         *  @returns {string} comma separated list of names
         *  @memberof DataTable#oApi
         */
        function _fnColumnOrdering ( oSettings )
        {
            var sNames = '';
            for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                sNames += oSettings.aoColumns[i].sName+',';
            }
            if ( sNames.length == iLen )
            {
                return "";
            }
            return sNames.slice(0, -1);
        }


        /**
         * Take the column definitions and static columns arrays and calculate how
         * they relate to column indexes. The callback function will then apply the
         * definition found for a column to a suitable configuration object.
         *  @param {object} oSettings dataTables settings object
         *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
         *  @param {array} aoCols The aoColumns array that defines columns individually
         *  @param {function} fn Callback function - takes two parameters, the calculated
         *    column index and the definition for that column.
         *  @memberof DataTable#oApi
         */
        function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
        {
            var i, iLen, j, jLen, k, kLen;

            // Column definitions with aTargets
            if ( aoColDefs )
            {
                /* Loop over the definitions array - loop in reverse so first instance has priority */
                for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
                {
                    /* Each definition can target multiple columns, as it is an array */
                    var aTargets = aoColDefs[i].aTargets;
                    if ( !$.isArray( aTargets ) )
                    {
                        _fnLog( oSettings, 1, 'aTargets must be an array of targets, not a '+(typeof aTargets) );
                    }

                    for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
                    {
                        if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
                        {
                            /* Add columns that we don't yet know about */
                            while( oSettings.aoColumns.length <= aTargets[j] )
                            {
                                _fnAddColumn( oSettings );
                            }

                            /* Integer, basic index */
                            fn( aTargets[j], aoColDefs[i] );
                        }
                        else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
                        {
                            /* Negative integer, right to left column counting */
                            fn( oSettings.aoColumns.length+aTargets[j], aoColDefs[i] );
                        }
                        else if ( typeof aTargets[j] === 'string' )
                        {
                            /* Class name matching on TH element */
                            for ( k=0, kLen=oSettings.aoColumns.length ; k<kLen ; k++ )
                            {
                                if ( aTargets[j] == "_all" ||
                                     $(oSettings.aoColumns[k].nTh).hasClass( aTargets[j] ) )
                                {
                                    fn( k, aoColDefs[i] );
                                }
                            }
                        }
                    }
                }
            }

            // Statically defined columns array
            if ( aoCols )
            {
                for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
                {
                    fn( i, aoCols[i] );
                }
            }
        }

        /**
         * Add a data array to the table, creating DOM node etc. This is the parallel to
         * _fnGatherData, but for adding rows from a Javascript source, rather than a
         * DOM source.
         *  @param {object} oSettings dataTables settings object
         *  @param {array} aData data array to be added
         *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
         *  @memberof DataTable#oApi
         */
        function _fnAddData ( oSettings, aDataSupplied )
        {
            var oCol;

            /* Take an independent copy of the data source so we can bash it about as we wish */
            var aDataIn = ($.isArray(aDataSupplied)) ?
                aDataSupplied.slice() :
                $.extend( true, {}, aDataSupplied );

            /* Create the object for storing information about this new row */
            var iRow = oSettings.aoData.length;
            var oData = $.extend( true, {}, DataTable.models.oRow );
            oData._aData = aDataIn;
            oSettings.aoData.push( oData );

            /* Create the cells */
            var nTd, sThisType;
            for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                oCol = oSettings.aoColumns[i];

                /* Use rendered data for filtering / sorting */
                if ( typeof oCol.fnRender === 'function' && oCol.bUseRendered && oCol.mData !== null )
                {
                    _fnSetCellData( oSettings, iRow, i, _fnRender(oSettings, iRow, i) );
                }
                else
                {
                    _fnSetCellData( oSettings, iRow, i, _fnGetCellData( oSettings, iRow, i ) );
                }

                /* See if we should auto-detect the column type */
                if ( oCol._bAutoType && oCol.sType != 'string' )
                {
                    /* Attempt to auto detect the type - same as _fnGatherData() */
                    var sVarType = _fnGetCellData( oSettings, iRow, i, 'type' );
                    if ( sVarType !== null && sVarType !== '' )
                    {
                        sThisType = _fnDetectType( sVarType );
                        if ( oCol.sType === null )
                        {
                            oCol.sType = sThisType;
                        }
                        else if ( oCol.sType != sThisType && oCol.sType != "html" )
                        {
                            /* String is always the 'fallback' option */
                            oCol.sType = 'string';
                        }
                    }
                }
            }

            /* Add to the display array */
            oSettings.aiDisplayMaster.push( iRow );

            /* Create the DOM information */
            if ( !oSettings.oFeatures.bDeferRender )
            {
                _fnCreateTr( oSettings, iRow );
            }

            return iRow;
        }


        /**
         * Read in the data from the target table from the DOM
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnGatherData( oSettings )
        {
            var iLoop, i, iLen, j, jLen, jInner,
                nTds, nTrs, nTd, nTr, aLocalData, iThisIndex,
                iRow, iRows, iColumn, iColumns, sNodeName,
                oCol, oData;

            /*
             * Process by row first
             * Add the data object for the whole table - storing the tr node. Note - no point in getting
             * DOM based data if we are going to go and replace it with Ajax source data.
             */
            if ( oSettings.bDeferLoading || oSettings.sAjaxSource === null )
            {
                nTr = oSettings.nTBody.firstChild;
                while ( nTr )
                {
                    if ( nTr.nodeName.toUpperCase() == "TR" )
                    {
                        iThisIndex = oSettings.aoData.length;
                        nTr._DT_RowIndex = iThisIndex;
                        oSettings.aoData.push( $.extend( true, {}, DataTable.models.oRow, {
                            "nTr": nTr
                        } ) );

                        oSettings.aiDisplayMaster.push( iThisIndex );
                        nTd = nTr.firstChild;
                        jInner = 0;
                        while ( nTd )
                        {
                            sNodeName = nTd.nodeName.toUpperCase();
                            if ( sNodeName == "TD" || sNodeName == "TH" )
                            {
                                _fnSetCellData( oSettings, iThisIndex, jInner, $.trim(nTd.innerHTML) );
                                jInner++;
                            }
                            nTd = nTd.nextSibling;
                        }
                    }
                    nTr = nTr.nextSibling;
                }
            }

            /* Gather in the TD elements of the Table - note that this is basically the same as
             * fnGetTdNodes, but that function takes account of hidden columns, which we haven't yet
             * setup!
             */
            nTrs = _fnGetTrNodes( oSettings );
            nTds = [];
            for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
            {
                nTd = nTrs[i].firstChild;
                while ( nTd )
                {
                    sNodeName = nTd.nodeName.toUpperCase();
                    if ( sNodeName == "TD" || sNodeName == "TH" )
                    {
                        nTds.push( nTd );
                    }
                    nTd = nTd.nextSibling;
                }
            }

            /* Now process by column */
            for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
            {
                oCol = oSettings.aoColumns[iColumn];

                /* Get the title of the column - unless there is a user set one */
                if ( oCol.sTitle === null )
                {
                    oCol.sTitle = oCol.nTh.innerHTML;
                }

                var
                    bAutoType = oCol._bAutoType,
                    bRender = typeof oCol.fnRender === 'function',
                    bClass = oCol.sClass !== null,
                    bVisible = oCol.bVisible,
                    nCell, sThisType, sRendered, sValType;

                /* A single loop to rule them all (and be more efficient) */
                if ( bAutoType || bRender || bClass || !bVisible )
                {
                    for ( iRow=0, iRows=oSettings.aoData.length ; iRow<iRows ; iRow++ )
                    {
                        oData = oSettings.aoData[iRow];
                        nCell = nTds[ (iRow*iColumns) + iColumn ];

                        /* Type detection */
                        if ( bAutoType && oCol.sType != 'string' )
                        {
                            sValType = _fnGetCellData( oSettings, iRow, iColumn, 'type' );
                            if ( sValType !== '' )
                            {
                                sThisType = _fnDetectType( sValType );
                                if ( oCol.sType === null )
                                {
                                    oCol.sType = sThisType;
                                }
                                else if ( oCol.sType != sThisType &&
                                          oCol.sType != "html" )
                                {
                                    /* String is always the 'fallback' option */
                                    oCol.sType = 'string';
                                }
                            }
                        }

                        if ( oCol.mRender )
                        {
                            // mRender has been defined, so we need to get the value and set it
                            nCell.innerHTML = _fnGetCellData( oSettings, iRow, iColumn, 'display' );
                        }
                        else if ( oCol.mData !== iColumn )
                        {
                            // If mData is not the same as the column number, then we need to
                            // get the dev set value. If it is the column, no point in wasting
                            // time setting the value that is already there!
                            nCell.innerHTML = _fnGetCellData( oSettings, iRow, iColumn, 'display' );
                        }

                        /* Rendering */
                        if ( bRender )
                        {
                            sRendered = _fnRender( oSettings, iRow, iColumn );
                            nCell.innerHTML = sRendered;
                            if ( oCol.bUseRendered )
                            {
                                /* Use the rendered data for filtering / sorting */
                                _fnSetCellData( oSettings, iRow, iColumn, sRendered );
                            }
                        }

                        /* Classes */
                        if ( bClass )
                        {
                            nCell.className += ' '+oCol.sClass;
                        }

                        /* Column visibility */
                        if ( !bVisible )
                        {
                            oData._anHidden[iColumn] = nCell;
                            nCell.parentNode.removeChild( nCell );
                        }
                        else
                        {
                            oData._anHidden[iColumn] = null;
                        }

                        if ( oCol.fnCreatedCell )
                        {
                            oCol.fnCreatedCell.call( oSettings.oInstance,
                                nCell, _fnGetCellData( oSettings, iRow, iColumn, 'display' ), oData._aData, iRow, iColumn
                            );
                        }
                    }
                }
            }

            /* Row created callbacks */
            if ( oSettings.aoRowCreatedCallback.length !== 0 )
            {
                for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
                {
                    oData = oSettings.aoData[i];
                    _fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, i] );
                }
            }
        }


        /**
         * Take a TR element and convert it to an index in aoData
         *  @param {object} oSettings dataTables settings object
         *  @param {node} n the TR element to find
         *  @returns {int} index if the node is found, null if not
         *  @memberof DataTable#oApi
         */
        function _fnNodeToDataIndex( oSettings, n )
        {
            return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
        }


        /**
         * Take a TD element and convert it into a column data index (not the visible index)
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow The row number the TD/TH can be found in
         *  @param {node} n The TD/TH element to find
         *  @returns {int} index if the node is found, -1 if not
         *  @memberof DataTable#oApi
         */
        function _fnNodeToColumnIndex( oSettings, iRow, n )
        {
            var anCells = _fnGetTdNodes( oSettings, iRow );

            for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                if ( anCells[i] === n )
                {
                    return i;
                }
            }
            return -1;
        }


        /**
         * Get an array of data for a given row from the internal data cache
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow aoData row id
         *  @param {string} sSpecific data get type ('type' 'filter' 'sort')
         *  @param {array} aiColumns Array of column indexes to get data from
         *  @returns {array} Data array
         *  @memberof DataTable#oApi
         */
        function _fnGetRowData( oSettings, iRow, sSpecific, aiColumns )
        {
            var out = [];
            for ( var i=0, iLen=aiColumns.length ; i<iLen ; i++ )
            {
                out.push( _fnGetCellData( oSettings, iRow, aiColumns[i], sSpecific ) );
            }
            return out;
        }


        /**
         * Get the data for a given cell from the internal cache, taking into account data mapping
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow aoData row id
         *  @param {int} iCol Column index
         *  @param {string} sSpecific data get type ('display', 'type' 'filter' 'sort')
         *  @returns {*} Cell data
         *  @memberof DataTable#oApi
         */
        function _fnGetCellData( oSettings, iRow, iCol, sSpecific )
        {
            var sData;
            var oCol = oSettings.aoColumns[iCol];
            var oData = oSettings.aoData[iRow]._aData;

            if ( (sData=oCol.fnGetData( oData, sSpecific )) === undefined )
            {
                if ( oSettings.iDrawError != oSettings.iDraw && oCol.sDefaultContent === null )
                {
                    _fnLog( oSettings, 0, "Requested unknown parameter "+
                        (typeof oCol.mData=='function' ? '{mData function}' : "'"+oCol.mData+"'")+
                        " from the data source for row "+iRow );
                    oSettings.iDrawError = oSettings.iDraw;
                }
                return oCol.sDefaultContent;
            }

            /* When the data source is null, we can use default column data */
            if ( sData === null && oCol.sDefaultContent !== null )
            {
                sData = oCol.sDefaultContent;
            }
            else if ( typeof sData === 'function' )
            {
                /* If the data source is a function, then we run it and use the return */
                return sData();
            }

            if ( sSpecific == 'display' && sData === null )
            {
                return '';
            }
            return sData;
        }


        /**
         * Set the value for a specific cell, into the internal data cache
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow aoData row id
         *  @param {int} iCol Column index
         *  @param {*} val Value to set
         *  @memberof DataTable#oApi
         */
        function _fnSetCellData( oSettings, iRow, iCol, val )
        {
            var oCol = oSettings.aoColumns[iCol];
            var oData = oSettings.aoData[iRow]._aData;

            oCol.fnSetData( oData, val );
        }


        // Private variable that is used to match array syntax in the data property object
        var __reArray = /\[.*?\]$/;

        /**
         * Return a function that can be used to get data from a source object, taking
         * into account the ability to use nested objects as a source
         *  @param {string|int|function} mSource The data source for the object
         *  @returns {function} Data get function
         *  @memberof DataTable#oApi
         */
        function _fnGetObjectDataFn( mSource )
        {
            if ( mSource === null )
            {
                /* Give an empty string for rendering / sorting etc */
                return function (data, type) {
                    return null;
                };
            }
            else if ( typeof mSource === 'function' )
            {
                return function (data, type, extra) {
                    return mSource( data, type, extra );
                };
            }
            else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1) )
            {
                /* If there is a . in the source string then the data source is in a
                 * nested object so we loop over the data for each level to get the next
                 * level down. On each loop we test for undefined, and if found immediately
                 * return. This allows entire objects to be missing and sDefaultContent to
                 * be used if defined, rather than throwing an error
                 */
                var fetchData = function (data, type, src) {
                    var a = src.split('.');
                    var arrayNotation, out, innerSrc;

                    if ( src !== "" )
                    {
                        for ( var i=0, iLen=a.length ; i<iLen ; i++ )
                        {
                            // Check if we are dealing with an array notation request
                            arrayNotation = a[i].match(__reArray);

                            if ( arrayNotation ) {
                                a[i] = a[i].replace(__reArray, '');

                                // Condition allows simply [] to be passed in
                                if ( a[i] !== "" ) {
                                    data = data[ a[i] ];
                                }
                                out = [];

                                // Get the remainder of the nested object to get
                                a.splice( 0, i+1 );
                                innerSrc = a.join('.');

                                // Traverse each entry in the array getting the properties requested
                                for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
                                    out.push( fetchData( data[j], type, innerSrc ) );
                                }

                                // If a string is given in between the array notation indicators, that
                                // is used to join the strings together, otherwise an array is returned
                                var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
                                data = (join==="") ? out : out.join(join);

                                // The inner call to fetchData has already traversed through the remainder
                                // of the source requested, so we exit from the loop
                                break;
                            }

                            if ( data === null || data[ a[i] ] === undefined )
                            {
                                return undefined;
                            }
                            data = data[ a[i] ];
                        }
                    }

                    return data;
                };

                return function (data, type) {
                    return fetchData( data, type, mSource );
                };
            }
            else
            {
                /* Array or flat object mapping */
                return function (data, type) {
                    return data[mSource];
                };
            }
        }


        /**
         * Return a function that can be used to set data from a source object, taking
         * into account the ability to use nested objects as a source
         *  @param {string|int|function} mSource The data source for the object
         *  @returns {function} Data set function
         *  @memberof DataTable#oApi
         */
        function _fnSetObjectDataFn( mSource )
        {
            if ( mSource === null )
            {
                /* Nothing to do when the data source is null */
                return function (data, val) {};
            }
            else if ( typeof mSource === 'function' )
            {
                return function (data, val) {
                    mSource( data, 'set', val );
                };
            }
            else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1) )
            {
                /* Like the get, we need to get data from a nested object */
                var setData = function (data, val, src) {
                    var a = src.split('.'), b;
                    var arrayNotation, o, innerSrc;

                    for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
                    {
                        // Check if we are dealing with an array notation request
                        arrayNotation = a[i].match(__reArray);

                        if ( arrayNotation )
                        {
                            a[i] = a[i].replace(__reArray, '');
                            data[ a[i] ] = [];

                            // Get the remainder of the nested object to set so we can recurse
                            b = a.slice();
                            b.splice( 0, i+1 );
                            innerSrc = b.join('.');

                            // Traverse each entry in the array setting the properties requested
                            for ( var j=0, jLen=val.length ; j<jLen ; j++ )
                            {
                                o = {};
                                setData( o, val[j], innerSrc );
                                data[ a[i] ].push( o );
                            }

                            // The inner call to setData has already traversed through the remainder
                            // of the source and has set the data, thus we can exit here
                            return;
                        }

                        // If the nested object doesn't currently exist - since we are
                        // trying to set the value - create it
                        if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
                        {
                            data[ a[i] ] = {};
                        }
                        data = data[ a[i] ];
                    }

                    // If array notation is used, we just want to strip it and use the property name
                    // and assign the value. If it isn't used, then we get the result we want anyway
                    data[ a[a.length-1].replace(__reArray, '') ] = val;
                };

                return function (data, val) {
                    return setData( data, val, mSource );
                };
            }
            else
            {
                /* Array or flat object mapping */
                return function (data, val) {
                    data[mSource] = val;
                };
            }
        }


        /**
         * Return an array with the full table data
         *  @param {object} oSettings dataTables settings object
         *  @returns array {array} aData Master data array
         *  @memberof DataTable#oApi
         */
        function _fnGetDataMaster ( oSettings )
        {
            var aData = [];
            var iLen = oSettings.aoData.length;
            for ( var i=0 ; i<iLen; i++ )
            {
                aData.push( oSettings.aoData[i]._aData );
            }
            return aData;
        }


        /**
         * Nuke the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnClearTable( oSettings )
        {
            oSettings.aoData.splice( 0, oSettings.aoData.length );
            oSettings.aiDisplayMaster.splice( 0, oSettings.aiDisplayMaster.length );
            oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length );
            _fnCalculateEnd( oSettings );
        }


         /**
         * Take an array of integers (index array) and remove a target integer (value - not
         * the key!)
         *  @param {array} a Index array to target
         *  @param {int} iTarget value to find
         *  @memberof DataTable#oApi
         */
        function _fnDeleteIndex( a, iTarget )
        {
            var iTargetIndex = -1;

            for ( var i=0, iLen=a.length ; i<iLen ; i++ )
            {
                if ( a[i] == iTarget )
                {
                    iTargetIndex = i;
                }
                else if ( a[i] > iTarget )
                {
                    a[i]--;
                }
            }

            if ( iTargetIndex != -1 )
            {
                a.splice( iTargetIndex, 1 );
            }
        }


         /**
         * Call the developer defined fnRender function for a given cell (row/column) with
         * the required parameters and return the result.
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow aoData index for the row
         *  @param {int} iCol aoColumns index for the column
         *  @returns {*} Return of the developer's fnRender function
         *  @memberof DataTable#oApi
         */
        function _fnRender( oSettings, iRow, iCol )
        {
            var oCol = oSettings.aoColumns[iCol];

            return oCol.fnRender( {
                "iDataRow":    iRow,
                "iDataColumn": iCol,
                "oSettings":   oSettings,
                "aData":       oSettings.aoData[iRow]._aData,
                "mDataProp":   oCol.mData
            }, _fnGetCellData(oSettings, iRow, iCol, 'display') );
        }
        /**
         * Create a new TR element (and it's TD children) for a row
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iRow Row to consider
         *  @memberof DataTable#oApi
         */
        function _fnCreateTr ( oSettings, iRow )
        {
            var oData = oSettings.aoData[iRow];
            var nTd;

            if ( oData.nTr === null )
            {
                oData.nTr = document.createElement('tr');

                /* Use a private property on the node to allow reserve mapping from the node
                 * to the aoData array for fast look up
                 */
                oData.nTr._DT_RowIndex = iRow;

                /* Special parameters can be given by the data source to be used on the row */
                if ( oData._aData.DT_RowId )
                {
                    oData.nTr.id = oData._aData.DT_RowId;
                }

                if ( oData._aData.DT_RowClass )
                {
                    oData.nTr.className = oData._aData.DT_RowClass;
                }

                /* Process each column */
                for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
                {
                    var oCol = oSettings.aoColumns[i];
                    nTd = document.createElement( oCol.sCellType );

                    /* Render if needed - if bUseRendered is true then we already have the rendered
                     * value in the data source - so can just use that
                     */
                    nTd.innerHTML = (typeof oCol.fnRender === 'function' && (!oCol.bUseRendered || oCol.mData === null)) ?
                        _fnRender( oSettings, iRow, i ) :
                        _fnGetCellData( oSettings, iRow, i, 'display' );

                    /* Add user defined class */
                    if ( oCol.sClass !== null )
                    {
                        nTd.className = oCol.sClass;
                    }

                    if ( oCol.bVisible )
                    {
                        oData.nTr.appendChild( nTd );
                        oData._anHidden[i] = null;
                    }
                    else
                    {
                        oData._anHidden[i] = nTd;
                    }

                    if ( oCol.fnCreatedCell )
                    {
                        oCol.fnCreatedCell.call( oSettings.oInstance,
                            nTd, _fnGetCellData( oSettings, iRow, i, 'display' ), oData._aData, iRow, i
                        );
                    }
                }

                _fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, iRow] );
            }
        }


        /**
         * Create the HTML header for the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnBuildHead( oSettings )
        {
            var i, nTh, iLen, j, jLen;
            var iThs = $('th, td', oSettings.nTHead).length;
            var iCorrector = 0;
            var jqChildren;

            /* If there is a header in place - then use it - otherwise it's going to get nuked... */
            if ( iThs !== 0 )
            {
                /* We've got a thead from the DOM, so remove hidden columns and apply width to vis cols */
                for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
                {
                    nTh = oSettings.aoColumns[i].nTh;
                    nTh.setAttribute('role', 'columnheader');
                    if ( oSettings.aoColumns[i].bSortable )
                    {
                        nTh.setAttribute('tabindex', oSettings.iTabIndex);
                        nTh.setAttribute('aria-controls', oSettings.sTableId);
                    }

                    if ( oSettings.aoColumns[i].sClass !== null )
                    {
                        $(nTh).addClass( oSettings.aoColumns[i].sClass );
                    }

                    /* Set the title of the column if it is user defined (not what was auto detected) */
                    if ( oSettings.aoColumns[i].sTitle != nTh.innerHTML )
                    {
                        nTh.innerHTML = oSettings.aoColumns[i].sTitle;
                    }
                }
            }
            else
            {
                /* We don't have a header in the DOM - so we are going to have to create one */
                var nTr = document.createElement( "tr" );

                for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
                {
                    nTh = oSettings.aoColumns[i].nTh;
                    nTh.innerHTML = oSettings.aoColumns[i].sTitle;
                    nTh.setAttribute('tabindex', '0');

                    if ( oSettings.aoColumns[i].sClass !== null )
                    {
                        $(nTh).addClass( oSettings.aoColumns[i].sClass );
                    }

                    nTr.appendChild( nTh );
                }
                $(oSettings.nTHead).html( '' )[0].appendChild( nTr );
                _fnDetectHeader( oSettings.aoHeader, oSettings.nTHead );
            }

            /* ARIA role for the rows */
            $(oSettings.nTHead).children('tr').attr('role', 'row');

            /* Add the extra markup needed by jQuery UI's themes */
            if ( oSettings.bJUI )
            {
                for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
                {
                    nTh = oSettings.aoColumns[i].nTh;

                    var nDiv = document.createElement('div');
                    nDiv.className = oSettings.oClasses.sSortJUIWrapper;
                    $(nTh).contents().appendTo(nDiv);

                    var nSpan = document.createElement('span');
                    nSpan.className = oSettings.oClasses.sSortIcon;
                    nDiv.appendChild( nSpan );
                    nTh.appendChild( nDiv );
                }
            }

            if ( oSettings.oFeatures.bSort )
            {
                for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
                {
                    if ( oSettings.aoColumns[i].bSortable !== false )
                    {
                        _fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );
                    }
                    else
                    {
                        $(oSettings.aoColumns[i].nTh).addClass( oSettings.oClasses.sSortableNone );
                    }
                }
            }

            /* Deal with the footer - add classes if required */
            if ( oSettings.oClasses.sFooterTH !== "" )
            {
                $(oSettings.nTFoot).children('tr').children('th').addClass( oSettings.oClasses.sFooterTH );
            }

            /* Cache the footer elements */
            if ( oSettings.nTFoot !== null )
            {
                var anCells = _fnGetUniqueThs( oSettings, null, oSettings.aoFooter );
                for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
                {
                    if ( anCells[i] )
                    {
                        oSettings.aoColumns[i].nTf = anCells[i];
                        if ( oSettings.aoColumns[i].sClass )
                        {
                            $(anCells[i]).addClass( oSettings.aoColumns[i].sClass );
                        }
                    }
                }
            }
        }


        /**
         * Draw the header (or footer) element based on the column visibility states. The
         * methodology here is to use the layout array from _fnDetectHeader, modified for
         * the instantaneous column visibility, to construct the new layout. The grid is
         * traversed over cell at a time in a rows x columns grid fashion, although each
         * cell insert can cover multiple elements in the grid - which is tracks using the
         * aApplied array. Cell inserts in the grid will only occur where there isn't
         * already a cell in that position.
         *  @param {object} oSettings dataTables settings object
         *  @param array {objects} aoSource Layout array from _fnDetectHeader
         *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
         *  @memberof DataTable#oApi
         */
        function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
        {
            var i, iLen, j, jLen, k, kLen, n, nLocalTr;
            var aoLocal = [];
            var aApplied = [];
            var iColumns = oSettings.aoColumns.length;
            var iRowspan, iColspan;

            if (  bIncludeHidden === undefined )
            {
                bIncludeHidden = false;
            }

            /* Make a copy of the master layout array, but without the visible columns in it */
            for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
            {
                aoLocal[i] = aoSource[i].slice();
                aoLocal[i].nTr = aoSource[i].nTr;

                /* Remove any columns which are currently hidden */
                for ( j=iColumns-1 ; j>=0 ; j-- )
                {
                    if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
                    {
                        aoLocal[i].splice( j, 1 );
                    }
                }

                /* Prep the applied array - it needs an element for each row */
                aApplied.push( [] );
            }

            for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
            {
                nLocalTr = aoLocal[i].nTr;

                /* All cells are going to be replaced, so empty out the row */
                if ( nLocalTr )
                {
                    while( (n = nLocalTr.firstChild) )
                    {
                        nLocalTr.removeChild( n );
                    }
                }

                for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
                {
                    iRowspan = 1;
                    iColspan = 1;

                    /* Check to see if there is already a cell (row/colspan) covering our target
                     * insert point. If there is, then there is nothing to do.
                     */
                    if ( aApplied[i][j] === undefined )
                    {
                        nLocalTr.appendChild( aoLocal[i][j].cell );
                        aApplied[i][j] = 1;

                        /* Expand the cell to cover as many rows as needed */
                        while ( aoLocal[i+iRowspan] !== undefined &&
                                aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
                        {
                            aApplied[i+iRowspan][j] = 1;
                            iRowspan++;
                        }

                        /* Expand the cell to cover as many columns as needed */
                        while ( aoLocal[i][j+iColspan] !== undefined &&
                                aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
                        {
                            /* Must update the applied array over the rows for the columns */
                            for ( k=0 ; k<iRowspan ; k++ )
                            {
                                aApplied[i+k][j+iColspan] = 1;
                            }
                            iColspan++;
                        }

                        /* Do the actual expansion in the DOM */
                        aoLocal[i][j].cell.rowSpan = iRowspan;
                        aoLocal[i][j].cell.colSpan = iColspan;
                    }
                }
            }
        }


        /**
         * Insert the required TR nodes into the table for display
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnDraw( oSettings )
        {
            /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
            var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
            if ( $.inArray( false, aPreDraw ) !== -1 )
            {
                _fnProcessingDisplay( oSettings, false );
                return;
            }

            var i, iLen, n;
            var anRows = [];
            var iRowCount = 0;
            var iStripes = oSettings.asStripeClasses.length;
            var iOpenRows = oSettings.aoOpenRows.length;

            oSettings.bDrawing = true;

            /* Check and see if we have an initial draw position from state saving */
            if ( oSettings.iInitDisplayStart !== undefined && oSettings.iInitDisplayStart != -1 )
            {
                if ( oSettings.oFeatures.bServerSide )
                {
                    oSettings._iDisplayStart = oSettings.iInitDisplayStart;
                }
                else
                {
                    oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ?
                        0 : oSettings.iInitDisplayStart;
                }
                oSettings.iInitDisplayStart = -1;
                _fnCalculateEnd( oSettings );
            }

            /* Server-side processing draw intercept */
            if ( oSettings.bDeferLoading )
            {
                oSettings.bDeferLoading = false;
                oSettings.iDraw++;
            }
            else if ( !oSettings.oFeatures.bServerSide )
            {
                oSettings.iDraw++;
            }
            else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
            {
                return;
            }

            if ( oSettings.aiDisplay.length !== 0 )
            {
                var iStart = oSettings._iDisplayStart;
                var iEnd = oSettings._iDisplayEnd;

                if ( oSettings.oFeatures.bServerSide )
                {
                    iStart = 0;
                    iEnd = oSettings.aoData.length;
                }

                for ( var j=iStart ; j<iEnd ; j++ )
                {
                    var aoData = oSettings.aoData[ oSettings.aiDisplay[j] ];
                    if ( aoData.nTr === null )
                    {
                        _fnCreateTr( oSettings, oSettings.aiDisplay[j] );
                    }

                    var nRow = aoData.nTr;

                    /* Remove the old striping classes and then add the new one */
                    if ( iStripes !== 0 )
                    {
                        var sStripe = oSettings.asStripeClasses[ iRowCount % iStripes ];
                        if ( aoData._sRowStripe != sStripe )
                        {
                            $(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
                            aoData._sRowStripe = sStripe;
                        }
                    }

                    /* Row callback functions - might want to manipulate the row */
                    _fnCallbackFire( oSettings, 'aoRowCallback', null,
                        [nRow, oSettings.aoData[ oSettings.aiDisplay[j] ]._aData, iRowCount, j] );

                    anRows.push( nRow );
                    iRowCount++;

                    /* If there is an open row - and it is attached to this parent - attach it on redraw */
                    if ( iOpenRows !== 0 )
                    {
                        for ( var k=0 ; k<iOpenRows ; k++ )
                        {
                            if ( nRow == oSettings.aoOpenRows[k].nParent )
                            {
                                anRows.push( oSettings.aoOpenRows[k].nTr );
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                /* Table is empty - create a row with an empty message in it */
                anRows[ 0 ] = document.createElement( 'tr' );

                if ( oSettings.asStripeClasses[0] )
                {
                    anRows[ 0 ].className = oSettings.asStripeClasses[0];
                }

                var oLang = oSettings.oLanguage;
                var sZero = oLang.sZeroRecords;
                if ( oSettings.iDraw == 1 && oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
                {
                    sZero = oLang.sLoadingRecords;
                }
                else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
                {
                    sZero = oLang.sEmptyTable;
                }

                var nTd = document.createElement( 'td' );
                nTd.setAttribute( 'valign', "top" );
                nTd.colSpan = _fnVisbleColumns( oSettings );
                nTd.className = oSettings.oClasses.sRowEmpty;
                nTd.innerHTML = _fnInfoMacros( oSettings, sZero );

                anRows[ iRowCount ].appendChild( nTd );
            }

            /* Header and footer callbacks */
            _fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
                _fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay ] );

            _fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
                _fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay ] );

            /*
             * Need to remove any old row from the display - note we can't just empty the tbody using
             * $().html('') since this will unbind the jQuery event handlers (even although the node
             * still exists!) - equally we can't use innerHTML, since IE throws an exception.
             */
            var
                nAddFrag = document.createDocumentFragment(),
                nRemoveFrag = document.createDocumentFragment(),
                nBodyPar, nTrs;

            if ( oSettings.nTBody )
            {
                nBodyPar = oSettings.nTBody.parentNode;
                nRemoveFrag.appendChild( oSettings.nTBody );

                /* When doing infinite scrolling, only remove child rows when sorting, filtering or start
                 * up. When not infinite scroll, always do it.
                 */
                if ( !oSettings.oScroll.bInfinite || !oSettings._bInitComplete ||
                    oSettings.bSorted || oSettings.bFiltered )
                {
                    while( (n = oSettings.nTBody.firstChild) )
                    {
                        oSettings.nTBody.removeChild( n );
                    }
                }

                /* Put the draw table into the dom */
                for ( i=0, iLen=anRows.length ; i<iLen ; i++ )
                {
                    nAddFrag.appendChild( anRows[i] );
                }

                oSettings.nTBody.appendChild( nAddFrag );
                if ( nBodyPar !== null )
                {
                    nBodyPar.appendChild( oSettings.nTBody );
                }
            }

            /* Call all required callback functions for the end of a draw */
            _fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );

            /* Draw is complete, sorting and filtering must be as well */
            oSettings.bSorted = false;
            oSettings.bFiltered = false;
            oSettings.bDrawing = false;

            if ( oSettings.oFeatures.bServerSide )
            {
                _fnProcessingDisplay( oSettings, false );
                if ( !oSettings._bInitComplete )
                {
                    _fnInitComplete( oSettings );
                }
            }
        }


        /**
         * Redraw the table - taking account of the various features which are enabled
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnReDraw( oSettings )
        {
            if ( oSettings.oFeatures.bSort )
            {
                /* Sorting will refilter and draw for us */
                _fnSort( oSettings, oSettings.oPreviousSearch );
            }
            else if ( oSettings.oFeatures.bFilter )
            {
                /* Filtering will redraw for us */
                _fnFilterComplete( oSettings, oSettings.oPreviousSearch );
            }
            else
            {
                _fnCalculateEnd( oSettings );
                _fnDraw( oSettings );
            }
        }


        /**
         * Add the options to the page HTML for the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnAddOptionsHtml ( oSettings )
        {
            /*
             * Create a temporary, empty, div which we can later on replace with what we have generated
             * we do it this way to rendering the 'options' html offline - speed :-)
             */
            var nHolding = $('<div></div>')[0];
            oSettings.nTable.parentNode.insertBefore( nHolding, oSettings.nTable );

            /*
             * All DataTables are wrapped in a div
             */
            oSettings.nTableWrapper = $('<div id="'+oSettings.sTableId+'_wrapper" class="'+oSettings.oClasses.sWrapper+'" role="grid"></div>')[0];
            oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

            /* Track where we want to insert the option */
            var nInsertNode = oSettings.nTableWrapper;

            /* Loop over the user set positioning and place the elements as needed */
            var aDom = oSettings.sDom.split('');
            var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
            for ( var i=0 ; i<aDom.length ; i++ )
            {
                iPushFeature = 0;
                cOption = aDom[i];

                if ( cOption == '<' )
                {
                    /* New container div */
                    nNewNode = $('<div></div>')[0];

                    /* Check to see if we should append an id and/or a class name to the container */
                    cNext = aDom[i+1];
                    if ( cNext == "'" || cNext == '"' )
                    {
                        sAttr = "";
                        j = 2;
                        while ( aDom[i+j] != cNext )
                        {
                            sAttr += aDom[i+j];
                            j++;
                        }

                        /* Replace jQuery UI constants */
                        if ( sAttr == "H" )
                        {
                            sAttr = oSettings.oClasses.sJUIHeader;
                        }
                        else if ( sAttr == "F" )
                        {
                            sAttr = oSettings.oClasses.sJUIFooter;
                        }

                        /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
                         * breaks the string into parts and applies them as needed
                         */
                        if ( sAttr.indexOf('.') != -1 )
                        {
                            var aSplit = sAttr.split('.');
                            nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
                            nNewNode.className = aSplit[1];
                        }
                        else if ( sAttr.charAt(0) == "#" )
                        {
                            nNewNode.id = sAttr.substr(1, sAttr.length-1);
                        }
                        else
                        {
                            nNewNode.className = sAttr;
                        }

                        i += j; /* Move along the position array */
                    }

                    nInsertNode.appendChild( nNewNode );
                    nInsertNode = nNewNode;
                }
                else if ( cOption == '>' )
                {
                    /* End container div */
                    nInsertNode = nInsertNode.parentNode;
                }
                else if ( cOption == 'l' && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange )
                {
                    /* Length */
                    nTmp = _fnFeatureHtmlLength( oSettings );
                    iPushFeature = 1;
                }
                else if ( cOption == 'f' && oSettings.oFeatures.bFilter )
                {
                    /* Filter */
                    nTmp = _fnFeatureHtmlFilter( oSettings );
                    iPushFeature = 1;
                }
                else if ( cOption == 'r' && oSettings.oFeatures.bProcessing )
                {
                    /* pRocessing */
                    nTmp = _fnFeatureHtmlProcessing( oSettings );
                    iPushFeature = 1;
                }
                else if ( cOption == 't' )
                {
                    /* Table */
                    nTmp = _fnFeatureHtmlTable( oSettings );
                    iPushFeature = 1;
                }
                else if ( cOption ==  'i' && oSettings.oFeatures.bInfo )
                {
                    /* Info */
                    nTmp = _fnFeatureHtmlInfo( oSettings );
                    iPushFeature = 1;
                }
                else if ( cOption == 'p' && oSettings.oFeatures.bPaginate )
                {
                    /* Pagination */
                    nTmp = _fnFeatureHtmlPaginate( oSettings );
                    iPushFeature = 1;
                }
                else if ( DataTable.ext.aoFeatures.length !== 0 )
                {
                    /* Plug-in features */
                    var aoFeatures = DataTable.ext.aoFeatures;
                    for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
                    {
                        if ( cOption == aoFeatures[k].cFeature )
                        {
                            nTmp = aoFeatures[k].fnInit( oSettings );
                            if ( nTmp )
                            {
                                iPushFeature = 1;
                            }
                            break;
                        }
                    }
                }

                /* Add to the 2D features array */
                if ( iPushFeature == 1 && nTmp !== null )
                {
                    if ( typeof oSettings.aanFeatures[cOption] !== 'object' )
                    {
                        oSettings.aanFeatures[cOption] = [];
                    }
                    oSettings.aanFeatures[cOption].push( nTmp );
                    nInsertNode.appendChild( nTmp );
                }
            }

            /* Built our DOM structure - replace the holding div with what we want */
            nHolding.parentNode.replaceChild( oSettings.nTableWrapper, nHolding );
        }


        /**
         * Use the DOM source to create up an array of header cells. The idea here is to
         * create a layout grid (array) of rows x columns, which contains a reference
         * to the cell that that point in the grid (regardless of col/rowspan), such that
         * any column / row could be removed and the new grid constructed
         *  @param array {object} aLayout Array to store the calculated layout in
         *  @param {node} nThead The header/footer element for the table
         *  @memberof DataTable#oApi
         */
        function _fnDetectHeader ( aLayout, nThead )
        {
            var nTrs = $(nThead).children('tr');
            var nTr, nCell;
            var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
            var bUnique;
            var fnShiftCol = function ( a, i, j ) {
                var k = a[i];
                        while ( k[j] ) {
                    j++;
                }
                return j;
            };

            aLayout.splice( 0, aLayout.length );

            /* We know how many rows there are in the layout - so prep it */
            for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
            {
                aLayout.push( [] );
            }

            /* Calculate a layout array */
            for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
            {
                nTr = nTrs[i];
                iColumn = 0;

                /* For every cell in the row... */
                nCell = nTr.firstChild;
                while ( nCell ) {
                    if ( nCell.nodeName.toUpperCase() == "TD" ||
                         nCell.nodeName.toUpperCase() == "TH" )
                    {
                        /* Get the col and rowspan attributes from the DOM and sanitise them */
                        iColspan = nCell.getAttribute('colspan') * 1;
                        iRowspan = nCell.getAttribute('rowspan') * 1;
                        iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
                        iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;

                        /* There might be colspan cells already in this row, so shift our target
                         * accordingly
                         */
                        iColShifted = fnShiftCol( aLayout, i, iColumn );

                        /* Cache calculation for unique columns */
                        bUnique = iColspan === 1 ? true : false;

                        /* If there is col / rowspan, copy the information into the layout grid */
                        for ( l=0 ; l<iColspan ; l++ )
                        {
                            for ( k=0 ; k<iRowspan ; k++ )
                            {
                                aLayout[i+k][iColShifted+l] = {
                                    "cell": nCell,
                                    "unique": bUnique
                                };
                                aLayout[i+k].nTr = nTr;
                            }
                        }
                    }
                    nCell = nCell.nextSibling;
                }
            }
        }


        /**
         * Get an array of unique th elements, one for each column
         *  @param {object} oSettings dataTables settings object
         *  @param {node} nHeader automatically detect the layout from this node - optional
         *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
         *  @returns array {node} aReturn list of unique th's
         *  @memberof DataTable#oApi
         */
        function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
        {
            var aReturn = [];
            if ( !aLayout )
            {
                aLayout = oSettings.aoHeader;
                if ( nHeader )
                {
                    aLayout = [];
                    _fnDetectHeader( aLayout, nHeader );
                }
            }

            for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
            {
                for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
                {
                    if ( aLayout[i][j].unique &&
                         (!aReturn[j] || !oSettings.bSortCellsTop) )
                    {
                        aReturn[j] = aLayout[i][j].cell;
                    }
                }
            }

            return aReturn;
        }



        /**
         * Update the table using an Ajax call
         *  @param {object} oSettings dataTables settings object
         *  @returns {boolean} Block the table drawing or not
         *  @memberof DataTable#oApi
         */
        function _fnAjaxUpdate( oSettings )
        {
            if ( oSettings.bAjaxDataGet )
            {
                oSettings.iDraw++;
                _fnProcessingDisplay( oSettings, true );
                var iColumns = oSettings.aoColumns.length;
                var aoData = _fnAjaxParameters( oSettings );
                _fnServerParams( oSettings, aoData );

                oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData,
                    function(json) {
                        _fnAjaxUpdateDraw( oSettings, json );
                    }, oSettings );
                return false;
            }
            else
            {
                return true;
            }
        }


        /**
         * Build up the parameters in an object needed for a server-side processing request
         *  @param {object} oSettings dataTables settings object
         *  @returns {bool} block the table drawing or not
         *  @memberof DataTable#oApi
         */
        function _fnAjaxParameters( oSettings )
        {
            var iColumns = oSettings.aoColumns.length;
            var aoData = [], mDataProp, aaSort, aDataSort;
            var i, j;

            aoData.push( { "name": "sEcho",          "value": oSettings.iDraw } );
            aoData.push( { "name": "iColumns",       "value": iColumns } );
            aoData.push( { "name": "sColumns",       "value": _fnColumnOrdering(oSettings) } );
            aoData.push( { "name": "iDisplayStart",  "value": oSettings._iDisplayStart } );
            aoData.push( { "name": "iDisplayLength", "value": oSettings.oFeatures.bPaginate !== false ?
                oSettings._iDisplayLength : -1 } );

            for ( i=0 ; i<iColumns ; i++ )
            {
              mDataProp = oSettings.aoColumns[i].mData;
                aoData.push( { "name": "mDataProp_"+i, "value": typeof(mDataProp)==="function" ? 'function' : mDataProp } );
            }

            /* Filtering */
            if ( oSettings.oFeatures.bFilter !== false )
            {
                aoData.push( { "name": "sSearch", "value": oSettings.oPreviousSearch.sSearch } );
                aoData.push( { "name": "bRegex",  "value": oSettings.oPreviousSearch.bRegex } );
                for ( i=0 ; i<iColumns ; i++ )
                {
                    aoData.push( { "name": "sSearch_"+i,     "value": oSettings.aoPreSearchCols[i].sSearch } );
                    aoData.push( { "name": "bRegex_"+i,      "value": oSettings.aoPreSearchCols[i].bRegex } );
                    aoData.push( { "name": "bSearchable_"+i, "value": oSettings.aoColumns[i].bSearchable } );
                }
            }

            /* Sorting */
            if ( oSettings.oFeatures.bSort !== false )
            {
                var iCounter = 0;

                aaSort = ( oSettings.aaSortingFixed !== null ) ?
                    oSettings.aaSortingFixed.concat( oSettings.aaSorting ) :
                    oSettings.aaSorting.slice();

                for ( i=0 ; i<aaSort.length ; i++ )
                {
                    aDataSort = oSettings.aoColumns[ aaSort[i][0] ].aDataSort;

                    for ( j=0 ; j<aDataSort.length ; j++ )
                    {
                        aoData.push( { "name": "iSortCol_"+iCounter,  "value": aDataSort[j] } );
                        aoData.push( { "name": "sSortDir_"+iCounter,  "value": aaSort[i][1] } );
                        iCounter++;
                    }
                }
                aoData.push( { "name": "iSortingCols",   "value": iCounter } );

                for ( i=0 ; i<iColumns ; i++ )
                {
                    aoData.push( { "name": "bSortable_"+i,  "value": oSettings.aoColumns[i].bSortable } );
                }
            }

            return aoData;
        }


        /**
         * Add Ajax parameters from plug-ins
         *  @param {object} oSettings dataTables settings object
         *  @param array {objects} aoData name/value pairs to send to the server
         *  @memberof DataTable#oApi
         */
        function _fnServerParams( oSettings, aoData )
        {
            _fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [aoData] );
        }


        /**
         * Data the data from the server (nuking the old) and redraw the table
         *  @param {object} oSettings dataTables settings object
         *  @param {object} json json data return from the server.
         *  @param {string} json.sEcho Tracking flag for DataTables to match requests
         *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
         *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
         *  @param {array} json.aaData The data to display on this page
         *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
         *  @memberof DataTable#oApi
         */
        function _fnAjaxUpdateDraw ( oSettings, json )
        {
            if ( json.sEcho !== undefined )
            {
                /* Protect against old returns over-writing a new one. Possible when you get
                 * very fast interaction, and later queries are completed much faster
                 */
                if ( json.sEcho*1 < oSettings.iDraw )
                {
                    return;
                }
                else
                {
                    oSettings.iDraw = json.sEcho * 1;
                }
            }

            if ( !oSettings.oScroll.bInfinite ||
                   (oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered)) )
            {
                _fnClearTable( oSettings );
            }
            oSettings._iRecordsTotal = parseInt(json.iTotalRecords, 10);
            oSettings._iRecordsDisplay = parseInt(json.iTotalDisplayRecords, 10);

            /* Determine if reordering is required */
            var sOrdering = _fnColumnOrdering(oSettings);
            var bReOrder = (json.sColumns !== undefined && sOrdering !== "" && json.sColumns != sOrdering );
            var aiIndex;
            if ( bReOrder )
            {
                aiIndex = _fnReOrderIndex( oSettings, json.sColumns );
            }

            var aData = _fnGetObjectDataFn( oSettings.sAjaxDataProp )( json );
            for ( var i=0, iLen=aData.length ; i<iLen ; i++ )
            {
                if ( bReOrder )
                {
                    /* If we need to re-order, then create a new array with the correct order and add it */
                    var aDataSorted = [];
                    for ( var j=0, jLen=oSettings.aoColumns.length ; j<jLen ; j++ )
                    {
                        aDataSorted.push( aData[i][ aiIndex[j] ] );
                    }
                    _fnAddData( oSettings, aDataSorted );
                }
                else
                {
                    /* No re-order required, sever got it "right" - just straight add */
                    _fnAddData( oSettings, aData[i] );
                }
            }
            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

            oSettings.bAjaxDataGet = false;
            _fnDraw( oSettings );
            oSettings.bAjaxDataGet = true;
            _fnProcessingDisplay( oSettings, false );
        }



        /**
         * Generate the node required for filtering text
         *  @returns {node} Filter control element
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlFilter ( oSettings )
        {
            var oPreviousSearch = oSettings.oPreviousSearch;

            var sSearchStr = oSettings.oLanguage.sSearch;
            sSearchStr = (sSearchStr.indexOf('_INPUT_') !== -1) ?
              sSearchStr.replace('_INPUT_', '<input type="text" />') :
              sSearchStr==="" ? '<input type="text" />' : sSearchStr+' <input type="text" />';

            var nFilter = document.createElement( 'div' );
            nFilter.className = oSettings.oClasses.sFilter;
            nFilter.innerHTML = '<label>'+sSearchStr+'</label>';
            if ( !oSettings.aanFeatures.f )
            {
                nFilter.id = oSettings.sTableId+'_filter';
            }

            var jqFilter = $('input[type="text"]', nFilter);

            // Store a reference to the input element, so other input elements could be
            // added to the filter wrapper if needed (submit button for example)
            nFilter._DT_Input = jqFilter[0];

            jqFilter.val( oPreviousSearch.sSearch.replace('"','&quot;') );
            jqFilter.bind( 'keyup.DT', function(e) {
                /* Update all other filter input elements for the new display */
                var n = oSettings.aanFeatures.f;
                var val = this.value==="" ? "" : this.value; // mental IE8 fix :-(

                for ( var i=0, iLen=n.length ; i<iLen ; i++ )
                {
                    if ( n[i] != $(this).parents('div.dataTables_filter')[0] )
                    {
                        $(n[i]._DT_Input).val( val );
                    }
                }

                /* Now do the filter */
                if ( val != oPreviousSearch.sSearch )
                {
                    _fnFilterComplete( oSettings, {
                        "sSearch": val,
                        "bRegex": oPreviousSearch.bRegex,
                        "bSmart": oPreviousSearch.bSmart ,
                        "bCaseInsensitive": oPreviousSearch.bCaseInsensitive
                    } );
                }
            } );

            jqFilter
                .attr('aria-controls', oSettings.sTableId)
                .bind( 'keypress.DT', function(e) {
                    /* Prevent form submission */
                    if ( e.keyCode == 13 )
                    {
                        return false;
                    }
                }
            );

            return nFilter;
        }


        /**
         * Filter the table using both the global filter and column based filtering
         *  @param {object} oSettings dataTables settings object
         *  @param {object} oSearch search information
         *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
         *  @memberof DataTable#oApi
         */
        function _fnFilterComplete ( oSettings, oInput, iForce )
        {
            var oPrevSearch = oSettings.oPreviousSearch;
            var aoPrevSearch = oSettings.aoPreSearchCols;
            var fnSaveFilter = function ( oFilter ) {
                /* Save the filtering values */
                oPrevSearch.sSearch = oFilter.sSearch;
                oPrevSearch.bRegex = oFilter.bRegex;
                oPrevSearch.bSmart = oFilter.bSmart;
                oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
            };

            /* In server-side processing all filtering is done by the server, so no point hanging around here */
            if ( !oSettings.oFeatures.bServerSide )
            {
                /* Global filter */
                _fnFilter( oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart, oInput.bCaseInsensitive );
                fnSaveFilter( oInput );

                /* Now do the individual column filter */
                for ( var i=0 ; i<oSettings.aoPreSearchCols.length ; i++ )
                {
                    _fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, aoPrevSearch[i].bRegex,
                        aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
                }

                /* Custom filtering */
                _fnFilterCustom( oSettings );
            }
            else
            {
                fnSaveFilter( oInput );
            }

            /* Tell the draw function we have been filtering */
            oSettings.bFiltered = true;
            $(oSettings.oInstance).trigger('filter', oSettings);

            /* Redraw the table */
            oSettings._iDisplayStart = 0;
            _fnCalculateEnd( oSettings );
            _fnDraw( oSettings );

            /* Rebuild search array 'offline' */
            _fnBuildSearchArray( oSettings, 0 );
        }


        /**
         * Apply custom filtering functions
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnFilterCustom( oSettings )
        {
            var afnFilters = DataTable.ext.afnFiltering;
            var aiFilterColumns = _fnGetColumns( oSettings, 'bSearchable' );

            for ( var i=0, iLen=afnFilters.length ; i<iLen ; i++ )
            {
                var iCorrector = 0;
                for ( var j=0, jLen=oSettings.aiDisplay.length ; j<jLen ; j++ )
                {
                    var iDisIndex = oSettings.aiDisplay[j-iCorrector];
                    var bTest = afnFilters[i](
                        oSettings,
                        _fnGetRowData( oSettings, iDisIndex, 'filter', aiFilterColumns ),
                        iDisIndex
                    );

                    /* Check if we should use this row based on the filtering function */
                    if ( !bTest )
                    {
                        oSettings.aiDisplay.splice( j-iCorrector, 1 );
                        iCorrector++;
                    }
                }
            }
        }


        /**
         * Filter the table on a per-column basis
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sInput string to filter on
         *  @param {int} iColumn column to filter
         *  @param {bool} bRegex treat search string as a regular expression or not
         *  @param {bool} bSmart use smart filtering or not
         *  @param {bool} bCaseInsensitive Do case insenstive matching or not
         *  @memberof DataTable#oApi
         */
        function _fnFilterColumn ( oSettings, sInput, iColumn, bRegex, bSmart, bCaseInsensitive )
        {
            if ( sInput === "" )
            {
                return;
            }

            var iIndexCorrector = 0;
            var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart, bCaseInsensitive );

            for ( var i=oSettings.aiDisplay.length-1 ; i>=0 ; i-- )
            {
                var sData = _fnDataToSearch( _fnGetCellData( oSettings, oSettings.aiDisplay[i], iColumn, 'filter' ),
                    oSettings.aoColumns[iColumn].sType );
                if ( ! rpSearch.test( sData ) )
                {
                    oSettings.aiDisplay.splice( i, 1 );
                    iIndexCorrector++;
                }
            }
        }


        /**
         * Filter the data table based on user input and draw the table
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sInput string to filter on
         *  @param {int} iForce optional - force a research of the master array (1) or not (undefined or 0)
         *  @param {bool} bRegex treat as a regular expression or not
         *  @param {bool} bSmart perform smart filtering or not
         *  @param {bool} bCaseInsensitive Do case insenstive matching or not
         *  @memberof DataTable#oApi
         */
        function _fnFilter( oSettings, sInput, iForce, bRegex, bSmart, bCaseInsensitive )
        {
            var i;
            var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart, bCaseInsensitive );
            var oPrevSearch = oSettings.oPreviousSearch;

            /* Check if we are forcing or not - optional parameter */
            if ( !iForce )
            {
                iForce = 0;
            }

            /* Need to take account of custom filtering functions - always filter */
            if ( DataTable.ext.afnFiltering.length !== 0 )
            {
                iForce = 1;
            }

            /*
             * If the input is blank - we want the full data set
             */
            if ( sInput.length <= 0 )
            {
                oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
            }
            else
            {
                /*
                 * We are starting a new search or the new search string is smaller
                 * then the old one (i.e. delete). Search from the master array
                 */
                if ( oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length ||
                       oPrevSearch.sSearch.length > sInput.length || iForce == 1 ||
                       sInput.indexOf(oPrevSearch.sSearch) !== 0 )
                {
                    /* Nuke the old display array - we are going to rebuild it */
                    oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);

                    /* Force a rebuild of the search array */
                    _fnBuildSearchArray( oSettings, 1 );

                    /* Search through all records to populate the search array
                     * The the oSettings.aiDisplayMaster and asDataSearch arrays have 1 to 1
                     * mapping
                     */
                    for ( i=0 ; i<oSettings.aiDisplayMaster.length ; i++ )
                    {
                        if ( rpSearch.test(oSettings.asDataSearch[i]) )
                        {
                            oSettings.aiDisplay.push( oSettings.aiDisplayMaster[i] );
                        }
                    }
              }
              else
                {
                /* Using old search array - refine it - do it this way for speed
                 * Don't have to search the whole master array again
                     */
                var iIndexCorrector = 0;

                /* Search the current results */
                for ( i=0 ; i<oSettings.asDataSearch.length ; i++ )
                    {
                    if ( ! rpSearch.test(oSettings.asDataSearch[i]) )
                        {
                        oSettings.aiDisplay.splice( i-iIndexCorrector, 1 );
                        iIndexCorrector++;
                    }
                }
              }
            }
        }


        /**
         * Create an array which can be quickly search through
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iMaster use the master data array - optional
         *  @memberof DataTable#oApi
         */
        function _fnBuildSearchArray ( oSettings, iMaster )
        {
            if ( !oSettings.oFeatures.bServerSide )
            {
                /* Clear out the old data */
                oSettings.asDataSearch = [];

                var aiFilterColumns = _fnGetColumns( oSettings, 'bSearchable' );
                var aiIndex = (iMaster===1) ?
                    oSettings.aiDisplayMaster :
                    oSettings.aiDisplay;

                for ( var i=0, iLen=aiIndex.length ; i<iLen ; i++ )
                {
                    oSettings.asDataSearch[i] = _fnBuildSearchRow(
                        oSettings,
                        _fnGetRowData( oSettings, aiIndex[i], 'filter', aiFilterColumns )
                    );
                }
            }
        }


        /**
         * Create a searchable string from a single data row
         *  @param {object} oSettings dataTables settings object
         *  @param {array} aData Row data array to use for the data to search
         *  @memberof DataTable#oApi
         */
        function _fnBuildSearchRow( oSettings, aData )
        {
            var sSearch = aData.join('  ');

            /* If it looks like there is an HTML entity in the string, attempt to decode it */
            if ( sSearch.indexOf('&') !== -1 )
            {
                sSearch = $('<div>').html(sSearch).text();
            }

            // Strip newline characters
            return sSearch.replace( /[\n\r]/g, " " );
        }

        /**
         * Build a regular expression object suitable for searching a table
         *  @param {string} sSearch string to search for
         *  @param {bool} bRegex treat as a regular expression or not
         *  @param {bool} bSmart perform smart filtering or not
         *  @param {bool} bCaseInsensitive Do case insensitive matching or not
         *  @returns {RegExp} constructed object
         *  @memberof DataTable#oApi
         */
        function _fnFilterCreateSearch( sSearch, bRegex, bSmart, bCaseInsensitive )
        {
            var asSearch, sRegExpString;

            if ( bSmart )
            {
                /* Generate the regular expression to use. Something along the lines of:
                 * ^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$
                 */
                asSearch = bRegex ? sSearch.split( ' ' ) : _fnEscapeRegex( sSearch ).split( ' ' );
                sRegExpString = '^(?=.*?'+asSearch.join( ')(?=.*?' )+').*$';
                return new RegExp( sRegExpString, bCaseInsensitive ? "i" : "" );
            }
            else
            {
                sSearch = bRegex ? sSearch : _fnEscapeRegex( sSearch );
                return new RegExp( sSearch, bCaseInsensitive ? "i" : "" );
            }
        }


        /**
         * Convert raw data into something that the user can search on
         *  @param {string} sData data to be modified
         *  @param {string} sType data type
         *  @returns {string} search string
         *  @memberof DataTable#oApi
         */
        function _fnDataToSearch ( sData, sType )
        {
            if ( typeof DataTable.ext.ofnSearch[sType] === "function" )
            {
                return DataTable.ext.ofnSearch[sType]( sData );
            }
            else if ( sData === null )
            {
                return '';
            }
            else if ( sType == "html" )
            {
                return sData.replace(/[\r\n]/g," ").replace( /<.*?>/g, "" );
            }
            else if ( typeof sData === "string" )
            {
                return sData.replace(/[\r\n]/g," ");
            }
            return sData;
        }


        /**
         * scape a string such that it can be used in a regular expression
         *  @param {string} sVal string to escape
         *  @returns {string} escaped string
         *  @memberof DataTable#oApi
         */
        function _fnEscapeRegex ( sVal )
        {
            var acEscape = [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ];
            var reReplace = new RegExp( '(\\' + acEscape.join('|\\') + ')', 'g' );
            return sVal.replace(reReplace, '\\$1');
        }


        /**
         * Generate the node required for the info display
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Information element
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlInfo ( oSettings )
        {
            var nInfo = document.createElement( 'div' );
            nInfo.className = oSettings.oClasses.sInfo;

            /* Actions that are to be taken once only for this feature */
            if ( !oSettings.aanFeatures.i )
            {
                /* Add draw callback */
                oSettings.aoDrawCallback.push( {
                    "fn": _fnUpdateInfo,
                    "sName": "information"
                } );

                /* Add id */
                nInfo.id = oSettings.sTableId+'_info';
            }
            oSettings.nTable.setAttribute( 'aria-describedby', oSettings.sTableId+'_info' );

            return nInfo;
        }


        /**
         * Update the information elements in the display
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnUpdateInfo ( oSettings )
        {
            /* Show information about the table */
            if ( !oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0 )
            {
                return;
            }

            var
                oLang = oSettings.oLanguage,
                iStart = oSettings._iDisplayStart+1,
                iEnd = oSettings.fnDisplayEnd(),
                iMax = oSettings.fnRecordsTotal(),
                iTotal = oSettings.fnRecordsDisplay(),
                sOut;

            if ( iTotal === 0 )
            {
                /* Empty record set */
                sOut = oLang.sInfoEmpty;
            }
            else {
                /* Normal record set */
                sOut = oLang.sInfo;
            }

            if ( iTotal != iMax )
            {
                /* Record set after filtering */
                sOut += ' ' + oLang.sInfoFiltered;
            }

            // Convert the macros
            sOut += oLang.sInfoPostFix;
            sOut = _fnInfoMacros( oSettings, sOut );

            if ( oLang.fnInfoCallback !== null )
            {
                sOut = oLang.fnInfoCallback.call( oSettings.oInstance,
                    oSettings, iStart, iEnd, iMax, iTotal, sOut );
            }

            var n = oSettings.aanFeatures.i;
            for ( var i=0, iLen=n.length ; i<iLen ; i++ )
            {
                $(n[i]).html( sOut );
            }
        }


        function _fnInfoMacros ( oSettings, str )
        {
            var
                iStart = oSettings._iDisplayStart+1,
                sStart = oSettings.fnFormatNumber( iStart ),
                iEnd = oSettings.fnDisplayEnd(),
                sEnd = oSettings.fnFormatNumber( iEnd ),
                iTotal = oSettings.fnRecordsDisplay(),
                sTotal = oSettings.fnFormatNumber( iTotal ),
                iMax = oSettings.fnRecordsTotal(),
                sMax = oSettings.fnFormatNumber( iMax );

            // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
            // internally
            if ( oSettings.oScroll.bInfinite )
            {
                sStart = oSettings.fnFormatNumber( 1 );
            }

            return str.
                replace(/_START_/g, sStart).
                replace(/_END_/g,   sEnd).
                replace(/_TOTAL_/g, sTotal).
                replace(/_MAX_/g,   sMax);
        }



        /**
         * Draw the table for the first time, adding all required features
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnInitialise ( oSettings )
        {
            var i, iLen, iAjaxStart=oSettings.iInitDisplayStart;

            /* Ensure that the table data is fully initialised */
            if ( oSettings.bInitialised === false )
            {
                setTimeout( function(){ _fnInitialise( oSettings ); }, 200 );
                return;
            }

            /* Show the display HTML options */
            _fnAddOptionsHtml( oSettings );

            /* Build and draw the header / footer for the table */
            _fnBuildHead( oSettings );
            _fnDrawHead( oSettings, oSettings.aoHeader );
            if ( oSettings.nTFoot )
            {
                _fnDrawHead( oSettings, oSettings.aoFooter );
            }

            /* Okay to show that something is going on now */
            _fnProcessingDisplay( oSettings, true );

            /* Calculate sizes for columns */
            if ( oSettings.oFeatures.bAutoWidth )
            {
                _fnCalculateColumnWidths( oSettings );
            }

            for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                if ( oSettings.aoColumns[i].sWidth !== null )
                {
                    oSettings.aoColumns[i].nTh.style.width = _fnStringToCss( oSettings.aoColumns[i].sWidth );
                }
            }

            /* If there is default sorting required - let's do it. The sort function will do the
             * drawing for us. Otherwise we draw the table regardless of the Ajax source - this allows
             * the table to look initialised for Ajax sourcing data (show 'loading' message possibly)
             */
            if ( oSettings.oFeatures.bSort )
            {
                _fnSort( oSettings );
            }
            else if ( oSettings.oFeatures.bFilter )
            {
                _fnFilterComplete( oSettings, oSettings.oPreviousSearch );
            }
            else
            {
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                _fnCalculateEnd( oSettings );
                _fnDraw( oSettings );
            }

            /* if there is an ajax source load the data */
            if ( oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
            {
                var aoData = [];
                _fnServerParams( oSettings, aoData );
                oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData, function(json) {
                    var aData = (oSettings.sAjaxDataProp !== "") ?
                        _fnGetObjectDataFn( oSettings.sAjaxDataProp )(json) : json;

                    /* Got the data - add it to the table */
                    for ( i=0 ; i<aData.length ; i++ )
                    {
                        _fnAddData( oSettings, aData[i] );
                    }

                    /* Reset the init display for cookie saving. We've already done a filter, and
                     * therefore cleared it before. So we need to make it appear 'fresh'
                     */
                    oSettings.iInitDisplayStart = iAjaxStart;

                    if ( oSettings.oFeatures.bSort )
                    {
                        _fnSort( oSettings );
                    }
                    else
                    {
                        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                        _fnCalculateEnd( oSettings );
                        _fnDraw( oSettings );
                    }

                    _fnProcessingDisplay( oSettings, false );
                    _fnInitComplete( oSettings, json );
                }, oSettings );
                return;
            }

            /* Server-side processing initialisation complete is done at the end of _fnDraw */
            if ( !oSettings.oFeatures.bServerSide )
            {
                _fnProcessingDisplay( oSettings, false );
                _fnInitComplete( oSettings );
            }
        }


        /**
         * Draw the table for the first time, adding all required features
         *  @param {object} oSettings dataTables settings object
         *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
         *    with client-side processing (optional)
         *  @memberof DataTable#oApi
         */
        function _fnInitComplete ( oSettings, json )
        {
            oSettings._bInitComplete = true;
            _fnCallbackFire( oSettings, 'aoInitComplete', 'init', [oSettings, json] );
        }


        /**
         * Language compatibility - when certain options are given, and others aren't, we
         * need to duplicate the values over, in order to provide backwards compatibility
         * with older language files.
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnLanguageCompat( oLanguage )
        {
            var oDefaults = DataTable.defaults.oLanguage;

            /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
             * sZeroRecords - assuming that is given.
             */
            if ( !oLanguage.sEmptyTable && oLanguage.sZeroRecords &&
                oDefaults.sEmptyTable === "No data available in table" )
            {
                _fnMap( oLanguage, oLanguage, 'sZeroRecords', 'sEmptyTable' );
            }

            /* Likewise with loading records */
            if ( !oLanguage.sLoadingRecords && oLanguage.sZeroRecords &&
                oDefaults.sLoadingRecords === "Loading..." )
            {
                _fnMap( oLanguage, oLanguage, 'sZeroRecords', 'sLoadingRecords' );
            }
        }



        /**
         * Generate the node required for user display length changing
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Display length feature node
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlLength ( oSettings )
        {
            if ( oSettings.oScroll.bInfinite )
            {
                return null;
            }

            /* This can be overruled by not using the _MENU_ var/macro in the language variable */
            var sName = 'name="'+oSettings.sTableId+'_length"';
            var sStdMenu = '<select size="1" '+sName+'>';
            var i, iLen;
            var aLengthMenu = oSettings.aLengthMenu;

            if ( aLengthMenu.length == 2 && typeof aLengthMenu[0] === 'object' &&
                    typeof aLengthMenu[1] === 'object' )
            {
                for ( i=0, iLen=aLengthMenu[0].length ; i<iLen ; i++ )
                {
                    sStdMenu += '<option value="'+aLengthMenu[0][i]+'">'+aLengthMenu[1][i]+'</option>';
                }
            }
            else
            {
                for ( i=0, iLen=aLengthMenu.length ; i<iLen ; i++ )
                {
                    sStdMenu += '<option value="'+aLengthMenu[i]+'">'+aLengthMenu[i]+'</option>';
                }
            }
            sStdMenu += '</select>';

            var nLength = document.createElement( 'div' );
            if ( !oSettings.aanFeatures.l )
            {
                nLength.id = oSettings.sTableId+'_length';
            }
            nLength.className = oSettings.oClasses.sLength;
            nLength.innerHTML = '<label>'+oSettings.oLanguage.sLengthMenu.replace( '_MENU_', sStdMenu )+'</label>';

            /*
             * Set the length to the current display length - thanks to Andrea Pavlovic for this fix,
             * and Stefan Skopnik for fixing the fix!
             */
            $('select option[value="'+oSettings._iDisplayLength+'"]', nLength).attr("selected", true);

            $('select', nLength).bind( 'change.DT', function(e) {
                var iVal = $(this).val();

                /* Update all other length options for the new display */
                var n = oSettings.aanFeatures.l;
                for ( i=0, iLen=n.length ; i<iLen ; i++ )
                {
                    if ( n[i] != this.parentNode )
                    {
                        $('select', n[i]).val( iVal );
                    }
                }

                /* Redraw the table */
                oSettings._iDisplayLength = parseInt(iVal, 10);
                _fnCalculateEnd( oSettings );

                /* If we have space to show extra rows (backing up from the end point - then do so */
                if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() )
                {
                    oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
                    if ( oSettings._iDisplayStart < 0 )
                    {
                        oSettings._iDisplayStart = 0;
                    }
                }

                if ( oSettings._iDisplayLength == -1 )
                {
                    oSettings._iDisplayStart = 0;
                }

                _fnDraw( oSettings );
            } );


            $('select', nLength).attr('aria-controls', oSettings.sTableId);

            return nLength;
        }


        /**
         * Recalculate the end point based on the start point
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnCalculateEnd( oSettings )
        {
            if ( oSettings.oFeatures.bPaginate === false )
            {
                oSettings._iDisplayEnd = oSettings.aiDisplay.length;
            }
            else
            {
                /* Set the end point of the display - based on how many elements there are
                 * still to display
                 */
                if ( oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length ||
                       oSettings._iDisplayLength == -1 )
                {
                    oSettings._iDisplayEnd = oSettings.aiDisplay.length;
                }
                else
                {
                    oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength;
                }
            }
        }



        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Note that most of the paging logic is done in
         * DataTable.ext.oPagination
         */

        /**
         * Generate the node required for default pagination
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Pagination feature node
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlPaginate ( oSettings )
        {
            if ( oSettings.oScroll.bInfinite )
            {
                return null;
            }

            var nPaginate = document.createElement( 'div' );
            nPaginate.className = oSettings.oClasses.sPaging+oSettings.sPaginationType;

            DataTable.ext.oPagination[ oSettings.sPaginationType ].fnInit( oSettings, nPaginate,
                function( oSettings ) {
                    _fnCalculateEnd( oSettings );
                    _fnDraw( oSettings );
                }
            );

            /* Add a draw callback for the pagination on first instance, to update the paging display */
            if ( !oSettings.aanFeatures.p )
            {
                oSettings.aoDrawCallback.push( {
                    "fn": function( oSettings ) {
                        DataTable.ext.oPagination[ oSettings.sPaginationType ].fnUpdate( oSettings, function( oSettings ) {
                            _fnCalculateEnd( oSettings );
                            _fnDraw( oSettings );
                        } );
                    },
                    "sName": "pagination"
                } );
            }
            return nPaginate;
        }


        /**
         * Alter the display settings to change the page
         *  @param {object} oSettings dataTables settings object
         *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
         *    or page number to jump to (integer)
         *  @returns {bool} true page has changed, false - no change (no effect) eg 'first' on page 1
         *  @memberof DataTable#oApi
         */
        function _fnPageChange ( oSettings, mAction )
        {
            var iOldStart = oSettings._iDisplayStart;

            if ( typeof mAction === "number" )
            {
                oSettings._iDisplayStart = mAction * oSettings._iDisplayLength;
                if ( oSettings._iDisplayStart > oSettings.fnRecordsDisplay() )
                {
                    oSettings._iDisplayStart = 0;
                }
            }
            else if ( mAction == "first" )
            {
                oSettings._iDisplayStart = 0;
            }
            else if ( mAction == "previous" )
            {
                oSettings._iDisplayStart = oSettings._iDisplayLength>=0 ?
                    oSettings._iDisplayStart - oSettings._iDisplayLength :
                    0;

                /* Correct for under-run */
                if ( oSettings._iDisplayStart < 0 )
                {
                  oSettings._iDisplayStart = 0;
                }
            }
            else if ( mAction == "next" )
            {
                if ( oSettings._iDisplayLength >= 0 )
                {
                    /* Make sure we are not over running the display array */
                    if ( oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay() )
                    {
                        oSettings._iDisplayStart += oSettings._iDisplayLength;
                    }
                }
                else
                {
                    oSettings._iDisplayStart = 0;
                }
            }
            else if ( mAction == "last" )
            {
                if ( oSettings._iDisplayLength >= 0 )
                {
                    var iPages = parseInt( (oSettings.fnRecordsDisplay()-1) / oSettings._iDisplayLength, 10 ) + 1;
                    oSettings._iDisplayStart = (iPages-1) * oSettings._iDisplayLength;
                }
                else
                {
                    oSettings._iDisplayStart = 0;
                }
            }
            else
            {
                _fnLog( oSettings, 0, "Unknown paging action: "+mAction );
            }
            $(oSettings.oInstance).trigger('page', oSettings);

            return iOldStart != oSettings._iDisplayStart;
        }



        /**
         * Generate the node required for the processing node
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Processing element
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlProcessing ( oSettings )
        {
            var nProcessing = document.createElement( 'div' );

            if ( !oSettings.aanFeatures.r )
            {
                nProcessing.id = oSettings.sTableId+'_processing';
            }
            nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
            nProcessing.className = oSettings.oClasses.sProcessing;
            oSettings.nTable.parentNode.insertBefore( nProcessing, oSettings.nTable );

            return nProcessing;
        }


        /**
         * Display or hide the processing indicator
         *  @param {object} oSettings dataTables settings object
         *  @param {bool} bShow Show the processing indicator (true) or not (false)
         *  @memberof DataTable#oApi
         */
        function _fnProcessingDisplay ( oSettings, bShow )
        {
            if ( oSettings.oFeatures.bProcessing )
            {
                var an = oSettings.aanFeatures.r;
                for ( var i=0, iLen=an.length ; i<iLen ; i++ )
                {
                    an[i].style.visibility = bShow ? "visible" : "hidden";
                }
            }

            $(oSettings.oInstance).trigger('processing', [oSettings, bShow]);
        }

        /**
         * Add any control elements for the table - specifically scrolling
         *  @param {object} oSettings dataTables settings object
         *  @returns {node} Node to add to the DOM
         *  @memberof DataTable#oApi
         */
        function _fnFeatureHtmlTable ( oSettings )
        {
            /* Check if scrolling is enabled or not - if not then leave the DOM unaltered */
            if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
            {
                return oSettings.nTable;
            }

            /*
             * The HTML structure that we want to generate in this function is:
             *  div - nScroller
             *    div - nScrollHead
             *      div - nScrollHeadInner
             *        table - nScrollHeadTable
             *          thead - nThead
             *    div - nScrollBody
             *      table - oSettings.nTable
             *        thead - nTheadSize
             *        tbody - nTbody
             *    div - nScrollFoot
             *      div - nScrollFootInner
             *        table - nScrollFootTable
             *          tfoot - nTfoot
             */
            var
                nScroller = document.createElement('div'),
                nScrollHead = document.createElement('div'),
                nScrollHeadInner = document.createElement('div'),
                nScrollBody = document.createElement('div'),
                nScrollFoot = document.createElement('div'),
                nScrollFootInner = document.createElement('div'),
                nScrollHeadTable = oSettings.nTable.cloneNode(false),
                nScrollFootTable = oSettings.nTable.cloneNode(false),
                nThead = oSettings.nTable.getElementsByTagName('thead')[0],
                nTfoot = oSettings.nTable.getElementsByTagName('tfoot').length === 0 ? null :
                    oSettings.nTable.getElementsByTagName('tfoot')[0],
                oClasses = oSettings.oClasses;

            nScrollHead.appendChild( nScrollHeadInner );
            nScrollFoot.appendChild( nScrollFootInner );
            nScrollBody.appendChild( oSettings.nTable );
            nScroller.appendChild( nScrollHead );
            nScroller.appendChild( nScrollBody );
            nScrollHeadInner.appendChild( nScrollHeadTable );
            nScrollHeadTable.appendChild( nThead );
            if ( nTfoot !== null )
            {
                nScroller.appendChild( nScrollFoot );
                nScrollFootInner.appendChild( nScrollFootTable );
                nScrollFootTable.appendChild( nTfoot );
            }

            nScroller.className = oClasses.sScrollWrapper;
            nScrollHead.className = oClasses.sScrollHead;
            nScrollHeadInner.className = oClasses.sScrollHeadInner;
            nScrollBody.className = oClasses.sScrollBody;
            nScrollFoot.className = oClasses.sScrollFoot;
            nScrollFootInner.className = oClasses.sScrollFootInner;

            if ( oSettings.oScroll.bAutoCss )
            {
                nScrollHead.style.overflow = "hidden";
                nScrollHead.style.position = "relative";
                nScrollFoot.style.overflow = "hidden";
                nScrollBody.style.overflow = "auto";
            }

            nScrollHead.style.border = "0";
            nScrollHead.style.width = "100%";
            nScrollFoot.style.border = "0";
            nScrollHeadInner.style.width = oSettings.oScroll.sXInner !== "" ?
                oSettings.oScroll.sXInner : "100%"; /* will be overwritten */

            /* Modify attributes to respect the clones */
            nScrollHeadTable.removeAttribute('id');
            nScrollHeadTable.style.marginLeft = "0";
            oSettings.nTable.style.marginLeft = "0";
            if ( nTfoot !== null )
            {
                nScrollFootTable.removeAttribute('id');
                nScrollFootTable.style.marginLeft = "0";
            }

            /* Move caption elements from the body to the header, footer or leave where it is
             * depending on the configuration. Note that the DTD says there can be only one caption */
            var nCaption = $(oSettings.nTable).children('caption');
            if ( nCaption.length > 0 )
            {
                nCaption = nCaption[0];
                if ( nCaption._captionSide === "top" )
                {
                    nScrollHeadTable.appendChild( nCaption );
                }
                else if ( nCaption._captionSide === "bottom" && nTfoot )
                {
                    nScrollFootTable.appendChild( nCaption );
                }
            }

            /*
             * Sizing
             */
            /* When x-scrolling add the width and a scroller to move the header with the body */
            if ( oSettings.oScroll.sX !== "" )
            {
                nScrollHead.style.width = _fnStringToCss( oSettings.oScroll.sX );
                nScrollBody.style.width = _fnStringToCss( oSettings.oScroll.sX );

                if ( nTfoot !== null )
                {
                    nScrollFoot.style.width = _fnStringToCss( oSettings.oScroll.sX );
                }

                /* When the body is scrolled, then we also want to scroll the headers */
                $(nScrollBody).scroll( function (e) {
                    nScrollHead.scrollLeft = this.scrollLeft;

                    if ( nTfoot !== null )
                    {
                        nScrollFoot.scrollLeft = this.scrollLeft;
                    }
                } );
            }

            /* When yscrolling, add the height */
            if ( oSettings.oScroll.sY !== "" )
            {
                nScrollBody.style.height = _fnStringToCss( oSettings.oScroll.sY );
            }

            /* Redraw - align columns across the tables */
            oSettings.aoDrawCallback.push( {
                "fn": _fnScrollDraw,
                "sName": "scrolling"
            } );

            /* Infinite scrolling event handlers */
            if ( oSettings.oScroll.bInfinite )
            {
                $(nScrollBody).scroll( function() {
                    /* Use a blocker to stop scrolling from loading more data while other data is still loading */
                    if ( !oSettings.bDrawing && $(this).scrollTop() !== 0 )
                    {
                        /* Check if we should load the next data set */
                        if ( $(this).scrollTop() + $(this).height() >
                            $(oSettings.nTable).height() - oSettings.oScroll.iLoadGap )
                        {
                            /* Only do the redraw if we have to - we might be at the end of the data */
                            if ( oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay() )
                            {
                                _fnPageChange( oSettings, 'next' );
                                _fnCalculateEnd( oSettings );
                                _fnDraw( oSettings );
                            }
                        }
                    }
                } );
            }

            oSettings.nScrollHead = nScrollHead;
            oSettings.nScrollFoot = nScrollFoot;

            return nScroller;
        }


        /**
         * Update the various tables for resizing. It's a bit of a pig this function, but
         * basically the idea to:
         *   1. Re-create the table inside the scrolling div
         *   2. Take live measurements from the DOM
         *   3. Apply the measurements
         *   4. Clean up
         *  @param {object} o dataTables settings object
         *  @returns {node} Node to add to the DOM
         *  @memberof DataTable#oApi
         */
        function _fnScrollDraw ( o )
        {
            var
                nScrollHeadInner = o.nScrollHead.getElementsByTagName('div')[0],
                nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
                nScrollBody = o.nTable.parentNode,
                i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis,
                nTheadSize, nTfootSize,
                iWidth, aApplied=[], aAppliedFooter=[], iSanityWidth,
                nScrollFootInner = (o.nTFoot !== null) ? o.nScrollFoot.getElementsByTagName('div')[0] : null,
                nScrollFootTable = (o.nTFoot !== null) ? nScrollFootInner.getElementsByTagName('table')[0] : null,
                ie67 = o.oBrowser.bScrollOversize,
                zeroOut = function(nSizer) {
                    oStyle = nSizer.style;
                    oStyle.paddingTop = "0";
                    oStyle.paddingBottom = "0";
                    oStyle.borderTopWidth = "0";
                    oStyle.borderBottomWidth = "0";
                    oStyle.height = 0;
                };

            /*
             * 1. Re-create the table inside the scrolling div
             */

            /* Remove the old minimised thead and tfoot elements in the inner table */
            $(o.nTable).children('thead, tfoot').remove();

            /* Clone the current header and footer elements and then place it into the inner table */
            nTheadSize = $(o.nTHead).clone()[0];
            o.nTable.insertBefore( nTheadSize, o.nTable.childNodes[0] );
            anHeadToSize = o.nTHead.getElementsByTagName('tr');
            anHeadSizers = nTheadSize.getElementsByTagName('tr');

            if ( o.nTFoot !== null )
            {
                nTfootSize = $(o.nTFoot).clone()[0];
                o.nTable.insertBefore( nTfootSize, o.nTable.childNodes[1] );
                anFootToSize = o.nTFoot.getElementsByTagName('tr');
                anFootSizers = nTfootSize.getElementsByTagName('tr');
            }

            /*
             * 2. Take live measurements from the DOM - do not alter the DOM itself!
             */

            /* Remove old sizing and apply the calculated column widths
             * Get the unique column headers in the newly created (cloned) header. We want to apply the
             * calculated sizes to this header
             */
            if ( o.oScroll.sX === "" )
            {
                nScrollBody.style.width = '100%';
                nScrollHeadInner.parentNode.style.width = '100%';
            }

            var nThs = _fnGetUniqueThs( o, nTheadSize );
            for ( i=0, iLen=nThs.length ; i<iLen ; i++ )
            {
                iVis = _fnVisibleToColumnIndex( o, i );
                nThs[i].style.width = o.aoColumns[iVis].sWidth;
            }

            if ( o.nTFoot !== null )
            {
                _fnApplyToChildren( function(n) {
                    n.style.width = "";
                }, anFootSizers );
            }

            // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
            // will end up forcing the scrollbar to appear, making our measurements wrong for when we
            // then hide it (end of this function), so add the header height to the body scroller.
            if ( o.oScroll.bCollapse && o.oScroll.sY !== "" )
            {
                nScrollBody.style.height = (nScrollBody.offsetHeight + o.nTHead.offsetHeight)+"px";
            }

            /* Size the table as a whole */
            iSanityWidth = $(o.nTable).outerWidth();
            if ( o.oScroll.sX === "" )
            {
                /* No x scrolling */
                o.nTable.style.width = "100%";

                /* I know this is rubbish - but IE7 will make the width of the table when 100% include
                 * the scrollbar - which is shouldn't. When there is a scrollbar we need to take this
                 * into account.
                 */
                if ( ie67 && ($('tbody', nScrollBody).height() > nScrollBody.offsetHeight ||
                    $(nScrollBody).css('overflow-y') == "scroll")  )
                {
                    o.nTable.style.width = _fnStringToCss( $(o.nTable).outerWidth() - o.oScroll.iBarWidth);
                }
            }
            else
            {
                if ( o.oScroll.sXInner !== "" )
                {
                    /* x scroll inner has been given - use it */
                    o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner);
                }
                else if ( iSanityWidth == $(nScrollBody).width() &&
                   $(nScrollBody).height() < $(o.nTable).height() )
                {
                    /* There is y-scrolling - try to take account of the y scroll bar */
                    o.nTable.style.width = _fnStringToCss( iSanityWidth-o.oScroll.iBarWidth );
                    if ( $(o.nTable).outerWidth() > iSanityWidth-o.oScroll.iBarWidth )
                    {
                        /* Not possible to take account of it */
                        o.nTable.style.width = _fnStringToCss( iSanityWidth );
                    }
                }
                else
                {
                    /* All else fails */
                    o.nTable.style.width = _fnStringToCss( iSanityWidth );
                }
            }

            /* Recalculate the sanity width - now that we've applied the required width, before it was
             * a temporary variable. This is required because the column width calculation is done
             * before this table DOM is created.
             */
            iSanityWidth = $(o.nTable).outerWidth();

            /* We want the hidden header to have zero height, so remove padding and borders. Then
             * set the width based on the real headers
             */

            // Apply all styles in one pass. Invalidates layout only once because we don't read any
            // DOM properties.
            _fnApplyToChildren( zeroOut, anHeadSizers );

            // Read all widths in next pass. Forces layout only once because we do not change
            // any DOM properties.
            _fnApplyToChildren( function(nSizer) {
                aApplied.push( _fnStringToCss( $(nSizer).width() ) );
            }, anHeadSizers );

            // Apply all widths in final pass. Invalidates layout only once because we do not
            // read any DOM properties.
            _fnApplyToChildren( function(nToSize, i) {
                nToSize.style.width = aApplied[i];
            }, anHeadToSize );

            $(anHeadSizers).height(0);

            /* Same again with the footer if we have one */
            if ( o.nTFoot !== null )
            {
                _fnApplyToChildren( zeroOut, anFootSizers );

                _fnApplyToChildren( function(nSizer) {
                    aAppliedFooter.push( _fnStringToCss( $(nSizer).width() ) );
                }, anFootSizers );

                _fnApplyToChildren( function(nToSize, i) {
                    nToSize.style.width = aAppliedFooter[i];
                }, anFootToSize );

                $(anFootSizers).height(0);
            }

            /*
             * 3. Apply the measurements
             */

            /* "Hide" the header and footer that we used for the sizing. We want to also fix their width
             * to what they currently are
             */
            _fnApplyToChildren( function(nSizer, i) {
                nSizer.innerHTML = "";
                nSizer.style.width = aApplied[i];
            }, anHeadSizers );

            if ( o.nTFoot !== null )
            {
                _fnApplyToChildren( function(nSizer, i) {
                    nSizer.innerHTML = "";
                    nSizer.style.width = aAppliedFooter[i];
                }, anFootSizers );
            }

            /* Sanity check that the table is of a sensible width. If not then we are going to get
             * misalignment - try to prevent this by not allowing the table to shrink below its min width
             */
            if ( $(o.nTable).outerWidth() < iSanityWidth )
            {
                /* The min width depends upon if we have a vertical scrollbar visible or not */
                var iCorrection = ((nScrollBody.scrollHeight > nScrollBody.offsetHeight ||
                    $(nScrollBody).css('overflow-y') == "scroll")) ?
                        iSanityWidth+o.oScroll.iBarWidth : iSanityWidth;

                /* IE6/7 are a law unto themselves... */
                if ( ie67 && (nScrollBody.scrollHeight >
                    nScrollBody.offsetHeight || $(nScrollBody).css('overflow-y') == "scroll")  )
                {
                    o.nTable.style.width = _fnStringToCss( iCorrection-o.oScroll.iBarWidth );
                }

                /* Apply the calculated minimum width to the table wrappers */
                nScrollBody.style.width = _fnStringToCss( iCorrection );
                o.nScrollHead.style.width = _fnStringToCss( iCorrection );

                if ( o.nTFoot !== null )
                {
                    o.nScrollFoot.style.width = _fnStringToCss( iCorrection );
                }

                /* And give the user a warning that we've stopped the table getting too small */
                if ( o.oScroll.sX === "" )
                {
                    _fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
                        " misalignment. The table has been drawn at its minimum possible width." );
                }
                else if ( o.oScroll.sXInner !== "" )
                {
                    _fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
                        " misalignment. Increase the sScrollXInner value or remove it to allow automatic"+
                        " calculation" );
                }
            }
            else
            {
                nScrollBody.style.width = _fnStringToCss( '100%' );
                o.nScrollHead.style.width = _fnStringToCss( '100%' );

                if ( o.nTFoot !== null )
                {
                    o.nScrollFoot.style.width = _fnStringToCss( '100%' );
                }
            }


            /*
             * 4. Clean up
             */
            if ( o.oScroll.sY === "" )
            {
                /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
                 * the scrollbar height from the visible display, rather than adding it on. We need to
                 * set the height in order to sort this. Don't want to do it in any other browsers.
                 */
                if ( ie67 )
                {
                    nScrollBody.style.height = _fnStringToCss( o.nTable.offsetHeight+o.oScroll.iBarWidth );
                }
            }

            if ( o.oScroll.sY !== "" && o.oScroll.bCollapse )
            {
                nScrollBody.style.height = _fnStringToCss( o.oScroll.sY );

                var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ?
                    o.oScroll.iBarWidth : 0;
                if ( o.nTable.offsetHeight < nScrollBody.offsetHeight )
                {
                    nScrollBody.style.height = _fnStringToCss( o.nTable.offsetHeight+iExtra );
                }
            }

            /* Finally set the width's of the header and footer tables */
            var iOuterWidth = $(o.nTable).outerWidth();
            nScrollHeadTable.style.width = _fnStringToCss( iOuterWidth );
            nScrollHeadInner.style.width = _fnStringToCss( iOuterWidth );

            // Figure out if there are scrollbar present - if so then we need a the header and footer to
            // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
            var bScrolling = $(o.nTable).height() > nScrollBody.clientHeight || $(nScrollBody).css('overflow-y') == "scroll";
            nScrollHeadInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth+"px" : "0px";

            if ( o.nTFoot !== null )
            {
                nScrollFootTable.style.width = _fnStringToCss( iOuterWidth );
                nScrollFootInner.style.width = _fnStringToCss( iOuterWidth );
                nScrollFootInner.style.paddingRight = bScrolling ? o.oScroll.iBarWidth+"px" : "0px";
            }

            /* Adjust the position of the header in case we loose the y-scrollbar */
            $(nScrollBody).scroll();

            /* If sorting or filtering has occurred, jump the scrolling back to the top */
            if ( o.bSorted || o.bFiltered )
            {
                nScrollBody.scrollTop = 0;
            }
        }


        /**
         * Apply a given function to the display child nodes of an element array (typically
         * TD children of TR rows
         *  @param {function} fn Method to apply to the objects
         *  @param array {nodes} an1 List of elements to look through for display children
         *  @param array {nodes} an2 Another list (identical structure to the first) - optional
         *  @memberof DataTable#oApi
         */
        function _fnApplyToChildren( fn, an1, an2 )
        {
            var index=0, i=0, iLen=an1.length;
            var nNode1, nNode2;

            while ( i < iLen )
            {
                nNode1 = an1[i].firstChild;
                nNode2 = an2 ? an2[i].firstChild : null;
                while ( nNode1 )
                {
                    if ( nNode1.nodeType === 1 )
                    {
                        if ( an2 )
                        {
                            fn( nNode1, nNode2, index );
                        }
                        else
                        {
                            fn( nNode1, index );
                        }
                        index++;
                    }
                    nNode1 = nNode1.nextSibling;
                    nNode2 = an2 ? nNode2.nextSibling : null;
                }
                i++;
            }
        }

        /**
         * Convert a CSS unit width to pixels (e.g. 2em)
         *  @param {string} sWidth width to be converted
         *  @param {node} nParent parent to get the with for (required for relative widths) - optional
         *  @returns {int} iWidth width in pixels
         *  @memberof DataTable#oApi
         */
        function _fnConvertToWidth ( sWidth, nParent )
        {
            if ( !sWidth || sWidth === null || sWidth === '' )
            {
                return 0;
            }

            if ( !nParent )
            {
                nParent = document.body;
            }

            var iWidth;
            var nTmp = document.createElement( "div" );
            nTmp.style.width = _fnStringToCss( sWidth );

            nParent.appendChild( nTmp );
            iWidth = nTmp.offsetWidth;
            nParent.removeChild( nTmp );

            return ( iWidth );
        }


        /**
         * Calculate the width of columns for the table
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnCalculateColumnWidths ( oSettings )
        {
            var iTableWidth = oSettings.nTable.offsetWidth;
            var iUserInputs = 0;
            var iTmpWidth;
            var iVisibleColumns = 0;
            var iColums = oSettings.aoColumns.length;
            var i, iIndex, iCorrector, iWidth;
            var oHeaders = $('th', oSettings.nTHead);
            var widthAttr = oSettings.nTable.getAttribute('width');
            var nWrapper = oSettings.nTable.parentNode;

            /* Convert any user input sizes into pixel sizes */
            for ( i=0 ; i<iColums ; i++ )
            {
                if ( oSettings.aoColumns[i].bVisible )
                {
                    iVisibleColumns++;

                    if ( oSettings.aoColumns[i].sWidth !== null )
                    {
                        iTmpWidth = _fnConvertToWidth( oSettings.aoColumns[i].sWidthOrig,
                            nWrapper );
                        if ( iTmpWidth !== null )
                        {
                            oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
                        }

                        iUserInputs++;
                    }
                }
            }

            /* If the number of columns in the DOM equals the number that we have to process in
             * DataTables, then we can use the offsets that are created by the web-browser. No custom
             * sizes can be set in order for this to happen, nor scrolling used
             */
            if ( iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums &&
                oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
            {
                for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
                {
                    iTmpWidth = $(oHeaders[i]).width();
                    if ( iTmpWidth !== null )
                    {
                        oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
                    }
                }
            }
            else
            {
                /* Otherwise we are going to have to do some calculations to get the width of each column.
                 * Construct a 1 row table with the widest node in the data, and any user defined widths,
                 * then insert it into the DOM and allow the browser to do all the hard work of
                 * calculating table widths.
                 */
                var
                    nCalcTmp = oSettings.nTable.cloneNode( false ),
                    nTheadClone = oSettings.nTHead.cloneNode(true),
                    nBody = document.createElement( 'tbody' ),
                    nTr = document.createElement( 'tr' ),
                    nDivSizing;

                nCalcTmp.removeAttribute( "id" );
                nCalcTmp.appendChild( nTheadClone );
                if ( oSettings.nTFoot !== null )
                {
                    nCalcTmp.appendChild( oSettings.nTFoot.cloneNode(true) );
                    _fnApplyToChildren( function(n) {
                        n.style.width = "";
                    }, nCalcTmp.getElementsByTagName('tr') );
                }

                nCalcTmp.appendChild( nBody );
                nBody.appendChild( nTr );

                /* Remove any sizing that was previously applied by the styles */
                var jqColSizing = $('thead th', nCalcTmp);
                if ( jqColSizing.length === 0 )
                {
                    jqColSizing = $('tbody tr:eq(0)>td', nCalcTmp);
                }

                /* Apply custom sizing to the cloned header */
                var nThs = _fnGetUniqueThs( oSettings, nTheadClone );
                iCorrector = 0;
                for ( i=0 ; i<iColums ; i++ )
                {
                    var oColumn = oSettings.aoColumns[i];
                    if ( oColumn.bVisible && oColumn.sWidthOrig !== null && oColumn.sWidthOrig !== "" )
                    {
                        nThs[i-iCorrector].style.width = _fnStringToCss( oColumn.sWidthOrig );
                    }
                    else if ( oColumn.bVisible )
                    {
                        nThs[i-iCorrector].style.width = "";
                    }
                    else
                    {
                        iCorrector++;
                    }
                }

                /* Find the biggest td for each column and put it into the table */
                for ( i=0 ; i<iColums ; i++ )
                {
                    if ( oSettings.aoColumns[i].bVisible )
                    {
                        var nTd = _fnGetWidestNode( oSettings, i );
                        if ( nTd !== null )
                        {
                            nTd = nTd.cloneNode(true);
                            if ( oSettings.aoColumns[i].sContentPadding !== "" )
                            {
                                nTd.innerHTML += oSettings.aoColumns[i].sContentPadding;
                            }
                            nTr.appendChild( nTd );
                        }
                    }
                }

                /* Build the table and 'display' it */
                nWrapper.appendChild( nCalcTmp );

                /* When scrolling (X or Y) we want to set the width of the table as appropriate. However,
                 * when not scrolling leave the table width as it is. This results in slightly different,
                 * but I think correct behaviour
                 */
                if ( oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "" )
                {
                    nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner);
                }
                else if ( oSettings.oScroll.sX !== "" )
                {
                    nCalcTmp.style.width = "";
                    if ( $(nCalcTmp).width() < nWrapper.offsetWidth )
                    {
                        nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
                    }
                }
                else if ( oSettings.oScroll.sY !== "" )
                {
                    nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
                }
                else if ( widthAttr )
                {
                    nCalcTmp.style.width = _fnStringToCss( widthAttr );
                }
                nCalcTmp.style.visibility = "hidden";

                /* Scrolling considerations */
                _fnScrollingWidthAdjust( oSettings, nCalcTmp );

                /* Read the width's calculated by the browser and store them for use by the caller. We
                 * first of all try to use the elements in the body, but it is possible that there are
                 * no elements there, under which circumstances we use the header elements
                 */
                var oNodes = $("tbody tr:eq(0)", nCalcTmp).children();
                if ( oNodes.length === 0 )
                {
                    oNodes = _fnGetUniqueThs( oSettings, $('thead', nCalcTmp)[0] );
                }

                /* Browsers need a bit of a hand when a width is assigned to any columns when
                 * x-scrolling as they tend to collapse the table to the min-width, even if
                 * we sent the column widths. So we need to keep track of what the table width
                 * should be by summing the user given values, and the automatic values
                 */
                if ( oSettings.oScroll.sX !== "" )
                {
                    var iTotal = 0;
                    iCorrector = 0;
                    for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
                    {
                        if ( oSettings.aoColumns[i].bVisible )
                        {
                            if ( oSettings.aoColumns[i].sWidthOrig === null )
                            {
                                iTotal += $(oNodes[iCorrector]).outerWidth();
                            }
                            else
                            {
                                iTotal += parseInt(oSettings.aoColumns[i].sWidth.replace('px',''), 10) +
                                    ($(oNodes[iCorrector]).outerWidth() - $(oNodes[iCorrector]).width());
                            }
                            iCorrector++;
                        }
                    }

                    nCalcTmp.style.width = _fnStringToCss( iTotal );
                    oSettings.nTable.style.width = _fnStringToCss( iTotal );
                }

                iCorrector = 0;
                for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
                {
                    if ( oSettings.aoColumns[i].bVisible )
                    {
                        iWidth = $(oNodes[iCorrector]).width();
                        if ( iWidth !== null && iWidth > 0 )
                        {
                            oSettings.aoColumns[i].sWidth = _fnStringToCss( iWidth );
                        }
                        iCorrector++;
                    }
                }

                var cssWidth = $(nCalcTmp).css('width');
                oSettings.nTable.style.width = (cssWidth.indexOf('%') !== -1) ?
                    cssWidth : _fnStringToCss( $(nCalcTmp).outerWidth() );
                nCalcTmp.parentNode.removeChild( nCalcTmp );
            }

            if ( widthAttr )
            {
                oSettings.nTable.style.width = _fnStringToCss( widthAttr );
            }
        }


        /**
         * Adjust a table's width to take account of scrolling
         *  @param {object} oSettings dataTables settings object
         *  @param {node} n table node
         *  @memberof DataTable#oApi
         */
        function _fnScrollingWidthAdjust ( oSettings, n )
        {
            if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "" )
            {
                /* When y-scrolling only, we want to remove the width of the scroll bar so the table
                 * + scroll bar will fit into the area avaialble.
                 */
                var iOrigWidth = $(n).width();
                n.style.width = _fnStringToCss( $(n).outerWidth()-oSettings.oScroll.iBarWidth );
            }
            else if ( oSettings.oScroll.sX !== "" )
            {
                /* When x-scrolling both ways, fix the table at it's current size, without adjusting */
                n.style.width = _fnStringToCss( $(n).outerWidth() );
            }
        }


        /**
         * Get the widest node
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iCol column of interest
         *  @returns {node} widest table node
         *  @memberof DataTable#oApi
         */
        function _fnGetWidestNode( oSettings, iCol )
        {
            var iMaxIndex = _fnGetMaxLenString( oSettings, iCol );
            if ( iMaxIndex < 0 )
            {
                return null;
            }

            if ( oSettings.aoData[iMaxIndex].nTr === null )
            {
                var n = document.createElement('td');
                n.innerHTML = _fnGetCellData( oSettings, iMaxIndex, iCol, '' );
                return n;
            }
            return _fnGetTdNodes(oSettings, iMaxIndex)[iCol];
        }


        /**
         * Get the maximum strlen for each data column
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iCol column of interest
         *  @returns {string} max string length for each column
         *  @memberof DataTable#oApi
         */
        function _fnGetMaxLenString( oSettings, iCol )
        {
            var iMax = -1;
            var iMaxIndex = -1;

            for ( var i=0 ; i<oSettings.aoData.length ; i++ )
            {
                var s = _fnGetCellData( oSettings, i, iCol, 'display' )+"";
                s = s.replace( /<.*?>/g, "" );
                if ( s.length > iMax )
                {
                    iMax = s.length;
                    iMaxIndex = i;
                }
            }

            return iMaxIndex;
        }


        /**
         * Append a CSS unit (only if required) to a string
         *  @param {array} aArray1 first array
         *  @param {array} aArray2 second array
         *  @returns {int} 0 if match, 1 if length is different, 2 if no match
         *  @memberof DataTable#oApi
         */
        function _fnStringToCss( s )
        {
            if ( s === null )
            {
                return "0px";
            }

            if ( typeof s == 'number' )
            {
                if ( s < 0 )
                {
                    return "0px";
                }
                return s+"px";
            }

            /* Check if the last character is not 0-9 */
            var c = s.charCodeAt( s.length-1 );
            if (c < 0x30 || c > 0x39)
            {
                return s;
            }
            return s+"px";
        }


        /**
         * Get the width of a scroll bar in this browser being used
         *  @returns {int} width in pixels
         *  @memberof DataTable#oApi
         */
        function _fnScrollBarWidth ()
        {
            var inner = document.createElement('p');
            var style = inner.style;
            style.width = "100%";
            style.height = "200px";
            style.padding = "0px";

            var outer = document.createElement('div');
            style = outer.style;
            style.position = "absolute";
            style.top = "0px";
            style.left = "0px";
            style.visibility = "hidden";
            style.width = "200px";
            style.height = "150px";
            style.padding = "0px";
            style.overflow = "hidden";
            outer.appendChild(inner);

            document.body.appendChild(outer);
            var w1 = inner.offsetWidth;
            outer.style.overflow = 'scroll';
            var w2 = inner.offsetWidth;
            if ( w1 == w2 )
            {
                w2 = outer.clientWidth;
            }

            document.body.removeChild(outer);
            return (w1 - w2);
        }

        /**
         * Change the order of the table
         *  @param {object} oSettings dataTables settings object
         *  @param {bool} bApplyClasses optional - should we apply classes or not
         *  @memberof DataTable#oApi
         */
        function _fnSort ( oSettings, bApplyClasses )
        {
            var
                i, iLen, j, jLen, k, kLen,
                sDataType, nTh,
                aaSort = [],
                aiOrig = [],
                oSort = DataTable.ext.oSort,
                aoData = oSettings.aoData,
                aoColumns = oSettings.aoColumns,
                oAria = oSettings.oLanguage.oAria;

            /* No sorting required if server-side or no sorting array */
            if ( !oSettings.oFeatures.bServerSide &&
                (oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null) )
            {
                aaSort = ( oSettings.aaSortingFixed !== null ) ?
                    oSettings.aaSortingFixed.concat( oSettings.aaSorting ) :
                    oSettings.aaSorting.slice();

                /* If there is a sorting data type, and a function belonging to it, then we need to
                 * get the data from the developer's function and apply it for this column
                 */
                for ( i=0 ; i<aaSort.length ; i++ )
                {
                    var iColumn = aaSort[i][0];
                    var iVisColumn = _fnColumnIndexToVisible( oSettings, iColumn );
                    sDataType = oSettings.aoColumns[ iColumn ].sSortDataType;
                    if ( DataTable.ext.afnSortData[sDataType] )
                    {
                        var aData = DataTable.ext.afnSortData[sDataType].call(
                            oSettings.oInstance, oSettings, iColumn, iVisColumn
                        );
                        if ( aData.length === aoData.length )
                        {
                            for ( j=0, jLen=aoData.length ; j<jLen ; j++ )
                            {
                                _fnSetCellData( oSettings, j, iColumn, aData[j] );
                            }
                        }
                        else
                        {
                            _fnLog( oSettings, 0, "Returned data sort array (col "+iColumn+") is the wrong length" );
                        }
                    }
                }

                /* Create a value - key array of the current row positions such that we can use their
                 * current position during the sort, if values match, in order to perform stable sorting
                 */
                for ( i=0, iLen=oSettings.aiDisplayMaster.length ; i<iLen ; i++ )
                {
                    aiOrig[ oSettings.aiDisplayMaster[i] ] = i;
                }

                /* Build an internal data array which is specific to the sort, so we can get and prep
                 * the data to be sorted only once, rather than needing to do it every time the sorting
                 * function runs. This make the sorting function a very simple comparison
                 */
                var iSortLen = aaSort.length;
                var fnSortFormat, aDataSort;
                for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
                {
                    for ( j=0 ; j<iSortLen ; j++ )
                    {
                        aDataSort = aoColumns[ aaSort[j][0] ].aDataSort;

                        for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
                        {
                            sDataType = aoColumns[ aDataSort[k] ].sType;
                            fnSortFormat = oSort[ (sDataType ? sDataType : 'string')+"-pre" ];

                            aoData[i]._aSortData[ aDataSort[k] ] = fnSortFormat ?
                                fnSortFormat( _fnGetCellData( oSettings, i, aDataSort[k], 'sort' ) ) :
                                _fnGetCellData( oSettings, i, aDataSort[k], 'sort' );
                        }
                    }
                }

                /* Do the sort - here we want multi-column sorting based on a given data source (column)
                 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
                 * follow on it's own, but this is what we want (example two column sorting):
                 *  fnLocalSorting = function(a,b){
                 *      var iTest;
                 *      iTest = oSort['string-asc']('data11', 'data12');
                 *      if (iTest !== 0)
                 *          return iTest;
                 *    iTest = oSort['numeric-desc']('data21', 'data22');
                 *    if (iTest !== 0)
                 *          return iTest;
                 *      return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
                 *  }
                 * Basically we have a test for each sorting column, if the data in that column is equal,
                 * test the next column. If all columns match, then we use a numeric sort on the row
                 * positions in the original data array to provide a stable sort.
                 */
                oSettings.aiDisplayMaster.sort( function ( a, b ) {
                    var k, l, lLen, iTest, aDataSort, sDataType;
                    for ( k=0 ; k<iSortLen ; k++ )
                    {
                        aDataSort = aoColumns[ aaSort[k][0] ].aDataSort;

                        for ( l=0, lLen=aDataSort.length ; l<lLen ; l++ )
                        {
                            sDataType = aoColumns[ aDataSort[l] ].sType;

                            iTest = oSort[ (sDataType ? sDataType : 'string')+"-"+aaSort[k][1] ](
                                aoData[a]._aSortData[ aDataSort[l] ],
                                aoData[b]._aSortData[ aDataSort[l] ]
                            );

                            if ( iTest !== 0 )
                            {
                                return iTest;
                            }
                        }
                    }

                    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
                } );
            }

            /* Alter the sorting classes to take account of the changes */
            if ( (bApplyClasses === undefined || bApplyClasses) && !oSettings.oFeatures.bDeferRender )
            {
                _fnSortingClasses( oSettings );
            }

            for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                var sTitle = aoColumns[i].sTitle.replace( /<.*?>/g, "" );
                nTh = aoColumns[i].nTh;
                nTh.removeAttribute('aria-sort');
                nTh.removeAttribute('aria-label');

                /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
                if ( aoColumns[i].bSortable )
                {
                    if ( aaSort.length > 0 && aaSort[0][0] == i )
                    {
                        nTh.setAttribute('aria-sort', aaSort[0][1]=="asc" ? "ascending" : "descending" );

                        var nextSort = (aoColumns[i].asSorting[ aaSort[0][2]+1 ]) ?
                            aoColumns[i].asSorting[ aaSort[0][2]+1 ] : aoColumns[i].asSorting[0];
                        nTh.setAttribute('aria-label', sTitle+
                            (nextSort=="asc" ? oAria.sSortAscending : oAria.sSortDescending) );
                    }
                    else
                    {
                        nTh.setAttribute('aria-label', sTitle+
                            (aoColumns[i].asSorting[0]=="asc" ? oAria.sSortAscending : oAria.sSortDescending) );
                    }
                }
                else
                {
                    nTh.setAttribute('aria-label', sTitle);
                }
            }

            /* Tell the draw function that we have sorted the data */
            oSettings.bSorted = true;
            $(oSettings.oInstance).trigger('sort', oSettings);

            /* Copy the master data into the draw array and re-draw */
            if ( oSettings.oFeatures.bFilter )
            {
                /* _fnFilter() will redraw the table for us */
                _fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
            }
            else
            {
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                oSettings._iDisplayStart = 0; /* reset display back to page 0 */
                _fnCalculateEnd( oSettings );
                _fnDraw( oSettings );
            }
        }


        /**
         * Attach a sort handler (click) to a node
         *  @param {object} oSettings dataTables settings object
         *  @param {node} nNode node to attach the handler to
         *  @param {int} iDataIndex column sorting index
         *  @param {function} [fnCallback] callback function
         *  @memberof DataTable#oApi
         */
        function _fnSortAttachListener ( oSettings, nNode, iDataIndex, fnCallback )
        {
            _fnBindAction( nNode, {}, function (e) {
                /* If the column is not sortable - don't to anything */
                if ( oSettings.aoColumns[iDataIndex].bSortable === false )
                {
                    return;
                }

                /*
                 * This is a little bit odd I admit... I declare a temporary function inside the scope of
                 * _fnBuildHead and the click handler in order that the code presented here can be used
                 * twice - once for when bProcessing is enabled, and another time for when it is
                 * disabled, as we need to perform slightly different actions.
                 *   Basically the issue here is that the Javascript engine in modern browsers don't
                 * appear to allow the rendering engine to update the display while it is still executing
                 * it's thread (well - it does but only after long intervals). This means that the
                 * 'processing' display doesn't appear for a table sort. To break the js thread up a bit
                 * I force an execution break by using setTimeout - but this breaks the expected
                 * thread continuation for the end-developer's point of view (their code would execute
                 * too early), so we only do it when we absolutely have to.
                 */
                var fnInnerSorting = function () {
                    var iColumn, iNextSort;

                    /* If the shift key is pressed then we are multiple column sorting */
                    if ( e.shiftKey )
                    {
                        /* Are we already doing some kind of sort on this column? */
                        var bFound = false;
                        for ( var i=0 ; i<oSettings.aaSorting.length ; i++ )
                        {
                            if ( oSettings.aaSorting[i][0] == iDataIndex )
                            {
                                bFound = true;
                                iColumn = oSettings.aaSorting[i][0];
                                iNextSort = oSettings.aaSorting[i][2]+1;

                                if ( !oSettings.aoColumns[iColumn].asSorting[iNextSort] )
                                {
                                    /* Reached the end of the sorting options, remove from multi-col sort */
                                    oSettings.aaSorting.splice( i, 1 );
                                }
                                else
                                {
                                    /* Move onto next sorting direction */
                                    oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                                    oSettings.aaSorting[i][2] = iNextSort;
                                }
                                break;
                            }
                        }

                        /* No sort yet - add it in */
                        if ( bFound === false )
                        {
                            oSettings.aaSorting.push( [ iDataIndex,
                                oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
                        }
                    }
                    else
                    {
                        /* If no shift key then single column sort */
                        if ( oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex )
                        {
                            iColumn = oSettings.aaSorting[0][0];
                            iNextSort = oSettings.aaSorting[0][2]+1;
                            if ( !oSettings.aoColumns[iColumn].asSorting[iNextSort] )
                            {
                                iNextSort = 0;
                            }
                            oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                            oSettings.aaSorting[0][2] = iNextSort;
                        }
                        else
                        {
                            oSettings.aaSorting.splice( 0, oSettings.aaSorting.length );
                            oSettings.aaSorting.push( [ iDataIndex,
                                oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
                        }
                    }

                    /* Run the sort */
                    _fnSort( oSettings );
                }; /* /fnInnerSorting */

                if ( !oSettings.oFeatures.bProcessing )
                {
                    fnInnerSorting();
                }
                else
                {
                    _fnProcessingDisplay( oSettings, true );
                    setTimeout( function() {
                        fnInnerSorting();
                        if ( !oSettings.oFeatures.bServerSide )
                        {
                            _fnProcessingDisplay( oSettings, false );
                        }
                    }, 0 );
                }

                /* Call the user specified callback function - used for async user interaction */
                if ( typeof fnCallback == 'function' )
                {
                    fnCallback( oSettings );
                }
            } );
        }


        /**
         * Set the sorting classes on the header, Note: it is safe to call this function
         * when bSort and bSortClasses are false
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnSortingClasses( oSettings )
        {
            var i, iLen, j, jLen, iFound;
            var aaSort, sClass;
            var iColumns = oSettings.aoColumns.length;
            var oClasses = oSettings.oClasses;

            for ( i=0 ; i<iColumns ; i++ )
            {
                if ( oSettings.aoColumns[i].bSortable )
                {
                    $(oSettings.aoColumns[i].nTh).removeClass( oClasses.sSortAsc +" "+ oClasses.sSortDesc +
                        " "+ oSettings.aoColumns[i].sSortingClass );
                }
            }

            if ( oSettings.aaSortingFixed !== null )
            {
                aaSort = oSettings.aaSortingFixed.concat( oSettings.aaSorting );
            }
            else
            {
                aaSort = oSettings.aaSorting.slice();
            }

            /* Apply the required classes to the header */
            for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
            {
                if ( oSettings.aoColumns[i].bSortable )
                {
                    sClass = oSettings.aoColumns[i].sSortingClass;
                    iFound = -1;
                    for ( j=0 ; j<aaSort.length ; j++ )
                    {
                        if ( aaSort[j][0] == i )
                        {
                            sClass = ( aaSort[j][1] == "asc" ) ?
                                oClasses.sSortAsc : oClasses.sSortDesc;
                            iFound = j;
                            break;
                        }
                    }
                    $(oSettings.aoColumns[i].nTh).addClass( sClass );

                    if ( oSettings.bJUI )
                    {
                        /* jQuery UI uses extra markup */
                        var jqSpan = $("span."+oClasses.sSortIcon,  oSettings.aoColumns[i].nTh);
                        jqSpan.removeClass(oClasses.sSortJUIAsc +" "+ oClasses.sSortJUIDesc +" "+
                            oClasses.sSortJUI +" "+ oClasses.sSortJUIAscAllowed +" "+ oClasses.sSortJUIDescAllowed );

                        var sSpanClass;
                        if ( iFound == -1 )
                        {
                            sSpanClass = oSettings.aoColumns[i].sSortingClassJUI;
                        }
                        else if ( aaSort[iFound][1] == "asc" )
                        {
                            sSpanClass = oClasses.sSortJUIAsc;
                        }
                        else
                        {
                            sSpanClass = oClasses.sSortJUIDesc;
                        }

                        jqSpan.addClass( sSpanClass );
                    }
                }
                else
                {
                    /* No sorting on this column, so add the base class. This will have been assigned by
                     * _fnAddColumn
                     */
                    $(oSettings.aoColumns[i].nTh).addClass( oSettings.aoColumns[i].sSortingClass );
                }
            }

            /*
             * Apply the required classes to the table body
             * Note that this is given as a feature switch since it can significantly slow down a sort
             * on large data sets (adding and removing of classes is always slow at the best of times..)
             * Further to this, note that this code is admittedly fairly ugly. It could be made a lot
             * simpler using jQuery selectors and add/removeClass, but that is significantly slower
             * (on the order of 5 times slower) - hence the direct DOM manipulation here.
             * Note that for deferred drawing we do use jQuery - the reason being that taking the first
             * row found to see if the whole column needs processed can miss classes since the first
             * column might be new.
             */
            sClass = oClasses.sSortColumn;

            if ( oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses )
            {
                var nTds = _fnGetTdNodes( oSettings );

                /* Determine what the sorting class for each column should be */
                var iClass, iTargetCol;
                var asClasses = [];
                for (i = 0; i < iColumns; i++)
                {
                    asClasses.push("");
                }
                for (i = 0, iClass = 1; i < aaSort.length; i++)
                {
                    iTargetCol = parseInt( aaSort[i][0], 10 );
                    asClasses[iTargetCol] = sClass + iClass;

                    if ( iClass < 3 )
                    {
                        iClass++;
                    }
                }

                /* Make changes to the classes for each cell as needed */
                var reClass = new RegExp(sClass + "[123]");
                var sTmpClass, sCurrentClass, sNewClass;
                for ( i=0, iLen=nTds.length; i<iLen; i++ )
                {
                    /* Determine which column we're looking at */
                    iTargetCol = i % iColumns;

                    /* What is the full list of classes now */
                    sCurrentClass = nTds[i].className;
                    /* What sorting class should be applied? */
                    sNewClass = asClasses[iTargetCol];
                    /* What would the new full list be if we did a replacement? */
                    sTmpClass = sCurrentClass.replace(reClass, sNewClass);

                    if ( sTmpClass != sCurrentClass )
                    {
                        /* We changed something */
                        nTds[i].className = $.trim( sTmpClass );
                    }
                    else if ( sNewClass.length > 0 && sCurrentClass.indexOf(sNewClass) == -1 )
                    {
                        /* We need to add a class */
                        nTds[i].className = sCurrentClass + " " + sNewClass;
                    }
                }
            }
        }



        /**
         * Save the state of a table in a cookie such that the page can be reloaded
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnSaveState ( oSettings )
        {
            if ( !oSettings.oFeatures.bStateSave || oSettings.bDestroying )
            {
                return;
            }

            /* Store the interesting variables */
            var i, iLen, bInfinite=oSettings.oScroll.bInfinite;
            var oState = {
                "iCreate":      new Date().getTime(),
                "iStart":       (bInfinite ? 0 : oSettings._iDisplayStart),
                "iEnd":         (bInfinite ? oSettings._iDisplayLength : oSettings._iDisplayEnd),
                "iLength":      oSettings._iDisplayLength,
                "aaSorting":    $.extend( true, [], oSettings.aaSorting ),
                "oSearch":      $.extend( true, {}, oSettings.oPreviousSearch ),
                "aoSearchCols": $.extend( true, [], oSettings.aoPreSearchCols ),
                "abVisCols":    []
            };

            for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
            {
                oState.abVisCols.push( oSettings.aoColumns[i].bVisible );
            }

            _fnCallbackFire( oSettings, "aoStateSaveParams", 'stateSaveParams', [oSettings, oState] );

            oSettings.fnStateSave.call( oSettings.oInstance, oSettings, oState );
        }


        /**
         * Attempt to load a saved table state from a cookie
         *  @param {object} oSettings dataTables settings object
         *  @param {object} oInit DataTables init object so we can override settings
         *  @memberof DataTable#oApi
         */
        function _fnLoadState ( oSettings, oInit )
        {
            if ( !oSettings.oFeatures.bStateSave )
            {
                return;
            }

            var oData = oSettings.fnStateLoad.call( oSettings.oInstance, oSettings );
            if ( !oData )
            {
                return;
            }

            /* Allow custom and plug-in manipulation functions to alter the saved data set and
             * cancelling of loading by returning false
             */
            var abStateLoad = _fnCallbackFire( oSettings, 'aoStateLoadParams', 'stateLoadParams', [oSettings, oData] );
            if ( $.inArray( false, abStateLoad ) !== -1 )
            {
                return;
            }

            /* Store the saved state so it might be accessed at any time */
            oSettings.oLoadedState = $.extend( true, {}, oData );

            /* Restore key features */
            oSettings._iDisplayStart    = oData.iStart;
            oSettings.iInitDisplayStart = oData.iStart;
            oSettings._iDisplayEnd      = oData.iEnd;
            oSettings._iDisplayLength   = oData.iLength;
            oSettings.aaSorting         = oData.aaSorting.slice();
            oSettings.saved_aaSorting   = oData.aaSorting.slice();

            /* Search filtering  */
            $.extend( oSettings.oPreviousSearch, oData.oSearch );
            $.extend( true, oSettings.aoPreSearchCols, oData.aoSearchCols );

            /* Column visibility state
             * Pass back visibility settings to the init handler, but to do not here override
             * the init object that the user might have passed in
             */
            oInit.saved_aoColumns = [];
            for ( var i=0 ; i<oData.abVisCols.length ; i++ )
            {
                oInit.saved_aoColumns[i] = {};
                oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i];
            }

            _fnCallbackFire( oSettings, 'aoStateLoaded', 'stateLoaded', [oSettings, oData] );
        }


        /**
         * Create a new cookie with a value to store the state of a table
         *  @param {string} sName name of the cookie to create
         *  @param {string} sValue the value the cookie should take
         *  @param {int} iSecs duration of the cookie
         *  @param {string} sBaseName sName is made up of the base + file name - this is the base
         *  @param {function} fnCallback User definable function to modify the cookie
         *  @memberof DataTable#oApi
         */
        function _fnCreateCookie ( sName, sValue, iSecs, sBaseName, fnCallback )
        {
            var date = new Date();
            date.setTime( date.getTime()+(iSecs*1000) );

            /*
             * Shocking but true - it would appear IE has major issues with having the path not having
             * a trailing slash on it. We need the cookie to be available based on the path, so we
             * have to append the file name to the cookie name. Appalling. Thanks to vex for adding the
             * patch to use at least some of the path
             */
            var aParts = window.location.pathname.split('/');
            var sNameFile = sName + '_' + aParts.pop().replace(/[\/:]/g,"").toLowerCase();
            var sFullCookie, oData;

            if ( fnCallback !== null )
            {
                oData = (typeof $.parseJSON === 'function') ?
                    $.parseJSON( sValue ) : eval( '('+sValue+')' );
                sFullCookie = fnCallback( sNameFile, oData, date.toGMTString(),
                    aParts.join('/')+"/" );
            }
            else
            {
                sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) +
                    "; expires=" + date.toGMTString() +"; path=" + aParts.join('/')+"/";
            }

            /* Are we going to go over the cookie limit of 4KiB? If so, try to delete a cookies
             * belonging to DataTables.
             */
            var
                aCookies =document.cookie.split(';'),
                iNewCookieLen = sFullCookie.split(';')[0].length,
                aOldCookies = [];

            if ( iNewCookieLen+document.cookie.length+10 > 4096 ) /* Magic 10 for padding */
            {
                for ( var i=0, iLen=aCookies.length ; i<iLen ; i++ )
                {
                    if ( aCookies[i].indexOf( sBaseName ) != -1 )
                    {
                        /* It's a DataTables cookie, so eval it and check the time stamp */
                        var aSplitCookie = aCookies[i].split('=');
                        try {
                            oData = eval( '('+decodeURIComponent(aSplitCookie[1])+')' );

                            if ( oData && oData.iCreate )
                            {
                                aOldCookies.push( {
                                    "name": aSplitCookie[0],
                                    "time": oData.iCreate
                                } );
                            }
                        }
                        catch( e ) {}
                    }
                }

                // Make sure we delete the oldest ones first
                aOldCookies.sort( function (a, b) {
                    return b.time - a.time;
                } );

                // Eliminate as many old DataTables cookies as we need to
                while ( iNewCookieLen + document.cookie.length + 10 > 4096 ) {
                    if ( aOldCookies.length === 0 ) {
                        // Deleted all DT cookies and still not enough space. Can't state save
                        return;
                    }

                    var old = aOldCookies.pop();
                    document.cookie = old.name+"=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path="+
                        aParts.join('/') + "/";
                }
            }

            document.cookie = sFullCookie;
        }


        /**
         * Read an old cookie to get a cookie with an old table state
         *  @param {string} sName name of the cookie to read
         *  @returns {string} contents of the cookie - or null if no cookie with that name found
         *  @memberof DataTable#oApi
         */
        function _fnReadCookie ( sName )
        {
            var
                aParts = window.location.pathname.split('/'),
                sNameEQ = sName + '_' + aParts[aParts.length-1].replace(/[\/:]/g,"").toLowerCase() + '=',
                sCookieContents = document.cookie.split(';');

            for( var i=0 ; i<sCookieContents.length ; i++ )
            {
                var c = sCookieContents[i];

                while (c.charAt(0)==' ')
                {
                    c = c.substring(1,c.length);
                }

                if (c.indexOf(sNameEQ) === 0)
                {
                    return decodeURIComponent( c.substring(sNameEQ.length,c.length) );
                }
            }
            return null;
        }


        /**
         * Return the settings object for a particular table
         *  @param {node} nTable table we are using as a dataTable
         *  @returns {object} Settings object - or null if not found
         *  @memberof DataTable#oApi
         */
        function _fnSettingsFromNode ( nTable )
        {
            for ( var i=0 ; i<DataTable.settings.length ; i++ )
            {
                if ( DataTable.settings[i].nTable === nTable )
                {
                    return DataTable.settings[i];
                }
            }

            return null;
        }


        /**
         * Return an array with the TR nodes for the table
         *  @param {object} oSettings dataTables settings object
         *  @returns {array} TR array
         *  @memberof DataTable#oApi
         */
        function _fnGetTrNodes ( oSettings )
        {
            var aNodes = [];
            var aoData = oSettings.aoData;
            for ( var i=0, iLen=aoData.length ; i<iLen ; i++ )
            {
                if ( aoData[i].nTr !== null )
                {
                    aNodes.push( aoData[i].nTr );
                }
            }
            return aNodes;
        }


        /**
         * Return an flat array with all TD nodes for the table, or row
         *  @param {object} oSettings dataTables settings object
         *  @param {int} [iIndividualRow] aoData index to get the nodes for - optional
         *    if not given then the return array will contain all nodes for the table
         *  @returns {array} TD array
         *  @memberof DataTable#oApi
         */
        function _fnGetTdNodes ( oSettings, iIndividualRow )
        {
            var anReturn = [];
            var iCorrector;
            var anTds, nTd;
            var iRow, iRows=oSettings.aoData.length,
                iColumn, iColumns, oData, sNodeName, iStart=0, iEnd=iRows;

            /* Allow the collection to be limited to just one row */
            if ( iIndividualRow !== undefined )
            {
                iStart = iIndividualRow;
                iEnd = iIndividualRow+1;
            }

            for ( iRow=iStart ; iRow<iEnd ; iRow++ )
            {
                oData = oSettings.aoData[iRow];
                if ( oData.nTr !== null )
                {
                    /* get the TD child nodes - taking into account text etc nodes */
                    anTds = [];
                    nTd = oData.nTr.firstChild;
                    while ( nTd )
                    {
                        sNodeName = nTd.nodeName.toLowerCase();
                        if ( sNodeName == 'td' || sNodeName == 'th' )
                        {
                            anTds.push( nTd );
                        }
                        nTd = nTd.nextSibling;
                    }

                    iCorrector = 0;
                    for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
                    {
                        if ( oSettings.aoColumns[iColumn].bVisible )
                        {
                            anReturn.push( anTds[iColumn-iCorrector] );
                        }
                        else
                        {
                            anReturn.push( oData._anHidden[iColumn] );
                            iCorrector++;
                        }
                    }
                }
            }

            return anReturn;
        }


        /**
         * Log an error message
         *  @param {object} oSettings dataTables settings object
         *  @param {int} iLevel log error messages, or display them to the user
         *  @param {string} sMesg error message
         *  @memberof DataTable#oApi
         */
        function _fnLog( oSettings, iLevel, sMesg )
        {
            var sAlert = (oSettings===null) ?
                "DataTables warning: "+sMesg :
                "DataTables warning (table id = '"+oSettings.sTableId+"'): "+sMesg;

            if ( iLevel === 0 )
            {
                if ( DataTable.ext.sErrMode == 'alert' )
                {
                    alert( sAlert );
                }
                else
                {
                    throw new Error(sAlert);
                }
                return;
            }
            else if ( window.console && console.log )
            {
                console.log( sAlert );
            }
        }


        /**
         * See if a property is defined on one object, if so assign it to the other object
         *  @param {object} oRet target object
         *  @param {object} oSrc source object
         *  @param {string} sName property
         *  @param {string} [sMappedName] name to map too - optional, sName used if not given
         *  @memberof DataTable#oApi
         */
        function _fnMap( oRet, oSrc, sName, sMappedName )
        {
            if ( sMappedName === undefined )
            {
                sMappedName = sName;
            }
            if ( oSrc[sName] !== undefined )
            {
                oRet[sMappedName] = oSrc[sName];
            }
        }


        /**
         * Extend objects - very similar to jQuery.extend, but deep copy objects, and shallow
         * copy arrays. The reason we need to do this, is that we don't want to deep copy array
         * init values (such as aaSorting) since the dev wouldn't be able to override them, but
         * we do want to deep copy arrays.
         *  @param {object} oOut Object to extend
         *  @param {object} oExtender Object from which the properties will be applied to oOut
         *  @returns {object} oOut Reference, just for convenience - oOut === the return.
         *  @memberof DataTable#oApi
         *  @todo This doesn't take account of arrays inside the deep copied objects.
         */
        function _fnExtend( oOut, oExtender )
        {
            var val;

            for ( var prop in oExtender )
            {
                if ( oExtender.hasOwnProperty(prop) )
                {
                    val = oExtender[prop];

                    if ( typeof oInit[prop] === 'object' && val !== null && $.isArray(val) === false )
                    {
                        $.extend( true, oOut[prop], val );
                    }
                    else
                    {
                        oOut[prop] = val;
                    }
                }
            }

            return oOut;
        }


        /**
         * Bind an event handers to allow a click or return key to activate the callback.
         * This is good for accessibility since a return on the keyboard will have the
         * same effect as a click, if the element has focus.
         *  @param {element} n Element to bind the action to
         *  @param {object} oData Data object to pass to the triggered function
         *  @param {function} fn Callback function for when the event is triggered
         *  @memberof DataTable#oApi
         */
        function _fnBindAction( n, oData, fn )
        {
            $(n)
                .bind( 'click.DT', oData, function (e) {
                        n.blur(); // Remove focus outline for mouse users
                        fn(e);
                    } )
                .bind( 'keypress.DT', oData, function (e){
                    if ( e.which === 13 ) {
                        fn(e);
                    } } )
                .bind( 'selectstart.DT', function () {
                    /* Take the brutal approach to cancelling text selection */
                    return false;
                    } );
        }


        /**
         * Register a callback function. Easily allows a callback function to be added to
         * an array store of callback functions that can then all be called together.
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sStore Name of the array storage for the callbacks in oSettings
         *  @param {function} fn Function to be called back
         *  @param {string} sName Identifying name for the callback (i.e. a label)
         *  @memberof DataTable#oApi
         */
        function _fnCallbackReg( oSettings, sStore, fn, sName )
        {
            if ( fn )
            {
                oSettings[sStore].push( {
                    "fn": fn,
                    "sName": sName
                } );
            }
        }


        /**
         * Fire callback functions and trigger events. Note that the loop over the callback
         * array store is done backwards! Further note that you do not want to fire off triggers
         * in time sensitive applications (for example cell creation) as its slow.
         *  @param {object} oSettings dataTables settings object
         *  @param {string} sStore Name of the array storage for the callbacks in oSettings
         *  @param {string} sTrigger Name of the jQuery custom event to trigger. If null no trigger
         *    is fired
         *  @param {array} aArgs Array of arguments to pass to the callback function / trigger
         *  @memberof DataTable#oApi
         */
        function _fnCallbackFire( oSettings, sStore, sTrigger, aArgs )
        {
            var aoStore = oSettings[sStore];
            var aRet =[];

            for ( var i=aoStore.length-1 ; i>=0 ; i-- )
            {
                aRet.push( aoStore[i].fn.apply( oSettings.oInstance, aArgs ) );
            }

            if ( sTrigger !== null )
            {
                $(oSettings.oInstance).trigger(sTrigger, aArgs);
            }

            return aRet;
        }


        /**
         * JSON stringify. If JSON.stringify it provided by the browser, json2.js or any other
         * library, then we use that as it is fast, safe and accurate. If the function isn't
         * available then we need to built it ourselves - the inspiration for this function comes
         * from Craig Buckler ( http://www.sitepoint.com/javascript-json-serialization/ ). It is
         * not perfect and absolutely should not be used as a replacement to json2.js - but it does
         * do what we need, without requiring a dependency for DataTables.
         *  @param {object} o JSON object to be converted
         *  @returns {string} JSON string
         *  @memberof DataTable#oApi
         */
        var _fnJsonString = (window.JSON) ? JSON.stringify : function( o )
        {
            /* Not an object or array */
            var sType = typeof o;
            if (sType !== "object" || o === null)
            {
                // simple data type
                if (sType === "string")
                {
                    o = '"'+o+'"';
                }
                return o+"";
            }

            /* If object or array, need to recurse over it */
            var
                sProp, mValue,
                json = [],
                bArr = $.isArray(o);

            for (sProp in o)
            {
                mValue = o[sProp];
                sType = typeof mValue;

                if (sType === "string")
                {
                    mValue = '"'+mValue+'"';
                }
                else if (sType === "object" && mValue !== null)
                {
                    mValue = _fnJsonString(mValue);
                }

                json.push((bArr ? "" : '"'+sProp+'":') + mValue);
            }

            return (bArr ? "[" : "{") + json + (bArr ? "]" : "}");
        };


        /**
         * From some browsers (specifically IE6/7) we need special handling to work around browser
         * bugs - this function is used to detect when these workarounds are needed.
         *  @param {object} oSettings dataTables settings object
         *  @memberof DataTable#oApi
         */
        function _fnBrowserDetect( oSettings )
        {
            /* IE6/7 will oversize a width 100% element inside a scrolling element, to include the
             * width of the scrollbar, while other browsers ensure the inner element is contained
             * without forcing scrolling
             */
            var n = $(
                '<div style="position:absolute; top:0; left:0; height:1px; width:1px; overflow:hidden">'+
                    '<div style="position:absolute; top:1px; left:1px; width:100px; overflow:scroll;">'+
                        '<div id="DT_BrowserTest" style="width:100%; height:10px;"></div>'+
                    '</div>'+
                '</div>')[0];

            document.body.appendChild( n );
            oSettings.oBrowser.bScrollOversize = $('#DT_BrowserTest', n)[0].offsetWidth === 100 ? true : false;
            document.body.removeChild( n );
        }


        /**
         * Perform a jQuery selector action on the table's TR elements (from the tbody) and
         * return the resulting jQuery object.
         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
         *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
         *    criterion ("applied") or all TR elements (i.e. no filter).
         *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
         *    Can be either 'current', whereby the current sorting of the table is used, or
         *    'original' whereby the original order the data was read into the table is used.
         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
         *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
         *    'current' and filter is 'applied', regardless of what they might be given as.
         *  @returns {object} jQuery object, filtered by the given selector.
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Highlight every second row
         *      oTable.$('tr:odd').css('backgroundColor', 'blue');
         *    } );
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Filter to rows with 'Webkit' in them, add a background colour and then
         *      // remove the filter, thus highlighting the 'Webkit' rows only.
         *      oTable.fnFilter('Webkit');
         *      oTable.$('tr', {"filter": "applied"}).css('backgroundColor', 'blue');
         *      oTable.fnFilter('');
         *    } );
         */
        this.$ = function ( sSelector, oOpts )
        {
            var i, iLen, a = [], tr;
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var aoData = oSettings.aoData;
            var aiDisplay = oSettings.aiDisplay;
            var aiDisplayMaster = oSettings.aiDisplayMaster;

            if ( !oOpts )
            {
                oOpts = {};
            }

            oOpts = $.extend( {}, {
                "filter": "none", // applied
                "order": "current", // "original"
                "page": "all" // current
            }, oOpts );

            // Current page implies that order=current and fitler=applied, since it is fairly
            // senseless otherwise
            if ( oOpts.page == 'current' )
            {
                for ( i=oSettings._iDisplayStart, iLen=oSettings.fnDisplayEnd() ; i<iLen ; i++ )
                {
                    tr = aoData[ aiDisplay[i] ].nTr;
                    if ( tr )
                    {
                        a.push( tr );
                    }
                }
            }
            else if ( oOpts.order == "current" && oOpts.filter == "none" )
            {
                for ( i=0, iLen=aiDisplayMaster.length ; i<iLen ; i++ )
                {
                    tr = aoData[ aiDisplayMaster[i] ].nTr;
                    if ( tr )
                    {
                        a.push( tr );
                    }
                }
            }
            else if ( oOpts.order == "current" && oOpts.filter == "applied" )
            {
                for ( i=0, iLen=aiDisplay.length ; i<iLen ; i++ )
                {
                    tr = aoData[ aiDisplay[i] ].nTr;
                    if ( tr )
                    {
                        a.push( tr );
                    }
                }
            }
            else if ( oOpts.order == "original" && oOpts.filter == "none" )
            {
                for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
                {
                    tr = aoData[ i ].nTr ;
                    if ( tr )
                    {
                        a.push( tr );
                    }
                }
            }
            else if ( oOpts.order == "original" && oOpts.filter == "applied" )
            {
                for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
                {
                    tr = aoData[ i ].nTr;
                    if ( $.inArray( i, aiDisplay ) !== -1 && tr )
                    {
                        a.push( tr );
                    }
                }
            }
            else
            {
                _fnLog( oSettings, 1, "Unknown selection options" );
            }

            /* We need to filter on the TR elements and also 'find' in their descendants
             * to make the selector act like it would in a full table - so we need
             * to build both results and then combine them together
             */
            var jqA = $(a);
            var jqTRs = jqA.filter( sSelector );
            var jqDescendants = jqA.find( sSelector );

            return $( [].concat($.makeArray(jqTRs), $.makeArray(jqDescendants)) );
        };


        /**
         * Almost identical to $ in operation, but in this case returns the data for the matched
         * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
         * rather than any descendants, so the data can be obtained for the row/cell. If matching
         * rows are found, the data returned is the original data array/object that was used to
         * create the row (or a generated array if from a DOM source).
         *
         * This method is often useful in-combination with $ where both functions are given the
         * same parameters and the array indexes will match identically.
         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
         *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
         *    criterion ("applied") or all elements (i.e. no filter).
         *  @param {string} [oOpts.order=current] Order of the data in the processed array.
         *    Can be either 'current', whereby the current sorting of the table is used, or
         *    'original' whereby the original order the data was read into the table is used.
         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
         *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
         *    'current' and filter is 'applied', regardless of what they might be given as.
         *  @returns {array} Data for the matched elements. If any elements, as a result of the
         *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
         *    entry in the array.
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Get the data from the first row in the table
         *      var data = oTable._('tr:first');
         *
         *      // Do something useful with the data
         *      alert( "First cell is: "+data[0] );
         *    } );
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Filter to 'Webkit' and get all data for
         *      oTable.fnFilter('Webkit');
         *      var data = oTable._('tr', {"filter": "applied"});
         *
         *      // Do something with the data
         *      alert( data.length+" rows matched the filter" );
         *    } );
         */
        this._ = function ( sSelector, oOpts )
        {
            var aOut = [];
            var i, iLen, iIndex;
            var aTrs = this.$( sSelector, oOpts );

            for ( i=0, iLen=aTrs.length ; i<iLen ; i++ )
            {
                aOut.push( this.fnGetData(aTrs[i]) );
            }

            return aOut;
        };


        /**
         * Add a single new row or multiple rows of data to the table. Please note
         * that this is suitable for client-side processing only - if you are using
         * server-side processing (i.e. "bServerSide": true), then to add data, you
         * must add it to the data source, i.e. the server-side, through an Ajax call.
         *  @param {array|object} mData The data to be added to the table. This can be:
         *    <ul>
         *      <li>1D array of data - add a single row with the data provided</li>
         *      <li>2D array of arrays - add multiple rows in a single call</li>
         *      <li>object - data object when using <i>mData</i></li>
         *      <li>array of objects - multiple data objects when using <i>mData</i></li>
         *    </ul>
         *  @param {bool} [bRedraw=true] redraw the table or not
         *  @returns {array} An array of integers, representing the list of indexes in
         *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
         *    the table.
         *  @dtopt API
         *
         *  @example
         *    // Global var for counter
         *    var giCount = 2;
         *
         *    $(document).ready(function() {
         *      $('#example').dataTable();
         *    } );
         *
         *    function fnClickAddRow() {
         *      $('#example').dataTable().fnAddData( [
         *        giCount+".1",
         *        giCount+".2",
         *        giCount+".3",
         *        giCount+".4" ]
         *      );
         *
         *      giCount++;
         *    }
         */
        this.fnAddData = function( mData, bRedraw )
        {
            if ( mData.length === 0 )
            {
                return [];
            }

            var aiReturn = [];
            var iTest;

            /* Find settings from table node */
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

            /* Check if we want to add multiple rows or not */
            if ( typeof mData[0] === "object" && mData[0] !== null )
            {
                for ( var i=0 ; i<mData.length ; i++ )
                {
                    iTest = _fnAddData( oSettings, mData[i] );
                    if ( iTest == -1 )
                    {
                        return aiReturn;
                    }
                    aiReturn.push( iTest );
                }
            }
            else
            {
                iTest = _fnAddData( oSettings, mData );
                if ( iTest == -1 )
                {
                    return aiReturn;
                }
                aiReturn.push( iTest );
            }

            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

            if ( bRedraw === undefined || bRedraw )
            {
                _fnReDraw( oSettings );
            }
            return aiReturn;
        };


        /**
         * This function will make DataTables recalculate the column sizes, based on the data
         * contained in the table and the sizes applied to the columns (in the DOM, CSS or
         * through the sWidth parameter). This can be useful when the width of the table's
         * parent element changes (for example a window resize).
         *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable( {
         *        "sScrollY": "200px",
         *        "bPaginate": false
         *      } );
         *
         *      $(window).bind('resize', function () {
         *        oTable.fnAdjustColumnSizing();
         *      } );
         *    } );
         */
        this.fnAdjustColumnSizing = function ( bRedraw )
        {
            var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
            _fnAdjustColumnSizing( oSettings );

            if ( bRedraw === undefined || bRedraw )
            {
                this.fnDraw( false );
            }
            else if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
            {
                /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
                this.oApi._fnScrollDraw(oSettings);
            }
        };


        /**
         * Quickly and simply clear a table
         *  @param {bool} [bRedraw=true] redraw the table or not
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
         *      oTable.fnClearTable();
         *    } );
         */
        this.fnClearTable = function( bRedraw )
        {
            /* Find settings from table node */
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            _fnClearTable( oSettings );

            if ( bRedraw === undefined || bRedraw )
            {
                _fnDraw( oSettings );
            }
        };


        /**
         * The exact opposite of 'opening' a row, this function will close any rows which
         * are currently 'open'.
         *  @param {node} nTr the table row to 'close'
         *  @returns {int} 0 on success, or 1 if failed (can't find the row)
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable;
         *
         *      // 'open' an information row when a row is clicked on
         *      $('#example tbody tr').click( function () {
         *        if ( oTable.fnIsOpen(this) ) {
         *          oTable.fnClose( this );
         *        } else {
         *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
         *        }
         *      } );
         *
         *      oTable = $('#example').dataTable();
         *    } );
         */
        this.fnClose = function( nTr )
        {
            /* Find settings from table node */
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

            for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
            {
                if ( oSettings.aoOpenRows[i].nParent == nTr )
                {
                    var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
                    if ( nTrParent )
                    {
                        /* Remove it if it is currently on display */
                        nTrParent.removeChild( oSettings.aoOpenRows[i].nTr );
                    }
                    oSettings.aoOpenRows.splice( i, 1 );
                    return 0;
                }
            }
            return 1;
        };


        /**
         * Remove a row for the table
         *  @param {mixed} mTarget The index of the row from aoData to be deleted, or
         *    the TR element you want to delete
         *  @param {function|null} [fnCallBack] Callback function
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @returns {array} The row that was deleted
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Immediately remove the first row
         *      oTable.fnDeleteRow( 0 );
         *    } );
         */
        this.fnDeleteRow = function( mTarget, fnCallBack, bRedraw )
        {
            /* Find settings from table node */
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var i, iLen, iAODataIndex;

            iAODataIndex = (typeof mTarget === 'object') ?
                _fnNodeToDataIndex(oSettings, mTarget) : mTarget;

            /* Return the data array from this row */
            var oData = oSettings.aoData.splice( iAODataIndex, 1 );

            /* Update the _DT_RowIndex parameter */
            for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
            {
                if ( oSettings.aoData[i].nTr !== null )
                {
                    oSettings.aoData[i].nTr._DT_RowIndex = i;
                }
            }

            /* Remove the target row from the search array */
            var iDisplayIndex = $.inArray( iAODataIndex, oSettings.aiDisplay );
            oSettings.asDataSearch.splice( iDisplayIndex, 1 );

            /* Delete from the display arrays */
            _fnDeleteIndex( oSettings.aiDisplayMaster, iAODataIndex );
            _fnDeleteIndex( oSettings.aiDisplay, iAODataIndex );

            /* If there is a user callback function - call it */
            if ( typeof fnCallBack === "function" )
            {
                fnCallBack.call( this, oSettings, oData );
            }

            /* Check for an 'overflow' they case for displaying the table */
            if ( oSettings._iDisplayStart >= oSettings.fnRecordsDisplay() )
            {
                oSettings._iDisplayStart -= oSettings._iDisplayLength;
                if ( oSettings._iDisplayStart < 0 )
                {
                    oSettings._iDisplayStart = 0;
                }
            }

            if ( bRedraw === undefined || bRedraw )
            {
                _fnCalculateEnd( oSettings );
                _fnDraw( oSettings );
            }

            return oData;
        };


        /**
         * Restore the table to it's original state in the DOM by removing all of DataTables
         * enhancements, alterations to the DOM structure of the table and event listeners.
         *  @param {boolean} [bRemove=false] Completely remove the table from the DOM
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
         *      var oTable = $('#example').dataTable();
         *      oTable.fnDestroy();
         *    } );
         */
        this.fnDestroy = function ( bRemove )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var nOrig = oSettings.nTableWrapper.parentNode;
            var nBody = oSettings.nTBody;
            var i, iLen;

            bRemove = (bRemove===undefined) ? false : bRemove;

            /* Flag to note that the table is currently being destroyed - no action should be taken */
            oSettings.bDestroying = true;

            /* Fire off the destroy callbacks for plug-ins etc */
            _fnCallbackFire( oSettings, "aoDestroyCallback", "destroy", [oSettings] );

            /* If the table is not being removed, restore the hidden columns */
            if ( !bRemove )
            {
                for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
                {
                    if ( oSettings.aoColumns[i].bVisible === false )
                    {
                        this.fnSetColumnVis( i, true );
                    }
                }
            }

            /* Blitz all DT events */
            $(oSettings.nTableWrapper).find('*').andSelf().unbind('.DT');

            /* If there is an 'empty' indicator row, remove it */
            $('tbody>tr>td.'+oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();

            /* When scrolling we had to break the table up - restore it */
            if ( oSettings.nTable != oSettings.nTHead.parentNode )
            {
                $(oSettings.nTable).children('thead').remove();
                oSettings.nTable.appendChild( oSettings.nTHead );
            }

            if ( oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode )
            {
                $(oSettings.nTable).children('tfoot').remove();
                oSettings.nTable.appendChild( oSettings.nTFoot );
            }

            /* Remove the DataTables generated nodes, events and classes */
            oSettings.nTable.parentNode.removeChild( oSettings.nTable );
            $(oSettings.nTableWrapper).remove();

            oSettings.aaSorting = [];
            oSettings.aaSortingFixed = [];
            _fnSortingClasses( oSettings );

            $(_fnGetTrNodes( oSettings )).removeClass( oSettings.asStripeClasses.join(' ') );

            $('th, td', oSettings.nTHead).removeClass( [
                oSettings.oClasses.sSortable,
                oSettings.oClasses.sSortableAsc,
                oSettings.oClasses.sSortableDesc,
                oSettings.oClasses.sSortableNone ].join(' ')
            );
            if ( oSettings.bJUI )
            {
                $('th span.'+oSettings.oClasses.sSortIcon
                    + ', td span.'+oSettings.oClasses.sSortIcon, oSettings.nTHead).remove();

                $('th, td', oSettings.nTHead).each( function () {
                    var jqWrapper = $('div.'+oSettings.oClasses.sSortJUIWrapper, this);
                    var kids = jqWrapper.contents();
                    $(this).append( kids );
                    jqWrapper.remove();
                } );
            }

            /* Add the TR elements back into the table in their original order */
            if ( !bRemove && oSettings.nTableReinsertBefore )
            {
                nOrig.insertBefore( oSettings.nTable, oSettings.nTableReinsertBefore );
            }
            else if ( !bRemove )
            {
                nOrig.appendChild( oSettings.nTable );
            }

            for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
            {
                if ( oSettings.aoData[i].nTr !== null )
                {
                    nBody.appendChild( oSettings.aoData[i].nTr );
                }
            }

            /* Restore the width of the original table */
            if ( oSettings.oFeatures.bAutoWidth === true )
            {
              oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth);
            }

            /* If the were originally stripe classes - then we add them back here. Note
             * this is not fool proof (for example if not all rows had stripe classes - but
             * it's a good effort without getting carried away
             */
            iLen = oSettings.asDestroyStripes.length;
            if (iLen)
            {
                var anRows = $(nBody).children('tr');
                for ( i=0 ; i<iLen ; i++ )
                {
                    anRows.filter(':nth-child(' + iLen + 'n + ' + i + ')').addClass( oSettings.asDestroyStripes[i] );
                }
            }

            /* Remove the settings object from the settings array */
            for ( i=0, iLen=DataTable.settings.length ; i<iLen ; i++ )
            {
                if ( DataTable.settings[i] == oSettings )
                {
                    DataTable.settings.splice( i, 1 );
                }
            }

            /* End it all */
            oSettings = null;
            oInit = null;
        };


        /**
         * Redraw the table
         *  @param {bool} [bComplete=true] Re-filter and resort (if enabled) the table before the draw.
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
         *      oTable.fnDraw();
         *    } );
         */
        this.fnDraw = function( bComplete )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            if ( bComplete === false )
            {
                _fnCalculateEnd( oSettings );
                _fnDraw( oSettings );
            }
            else
            {
                _fnReDraw( oSettings );
            }
        };


        /**
         * Filter the input based on data
         *  @param {string} sInput String to filter the table on
         *  @param {int|null} [iColumn] Column to limit filtering to
         *  @param {bool} [bRegex=false] Treat as regular expression or not
         *  @param {bool} [bSmart=true] Perform smart filtering or not
         *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
         *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Sometime later - filter...
         *      oTable.fnFilter( 'test string' );
         *    } );
         */
        this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

            if ( !oSettings.oFeatures.bFilter )
            {
                return;
            }

            if ( bRegex === undefined || bRegex === null )
            {
                bRegex = false;
            }

            if ( bSmart === undefined || bSmart === null )
            {
                bSmart = true;
            }

            if ( bShowGlobal === undefined || bShowGlobal === null )
            {
                bShowGlobal = true;
            }

            if ( bCaseInsensitive === undefined || bCaseInsensitive === null )
            {
                bCaseInsensitive = true;
            }

            if ( iColumn === undefined || iColumn === null )
            {
                /* Global filter */
                _fnFilterComplete( oSettings, {
                    "sSearch":sInput+"",
                    "bRegex": bRegex,
                    "bSmart": bSmart,
                    "bCaseInsensitive": bCaseInsensitive
                }, 1 );

                if ( bShowGlobal && oSettings.aanFeatures.f )
                {
                    var n = oSettings.aanFeatures.f;
                    for ( var i=0, iLen=n.length ; i<iLen ; i++ )
                    {
                        // IE9 throws an 'unknown error' if document.activeElement is used
                        // inside an iframe or frame...
                        try {
                            if ( n[i]._DT_Input != document.activeElement )
                            {
                                $(n[i]._DT_Input).val( sInput );
                            }
                        }
                        catch ( e ) {
                            $(n[i]._DT_Input).val( sInput );
                        }
                    }
                }
            }
            else
            {
                /* Single column filter */
                $.extend( oSettings.aoPreSearchCols[ iColumn ], {
                    "sSearch": sInput+"",
                    "bRegex": bRegex,
                    "bSmart": bSmart,
                    "bCaseInsensitive": bCaseInsensitive
                } );
                _fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
            }
        };


        /**
         * Get the data for the whole table, an individual row or an individual cell based on the
         * provided parameters.
         *  @param {int|node} [mRow] A TR row node, TD/TH cell node or an integer. If given as
         *    a TR node then the data source for the whole row will be returned. If given as a
         *    TD/TH cell node then iCol will be automatically calculated and the data for the
         *    cell returned. If given as an integer, then this is treated as the aoData internal
         *    data index for the row (see fnGetPosition) and the data for that row used.
         *  @param {int} [iCol] Optional column index that you want the data of.
         *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
         *    returned. If mRow is defined, just data for that row, and is iCol is
         *    defined, only data for the designated cell is returned.
         *  @dtopt API
         *
         *  @example
         *    // Row data
         *    $(document).ready(function() {
         *      oTable = $('#example').dataTable();
         *
         *      oTable.$('tr').click( function () {
         *        var data = oTable.fnGetData( this );
         *        // ... do something with the array / object of data for the row
         *      } );
         *    } );
         *
         *  @example
         *    // Individual cell data
         *    $(document).ready(function() {
         *      oTable = $('#example').dataTable();
         *
         *      oTable.$('td').click( function () {
         *        var sData = oTable.fnGetData( this );
         *        alert( 'The cell clicked on had the value of '+sData );
         *      } );
         *    } );
         */
        this.fnGetData = function( mRow, iCol )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

            if ( mRow !== undefined )
            {
                var iRow = mRow;
                if ( typeof mRow === 'object' )
                {
                    var sNode = mRow.nodeName.toLowerCase();
                    if (sNode === "tr" )
                    {
                        iRow = _fnNodeToDataIndex(oSettings, mRow);
                    }
                    else if ( sNode === "td" )
                    {
                        iRow = _fnNodeToDataIndex(oSettings, mRow.parentNode);
                        iCol = _fnNodeToColumnIndex( oSettings, iRow, mRow );
                    }
                }

                if ( iCol !== undefined )
                {
                    return _fnGetCellData( oSettings, iRow, iCol, '' );
                }
                return (oSettings.aoData[iRow]!==undefined) ?
                    oSettings.aoData[iRow]._aData : null;
            }
            return _fnGetDataMaster( oSettings );
        };


        /**
         * Get an array of the TR nodes that are used in the table's body. Note that you will
         * typically want to use the '$' API method in preference to this as it is more
         * flexible.
         *  @param {int} [iRow] Optional row index for the TR element you want
         *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
         *    in the table's body, or iRow is defined, just the TR element requested.
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Get the nodes from the table
         *      var nNodes = oTable.fnGetNodes( );
         *    } );
         */
        this.fnGetNodes = function( iRow )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

            if ( iRow !== undefined ) {
                return (oSettings.aoData[iRow]!==undefined) ?
                    oSettings.aoData[iRow].nTr : null;
            }
            return _fnGetTrNodes( oSettings );
        };


        /**
         * Get the array indexes of a particular cell from it's DOM element
         * and column index including hidden columns
         *  @param {node} nNode this can either be a TR, TD or TH in the table's body
         *  @returns {int} If nNode is given as a TR, then a single index is returned, or
         *    if given as a cell, an array of [row index, column index (visible),
         *    column index (all)] is given.
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      $('#example tbody td').click( function () {
         *        // Get the position of the current data from the node
         *        var aPos = oTable.fnGetPosition( this );
         *
         *        // Get the data array for this row
         *        var aData = oTable.fnGetData( aPos[0] );
         *
         *        // Update the data array and return the value
         *        aData[ aPos[1] ] = 'clicked';
         *        this.innerHTML = 'clicked';
         *      } );
         *
         *      // Init DataTables
         *      oTable = $('#example').dataTable();
         *    } );
         */
        this.fnGetPosition = function( nNode )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var sNodeName = nNode.nodeName.toUpperCase();

            if ( sNodeName == "TR" )
            {
                return _fnNodeToDataIndex(oSettings, nNode);
            }
            else if ( sNodeName == "TD" || sNodeName == "TH" )
            {
                var iDataIndex = _fnNodeToDataIndex( oSettings, nNode.parentNode );
                var iColumnIndex = _fnNodeToColumnIndex( oSettings, iDataIndex, nNode );
                return [ iDataIndex, _fnColumnIndexToVisible(oSettings, iColumnIndex ), iColumnIndex ];
            }
            return null;
        };


        /**
         * Check to see if a row is 'open' or not.
         *  @param {node} nTr the table row to check
         *  @returns {boolean} true if the row is currently open, false otherwise
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable;
         *
         *      // 'open' an information row when a row is clicked on
         *      $('#example tbody tr').click( function () {
         *        if ( oTable.fnIsOpen(this) ) {
         *          oTable.fnClose( this );
         *        } else {
         *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
         *        }
         *      } );
         *
         *      oTable = $('#example').dataTable();
         *    } );
         */
        this.fnIsOpen = function( nTr )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var aoOpenRows = oSettings.aoOpenRows;

            for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
            {
                if ( oSettings.aoOpenRows[i].nParent == nTr )
                {
                    return true;
                }
            }
            return false;
        };


        /**
         * This function will place a new row directly after a row which is currently
         * on display on the page, with the HTML contents that is passed into the
         * function. This can be used, for example, to ask for confirmation that a
         * particular record should be deleted.
         *  @param {node} nTr The table row to 'open'
         *  @param {string|node|jQuery} mHtml The HTML to put into the row
         *  @param {string} sClass Class to give the new TD cell
         *  @returns {node} The row opened. Note that if the table row passed in as the
         *    first parameter, is not found in the table, this method will silently
         *    return.
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable;
         *
         *      // 'open' an information row when a row is clicked on
         *      $('#example tbody tr').click( function () {
         *        if ( oTable.fnIsOpen(this) ) {
         *          oTable.fnClose( this );
         *        } else {
         *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
         *        }
         *      } );
         *
         *      oTable = $('#example').dataTable();
         *    } );
         */
        this.fnOpen = function( nTr, mHtml, sClass )
        {
            /* Find settings from table node */
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );

            /* Check that the row given is in the table */
            var nTableRows = _fnGetTrNodes( oSettings );
            if ( $.inArray(nTr, nTableRows) === -1 )
            {
                return;
            }

            /* the old open one if there is one */
            this.fnClose( nTr );

            var nNewRow = document.createElement("tr");
            var nNewCell = document.createElement("td");
            nNewRow.appendChild( nNewCell );
            nNewCell.className = sClass;
            nNewCell.colSpan = _fnVisbleColumns( oSettings );

            if (typeof mHtml === "string")
            {
                nNewCell.innerHTML = mHtml;
            }
            else
            {
                $(nNewCell).html( mHtml );
            }

            /* If the nTr isn't on the page at the moment - then we don't insert at the moment */
            var nTrs = $('tr', oSettings.nTBody);
            if ( $.inArray(nTr, nTrs) != -1  )
            {
                $(nNewRow).insertAfter(nTr);
            }

            oSettings.aoOpenRows.push( {
                "nTr": nNewRow,
                "nParent": nTr
            } );

            return nNewRow;
        };


        /**
         * Change the pagination - provides the internal logic for pagination in a simple API
         * function. With this function you can have a DataTables table go to the next,
         * previous, first or last pages.
         *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
         *    or page number to jump to (integer), note that page 0 is the first page.
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      oTable.fnPageChange( 'next' );
         *    } );
         */
        this.fnPageChange = function ( mAction, bRedraw )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            _fnPageChange( oSettings, mAction );
            _fnCalculateEnd( oSettings );

            if ( bRedraw === undefined || bRedraw )
            {
                _fnDraw( oSettings );
            }
        };


        /**
         * Show a particular column
         *  @param {int} iCol The column whose display should be changed
         *  @param {bool} bShow Show (true) or hide (false) the column
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Hide the second column after initialisation
         *      oTable.fnSetColumnVis( 1, false );
         *    } );
         */
        this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var i, iLen;
            var aoColumns = oSettings.aoColumns;
            var aoData = oSettings.aoData;
            var nTd, bAppend, iBefore;

            /* No point in doing anything if we are requesting what is already true */
            if ( aoColumns[iCol].bVisible == bShow )
            {
                return;
            }

            /* Show the column */
            if ( bShow )
            {
                var iInsert = 0;
                for ( i=0 ; i<iCol ; i++ )
                {
                    if ( aoColumns[i].bVisible )
                    {
                        iInsert++;
                    }
                }

                /* Need to decide if we should use appendChild or insertBefore */
                bAppend = (iInsert >= _fnVisbleColumns( oSettings ));

                /* Which coloumn should we be inserting before? */
                if ( !bAppend )
                {
                    for ( i=iCol ; i<aoColumns.length ; i++ )
                    {
                        if ( aoColumns[i].bVisible )
                        {
                            iBefore = i;
                            break;
                        }
                    }
                }

                for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
                {
                    if ( aoData[i].nTr !== null )
                    {
                        if ( bAppend )
                        {
                            aoData[i].nTr.appendChild(
                                aoData[i]._anHidden[iCol]
                            );
                        }
                        else
                        {
                            aoData[i].nTr.insertBefore(
                                aoData[i]._anHidden[iCol],
                                _fnGetTdNodes( oSettings, i )[iBefore] );
                        }
                    }
                }
            }
            else
            {
                /* Remove a column from display */
                for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
                {
                    if ( aoData[i].nTr !== null )
                    {
                        nTd = _fnGetTdNodes( oSettings, i )[iCol];
                        aoData[i]._anHidden[iCol] = nTd;
                        nTd.parentNode.removeChild( nTd );
                    }
                }
            }

            /* Clear to set the visible flag */
            aoColumns[iCol].bVisible = bShow;

            /* Redraw the header and footer based on the new column visibility */
            _fnDrawHead( oSettings, oSettings.aoHeader );
            if ( oSettings.nTFoot )
            {
                _fnDrawHead( oSettings, oSettings.aoFooter );
            }

            /* If there are any 'open' rows, then we need to alter the colspan for this col change */
            for ( i=0, iLen=oSettings.aoOpenRows.length ; i<iLen ; i++ )
            {
                oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns( oSettings );
            }

            /* Do a redraw incase anything depending on the table columns needs it
             * (built-in: scrolling)
             */
            if ( bRedraw === undefined || bRedraw )
            {
                _fnAdjustColumnSizing( oSettings );
                _fnDraw( oSettings );
            }

            _fnSaveState( oSettings );
        };


        /**
         * Get the settings for a particular table for external manipulation
         *  @returns {object} DataTables settings object. See
         *    {@link DataTable.models.oSettings}
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      var oSettings = oTable.fnSettings();
         *
         *      // Show an example parameter from the settings
         *      alert( oSettings._iDisplayStart );
         *    } );
         */
        this.fnSettings = function()
        {
            return _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
        };


        /**
         * Sort the table by a particular column
         *  @param {int} iCol the data index to sort on. Note that this will not match the
         *    'display index' if you have hidden data entries
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Sort immediately with columns 0 and 1
         *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
         *    } );
         */
        this.fnSort = function( aaSort )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            oSettings.aaSorting = aaSort;
            _fnSort( oSettings );
        };


        /**
         * Attach a sort listener to an element for a given column
         *  @param {node} nNode the element to attach the sort listener to
         *  @param {int} iColumn the column that a click on this node will sort on
         *  @param {function} [fnCallback] callback function when sort is run
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *
         *      // Sort on column 1, when 'sorter' is clicked on
         *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
         *    } );
         */
        this.fnSortListener = function( nNode, iColumn, fnCallback )
        {
            _fnSortAttachListener( _fnSettingsFromNode( this[DataTable.ext.iApiIndex] ), nNode, iColumn,
                fnCallback );
        };


        /**
         * Update a table cell or row - this method will accept either a single value to
         * update the cell with, an array of values with one element for each column or
         * an object in the same format as the original data source. The function is
         * self-referencing in order to make the multi column updates easier.
         *  @param {object|array|string} mData Data to update the cell/row with
         *  @param {node|int} mRow TR element you want to update or the aoData index
         *  @param {int} [iColumn] The column to update (not used of mData is an array or object)
         *  @param {bool} [bRedraw=true] Redraw the table or not
         *  @param {bool} [bAction=true] Perform pre-draw actions or not
         *  @returns {int} 0 on success, 1 on error
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
         *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], 1, 0 ); // Row
         *    } );
         */
        this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
        {
            var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
            var i, iLen, sDisplay;
            var iRow = (typeof mRow === 'object') ?
                _fnNodeToDataIndex(oSettings, mRow) : mRow;

            if ( $.isArray(mData) && iColumn === undefined )
            {
                /* Array update - update the whole row */
                oSettings.aoData[iRow]._aData = mData.slice();

                /* Flag to the function that we are recursing */
                for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
                {
                    this.fnUpdate( _fnGetCellData( oSettings, iRow, i ), iRow, i, false, false );
                }
            }
            else if ( $.isPlainObject(mData) && iColumn === undefined )
            {
                /* Object update - update the whole row - assume the developer gets the object right */
                oSettings.aoData[iRow]._aData = $.extend( true, {}, mData );

                for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
                {
                    this.fnUpdate( _fnGetCellData( oSettings, iRow, i ), iRow, i, false, false );
                }
            }
            else
            {
                /* Individual cell update */
                _fnSetCellData( oSettings, iRow, iColumn, mData );
                sDisplay = _fnGetCellData( oSettings, iRow, iColumn, 'display' );

                var oCol = oSettings.aoColumns[iColumn];
                if ( oCol.fnRender !== null )
                {
                    sDisplay = _fnRender( oSettings, iRow, iColumn );
                    if ( oCol.bUseRendered )
                    {
                        _fnSetCellData( oSettings, iRow, iColumn, sDisplay );
                    }
                }

                if ( oSettings.aoData[iRow].nTr !== null )
                {
                    /* Do the actual HTML update */
                    _fnGetTdNodes( oSettings, iRow )[iColumn].innerHTML = sDisplay;
                }
            }

            /* Modify the search index for this row (strictly this is likely not needed, since fnReDraw
             * will rebuild the search array - however, the redraw might be disabled by the user)
             */
            var iDisplayIndex = $.inArray( iRow, oSettings.aiDisplay );
            oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow(
                oSettings,
                _fnGetRowData( oSettings, iRow, 'filter', _fnGetColumns( oSettings, 'bSearchable' ) )
            );

            /* Perform pre-draw actions */
            if ( bAction === undefined || bAction )
            {
                _fnAdjustColumnSizing( oSettings );
            }

            /* Redraw the table */
            if ( bRedraw === undefined || bRedraw )
            {
                _fnReDraw( oSettings );
            }
            return 0;
        };


        /**
         * Provide a common method for plug-ins to check the version of DataTables being used, in order
         * to ensure compatibility.
         *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
         *    formats "X" and "X.Y" are also acceptable.
         *  @returns {boolean} true if this version of DataTables is greater or equal to the required
         *    version, or false if this version of DataTales is not suitable
         *  @method
         *  @dtopt API
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      alert( oTable.fnVersionCheck( '1.9.0' ) );
         *    } );
         */
        this.fnVersionCheck = DataTable.ext.fnVersionCheck;


        /*
         * This is really a good bit rubbish this method of exposing the internal methods
         * publicly... - To be fixed in 2.0 using methods on the prototype
         */


        /**
         * Create a wrapper function for exporting an internal functions to an external API.
         *  @param {string} sFunc API function name
         *  @returns {function} wrapped function
         *  @memberof DataTable#oApi
         */
        function _fnExternApiFunc (sFunc)
        {
            return function() {
                var aArgs = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
                    Array.prototype.slice.call(arguments) );
                return DataTable.ext.oApi[sFunc].apply( this, aArgs );
            };
        }


        /**
         * Reference to internal functions for use by plug-in developers. Note that these
         * methods are references to internal functions and are considered to be private.
         * If you use these methods, be aware that they are liable to change between versions
         * (check the upgrade notes).
         *  @namespace
         */
        this.oApi = {
            "_fnExternApiFunc": _fnExternApiFunc,
            "_fnInitialise": _fnInitialise,
            "_fnInitComplete": _fnInitComplete,
            "_fnLanguageCompat": _fnLanguageCompat,
            "_fnAddColumn": _fnAddColumn,
            "_fnColumnOptions": _fnColumnOptions,
            "_fnAddData": _fnAddData,
            "_fnCreateTr": _fnCreateTr,
            "_fnGatherData": _fnGatherData,
            "_fnBuildHead": _fnBuildHead,
            "_fnDrawHead": _fnDrawHead,
            "_fnDraw": _fnDraw,
            "_fnReDraw": _fnReDraw,
            "_fnAjaxUpdate": _fnAjaxUpdate,
            "_fnAjaxParameters": _fnAjaxParameters,
            "_fnAjaxUpdateDraw": _fnAjaxUpdateDraw,
            "_fnServerParams": _fnServerParams,
            "_fnAddOptionsHtml": _fnAddOptionsHtml,
            "_fnFeatureHtmlTable": _fnFeatureHtmlTable,
            "_fnScrollDraw": _fnScrollDraw,
            "_fnAdjustColumnSizing": _fnAdjustColumnSizing,
            "_fnFeatureHtmlFilter": _fnFeatureHtmlFilter,
            "_fnFilterComplete": _fnFilterComplete,
            "_fnFilterCustom": _fnFilterCustom,
            "_fnFilterColumn": _fnFilterColumn,
            "_fnFilter": _fnFilter,
            "_fnBuildSearchArray": _fnBuildSearchArray,
            "_fnBuildSearchRow": _fnBuildSearchRow,
            "_fnFilterCreateSearch": _fnFilterCreateSearch,
            "_fnDataToSearch": _fnDataToSearch,
            "_fnSort": _fnSort,
            "_fnSortAttachListener": _fnSortAttachListener,
            "_fnSortingClasses": _fnSortingClasses,
            "_fnFeatureHtmlPaginate": _fnFeatureHtmlPaginate,
            "_fnPageChange": _fnPageChange,
            "_fnFeatureHtmlInfo": _fnFeatureHtmlInfo,
            "_fnUpdateInfo": _fnUpdateInfo,
            "_fnFeatureHtmlLength": _fnFeatureHtmlLength,
            "_fnFeatureHtmlProcessing": _fnFeatureHtmlProcessing,
            "_fnProcessingDisplay": _fnProcessingDisplay,
            "_fnVisibleToColumnIndex": _fnVisibleToColumnIndex,
            "_fnColumnIndexToVisible": _fnColumnIndexToVisible,
            "_fnNodeToDataIndex": _fnNodeToDataIndex,
            "_fnVisbleColumns": _fnVisbleColumns,
            "_fnCalculateEnd": _fnCalculateEnd,
            "_fnConvertToWidth": _fnConvertToWidth,
            "_fnCalculateColumnWidths": _fnCalculateColumnWidths,
            "_fnScrollingWidthAdjust": _fnScrollingWidthAdjust,
            "_fnGetWidestNode": _fnGetWidestNode,
            "_fnGetMaxLenString": _fnGetMaxLenString,
            "_fnStringToCss": _fnStringToCss,
            "_fnDetectType": _fnDetectType,
            "_fnSettingsFromNode": _fnSettingsFromNode,
            "_fnGetDataMaster": _fnGetDataMaster,
            "_fnGetTrNodes": _fnGetTrNodes,
            "_fnGetTdNodes": _fnGetTdNodes,
            "_fnEscapeRegex": _fnEscapeRegex,
            "_fnDeleteIndex": _fnDeleteIndex,
            "_fnReOrderIndex": _fnReOrderIndex,
            "_fnColumnOrdering": _fnColumnOrdering,
            "_fnLog": _fnLog,
            "_fnClearTable": _fnClearTable,
            "_fnSaveState": _fnSaveState,
            "_fnLoadState": _fnLoadState,
            "_fnCreateCookie": _fnCreateCookie,
            "_fnReadCookie": _fnReadCookie,
            "_fnDetectHeader": _fnDetectHeader,
            "_fnGetUniqueThs": _fnGetUniqueThs,
            "_fnScrollBarWidth": _fnScrollBarWidth,
            "_fnApplyToChildren": _fnApplyToChildren,
            "_fnMap": _fnMap,
            "_fnGetRowData": _fnGetRowData,
            "_fnGetCellData": _fnGetCellData,
            "_fnSetCellData": _fnSetCellData,
            "_fnGetObjectDataFn": _fnGetObjectDataFn,
            "_fnSetObjectDataFn": _fnSetObjectDataFn,
            "_fnApplyColumnDefs": _fnApplyColumnDefs,
            "_fnBindAction": _fnBindAction,
            "_fnExtend": _fnExtend,
            "_fnCallbackReg": _fnCallbackReg,
            "_fnCallbackFire": _fnCallbackFire,
            "_fnJsonString": _fnJsonString,
            "_fnRender": _fnRender,
            "_fnNodeToColumnIndex": _fnNodeToColumnIndex,
            "_fnInfoMacros": _fnInfoMacros,
            "_fnBrowserDetect": _fnBrowserDetect,
            "_fnGetColumns": _fnGetColumns
        };

        $.extend( DataTable.ext.oApi, this.oApi );

        for ( var sFunc in DataTable.ext.oApi )
        {
            if ( sFunc )
            {
                this[sFunc] = _fnExternApiFunc(sFunc);
            }
        }


        var _that = this;
        this.each(function() {
            var i=0, iLen, j, jLen, k, kLen;
            var sId = this.getAttribute( 'id' );
            var bInitHandedOff = false;
            var bUsePassedData = false;


            /* Sanity check */
            if ( this.nodeName.toLowerCase() != 'table' )
            {
                _fnLog( null, 0, "Attempted to initialise DataTables on a node which is not a "+
                    "table: "+this.nodeName );
                return;
            }

            /* Check to see if we are re-initialising a table */
            for ( i=0, iLen=DataTable.settings.length ; i<iLen ; i++ )
            {
                /* Base check on table node */
                if ( DataTable.settings[i].nTable == this )
                {
                    if ( oInit === undefined || oInit.bRetrieve )
                    {
                        return DataTable.settings[i].oInstance;
                    }
                    else if ( oInit.bDestroy )
                    {
                        DataTable.settings[i].oInstance.fnDestroy();
                        break;
                    }
                    else
                    {
                        _fnLog( DataTable.settings[i], 0, "Cannot reinitialise DataTable.\n\n"+
                            "To retrieve the DataTables object for this table, pass no arguments or see "+
                            "the docs for bRetrieve and bDestroy" );
                        return;
                    }
                }

                /* If the element we are initialising has the same ID as a table which was previously
                 * initialised, but the table nodes don't match (from before) then we destroy the old
                 * instance by simply deleting it. This is under the assumption that the table has been
                 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
                 */
                if ( DataTable.settings[i].sTableId == this.id )
                {
                    DataTable.settings.splice( i, 1 );
                    break;
                }
            }

            /* Ensure the table has an ID - required for accessibility */
            if ( sId === null || sId === "" )
            {
                sId = "DataTables_Table_"+(DataTable.ext._oExternConfig.iNextUnique++);
                this.id = sId;
            }

            /* Create the settings object for this table and set some of the default parameters */
            var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
                "nTable":        this,
                "oApi":          _that.oApi,
                "oInit":         oInit,
                "sDestroyWidth": $(this).width(),
                "sInstance":     sId,
                "sTableId":      sId
            } );
            DataTable.settings.push( oSettings );

            // Need to add the instance after the instance after the settings object has been added
            // to the settings array, so we can self reference the table instance if more than one
            oSettings.oInstance = (_that.length===1) ? _that : $(this).dataTable();

            /* Setting up the initialisation object */
            if ( !oInit )
            {
                oInit = {};
            }

            // Backwards compatibility, before we apply all the defaults
            if ( oInit.oLanguage )
            {
                _fnLanguageCompat( oInit.oLanguage );
            }

            oInit = _fnExtend( $.extend(true, {}, DataTable.defaults), oInit );

            // Map the initialisation options onto the settings object
            _fnMap( oSettings.oFeatures, oInit, "bPaginate" );
            _fnMap( oSettings.oFeatures, oInit, "bLengthChange" );
            _fnMap( oSettings.oFeatures, oInit, "bFilter" );
            _fnMap( oSettings.oFeatures, oInit, "bSort" );
            _fnMap( oSettings.oFeatures, oInit, "bInfo" );
            _fnMap( oSettings.oFeatures, oInit, "bProcessing" );
            _fnMap( oSettings.oFeatures, oInit, "bAutoWidth" );
            _fnMap( oSettings.oFeatures, oInit, "bSortClasses" );
            _fnMap( oSettings.oFeatures, oInit, "bServerSide" );
            _fnMap( oSettings.oFeatures, oInit, "bDeferRender" );
            _fnMap( oSettings.oScroll, oInit, "sScrollX", "sX" );
            _fnMap( oSettings.oScroll, oInit, "sScrollXInner", "sXInner" );
            _fnMap( oSettings.oScroll, oInit, "sScrollY", "sY" );
            _fnMap( oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse" );
            _fnMap( oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite" );
            _fnMap( oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap" );
            _fnMap( oSettings.oScroll, oInit, "bScrollAutoCss", "bAutoCss" );
            _fnMap( oSettings, oInit, "asStripeClasses" );
            _fnMap( oSettings, oInit, "asStripClasses", "asStripeClasses" ); // legacy
            _fnMap( oSettings, oInit, "fnServerData" );
            _fnMap( oSettings, oInit, "fnFormatNumber" );
            _fnMap( oSettings, oInit, "sServerMethod" );
            _fnMap( oSettings, oInit, "aaSorting" );
            _fnMap( oSettings, oInit, "aaSortingFixed" );
            _fnMap( oSettings, oInit, "aLengthMenu" );
            _fnMap( oSettings, oInit, "sPaginationType" );
            _fnMap( oSettings, oInit, "sAjaxSource" );
            _fnMap( oSettings, oInit, "sAjaxDataProp" );
            _fnMap( oSettings, oInit, "iCookieDuration" );
            _fnMap( oSettings, oInit, "sCookiePrefix" );
            _fnMap( oSettings, oInit, "sDom" );
            _fnMap( oSettings, oInit, "bSortCellsTop" );
            _fnMap( oSettings, oInit, "iTabIndex" );
            _fnMap( oSettings, oInit, "oSearch", "oPreviousSearch" );
            _fnMap( oSettings, oInit, "aoSearchCols", "aoPreSearchCols" );
            _fnMap( oSettings, oInit, "iDisplayLength", "_iDisplayLength" );
            _fnMap( oSettings, oInit, "bJQueryUI", "bJUI" );
            _fnMap( oSettings, oInit, "fnCookieCallback" );
            _fnMap( oSettings, oInit, "fnStateLoad" );
            _fnMap( oSettings, oInit, "fnStateSave" );
            _fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );

            /* Callback functions which are array driven */
            _fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
            _fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
            _fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
            _fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
            _fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
            _fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
            _fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
            _fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
            _fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
            _fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
            _fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );

            if ( oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort &&
                   oSettings.oFeatures.bSortClasses )
            {
                /* Enable sort classes for server-side processing. Safe to do it here, since server-side
                 * processing must be enabled by the developer
                 */
                _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSortingClasses, 'server_side_sort_classes' );
            }
            else if ( oSettings.oFeatures.bDeferRender )
            {
                _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSortingClasses, 'defer_sort_classes' );
            }

            if ( oInit.bJQueryUI )
            {
                /* Use the JUI classes object for display. You could clone the oStdClasses object if
                 * you want to have multiple tables with multiple independent classes
                 */
                $.extend( oSettings.oClasses, DataTable.ext.oJUIClasses );

                if ( oInit.sDom === DataTable.defaults.sDom && DataTable.defaults.sDom === "lfrtip" )
                {
                    /* Set the DOM to use a layout suitable for jQuery UI's theming */
                    oSettings.sDom = '<"H"lfr>t<"F"ip>';
                }
            }
            else
            {
                $.extend( oSettings.oClasses, DataTable.ext.oStdClasses );
            }
            $(this).addClass( oSettings.oClasses.sTable );

            /* Calculate the scroll bar width and cache it for use later on */
            if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
            {
                oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
            }

            if ( oSettings.iInitDisplayStart === undefined )
            {
                /* Display start point, taking into account the save saving */
                oSettings.iInitDisplayStart = oInit.iDisplayStart;
                oSettings._iDisplayStart = oInit.iDisplayStart;
            }

            /* Must be done after everything which can be overridden by a cookie! */
            if ( oInit.bStateSave )
            {
                oSettings.oFeatures.bStateSave = true;
                _fnLoadState( oSettings, oInit );
                _fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
            }

            if ( oInit.iDeferLoading !== null )
            {
                oSettings.bDeferLoading = true;
                var tmp = $.isArray( oInit.iDeferLoading );
                oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
                oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
            }

            if ( oInit.aaData !== null )
            {
                bUsePassedData = true;
            }

            /* Language definitions */
            if ( oInit.oLanguage.sUrl !== "" )
            {
                /* Get the language definitions from a file - because this Ajax call makes the language
                 * get async to the remainder of this function we use bInitHandedOff to indicate that
                 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
                 */
                oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
                $.getJSON( oSettings.oLanguage.sUrl, null, function( json ) {
                    _fnLanguageCompat( json );
                    $.extend( true, oSettings.oLanguage, oInit.oLanguage, json );
                    _fnInitialise( oSettings );
                } );
                bInitHandedOff = true;
            }
            else
            {
                $.extend( true, oSettings.oLanguage, oInit.oLanguage );
            }


            /*
             * Stripes
             */
            if ( oInit.asStripeClasses === null )
            {
                oSettings.asStripeClasses =[
                    oSettings.oClasses.sStripeOdd,
                    oSettings.oClasses.sStripeEven
                ];
            }

            /* Remove row stripe classes if they are already on the table row */
            iLen=oSettings.asStripeClasses.length;
            oSettings.asDestroyStripes = [];
            if (iLen)
            {
                var bStripeRemove = false;
                var anRows = $(this).children('tbody').children('tr:lt(' + iLen + ')');
                for ( i=0 ; i<iLen ; i++ )
                {
                    if ( anRows.hasClass( oSettings.asStripeClasses[i] ) )
                    {
                        bStripeRemove = true;

                        /* Store the classes which we are about to remove so they can be re-added on destroy */
                        oSettings.asDestroyStripes.push( oSettings.asStripeClasses[i] );
                    }
                }

                if ( bStripeRemove )
                {
                    anRows.removeClass( oSettings.asStripeClasses.join(' ') );
                }
            }

            /*
             * Columns
             * See if we should load columns automatically or use defined ones
             */
            var anThs = [];
            var aoColumnsInit;
            var nThead = this.getElementsByTagName('thead');
            if ( nThead.length !== 0 )
            {
                _fnDetectHeader( oSettings.aoHeader, nThead[0] );
                anThs = _fnGetUniqueThs( oSettings );
            }

            /* If not given a column array, generate one with nulls */
            if ( oInit.aoColumns === null )
            {
                aoColumnsInit = [];
                for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
                {
                    aoColumnsInit.push( null );
                }
            }
            else
            {
                aoColumnsInit = oInit.aoColumns;
            }

            /* Add the columns */
            for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
            {
                /* Short cut - use the loop to check if we have column visibility state to restore */
                if ( oInit.saved_aoColumns !== undefined && oInit.saved_aoColumns.length == iLen )
                {
                    if ( aoColumnsInit[i] === null )
                    {
                        aoColumnsInit[i] = {};
                    }
                    aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible;
                }

                _fnAddColumn( oSettings, anThs ? anThs[i] : null );
            }

            /* Apply the column definitions */
            _fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
                _fnColumnOptions( oSettings, iCol, oDef );
            } );


            /*
             * Sorting
             * Check the aaSorting array
             */
            for ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )
            {
                if ( oSettings.aaSorting[i][0] >= oSettings.aoColumns.length )
                {
                    oSettings.aaSorting[i][0] = 0;
                }
                var oColumn = oSettings.aoColumns[ oSettings.aaSorting[i][0] ];

                /* Add a default sorting index */
                if ( oSettings.aaSorting[i][2] === undefined )
                {
                    oSettings.aaSorting[i][2] = 0;
                }

                /* If aaSorting is not defined, then we use the first indicator in asSorting */
                if ( oInit.aaSorting === undefined && oSettings.saved_aaSorting === undefined )
                {
                    oSettings.aaSorting[i][1] = oColumn.asSorting[0];
                }

                /* Set the current sorting index based on aoColumns.asSorting */
                for ( j=0, jLen=oColumn.asSorting.length ; j<jLen ; j++ )
                {
                    if ( oSettings.aaSorting[i][1] == oColumn.asSorting[j] )
                    {
                        oSettings.aaSorting[i][2] = j;
                        break;
                    }
                }
            }

            /* Do a first pass on the sorting classes (allows any size changes to be taken into
             * account, and also will apply sorting disabled classes if disabled
             */
            _fnSortingClasses( oSettings );


            /*
             * Final init
             * Cache the header, body and footer as required, creating them if needed
             */

            /* Browser support detection */
            _fnBrowserDetect( oSettings );

            // Work around for Webkit bug 83867 - store the caption-side before removing from doc
            var captions = $(this).children('caption').each( function () {
                this._captionSide = $(this).css('caption-side');
            } );

            var thead = $(this).children('thead');
            if ( thead.length === 0 )
            {
                thead = [ document.createElement( 'thead' ) ];
                this.appendChild( thead[0] );
            }
            oSettings.nTHead = thead[0];

            var tbody = $(this).children('tbody');
            if ( tbody.length === 0 )
            {
                tbody = [ document.createElement( 'tbody' ) ];
                this.appendChild( tbody[0] );
            }
            oSettings.nTBody = tbody[0];
            oSettings.nTBody.setAttribute( "role", "alert" );
            oSettings.nTBody.setAttribute( "aria-live", "polite" );
            oSettings.nTBody.setAttribute( "aria-relevant", "all" );

            var tfoot = $(this).children('tfoot');
            if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
            {
                // If we are a scrolling table, and no footer has been given, then we need to create
                // a tfoot element for the caption element to be appended to
                tfoot = [ document.createElement( 'tfoot' ) ];
                this.appendChild( tfoot[0] );
            }

            if ( tfoot.length > 0 )
            {
                oSettings.nTFoot = tfoot[0];
                _fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
            }

            /* Check if there is data passing into the constructor */
            if ( bUsePassedData )
            {
                for ( i=0 ; i<oInit.aaData.length ; i++ )
                {
                    _fnAddData( oSettings, oInit.aaData[ i ] );
                }
            }
            else
            {
                /* Grab the data from the page */
                _fnGatherData( oSettings );
            }

            /* Copy the data index array */
            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

            /* Initialisation complete - table can be drawn */
            oSettings.bInitialised = true;

            /* Check if we need to initialise the table (it might not have been handed off to the
             * language processor)
             */
            if ( bInitHandedOff === false )
            {
                _fnInitialise( oSettings );
            }
        } );
        _that = null;
        return this;
    };



    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @static
     *  @dtopt API-Static
     *
     *  @example
     *    alert( $.fn.dataTable.fnVersionCheck( '1.9.0' ) );
     */
    DataTable.fnVersionCheck = function( sVersion )
    {
        /* This is cheap, but effective */
        var fnZPad = function (Zpad, count)
        {
            while(Zpad.length < count) {
                Zpad += '0';
            }
            return Zpad;
        };
        var aThis = DataTable.ext.sVersion.split('.');
        var aThat = sVersion.split('.');
        var sThis = '', sThat = '';

        for ( var i=0, iLen=aThat.length ; i<iLen ; i++ )
        {
            sThis += fnZPad( aThis[i], 3 );
            sThat += fnZPad( aThat[i], 3 );
        }

        return parseInt(sThis, 10) >= parseInt(sThat, 10);
    };


    /**
     * Check if a TABLE node is a DataTable table already or not.
     *  @param {node} nTable The TABLE node to check if it is a DataTable or not (note that other
     *    node types can be passed in, but will always return false).
     *  @returns {boolean} true the table given is a DataTable, or false otherwise
     *  @static
     *  @dtopt API-Static
     *
     *  @example
     *    var ex = document.getElementById('example');
     *    if ( ! $.fn.DataTable.fnIsDataTable( ex ) ) {
     *      $(ex).dataTable();
     *    }
     */
    DataTable.fnIsDataTable = function ( nTable )
    {
        var o = DataTable.settings;

        for ( var i=0 ; i<o.length ; i++ )
        {
            if ( o[i].nTable === nTable || o[i].nScrollHead === nTable || o[i].nScrollFoot === nTable )
            {
                return true;
            }
        }

        return false;
    };


    /**
     * Get all DataTable tables that have been initialised - optionally you can select to
     * get only currently visible tables.
     *  @param {boolean} [bVisible=false] Flag to indicate if you want all (default) or
     *    visible tables only.
     *  @returns {array} Array of TABLE nodes (not DataTable instances) which are DataTables
     *  @static
     *  @dtopt API-Static
     *
     *  @example
     *    var table = $.fn.dataTable.fnTables(true);
     *    if ( table.length > 0 ) {
     *      $(table).dataTable().fnAdjustColumnSizing();
     *    }
     */
    DataTable.fnTables = function ( bVisible )
    {
        var out = [];

        jQuery.each( DataTable.settings, function (i, o) {
            if ( !bVisible || (bVisible === true && $(o.nTable).is(':visible')) )
            {
                out.push( o.nTable );
            }
        } );

        return out;
    };


    /**
     * Version string for plug-ins to check compatibility. Allowed format is
     * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
     * e are optional
     *  @member
     *  @type string
     *  @default Version number
     */
    DataTable.version = "1.9.4";

    /**
     * Private data store, containing all of the settings objects that are created for the
     * tables on a given page.
     *
     * Note that the <i>DataTable.settings</i> object is aliased to <i>jQuery.fn.dataTableExt</i>
     * through which it may be accessed and manipulated, or <i>jQuery.fn.dataTable.settings</i>.
     *  @member
     *  @type array
     *  @default []
     *  @private
     */
    DataTable.settings = [];

    /**
     * Object models container, for the various models that DataTables has available
     * to it. These models define the objects that are used to hold the active state
     * and configuration of the table.
     *  @namespace
     */
    DataTable.models = {};


    /**
     * DataTables extension options and plug-ins. This namespace acts as a collection "area"
     * for plug-ins that can be used to extend the default DataTables behaviour - indeed many
     * of the build in methods use this method to provide their own capabilities (sorting methods
     * for example).
     *
     * Note that this namespace is aliased to jQuery.fn.dataTableExt so it can be readily accessed
     * and modified by plug-ins.
     *  @namespace
     */
    DataTable.models.ext = {
        /**
         * Plug-in filtering functions - this method of filtering is complimentary to the default
         * type based filtering, and a lot more comprehensive as it allows you complete control
         * over the filtering logic. Each element in this array is a function (parameters
         * described below) that is called for every row in the table, and your logic decides if
         * it should be included in the filtered data set or not.
         *   <ul>
         *     <li>
         *       Function input parameters:
         *       <ul>
         *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
         *         <li>{array|object} Data for the row to be processed (same as the original format
         *           that was passed in as the data source, or an array from a DOM data source</li>
         *         <li>{int} Row index in aoData ({@link DataTable.models.oSettings.aoData}), which can
         *           be useful to retrieve the TR element if you need DOM interaction.</li>
         *       </ul>
         *     </li>
         *     <li>
         *       Function return:
         *       <ul>
         *         <li>{boolean} Include the row in the filtered result set (true) or not (false)</li>
         *       </ul>
         *     </il>
         *   </ul>
         *  @type array
         *  @default []
         *
         *  @example
         *    // The following example shows custom filtering being applied to the fourth column (i.e.
         *    // the aData[3] index) based on two input values from the end-user, matching the data in
         *    // a certain range.
         *    $.fn.dataTableExt.afnFiltering.push(
         *      function( oSettings, aData, iDataIndex ) {
         *        var iMin = document.getElementById('min').value * 1;
         *        var iMax = document.getElementById('max').value * 1;
         *        var iVersion = aData[3] == "-" ? 0 : aData[3]*1;
         *        if ( iMin == "" && iMax == "" ) {
         *          return true;
         *        }
         *        else if ( iMin == "" && iVersion < iMax ) {
         *          return true;
         *        }
         *        else if ( iMin < iVersion && "" == iMax ) {
         *          return true;
         *        }
         *        else if ( iMin < iVersion && iVersion < iMax ) {
         *          return true;
         *        }
         *        return false;
         *      }
         *    );
         */
        "afnFiltering": [],


        /**
         * Plug-in sorting functions - this method of sorting is complimentary to the default type
         * based sorting that DataTables does automatically, allowing much greater control over the
         * the data that is being used to sort a column. This is useful if you want to do sorting
         * based on live data (for example the contents of an 'input' element) rather than just the
         * static string that DataTables knows of. The way these plug-ins work is that you create
         * an array of the values you wish to be sorted for the column in question and then return
         * that array. Which pre-sorting function is run here depends on the sSortDataType parameter
         * that is used for the column (if any). This is the corollary of <i>ofnSearch</i> for sort
         * data.
         *   <ul>
         *     <li>
         *       Function input parameters:
         *       <ul>
         *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
         *         <li>{int} Target column index</li>
         *       </ul>
         *     </li>
         *     <li>
         *       Function return:
         *       <ul>
         *         <li>{array} Data for the column to be sorted upon</li>
         *       </ul>
         *     </il>
         *   </ul>
         *
         * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
         * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
         * used as a function will give you a 'type' (sorting, filtering etc) that you can use to
         * prepare the data as required for the different types. As such, this method is deprecated.
         *  @type array
         *  @default []
         *  @deprecated
         *
         *  @example
         *    // Updating the cached sorting information with user entered values in HTML input elements
         *    jQuery.fn.dataTableExt.afnSortData['dom-text'] = function ( oSettings, iColumn )
         *    {
         *      var aData = [];
         *      $( 'td:eq('+iColumn+') input', oSettings.oApi._fnGetTrNodes(oSettings) ).each( function () {
         *        aData.push( this.value );
         *      } );
         *      return aData;
         *    }
         */
        "afnSortData": [],


        /**
         * Feature plug-ins - This is an array of objects which describe the feature plug-ins that are
         * available to DataTables. These feature plug-ins are accessible through the sDom initialisation
         * option. As such, each feature plug-in must describe a function that is used to initialise
         * itself (fnInit), a character so the feature can be enabled by sDom (cFeature) and the name
         * of the feature (sFeature). Thus the objects attached to this method must provide:
         *   <ul>
         *     <li>{function} fnInit Initialisation of the plug-in
         *       <ul>
         *         <li>
         *           Function input parameters:
         *           <ul>
         *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
         *           </ul>
         *         </li>
         *         <li>
         *           Function return:
         *           <ul>
         *             <li>{node|null} The element which contains your feature. Note that the return
         *                may also be void if your plug-in does not require to inject any DOM elements
         *                into DataTables control (sDom) - for example this might be useful when
         *                developing a plug-in which allows table control via keyboard entry.</li>
         *           </ul>
         *         </il>
         *       </ul>
         *     </li>
         *     <li>{character} cFeature Character that will be matched in sDom - case sensitive</li>
         *     <li>{string} sFeature Feature name</li>
         *   </ul>
         *  @type array
         *  @default []
         *
         *  @example
         *    // How TableTools initialises itself.
         *    $.fn.dataTableExt.aoFeatures.push( {
         *      "fnInit": function( oSettings ) {
         *        return new TableTools( { "oDTSettings": oSettings } );
         *      },
         *      "cFeature": "T",
         *      "sFeature": "TableTools"
         *    } );
         */
        "aoFeatures": [],


        /**
         * Type detection plug-in functions - DataTables utilises types to define how sorting and
         * filtering behave, and types can be either  be defined by the developer (sType for the
         * column) or they can be automatically detected by the methods in this array. The functions
         * defined in the array are quite simple, taking a single parameter (the data to analyse)
         * and returning the type if it is a known type, or null otherwise.
         *   <ul>
         *     <li>
         *       Function input parameters:
         *       <ul>
         *         <li>{*} Data from the column cell to be analysed</li>
         *       </ul>
         *     </li>
         *     <li>
         *       Function return:
         *       <ul>
         *         <li>{string|null} Data type detected, or null if unknown (and thus pass it
         *           on to the other type detection functions.</li>
         *       </ul>
         *     </il>
         *   </ul>
         *  @type array
         *  @default []
         *
         *  @example
         *    // Currency type detection plug-in:
         *    jQuery.fn.dataTableExt.aTypes.push(
         *      function ( sData ) {
         *        var sValidChars = "0123456789.-";
         *        var Char;
         *
         *        // Check the numeric part
         *        for ( i=1 ; i<sData.length ; i++ ) {
         *          Char = sData.charAt(i);
         *          if (sValidChars.indexOf(Char) == -1) {
         *            return null;
         *          }
         *        }
         *
         *        // Check prefixed by currency
         *        if ( sData.charAt(0) == '$' || sData.charAt(0) == '&pound;' ) {
         *          return 'currency';
         *        }
         *        return null;
         *      }
         *    );
         */
        "aTypes": [],


        /**
         * Provide a common method for plug-ins to check the version of DataTables being used,
         * in order to ensure compatibility.
         *  @type function
         *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note
         *    that the formats "X" and "X.Y" are also acceptable.
         *  @returns {boolean} true if this version of DataTables is greater or equal to the
         *    required version, or false if this version of DataTales is not suitable
         *
         *  @example
         *    $(document).ready(function() {
         *      var oTable = $('#example').dataTable();
         *      alert( oTable.fnVersionCheck( '1.9.0' ) );
         *    } );
         */
        "fnVersionCheck": DataTable.fnVersionCheck,


        /**
         * Index for what 'this' index API functions should use
         *  @type int
         *  @default 0
         */
        "iApiIndex": 0,


        /**
         * Pre-processing of filtering data plug-ins - When you assign the sType for a column
         * (or have it automatically detected for you by DataTables or a type detection plug-in),
         * you will typically be using this for custom sorting, but it can also be used to provide
         * custom filtering by allowing you to pre-processing the data and returning the data in
         * the format that should be filtered upon. This is done by adding functions this object
         * with a parameter name which matches the sType for that target column. This is the
         * corollary of <i>afnSortData</i> for filtering data.
         *   <ul>
         *     <li>
         *       Function input parameters:
         *       <ul>
         *         <li>{*} Data from the column cell to be prepared for filtering</li>
         *       </ul>
         *     </li>
         *     <li>
         *       Function return:
         *       <ul>
         *         <li>{string|null} Formatted string that will be used for the filtering.</li>
         *       </ul>
         *     </il>
         *   </ul>
         *
         * Note that as of v1.9, it is typically preferable to use <i>mData</i> to prepare data for
         * the different uses that DataTables can put the data to. Specifically <i>mData</i> when
         * used as a function will give you a 'type' (sorting, filtering etc) that you can use to
         * prepare the data as required for the different types. As such, this method is deprecated.
         *  @type object
         *  @default {}
         *  @deprecated
         *
         *  @example
         *    $.fn.dataTableExt.ofnSearch['title-numeric'] = function ( sData ) {
         *      return sData.replace(/\n/g," ").replace( /<.*?>/g, "" );
         *    }
         */
        "ofnSearch": {},


        /**
         * Container for all private functions in DataTables so they can be exposed externally
         *  @type object
         *  @default {}
         */
        "oApi": {},


        /**
         * Storage for the various classes that DataTables uses
         *  @type object
         *  @default {}
         */
        "oStdClasses": {},


        /**
         * Storage for the various classes that DataTables uses - jQuery UI suitable
         *  @type object
         *  @default {}
         */
        "oJUIClasses": {},


        /**
         * Pagination plug-in methods - The style and controls of the pagination can significantly
         * impact on how the end user interacts with the data in your table, and DataTables allows
         * the addition of pagination controls by extending this object, which can then be enabled
         * through the <i>sPaginationType</i> initialisation parameter. Each pagination type that
         * is added is an object (the property name of which is what <i>sPaginationType</i> refers
         * to) that has two properties, both methods that are used by DataTables to update the
         * control's state.
         *   <ul>
         *     <li>
         *       fnInit -  Initialisation of the paging controls. Called only during initialisation
         *         of the table. It is expected that this function will add the required DOM elements
         *         to the page for the paging controls to work. The element pointer
         *         'oSettings.aanFeatures.p' array is provided by DataTables to contain the paging
         *         controls (note that this is a 2D array to allow for multiple instances of each
         *         DataTables DOM element). It is suggested that you add the controls to this element
         *         as children
         *       <ul>
         *         <li>
         *           Function input parameters:
         *           <ul>
         *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
         *             <li>{node} Container into which the pagination controls must be inserted</li>
         *             <li>{function} Draw callback function - whenever the controls cause a page
         *               change, this method must be called to redraw the table.</li>
         *           </ul>
         *         </li>
         *         <li>
         *           Function return:
         *           <ul>
         *             <li>No return required</li>
         *           </ul>
         *         </il>
         *       </ul>
         *     </il>
         *     <li>
         *       fnInit -  This function is called whenever the paging status of the table changes and is
         *         typically used to update classes and/or text of the paging controls to reflex the new
         *         status.
         *       <ul>
         *         <li>
         *           Function input parameters:
         *           <ul>
         *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
         *             <li>{function} Draw callback function - in case you need to redraw the table again
         *               or attach new event listeners</li>
         *           </ul>
         *         </li>
         *         <li>
         *           Function return:
         *           <ul>
         *             <li>No return required</li>
         *           </ul>
         *         </il>
         *       </ul>
         *     </il>
         *   </ul>
         *  @type object
         *  @default {}
         *
         *  @example
         *    $.fn.dataTableExt.oPagination.four_button = {
         *      "fnInit": function ( oSettings, nPaging, fnCallbackDraw ) {
         *        nFirst = document.createElement( 'span' );
         *        nPrevious = document.createElement( 'span' );
         *        nNext = document.createElement( 'span' );
         *        nLast = document.createElement( 'span' );
         *
         *        nFirst.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sFirst ) );
         *        nPrevious.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sPrevious ) );
         *        nNext.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sNext ) );
         *        nLast.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sLast ) );
         *
         *        nFirst.className = "paginate_button first";
         *        nPrevious.className = "paginate_button previous";
         *        nNext.className="paginate_button next";
         *        nLast.className = "paginate_button last";
         *
         *        nPaging.appendChild( nFirst );
         *        nPaging.appendChild( nPrevious );
         *        nPaging.appendChild( nNext );
         *        nPaging.appendChild( nLast );
         *
         *        $(nFirst).click( function () {
         *          oSettings.oApi._fnPageChange( oSettings, "first" );
         *          fnCallbackDraw( oSettings );
         *        } );
         *
         *        $(nPrevious).click( function() {
         *          oSettings.oApi._fnPageChange( oSettings, "previous" );
         *          fnCallbackDraw( oSettings );
         *        } );
         *
         *        $(nNext).click( function() {
         *          oSettings.oApi._fnPageChange( oSettings, "next" );
         *          fnCallbackDraw( oSettings );
         *        } );
         *
         *        $(nLast).click( function() {
         *          oSettings.oApi._fnPageChange( oSettings, "last" );
         *          fnCallbackDraw( oSettings );
         *        } );
         *
         *        $(nFirst).bind( 'selectstart', function () { return false; } );
         *        $(nPrevious).bind( 'selectstart', function () { return false; } );
         *        $(nNext).bind( 'selectstart', function () { return false; } );
         *        $(nLast).bind( 'selectstart', function () { return false; } );
         *      },
         *
         *      "fnUpdate": function ( oSettings, fnCallbackDraw ) {
         *        if ( !oSettings.aanFeatures.p ) {
         *          return;
         *        }
         *
         *        // Loop over each instance of the pager
         *        var an = oSettings.aanFeatures.p;
         *        for ( var i=0, iLen=an.length ; i<iLen ; i++ ) {
         *          var buttons = an[i].getElementsByTagName('span');
         *          if ( oSettings._iDisplayStart === 0 ) {
         *            buttons[0].className = "paginate_disabled_previous";
         *            buttons[1].className = "paginate_disabled_previous";
         *          }
         *          else {
         *            buttons[0].className = "paginate_enabled_previous";
         *            buttons[1].className = "paginate_enabled_previous";
         *          }
         *
         *          if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) {
         *            buttons[2].className = "paginate_disabled_next";
         *            buttons[3].className = "paginate_disabled_next";
         *          }
         *          else {
         *            buttons[2].className = "paginate_enabled_next";
         *            buttons[3].className = "paginate_enabled_next";
         *          }
         *        }
         *      }
         *    };
         */
        "oPagination": {},


        /**
         * Sorting plug-in methods - Sorting in DataTables is based on the detected type of the
         * data column (you can add your own type detection functions, or override automatic
         * detection using sType). With this specific type given to the column, DataTables will
         * apply the required sort from the functions in the object. Each sort type must provide
         * two mandatory methods, one each for ascending and descending sorting, and can optionally
         * provide a pre-formatting method that will help speed up sorting by allowing DataTables
         * to pre-format the sort data only once (rather than every time the actual sort functions
         * are run). The two sorting functions are typical Javascript sort methods:
         *   <ul>
         *     <li>
         *       Function input parameters:
         *       <ul>
         *         <li>{*} Data to compare to the second parameter</li>
         *         <li>{*} Data to compare to the first parameter</li>
         *       </ul>
         *     </li>
         *     <li>
         *       Function return:
         *       <ul>
         *         <li>{int} Sorting match: <0 if first parameter should be sorted lower than
         *           the second parameter, ===0 if the two parameters are equal and >0 if
         *           the first parameter should be sorted height than the second parameter.</li>
         *       </ul>
         *     </il>
         *   </ul>
         *  @type object
         *  @default {}
         *
         *  @example
         *    // Case-sensitive string sorting, with no pre-formatting method
         *    $.extend( $.fn.dataTableExt.oSort, {
         *      "string-case-asc": function(x,y) {
         *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
         *      },
         *      "string-case-desc": function(x,y) {
         *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
         *      }
         *    } );
         *
         *  @example
         *    // Case-insensitive string sorting, with pre-formatting
         *    $.extend( $.fn.dataTableExt.oSort, {
         *      "string-pre": function(x) {
         *        return x.toLowerCase();
         *      },
         *      "string-asc": function(x,y) {
         *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
         *      },
         *      "string-desc": function(x,y) {
         *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
         *      }
         *    } );
         */
        "oSort": {},


        /**
         * Version string for plug-ins to check compatibility. Allowed format is
         * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
         * e are optional
         *  @type string
         *  @default Version number
         */
        "sVersion": DataTable.version,


        /**
         * How should DataTables report an error. Can take the value 'alert' or 'throw'
         *  @type string
         *  @default alert
         */
        "sErrMode": "alert",


        /**
         * Store information for DataTables to access globally about other instances
         *  @namespace
         *  @private
         */
        "_oExternConfig": {
            /* int:iNextUnique - next unique number for an instance */
            "iNextUnique": 0
        }
    };




    /**
     * Template object for the way in which DataTables holds information about
     * search information for the global filter and individual column filters.
     *  @namespace
     */
    DataTable.models.oSearch = {
        /**
         * Flag to indicate if the filtering should be case insensitive or not
         *  @type boolean
         *  @default true
         */
        "bCaseInsensitive": true,

        /**
         * Applied search term
         *  @type string
         *  @default <i>Empty string</i>
         */
        "sSearch": "",

        /**
         * Flag to indicate if the search term should be interpreted as a
         * regular expression (true) or not (false) and therefore and special
         * regex characters escaped.
         *  @type boolean
         *  @default false
         */
        "bRegex": false,

        /**
         * Flag to indicate if DataTables is to use its smart filtering or not.
         *  @type boolean
         *  @default true
         */
        "bSmart": true
    };




    /**
     * Template object for the way in which DataTables holds information about
     * each individual row. This is the object format used for the settings
     * aoData array.
     *  @namespace
     */
    DataTable.models.oRow = {
        /**
         * TR element for the row
         *  @type node
         *  @default null
         */
        "nTr": null,

        /**
         * Data object from the original data source for the row. This is either
         * an array if using the traditional form of DataTables, or an object if
         * using mData options. The exact type will depend on the passed in
         * data from the data source, or will be an array if using DOM a data
         * source.
         *  @type array|object
         *  @default []
         */
        "_aData": [],

        /**
         * Sorting data cache - this array is ostensibly the same length as the
         * number of columns (although each index is generated only as it is
         * needed), and holds the data that is used for sorting each column in the
         * row. We do this cache generation at the start of the sort in order that
         * the formatting of the sort data need be done only once for each cell
         * per sort. This array should not be read from or written to by anything
         * other than the master sorting methods.
         *  @type array
         *  @default []
         *  @private
         */
        "_aSortData": [],

        /**
         * Array of TD elements that are cached for hidden rows, so they can be
         * reinserted into the table if a column is made visible again (or to act
         * as a store if a column is made hidden). Only hidden columns have a
         * reference in the array. For non-hidden columns the value is either
         * undefined or null.
         *  @type array nodes
         *  @default []
         *  @private
         */
        "_anHidden": [],

        /**
         * Cache of the class name that DataTables has applied to the row, so we
         * can quickly look at this variable rather than needing to do a DOM check
         * on className for the nTr property.
         *  @type string
         *  @default <i>Empty string</i>
         *  @private
         */
        "_sRowStripe": ""
    };



    /**
     * Template object for the column information object in DataTables. This object
     * is held in the settings aoColumns array and contains all the information that
     * DataTables needs about each individual column.
     *
     * Note that this object is related to {@link DataTable.defaults.columns}
     * but this one is the internal data store for DataTables's cache of columns.
     * It should NOT be manipulated outside of DataTables. Any configuration should
     * be done through the initialisation options.
     *  @namespace
     */
    DataTable.models.oColumn = {
        /**
         * A list of the columns that sorting should occur on when this column
         * is sorted. That this property is an array allows multi-column sorting
         * to be defined for a column (for example first name / last name columns
         * would benefit from this). The values are integers pointing to the
         * columns to be sorted on (typically it will be a single integer pointing
         * at itself, but that doesn't need to be the case).
         *  @type array
         */
        "aDataSort": null,

        /**
         * Define the sorting directions that are applied to the column, in sequence
         * as the column is repeatedly sorted upon - i.e. the first value is used
         * as the sorting direction when the column if first sorted (clicked on).
         * Sort it again (click again) and it will move on to the next index.
         * Repeat until loop.
         *  @type array
         */
        "asSorting": null,

        /**
         * Flag to indicate if the column is searchable, and thus should be included
         * in the filtering or not.
         *  @type boolean
         */
        "bSearchable": null,

        /**
         * Flag to indicate if the column is sortable or not.
         *  @type boolean
         */
        "bSortable": null,

        /**
         * <code>Deprecated</code> When using fnRender, you have two options for what
         * to do with the data, and this property serves as the switch. Firstly, you
         * can have the sorting and filtering use the rendered value (true - default),
         * or you can have the sorting and filtering us the original value (false).
         *
         * Please note that this option has now been deprecated and will be removed
         * in the next version of DataTables. Please use mRender / mData rather than
         * fnRender.
         *  @type boolean
         *  @deprecated
         */
        "bUseRendered": null,

        /**
         * Flag to indicate if the column is currently visible in the table or not
         *  @type boolean
         */
        "bVisible": null,

        /**
         * Flag to indicate to the type detection method if the automatic type
         * detection should be used, or if a column type (sType) has been specified
         *  @type boolean
         *  @default true
         *  @private
         */
        "_bAutoType": true,

        /**
         * Developer definable function that is called whenever a cell is created (Ajax source,
         * etc) or processed for input (DOM source). This can be used as a compliment to mRender
         * allowing you to modify the DOM element (add background colour for example) when the
         * element is available.
         *  @type function
         *  @param {element} nTd The TD node that has been created
         *  @param {*} sData The Data for the cell
         *  @param {array|object} oData The data for the whole row
         *  @param {int} iRow The row index for the aoData data store
         *  @default null
         */
        "fnCreatedCell": null,

        /**
         * Function to get data from a cell in a column. You should <b>never</b>
         * access data directly through _aData internally in DataTables - always use
         * the method attached to this property. It allows mData to function as
         * required. This function is automatically assigned by the column
         * initialisation method
         *  @type function
         *  @param {array|object} oData The data array/object for the array
         *    (i.e. aoData[]._aData)
         *  @param {string} sSpecific The specific data type you want to get -
         *    'display', 'type' 'filter' 'sort'
         *  @returns {*} The data for the cell from the given row's data
         *  @default null
         */
        "fnGetData": null,

        /**
         * <code>Deprecated</code> Custom display function that will be called for the
         * display of each cell in this column.
         *
         * Please note that this option has now been deprecated and will be removed
         * in the next version of DataTables. Please use mRender / mData rather than
         * fnRender.
         *  @type function
         *  @param {object} o Object with the following parameters:
         *  @param {int}    o.iDataRow The row in aoData
         *  @param {int}    o.iDataColumn The column in question
         *  @param {array}  o.aData The data for the row in question
         *  @param {object} o.oSettings The settings object for this DataTables instance
         *  @returns {string} The string you which to use in the display
         *  @default null
         *  @deprecated
         */
        "fnRender": null,

        /**
         * Function to set data for a cell in the column. You should <b>never</b>
         * set the data directly to _aData internally in DataTables - always use
         * this method. It allows mData to function as required. This function
         * is automatically assigned by the column initialisation method
         *  @type function
         *  @param {array|object} oData The data array/object for the array
         *    (i.e. aoData[]._aData)
         *  @param {*} sValue Value to set
         *  @default null
         */
        "fnSetData": null,

        /**
         * Property to read the value for the cells in the column from the data
         * source array / object. If null, then the default content is used, if a
         * function is given then the return from the function is used.
         *  @type function|int|string|null
         *  @default null
         */
        "mData": null,

        /**
         * Partner property to mData which is used (only when defined) to get
         * the data - i.e. it is basically the same as mData, but without the
         * 'set' option, and also the data fed to it is the result from mData.
         * This is the rendering method to match the data method of mData.
         *  @type function|int|string|null
         *  @default null
         */
        "mRender": null,

        /**
         * Unique header TH/TD element for this column - this is what the sorting
         * listener is attached to (if sorting is enabled.)
         *  @type node
         *  @default null
         */
        "nTh": null,

        /**
         * Unique footer TH/TD element for this column (if there is one). Not used
         * in DataTables as such, but can be used for plug-ins to reference the
         * footer for each column.
         *  @type node
         *  @default null
         */
        "nTf": null,

        /**
         * The class to apply to all TD elements in the table's TBODY for the column
         *  @type string
         *  @default null
         */
        "sClass": null,

        /**
         * When DataTables calculates the column widths to assign to each column,
         * it finds the longest string in each column and then constructs a
         * temporary table and reads the widths from that. The problem with this
         * is that "mmm" is much wider then "iiii", but the latter is a longer
         * string - thus the calculation can go wrong (doing it properly and putting
         * it into an DOM object and measuring that is horribly(!) slow). Thus as
         * a "work around" we provide this option. It will append its value to the
         * text that is found to be the longest string for the column - i.e. padding.
         *  @type string
         */
        "sContentPadding": null,

        /**
         * Allows a default value to be given for a column's data, and will be used
         * whenever a null data source is encountered (this can be because mData
         * is set to null, or because the data source itself is null).
         *  @type string
         *  @default null
         */
        "sDefaultContent": null,

        /**
         * Name for the column, allowing reference to the column by name as well as
         * by index (needs a lookup to work by name).
         *  @type string
         */
        "sName": null,

        /**
         * Custom sorting data type - defines which of the available plug-ins in
         * afnSortData the custom sorting will use - if any is defined.
         *  @type string
         *  @default std
         */
        "sSortDataType": 'std',

        /**
         * Class to be applied to the header element when sorting on this column
         *  @type string
         *  @default null
         */
        "sSortingClass": null,

        /**
         * Class to be applied to the header element when sorting on this column -
         * when jQuery UI theming is used.
         *  @type string
         *  @default null
         */
        "sSortingClassJUI": null,

        /**
         * Title of the column - what is seen in the TH element (nTh).
         *  @type string
         */
        "sTitle": null,

        /**
         * Column sorting and filtering type
         *  @type string
         *  @default null
         */
        "sType": null,

        /**
         * Width of the column
         *  @type string
         *  @default null
         */
        "sWidth": null,

        /**
         * Width of the column when it was first "encountered"
         *  @type string
         *  @default null
         */
        "sWidthOrig": null
    };



    /**
     * Initialisation options that can be given to DataTables at initialisation
     * time.
     *  @namespace
     */
    DataTable.defaults = {
        /**
         * An array of data to use for the table, passed in at initialisation which
         * will be used in preference to any data which is already in the DOM. This is
         * particularly useful for constructing tables purely in Javascript, for
         * example with a custom Ajax call.
         *  @type array
         *  @default null
         *  @dtopt Option
         *
         *  @example
         *    // Using a 2D array data source
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "aaData": [
         *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
         *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
         *        ],
         *        "aoColumns": [
         *          { "sTitle": "Engine" },
         *          { "sTitle": "Browser" },
         *          { "sTitle": "Platform" },
         *          { "sTitle": "Version" },
         *          { "sTitle": "Grade" }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using an array of objects as a data source (mData)
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "aaData": [
         *          {
         *            "engine":   "Trident",
         *            "browser":  "Internet Explorer 4.0",
         *            "platform": "Win 95+",
         *            "version":  4,
         *            "grade":    "X"
         *          },
         *          {
         *            "engine":   "Trident",
         *            "browser":  "Internet Explorer 5.0",
         *            "platform": "Win 95+",
         *            "version":  5,
         *            "grade":    "C"
         *          }
         *        ],
         *        "aoColumns": [
         *          { "sTitle": "Engine",   "mData": "engine" },
         *          { "sTitle": "Browser",  "mData": "browser" },
         *          { "sTitle": "Platform", "mData": "platform" },
         *          { "sTitle": "Version",  "mData": "version" },
         *          { "sTitle": "Grade",    "mData": "grade" }
         *        ]
         *      } );
         *    } );
         */
        "aaData": null,


        /**
         * If sorting is enabled, then DataTables will perform a first pass sort on
         * initialisation. You can define which column(s) the sort is performed upon,
         * and the sorting direction, with this variable. The aaSorting array should
         * contain an array for each column to be sorted initially containing the
         * column's index and a direction string ('asc' or 'desc').
         *  @type array
         *  @default [[0,'asc']]
         *  @dtopt Option
         *
         *  @example
         *    // Sort by 3rd column first, and then 4th column
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aaSorting": [[2,'asc'], [3,'desc']]
         *      } );
         *    } );
         *
         *    // No initial sorting
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aaSorting": []
         *      } );
         *    } );
         */
        "aaSorting": [[0,'asc']],


        /**
         * This parameter is basically identical to the aaSorting parameter, but
         * cannot be overridden by user interaction with the table. What this means
         * is that you could have a column (visible or hidden) which the sorting will
         * always be forced on first - any sorting after that (from the user) will
         * then be performed as required. This can be useful for grouping rows
         * together.
         *  @type array
         *  @default null
         *  @dtopt Option
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aaSortingFixed": [[0,'asc']]
         *      } );
         *    } )
         */
        "aaSortingFixed": null,


        /**
         * This parameter allows you to readily specify the entries in the length drop
         * down menu that DataTables shows when pagination is enabled. It can be
         * either a 1D array of options which will be used for both the displayed
         * option and the value, or a 2D array which will use the array in the first
         * position as the value, and the array in the second position as the
         * displayed options (useful for language strings such as 'All').
         *  @type array
         *  @default [ 10, 25, 50, 100 ]
         *  @dtopt Option
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aLengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
         *      } );
         *    } );
         *
         *  @example
         *    // Setting the default display length as well as length menu
         *    // This is likely to be wanted if you remove the '10' option which
         *    // is the iDisplayLength default.
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "iDisplayLength": 25,
         *        "aLengthMenu": [[25, 50, 100, -1], [25, 50, 100, "All"]]
         *      } );
         *    } );
         */
        "aLengthMenu": [ 10, 25, 50, 100 ],


        /**
         * The aoColumns option in the initialisation parameter allows you to define
         * details about the way individual columns behave. For a full list of
         * column options that can be set, please see
         * {@link DataTable.defaults.columns}. Note that if you use aoColumns to
         * define your columns, you must have an entry in the array for every single
         * column that you have in your table (these can be null if you don't which
         * to specify any options).
         *  @member
         */
        "aoColumns": null,

        /**
         * Very similar to aoColumns, aoColumnDefs allows you to target a specific
         * column, multiple columns, or all columns, using the aTargets property of
         * each object in the array. This allows great flexibility when creating
         * tables, as the aoColumnDefs arrays can be of any length, targeting the
         * columns you specifically want. aoColumnDefs may use any of the column
         * options available: {@link DataTable.defaults.columns}, but it _must_
         * have aTargets defined in each object in the array. Values in the aTargets
         * array may be:
         *   <ul>
         *     <li>a string - class name will be matched on the TH for the column</li>
         *     <li>0 or a positive integer - column index counting from the left</li>
         *     <li>a negative integer - column index counting from the right</li>
         *     <li>the string "_all" - all columns (i.e. assign a default)</li>
         *   </ul>
         *  @member
         */
        "aoColumnDefs": null,


        /**
         * Basically the same as oSearch, this parameter defines the individual column
         * filtering state at initialisation time. The array must be of the same size
         * as the number of columns, and each element be an object with the parameters
         * "sSearch" and "bEscapeRegex" (the latter is optional). 'null' is also
         * accepted and the default will be used.
         *  @type array
         *  @default []
         *  @dtopt Option
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoSearchCols": [
         *          null,
         *          { "sSearch": "My filter" },
         *          null,
         *          { "sSearch": "^[0-9]", "bEscapeRegex": false }
         *        ]
         *      } );
         *    } )
         */
        "aoSearchCols": [],


        /**
         * An array of CSS classes that should be applied to displayed rows. This
         * array may be of any length, and DataTables will apply each class
         * sequentially, looping when required.
         *  @type array
         *  @default null <i>Will take the values determined by the oClasses.sStripe*
         *    options</i>
         *  @dtopt Option
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "asStripeClasses": [ 'strip1', 'strip2', 'strip3' ]
         *      } );
         *    } )
         */
        "asStripeClasses": null,


        /**
         * Enable or disable automatic column width calculation. This can be disabled
         * as an optimisation (it takes some time to calculate the widths) if the
         * tables widths are passed in using aoColumns.
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bAutoWidth": false
         *      } );
         *    } );
         */
        "bAutoWidth": true,


        /**
         * Deferred rendering can provide DataTables with a huge speed boost when you
         * are using an Ajax or JS data source for the table. This option, when set to
         * true, will cause DataTables to defer the creation of the table elements for
         * each row until they are needed for a draw - saving a significant amount of
         * time.
         *  @type boolean
         *  @default false
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "sAjaxSource": "sources/arrays.txt",
         *        "bDeferRender": true
         *      } );
         *    } );
         */
        "bDeferRender": false,


        /**
         * Replace a DataTable which matches the given selector and replace it with
         * one which has the properties of the new initialisation object passed. If no
         * table matches the selector, then the new DataTable will be constructed as
         * per normal.
         *  @type boolean
         *  @default false
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sScrollY": "200px",
         *        "bPaginate": false
         *      } );
         *
         *      // Some time later....
         *      $('#example').dataTable( {
         *        "bFilter": false,
         *        "bDestroy": true
         *      } );
         *    } );
         */
        "bDestroy": false,


        /**
         * Enable or disable filtering of data. Filtering in DataTables is "smart" in
         * that it allows the end user to input multiple words (space separated) and
         * will match a row containing those words, even if not in the order that was
         * specified (this allow matching across multiple columns). Note that if you
         * wish to use filtering in DataTables this must remain 'true' - to remove the
         * default filtering input box and retain filtering abilities, please use
         * {@link DataTable.defaults.sDom}.
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bFilter": false
         *      } );
         *    } );
         */
        "bFilter": true,


        /**
         * Enable or disable the table information display. This shows information
         * about the data that is currently visible on the page, including information
         * about filtered data if that action is being performed.
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bInfo": false
         *      } );
         *    } );
         */
        "bInfo": true,


        /**
         * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
         * slightly different and additional mark-up from what DataTables has
         * traditionally used).
         *  @type boolean
         *  @default false
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bJQueryUI": true
         *      } );
         *    } );
         */
        "bJQueryUI": false,


        /**
         * Allows the end user to select the size of a formatted page from a select
         * menu (sizes are 10, 25, 50 and 100). Requires pagination (bPaginate).
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bLengthChange": false
         *      } );
         *    } );
         */
        "bLengthChange": true,


        /**
         * Enable or disable pagination.
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bPaginate": false
         *      } );
         *    } );
         */
        "bPaginate": true,


        /**
         * Enable or disable the display of a 'processing' indicator when the table is
         * being processed (e.g. a sort). This is particularly useful for tables with
         * large amounts of data where it can take a noticeable amount of time to sort
         * the entries.
         *  @type boolean
         *  @default false
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bProcessing": true
         *      } );
         *    } );
         */
        "bProcessing": false,


        /**
         * Retrieve the DataTables object for the given selector. Note that if the
         * table has already been initialised, this parameter will cause DataTables
         * to simply return the object that has already been set up - it will not take
         * account of any changes you might have made to the initialisation object
         * passed to DataTables (setting this parameter to true is an acknowledgement
         * that you understand this). bDestroy can be used to reinitialise a table if
         * you need.
         *  @type boolean
         *  @default false
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      initTable();
         *      tableActions();
         *    } );
         *
         *    function initTable ()
         *    {
         *      return $('#example').dataTable( {
         *        "sScrollY": "200px",
         *        "bPaginate": false,
         *        "bRetrieve": true
         *      } );
         *    }
         *
         *    function tableActions ()
         *    {
         *      var oTable = initTable();
         *      // perform API operations with oTable
         *    }
         */
        "bRetrieve": false,


        /**
         * Indicate if DataTables should be allowed to set the padding / margin
         * etc for the scrolling header elements or not. Typically you will want
         * this.
         *  @type boolean
         *  @default true
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bScrollAutoCss": false,
         *        "sScrollY": "200px"
         *      } );
         *    } );
         */
        "bScrollAutoCss": true,


        /**
         * When vertical (y) scrolling is enabled, DataTables will force the height of
         * the table's viewport to the given height at all times (useful for layout).
         * However, this can look odd when filtering data down to a small data set,
         * and the footer is left "floating" further down. This parameter (when
         * enabled) will cause DataTables to collapse the table's viewport down when
         * the result set will fit within the given Y height.
         *  @type boolean
         *  @default false
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sScrollY": "200",
         *        "bScrollCollapse": true
         *      } );
         *    } );
         */
        "bScrollCollapse": false,


        /**
         * Enable infinite scrolling for DataTables (to be used in combination with
         * sScrollY). Infinite scrolling means that DataTables will continually load
         * data as a user scrolls through a table, which is very useful for large
         * dataset. This cannot be used with pagination, which is automatically
         * disabled. Note - the Scroller extra for DataTables is recommended in
         * in preference to this option.
         *  @type boolean
         *  @default false
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bScrollInfinite": true,
         *        "bScrollCollapse": true,
         *        "sScrollY": "200px"
         *      } );
         *    } );
         */
        "bScrollInfinite": false,


        /**
         * Configure DataTables to use server-side processing. Note that the
         * sAjaxSource parameter must also be given in order to give DataTables a
         * source to obtain the required data for each draw.
         *  @type boolean
         *  @default false
         *  @dtopt Features
         *  @dtopt Server-side
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bServerSide": true,
         *        "sAjaxSource": "xhr.php"
         *      } );
         *    } );
         */
        "bServerSide": false,


        /**
         * Enable or disable sorting of columns. Sorting of individual columns can be
         * disabled by the "bSortable" option for each column.
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bSort": false
         *      } );
         *    } );
         */
        "bSort": true,


        /**
         * Allows control over whether DataTables should use the top (true) unique
         * cell that is found for a single column, or the bottom (false - default).
         * This is useful when using complex headers.
         *  @type boolean
         *  @default false
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bSortCellsTop": true
         *      } );
         *    } );
         */
        "bSortCellsTop": false,


        /**
         * Enable or disable the addition of the classes 'sorting_1', 'sorting_2' and
         * 'sorting_3' to the columns which are currently being sorted on. This is
         * presented as a feature switch as it can increase processing time (while
         * classes are removed and added) so for large data sets you might want to
         * turn this off.
         *  @type boolean
         *  @default true
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bSortClasses": false
         *      } );
         *    } );
         */
        "bSortClasses": true,


        /**
         * Enable or disable state saving. When enabled a cookie will be used to save
         * table display information such as pagination information, display length,
         * filtering and sorting. As such when the end user reloads the page the
         * display display will match what thy had previously set up.
         *  @type boolean
         *  @default false
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "bStateSave": true
         *      } );
         *    } );
         */
        "bStateSave": false,


        /**
         * Customise the cookie and / or the parameters being stored when using
         * DataTables with state saving enabled. This function is called whenever
         * the cookie is modified, and it expects a fully formed cookie string to be
         * returned. Note that the data object passed in is a Javascript object which
         * must be converted to a string (JSON.stringify for example).
         *  @type function
         *  @param {string} sName Name of the cookie defined by DataTables
         *  @param {object} oData Data to be stored in the cookie
         *  @param {string} sExpires Cookie expires string
         *  @param {string} sPath Path of the cookie to set
         *  @returns {string} Cookie formatted string (which should be encoded by
         *    using encodeURIComponent())
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function () {
         *      $('#example').dataTable( {
         *        "fnCookieCallback": function (sName, oData, sExpires, sPath) {
         *          // Customise oData or sName or whatever else here
         *          return sName + "="+JSON.stringify(oData)+"; expires=" + sExpires +"; path=" + sPath;
         *        }
         *      } );
         *    } );
         */
        "fnCookieCallback": null,


        /**
         * This function is called when a TR element is created (and all TD child
         * elements have been inserted), or registered if using a DOM source, allowing
         * manipulation of the TR element (adding classes etc).
         *  @type function
         *  @param {node} nRow "TR" element for the current row
         *  @param {array} aData Raw data array for this row
         *  @param {int} iDataIndex The index of this row in aoData
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnCreatedRow": function( nRow, aData, iDataIndex ) {
         *          // Bold the grade for all 'A' grade browsers
         *          if ( aData[4] == "A" )
         *          {
         *            $('td:eq(4)', nRow).html( '<b>A</b>' );
         *          }
         *        }
         *      } );
         *    } );
         */
        "fnCreatedRow": null,


        /**
         * This function is called on every 'draw' event, and allows you to
         * dynamically modify any aspect you want about the created DOM.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnDrawCallback": function( oSettings ) {
         *          alert( 'DataTables has redrawn the table' );
         *        }
         *      } );
         *    } );
         */
        "fnDrawCallback": null,


        /**
         * Identical to fnHeaderCallback() but for the table footer this function
         * allows you to modify the table footer on every 'draw' even.
         *  @type function
         *  @param {node} nFoot "TR" element for the footer
         *  @param {array} aData Full table data (as derived from the original HTML)
         *  @param {int} iStart Index for the current display starting point in the
         *    display array
         *  @param {int} iEnd Index for the current display ending point in the
         *    display array
         *  @param {array int} aiDisplay Index array to translate the visual position
         *    to the full data array
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnFooterCallback": function( nFoot, aData, iStart, iEnd, aiDisplay ) {
         *          nFoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+iStart;
         *        }
         *      } );
         *    } )
         */
        "fnFooterCallback": null,


        /**
         * When rendering large numbers in the information element for the table
         * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
         * to have a comma separator for the 'thousands' units (e.g. 1 million is
         * rendered as "1,000,000") to help readability for the end user. This
         * function will override the default method DataTables uses.
         *  @type function
         *  @member
         *  @param {int} iIn number to be formatted
         *  @returns {string} formatted string for DataTables to show the number
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnFormatNumber": function ( iIn ) {
         *          if ( iIn &lt; 1000 ) {
         *            return iIn;
         *          } else {
         *            var
         *              s=(iIn+""),
         *              a=s.split(""), out="",
         *              iLen=s.length;
         *
         *            for ( var i=0 ; i&lt;iLen ; i++ ) {
         *              if ( i%3 === 0 &amp;&amp; i !== 0 ) {
         *                out = "'"+out;
         *              }
         *              out = a[iLen-i-1]+out;
         *            }
         *          }
         *          return out;
         *        };
         *      } );
         *    } );
         */
        "fnFormatNumber": function ( iIn ) {
            if ( iIn < 1000 )
            {
                // A small optimisation for what is likely to be the majority of use cases
                return iIn;
            }

            var s=(iIn+""), a=s.split(""), out="", iLen=s.length;

            for ( var i=0 ; i<iLen ; i++ )
            {
                if ( i%3 === 0 && i !== 0 )
                {
                    out = this.oLanguage.sInfoThousands+out;
                }
                out = a[iLen-i-1]+out;
            }
            return out;
        },


        /**
         * This function is called on every 'draw' event, and allows you to
         * dynamically modify the header row. This can be used to calculate and
         * display useful information about the table.
         *  @type function
         *  @param {node} nHead "TR" element for the header
         *  @param {array} aData Full table data (as derived from the original HTML)
         *  @param {int} iStart Index for the current display starting point in the
         *    display array
         *  @param {int} iEnd Index for the current display ending point in the
         *    display array
         *  @param {array int} aiDisplay Index array to translate the visual position
         *    to the full data array
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnHeaderCallback": function( nHead, aData, iStart, iEnd, aiDisplay ) {
         *          nHead.getElementsByTagName('th')[0].innerHTML = "Displaying "+(iEnd-iStart)+" records";
         *        }
         *      } );
         *    } )
         */
        "fnHeaderCallback": null,


        /**
         * The information element can be used to convey information about the current
         * state of the table. Although the internationalisation options presented by
         * DataTables are quite capable of dealing with most customisations, there may
         * be times where you wish to customise the string further. This callback
         * allows you to do exactly that.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @param {int} iStart Starting position in data for the draw
         *  @param {int} iEnd End position in data for the draw
         *  @param {int} iMax Total number of rows in the table (regardless of
         *    filtering)
         *  @param {int} iTotal Total number of rows in the data set, after filtering
         *  @param {string} sPre The string that DataTables has formatted using it's
         *    own rules
         *  @returns {string} The string to be displayed in the information element.
         *  @dtopt Callbacks
         *
         *  @example
         *    $('#example').dataTable( {
         *      "fnInfoCallback": function( oSettings, iStart, iEnd, iMax, iTotal, sPre ) {
         *        return iStart +" to "+ iEnd;
         *      }
         *    } );
         */
        "fnInfoCallback": null,


        /**
         * Called when the table has been initialised. Normally DataTables will
         * initialise sequentially and there will be no need for this function,
         * however, this does not hold true when using external language information
         * since that is obtained using an async XHR call.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @param {object} json The JSON object request from the server - only
         *    present if client-side Ajax sourced data is used
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnInitComplete": function(oSettings, json) {
         *          alert( 'DataTables has finished its initialisation.' );
         *        }
         *      } );
         *    } )
         */
        "fnInitComplete": null,


        /**
         * Called at the very start of each table draw and can be used to cancel the
         * draw by returning false, any other return (including undefined) results in
         * the full draw occurring).
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @returns {boolean} False will cancel the draw, anything else (including no
         *    return) will allow it to complete.
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnPreDrawCallback": function( oSettings ) {
         *          if ( $('#test').val() == 1 ) {
         *            return false;
         *          }
         *        }
         *      } );
         *    } );
         */
        "fnPreDrawCallback": null,


        /**
         * This function allows you to 'post process' each row after it have been
         * generated for each table draw, but before it is rendered on screen. This
         * function might be used for setting the row class name etc.
         *  @type function
         *  @param {node} nRow "TR" element for the current row
         *  @param {array} aData Raw data array for this row
         *  @param {int} iDisplayIndex The display index for the current table draw
         *  @param {int} iDisplayIndexFull The index of the data in the full list of
         *    rows (after filtering)
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "fnRowCallback": function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
         *          // Bold the grade for all 'A' grade browsers
         *          if ( aData[4] == "A" )
         *          {
         *            $('td:eq(4)', nRow).html( '<b>A</b>' );
         *          }
         *        }
         *      } );
         *    } );
         */
        "fnRowCallback": null,


        /**
         * This parameter allows you to override the default function which obtains
         * the data from the server ($.getJSON) so something more suitable for your
         * application. For example you could use POST data, or pull information from
         * a Gears or AIR database.
         *  @type function
         *  @member
         *  @param {string} sSource HTTP source to obtain the data from (sAjaxSource)
         *  @param {array} aoData A key/value pair object containing the data to send
         *    to the server
         *  @param {function} fnCallback to be called on completion of the data get
         *    process that will draw the data on the page.
         *  @param {object} oSettings DataTables settings object
         *  @dtopt Callbacks
         *  @dtopt Server-side
         *
         *  @example
         *    // POST data to server
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bProcessing": true,
         *        "bServerSide": true,
         *        "sAjaxSource": "xhr.php",
         *        "fnServerData": function ( sSource, aoData, fnCallback, oSettings ) {
         *          oSettings.jqXHR = $.ajax( {
         *            "dataType": 'json',
         *            "type": "POST",
         *            "url": sSource,
         *            "data": aoData,
         *            "success": fnCallback
         *          } );
         *        }
         *      } );
         *    } );
         */
        "fnServerData": function ( sUrl, aoData, fnCallback, oSettings ) {
            oSettings.jqXHR = $.ajax( {
                "url":  sUrl,
                "data": aoData,
                "success": function (json) {
                    if ( json.sError ) {
                        oSettings.oApi._fnLog( oSettings, 0, json.sError );
                    }

                    $(oSettings.oInstance).trigger('xhr', [oSettings, json]);
                    fnCallback( json );
                },
                "dataType": "json",
                "cache": false,
                "type": oSettings.sServerMethod,
                "error": function (xhr, error, thrown) {
                    if ( error == "parsererror" ) {
                        oSettings.oApi._fnLog( oSettings, 0, "DataTables warning: JSON data from "+
                            "server could not be parsed. This is caused by a JSON formatting error." );
                    }
                }
            } );
        },


        /**
         * It is often useful to send extra data to the server when making an Ajax
         * request - for example custom filtering information, and this callback
         * function makes it trivial to send extra information to the server. The
         * passed in parameter is the data set that has been constructed by
         * DataTables, and you can add to this or modify it as you require.
         *  @type function
         *  @param {array} aoData Data array (array of objects which are name/value
         *    pairs) that has been constructed by DataTables and will be sent to the
         *    server. In the case of Ajax sourced data with server-side processing
         *    this will be an empty array, for server-side processing there will be a
         *    significant number of parameters!
         *  @returns {undefined} Ensure that you modify the aoData array passed in,
         *    as this is passed by reference.
         *  @dtopt Callbacks
         *  @dtopt Server-side
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bProcessing": true,
         *        "bServerSide": true,
         *        "sAjaxSource": "scripts/server_processing.php",
         *        "fnServerParams": function ( aoData ) {
         *          aoData.push( { "name": "more_data", "value": "my_value" } );
         *        }
         *      } );
         *    } );
         */
        "fnServerParams": null,


        /**
         * Load the table state. With this function you can define from where, and how, the
         * state of a table is loaded. By default DataTables will load from its state saving
         * cookie, but you might wish to use local storage (HTML5) or a server-side database.
         *  @type function
         *  @member
         *  @param {object} oSettings DataTables settings object
         *  @return {object} The DataTables state object to be loaded
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bStateSave": true,
         *        "fnStateLoad": function (oSettings) {
         *          var o;
         *
         *          // Send an Ajax request to the server to get the data. Note that
         *          // this is a synchronous request.
         *          $.ajax( {
         *            "url": "/state_load",
         *            "async": false,
         *            "dataType": "json",
         *            "success": function (json) {
         *              o = json;
         *            }
         *          } );
         *
         *          return o;
         *        }
         *      } );
         *    } );
         */
        "fnStateLoad": function ( oSettings ) {
            var sData = this.oApi._fnReadCookie( oSettings.sCookiePrefix+oSettings.sInstance );
            var oData;

            try {
                oData = (typeof $.parseJSON === 'function') ?
                    $.parseJSON(sData) : eval( '('+sData+')' );
            } catch (e) {
                oData = null;
            }

            return oData;
        },


        /**
         * Callback which allows modification of the saved state prior to loading that state.
         * This callback is called when the table is loading state from the stored data, but
         * prior to the settings object being modified by the saved state. Note that for
         * plug-in authors, you should use the 'stateLoadParams' event to load parameters for
         * a plug-in.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @param {object} oData The state object that is to be loaded
         *  @dtopt Callbacks
         *
         *  @example
         *    // Remove a saved filter, so filtering is never loaded
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bStateSave": true,
         *        "fnStateLoadParams": function (oSettings, oData) {
         *          oData.oSearch.sSearch = "";
         *        }
         *      } );
         *    } );
         *
         *  @example
         *    // Disallow state loading by returning false
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bStateSave": true,
         *        "fnStateLoadParams": function (oSettings, oData) {
         *          return false;
         *        }
         *      } );
         *    } );
         */
        "fnStateLoadParams": null,


        /**
         * Callback that is called when the state has been loaded from the state saving method
         * and the DataTables settings object has been modified as a result of the loaded state.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @param {object} oData The state object that was loaded
         *  @dtopt Callbacks
         *
         *  @example
         *    // Show an alert with the filtering value that was saved
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bStateSave": true,
         *        "fnStateLoaded": function (oSettings, oData) {
         *          alert( 'Saved filter was: '+oData.oSearch.sSearch );
         *        }
         *      } );
         *    } );
         */
        "fnStateLoaded": null,


        /**
         * Save the table state. This function allows you to define where and how the state
         * information for the table is stored - by default it will use a cookie, but you
         * might want to use local storage (HTML5) or a server-side database.
         *  @type function
         *  @member
         *  @param {object} oSettings DataTables settings object
         *  @param {object} oData The state object to be saved
         *  @dtopt Callbacks
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bStateSave": true,
         *        "fnStateSave": function (oSettings, oData) {
         *          // Send an Ajax request to the server with the state object
         *          $.ajax( {
         *            "url": "/state_save",
         *            "data": oData,
         *            "dataType": "json",
         *            "method": "POST"
         *            "success": function () {}
         *          } );
         *        }
         *      } );
         *    } );
         */
        "fnStateSave": function ( oSettings, oData ) {
            this.oApi._fnCreateCookie(
                oSettings.sCookiePrefix+oSettings.sInstance,
                this.oApi._fnJsonString(oData),
                oSettings.iCookieDuration,
                oSettings.sCookiePrefix,
                oSettings.fnCookieCallback
            );
        },


        /**
         * Callback which allows modification of the state to be saved. Called when the table
         * has changed state a new state save is required. This method allows modification of
         * the state saving object prior to actually doing the save, including addition or
         * other state properties or modification. Note that for plug-in authors, you should
         * use the 'stateSaveParams' event to save parameters for a plug-in.
         *  @type function
         *  @param {object} oSettings DataTables settings object
         *  @param {object} oData The state object to be saved
         *  @dtopt Callbacks
         *
         *  @example
         *    // Remove a saved filter, so filtering is never saved
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bStateSave": true,
         *        "fnStateSaveParams": function (oSettings, oData) {
         *          oData.oSearch.sSearch = "";
         *        }
         *      } );
         *    } );
         */
        "fnStateSaveParams": null,


        /**
         * Duration of the cookie which is used for storing session information. This
         * value is given in seconds.
         *  @type int
         *  @default 7200 <i>(2 hours)</i>
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "iCookieDuration": 60*60*24; // 1 day
         *      } );
         *    } )
         */
        "iCookieDuration": 7200,


        /**
         * When enabled DataTables will not make a request to the server for the first
         * page draw - rather it will use the data already on the page (no sorting etc
         * will be applied to it), thus saving on an XHR at load time. iDeferLoading
         * is used to indicate that deferred loading is required, but it is also used
         * to tell DataTables how many records there are in the full table (allowing
         * the information element and pagination to be displayed correctly). In the case
         * where a filtering is applied to the table on initial load, this can be
         * indicated by giving the parameter as an array, where the first element is
         * the number of records available after filtering and the second element is the
         * number of records without filtering (allowing the table information element
         * to be shown correctly).
         *  @type int | array
         *  @default null
         *  @dtopt Options
         *
         *  @example
         *    // 57 records available in the table, no filtering applied
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bServerSide": true,
         *        "sAjaxSource": "scripts/server_processing.php",
         *        "iDeferLoading": 57
         *      } );
         *    } );
         *
         *  @example
         *    // 57 records after filtering, 100 without filtering (an initial filter applied)
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bServerSide": true,
         *        "sAjaxSource": "scripts/server_processing.php",
         *        "iDeferLoading": [ 57, 100 ],
         *        "oSearch": {
         *          "sSearch": "my_filter"
         *        }
         *      } );
         *    } );
         */
        "iDeferLoading": null,


        /**
         * Number of rows to display on a single page when using pagination. If
         * feature enabled (bLengthChange) then the end user will be able to override
         * this to a custom setting using a pop-up menu.
         *  @type int
         *  @default 10
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "iDisplayLength": 50
         *      } );
         *    } )
         */
        "iDisplayLength": 10,


        /**
         * Define the starting point for data display when using DataTables with
         * pagination. Note that this parameter is the number of records, rather than
         * the page number, so if you have 10 records per page and want to start on
         * the third page, it should be "20".
         *  @type int
         *  @default 0
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "iDisplayStart": 20
         *      } );
         *    } )
         */
        "iDisplayStart": 0,


        /**
         * The scroll gap is the amount of scrolling that is left to go before
         * DataTables will load the next 'page' of data automatically. You typically
         * want a gap which is big enough that the scrolling will be smooth for the
         * user, while not so large that it will load more data than need.
         *  @type int
         *  @default 100
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bScrollInfinite": true,
         *        "bScrollCollapse": true,
         *        "sScrollY": "200px",
         *        "iScrollLoadGap": 50
         *      } );
         *    } );
         */
        "iScrollLoadGap": 100,


        /**
         * By default DataTables allows keyboard navigation of the table (sorting, paging,
         * and filtering) by adding a tabindex attribute to the required elements. This
         * allows you to tab through the controls and press the enter key to activate them.
         * The tabindex is default 0, meaning that the tab follows the flow of the document.
         * You can overrule this using this parameter if you wish. Use a value of -1 to
         * disable built-in keyboard navigation.
         *  @type int
         *  @default 0
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "iTabIndex": 1
         *      } );
         *    } );
         */
        "iTabIndex": 0,


        /**
         * All strings that DataTables uses in the user interface that it creates
         * are defined in this object, allowing you to modified them individually or
         * completely replace them all as required.
         *  @namespace
         */
        "oLanguage": {
            /**
             * Strings that are used for WAI-ARIA labels and controls only (these are not
             * actually visible on the page, but will be read by screenreaders, and thus
             * must be internationalised as well).
             *  @namespace
             */
            "oAria": {
                /**
                 * ARIA label that is added to the table headers when the column may be
                 * sorted ascending by activing the column (click or return when focused).
                 * Note that the column header is prefixed to this string.
                 *  @type string
                 *  @default : activate to sort column ascending
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "oLanguage": {
                 *          "oAria": {
                 *            "sSortAscending": " - click/return to sort ascending"
                 *          }
                 *        }
                 *      } );
                 *    } );
                 */
                "sSortAscending": ": activate to sort column ascending",

                /**
                 * ARIA label that is added to the table headers when the column may be
                 * sorted descending by activing the column (click or return when focused).
                 * Note that the column header is prefixed to this string.
                 *  @type string
                 *  @default : activate to sort column ascending
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "oLanguage": {
                 *          "oAria": {
                 *            "sSortDescending": " - click/return to sort descending"
                 *          }
                 *        }
                 *      } );
                 *    } );
                 */
                "sSortDescending": ": activate to sort column descending"
            },

            /**
             * Pagination string used by DataTables for the two built-in pagination
             * control types ("two_button" and "full_numbers")
             *  @namespace
             */
            "oPaginate": {
                /**
                 * Text to use when using the 'full_numbers' type of pagination for the
                 * button to take the user to the first page.
                 *  @type string
                 *  @default First
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "oLanguage": {
                 *          "oPaginate": {
                 *            "sFirst": "First page"
                 *          }
                 *        }
                 *      } );
                 *    } );
                 */
                "sFirst": "First",


                /**
                 * Text to use when using the 'full_numbers' type of pagination for the
                 * button to take the user to the last page.
                 *  @type string
                 *  @default Last
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "oLanguage": {
                 *          "oPaginate": {
                 *            "sLast": "Last page"
                 *          }
                 *        }
                 *      } );
                 *    } );
                 */
                "sLast": "Last",


                /**
                 * Text to use for the 'next' pagination button (to take the user to the
                 * next page).
                 *  @type string
                 *  @default Next
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "oLanguage": {
                 *          "oPaginate": {
                 *            "sNext": "Next page"
                 *          }
                 *        }
                 *      } );
                 *    } );
                 */
                "sNext": "Next",


                /**
                 * Text to use for the 'previous' pagination button (to take the user to
                 * the previous page).
                 *  @type string
                 *  @default Previous
                 *  @dtopt Language
                 *
                 *  @example
                 *    $(document).ready( function() {
                 *      $('#example').dataTable( {
                 *        "oLanguage": {
                 *          "oPaginate": {
                 *            "sPrevious": "Previous page"
                 *          }
                 *        }
                 *      } );
                 *    } );
                 */
                "sPrevious": "Previous"
            },

            /**
             * This string is shown in preference to sZeroRecords when the table is
             * empty of data (regardless of filtering). Note that this is an optional
             * parameter - if it is not given, the value of sZeroRecords will be used
             * instead (either the default or given value).
             *  @type string
             *  @default No data available in table
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sEmptyTable": "No data available in table"
             *        }
             *      } );
             *    } );
             */
            "sEmptyTable": "No data available in table",


            /**
             * This string gives information to the end user about the information that
             * is current on display on the page. The _START_, _END_ and _TOTAL_
             * variables are all dynamically replaced as the table display updates, and
             * can be freely moved or removed as the language requirements change.
             *  @type string
             *  @default Showing _START_ to _END_ of _TOTAL_ entries
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sInfo": "Got a total of _TOTAL_ entries to show (_START_ to _END_)"
             *        }
             *      } );
             *    } );
             */
            "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


            /**
             * Display information string for when the table is empty. Typically the
             * format of this string should match sInfo.
             *  @type string
             *  @default Showing 0 to 0 of 0 entries
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sInfoEmpty": "No entries to show"
             *        }
             *      } );
             *    } );
             */
            "sInfoEmpty": "Showing 0 to 0 of 0 entries",


            /**
             * When a user filters the information in a table, this string is appended
             * to the information (sInfo) to give an idea of how strong the filtering
             * is. The variable _MAX_ is dynamically updated.
             *  @type string
             *  @default (filtered from _MAX_ total entries)
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sInfoFiltered": " - filtering from _MAX_ records"
             *        }
             *      } );
             *    } );
             */
            "sInfoFiltered": "(filtered from _MAX_ total entries)",


            /**
             * If can be useful to append extra information to the info string at times,
             * and this variable does exactly that. This information will be appended to
             * the sInfo (sInfoEmpty and sInfoFiltered in whatever combination they are
             * being used) at all times.
             *  @type string
             *  @default <i>Empty string</i>
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sInfoPostFix": "All records shown are derived from real information."
             *        }
             *      } );
             *    } );
             */
            "sInfoPostFix": "",


            /**
             * DataTables has a build in number formatter (fnFormatNumber) which is used
             * to format large numbers that are used in the table information. By
             * default a comma is used, but this can be trivially changed to any
             * character you wish with this parameter.
             *  @type string
             *  @default ,
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sInfoThousands": "'"
             *        }
             *      } );
             *    } );
             */
            "sInfoThousands": ",",


            /**
             * Detail the action that will be taken when the drop down menu for the
             * pagination length option is changed. The '_MENU_' variable is replaced
             * with a default select list of 10, 25, 50 and 100, and can be replaced
             * with a custom select box if required.
             *  @type string
             *  @default Show _MENU_ entries
             *  @dtopt Language
             *
             *  @example
             *    // Language change only
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sLengthMenu": "Display _MENU_ records"
             *        }
             *      } );
             *    } );
             *
             *  @example
             *    // Language and options change
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sLengthMenu": 'Display <select>'+
             *            '<option value="10">10</option>'+
             *            '<option value="20">20</option>'+
             *            '<option value="30">30</option>'+
             *            '<option value="40">40</option>'+
             *            '<option value="50">50</option>'+
             *            '<option value="-1">All</option>'+
             *            '</select> records'
             *        }
             *      } );
             *    } );
             */
            "sLengthMenu": "Show _MENU_ entries",


            /**
             * When using Ajax sourced data and during the first draw when DataTables is
             * gathering the data, this message is shown in an empty row in the table to
             * indicate to the end user the the data is being loaded. Note that this
             * parameter is not used when loading data by server-side processing, just
             * Ajax sourced data with client-side processing.
             *  @type string
             *  @default Loading...
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sLoadingRecords": "Please wait - loading..."
             *        }
             *      } );
             *    } );
             */
            "sLoadingRecords": "Loading...",


            /**
             * Text which is displayed when the table is processing a user action
             * (usually a sort command or similar).
             *  @type string
             *  @default Processing...
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sProcessing": "DataTables is currently busy"
             *        }
             *      } );
             *    } );
             */
            "sProcessing": "Processing...",


            /**
             * Details the actions that will be taken when the user types into the
             * filtering input text box. The variable "_INPUT_", if used in the string,
             * is replaced with the HTML text box for the filtering input allowing
             * control over where it appears in the string. If "_INPUT_" is not given
             * then the input box is appended to the string automatically.
             *  @type string
             *  @default Search:
             *  @dtopt Language
             *
             *  @example
             *    // Input text box will be appended at the end automatically
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sSearch": "Filter records:"
             *        }
             *      } );
             *    } );
             *
             *  @example
             *    // Specify where the filter should appear
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sSearch": "Apply filter _INPUT_ to table"
             *        }
             *      } );
             *    } );
             */
            "sSearch": "Search:",


            /**
             * All of the language information can be stored in a file on the
             * server-side, which DataTables will look up if this parameter is passed.
             * It must store the URL of the language file, which is in a JSON format,
             * and the object has the same properties as the oLanguage object in the
             * initialiser object (i.e. the above parameters). Please refer to one of
             * the example language files to see how this works in action.
             *  @type string
             *  @default <i>Empty string - i.e. disabled</i>
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sUrl": "http://www.sprymedia.co.uk/dataTables/lang.txt"
             *        }
             *      } );
             *    } );
             */
            "sUrl": "",


            /**
             * Text shown inside the table records when the is no information to be
             * displayed after filtering. sEmptyTable is shown when there is simply no
             * information in the table at all (regardless of filtering).
             *  @type string
             *  @default No matching records found
             *  @dtopt Language
             *
             *  @example
             *    $(document).ready( function() {
             *      $('#example').dataTable( {
             *        "oLanguage": {
             *          "sZeroRecords": "No records to display"
             *        }
             *      } );
             *    } );
             */
            "sZeroRecords": "No matching records found"
        },


        /**
         * This parameter allows you to have define the global filtering state at
         * initialisation time. As an object the "sSearch" parameter must be
         * defined, but all other parameters are optional. When "bRegex" is true,
         * the search string will be treated as a regular expression, when false
         * (default) it will be treated as a straight string. When "bSmart"
         * DataTables will use it's smart filtering methods (to word match at
         * any point in the data), when false this will not be done.
         *  @namespace
         *  @extends DataTable.models.oSearch
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "oSearch": {"sSearch": "Initial search"}
         *      } );
         *    } )
         */
        "oSearch": $.extend( {}, DataTable.models.oSearch ),


        /**
         * By default DataTables will look for the property 'aaData' when obtaining
         * data from an Ajax source or for server-side processing - this parameter
         * allows that property to be changed. You can use Javascript dotted object
         * notation to get a data source for multiple levels of nesting.
         *  @type string
         *  @default aaData
         *  @dtopt Options
         *  @dtopt Server-side
         *
         *  @example
         *    // Get data from { "data": [...] }
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "sAjaxSource": "sources/data.txt",
         *        "sAjaxDataProp": "data"
         *      } );
         *    } );
         *
         *  @example
         *    // Get data from { "data": { "inner": [...] } }
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "sAjaxSource": "sources/data.txt",
         *        "sAjaxDataProp": "data.inner"
         *      } );
         *    } );
         */
        "sAjaxDataProp": "aaData",


        /**
         * You can instruct DataTables to load data from an external source using this
         * parameter (use aData if you want to pass data in you already have). Simply
         * provide a url a JSON object can be obtained from. This object must include
         * the parameter 'aaData' which is the data source for the table.
         *  @type string
         *  @default null
         *  @dtopt Options
         *  @dtopt Server-side
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sAjaxSource": "http://www.sprymedia.co.uk/dataTables/json.php"
         *      } );
         *    } )
         */
        "sAjaxSource": null,


        /**
         * This parameter can be used to override the default prefix that DataTables
         * assigns to a cookie when state saving is enabled.
         *  @type string
         *  @default SpryMedia_DataTables_
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sCookiePrefix": "my_datatable_",
         *      } );
         *    } );
         */
        "sCookiePrefix": "SpryMedia_DataTables_",


        /**
         * This initialisation variable allows you to specify exactly where in the
         * DOM you want DataTables to inject the various controls it adds to the page
         * (for example you might want the pagination controls at the top of the
         * table). DIV elements (with or without a custom class) can also be added to
         * aid styling. The follow syntax is used:
         *   <ul>
         *     <li>The following options are allowed:
         *       <ul>
         *         <li>'l' - Length changing</li
         *         <li>'f' - Filtering input</li>
         *         <li>'t' - The table!</li>
         *         <li>'i' - Information</li>
         *         <li>'p' - Pagination</li>
         *         <li>'r' - pRocessing</li>
         *       </ul>
         *     </li>
         *     <li>The following constants are allowed:
         *       <ul>
         *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
         *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
         *       </ul>
         *     </li>
         *     <li>The following syntax is expected:
         *       <ul>
         *         <li>'&lt;' and '&gt;' - div elements</li>
         *         <li>'&lt;"class" and '&gt;' - div with a class</li>
         *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
         *       </ul>
         *     </li>
         *     <li>Examples:
         *       <ul>
         *         <li>'&lt;"wrapper"flipt&gt;'</li>
         *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
         *       </ul>
         *     </li>
         *   </ul>
         *  @type string
         *  @default lfrtip <i>(when bJQueryUI is false)</i> <b>or</b>
         *    <"H"lfr>t<"F"ip> <i>(when bJQueryUI is true)</i>
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sDom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
         *      } );
         *    } );
         */
        "sDom": "lfrtip",


        /**
         * DataTables features two different built-in pagination interaction methods
         * ('two_button' or 'full_numbers') which present different page controls to
         * the end user. Further methods can be added using the API (see below).
         *  @type string
         *  @default two_button
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sPaginationType": "full_numbers"
         *      } );
         *    } )
         */
        "sPaginationType": "two_button",


        /**
         * Enable horizontal scrolling. When a table is too wide to fit into a certain
         * layout, or you have a large number of columns in the table, you can enable
         * x-scrolling to show the table in a viewport, which can be scrolled. This
         * property can be any CSS unit, or a number (in which case it will be treated
         * as a pixel measurement).
         *  @type string
         *  @default <i>blank string - i.e. disabled</i>
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sScrollX": "100%",
         *        "bScrollCollapse": true
         *      } );
         *    } );
         */
        "sScrollX": "",


        /**
         * This property can be used to force a DataTable to use more width than it
         * might otherwise do when x-scrolling is enabled. For example if you have a
         * table which requires to be well spaced, this parameter is useful for
         * "over-sizing" the table, and thus forcing scrolling. This property can by
         * any CSS unit, or a number (in which case it will be treated as a pixel
         * measurement).
         *  @type string
         *  @default <i>blank string - i.e. disabled</i>
         *  @dtopt Options
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sScrollX": "100%",
         *        "sScrollXInner": "110%"
         *      } );
         *    } );
         */
        "sScrollXInner": "",


        /**
         * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
         * to the given height, and enable scrolling for any data which overflows the
         * current viewport. This can be used as an alternative to paging to display
         * a lot of data in a small area (although paging and scrolling can both be
         * enabled at the same time). This property can be any CSS unit, or a number
         * (in which case it will be treated as a pixel measurement).
         *  @type string
         *  @default <i>blank string - i.e. disabled</i>
         *  @dtopt Features
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "sScrollY": "200px",
         *        "bPaginate": false
         *      } );
         *    } );
         */
        "sScrollY": "",


        /**
         * Set the HTTP method that is used to make the Ajax call for server-side
         * processing or Ajax sourced data.
         *  @type string
         *  @default GET
         *  @dtopt Options
         *  @dtopt Server-side
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "bServerSide": true,
         *        "sAjaxSource": "scripts/post.php",
         *        "sServerMethod": "POST"
         *      } );
         *    } );
         */
        "sServerMethod": "GET"
    };



    /**
     * Column options that can be given to DataTables at initialisation time.
     *  @namespace
     */
    DataTable.defaults.columns = {
        /**
         * Allows a column's sorting to take multiple columns into account when
         * doing a sort. For example first name / last name columns make sense to
         * do a multi-column sort over the two columns.
         *  @type array
         *  @default null <i>Takes the value of the column index automatically</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "aDataSort": [ 0, 1 ], "aTargets": [ 0 ] },
         *          { "aDataSort": [ 1, 0 ], "aTargets": [ 1 ] },
         *          { "aDataSort": [ 2, 3, 4 ], "aTargets": [ 2 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "aDataSort": [ 0, 1 ] },
         *          { "aDataSort": [ 1, 0 ] },
         *          { "aDataSort": [ 2, 3, 4 ] },
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "aDataSort": null,


        /**
         * You can control the default sorting direction, and even alter the behaviour
         * of the sort handler (i.e. only allow ascending sorting etc) using this
         * parameter.
         *  @type array
         *  @default [ 'asc', 'desc' ]
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "asSorting": [ "asc" ], "aTargets": [ 1 ] },
         *          { "asSorting": [ "desc", "asc", "asc" ], "aTargets": [ 2 ] },
         *          { "asSorting": [ "desc" ], "aTargets": [ 3 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          null,
         *          { "asSorting": [ "asc" ] },
         *          { "asSorting": [ "desc", "asc", "asc" ] },
         *          { "asSorting": [ "desc" ] },
         *          null
         *        ]
         *      } );
         *    } );
         */
        "asSorting": [ 'asc', 'desc' ],


        /**
         * Enable or disable filtering on the data in this column.
         *  @type boolean
         *  @default true
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "bSearchable": false, "aTargets": [ 0 ] }
         *        ] } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "bSearchable": false },
         *          null,
         *          null,
         *          null,
         *          null
         *        ] } );
         *    } );
         */
        "bSearchable": true,


        /**
         * Enable or disable sorting on this column.
         *  @type boolean
         *  @default true
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "bSortable": false, "aTargets": [ 0 ] }
         *        ] } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "bSortable": false },
         *          null,
         *          null,
         *          null,
         *          null
         *        ] } );
         *    } );
         */
        "bSortable": true,


        /**
         * <code>Deprecated</code> When using fnRender() for a column, you may wish
         * to use the original data (before rendering) for sorting and filtering
         * (the default is to used the rendered data that the user can see). This
         * may be useful for dates etc.
         *
         * Please note that this option has now been deprecated and will be removed
         * in the next version of DataTables. Please use mRender / mData rather than
         * fnRender.
         *  @type boolean
         *  @default true
         *  @dtopt Columns
         *  @deprecated
         */
        "bUseRendered": true,


        /**
         * Enable or disable the display of this column.
         *  @type boolean
         *  @default true
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "bVisible": false, "aTargets": [ 0 ] }
         *        ] } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "bVisible": false },
         *          null,
         *          null,
         *          null,
         *          null
         *        ] } );
         *    } );
         */
        "bVisible": true,


        /**
         * Developer definable function that is called whenever a cell is created (Ajax source,
         * etc) or processed for input (DOM source). This can be used as a compliment to mRender
         * allowing you to modify the DOM element (add background colour for example) when the
         * element is available.
         *  @type function
         *  @param {element} nTd The TD node that has been created
         *  @param {*} sData The Data for the cell
         *  @param {array|object} oData The data for the whole row
         *  @param {int} iRow The row index for the aoData data store
         *  @param {int} iCol The column index for aoColumns
         *  @dtopt Columns
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [ {
         *          "aTargets": [3],
         *          "fnCreatedCell": function (nTd, sData, oData, iRow, iCol) {
         *            if ( sData == "1.7" ) {
         *              $(nTd).css('color', 'blue')
         *            }
         *          }
         *        } ]
         *      });
         *    } );
         */
        "fnCreatedCell": null,


        /**
         * <code>Deprecated</code> Custom display function that will be called for the
         * display of each cell in this column.
         *
         * Please note that this option has now been deprecated and will be removed
         * in the next version of DataTables. Please use mRender / mData rather than
         * fnRender.
         *  @type function
         *  @param {object} o Object with the following parameters:
         *  @param {int}    o.iDataRow The row in aoData
         *  @param {int}    o.iDataColumn The column in question
         *  @param {array}  o.aData The data for the row in question
         *  @param {object} o.oSettings The settings object for this DataTables instance
         *  @param {object} o.mDataProp The data property used for this column
         *  @param {*}      val The current cell value
         *  @returns {string} The string you which to use in the display
         *  @dtopt Columns
         *  @deprecated
         */
        "fnRender": null,


        /**
         * The column index (starting from 0!) that you wish a sort to be performed
         * upon when this column is selected for sorting. This can be used for sorting
         * on hidden columns for example.
         *  @type int
         *  @default -1 <i>Use automatically calculated column index</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "iDataSort": 1, "aTargets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "iDataSort": 1 },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "iDataSort": -1,


        /**
         * This parameter has been replaced by mData in DataTables to ensure naming
         * consistency. mDataProp can still be used, as there is backwards compatibility
         * in DataTables for this option, but it is strongly recommended that you use
         * mData in preference to mDataProp.
         *  @name DataTable.defaults.columns.mDataProp
         */


        /**
         * This property can be used to read data from any JSON data source property,
         * including deeply nested objects / properties. mData can be given in a
         * number of different ways which effect its behaviour:
         *   <ul>
         *     <li>integer - treated as an array index for the data source. This is the
         *       default that DataTables uses (incrementally increased for each column).</li>
         *     <li>string - read an object property from the data source. Note that you can
         *       use Javascript dotted notation to read deep properties / arrays from the
         *       data source.</li>
         *     <li>null - the sDefaultContent option will be used for the cell (null
         *       by default, so you will need to specify the default content you want -
         *       typically an empty string). This can be useful on generated columns such
         *       as edit / delete action columns.</li>
         *     <li>function - the function given will be executed whenever DataTables
         *       needs to set or get the data for a cell in the column. The function
         *       takes three parameters:
         *       <ul>
         *         <li>{array|object} The data source for the row</li>
         *         <li>{string} The type call data requested - this will be 'set' when
         *           setting data or 'filter', 'display', 'type', 'sort' or undefined when
         *           gathering data. Note that when <i>undefined</i> is given for the type
         *           DataTables expects to get the raw data for the object back</li>
         *         <li>{*} Data to set when the second parameter is 'set'.</li>
         *       </ul>
         *       The return value from the function is not required when 'set' is the type
         *       of call, but otherwise the return is what will be used for the data
         *       requested.</li>
         *    </ul>
         *
         * Note that prior to DataTables 1.9.2 mData was called mDataProp. The name change
         * reflects the flexibility of this property and is consistent with the naming of
         * mRender. If 'mDataProp' is given, then it will still be used by DataTables, as
         * it automatically maps the old name to the new if required.
         *  @type string|int|function|null
         *  @default null <i>Use automatically calculated column index</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Read table data from objects
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "sAjaxSource": "sources/deep.txt",
         *        "aoColumns": [
         *          { "mData": "engine" },
         *          { "mData": "browser" },
         *          { "mData": "platform.inner" },
         *          { "mData": "platform.details.0" },
         *          { "mData": "platform.details.1" }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using mData as a function to provide different information for
         *    // sorting, filtering and display. In this case, currency (price)
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "aoColumnDefs": [ {
         *          "aTargets": [ 0 ],
         *          "mData": function ( source, type, val ) {
         *            if (type === 'set') {
         *              source.price = val;
         *              // Store the computed dislay and filter values for efficiency
         *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
         *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
         *              return;
         *            }
         *            else if (type === 'display') {
         *              return source.price_display;
         *            }
         *            else if (type === 'filter') {
         *              return source.price_filter;
         *            }
         *            // 'sort', 'type' and undefined all just use the integer
         *            return source.price;
         *          }
         *        } ]
         *      } );
         *    } );
         */
        "mData": null,


        /**
         * This property is the rendering partner to mData and it is suggested that
         * when you want to manipulate data for display (including filtering, sorting etc)
         * but not altering the underlying data for the table, use this property. mData
         * can actually do everything this property can and more, but this parameter is
         * easier to use since there is no 'set' option. Like mData is can be given
         * in a number of different ways to effect its behaviour, with the addition of
         * supporting array syntax for easy outputting of arrays (including arrays of
         * objects):
         *   <ul>
         *     <li>integer - treated as an array index for the data source. This is the
         *       default that DataTables uses (incrementally increased for each column).</li>
         *     <li>string - read an object property from the data source. Note that you can
         *       use Javascript dotted notation to read deep properties / arrays from the
         *       data source and also array brackets to indicate that the data reader should
         *       loop over the data source array. When characters are given between the array
         *       brackets, these characters are used to join the data source array together.
         *       For example: "accounts[, ].name" would result in a comma separated list with
         *       the 'name' value from the 'accounts' array of objects.</li>
         *     <li>function - the function given will be executed whenever DataTables
         *       needs to set or get the data for a cell in the column. The function
         *       takes three parameters:
         *       <ul>
         *         <li>{array|object} The data source for the row (based on mData)</li>
         *         <li>{string} The type call data requested - this will be 'filter', 'display',
         *           'type' or 'sort'.</li>
         *         <li>{array|object} The full data source for the row (not based on mData)</li>
         *       </ul>
         *       The return value from the function is what will be used for the data
         *       requested.</li>
         *    </ul>
         *  @type string|int|function|null
         *  @default null <i>Use mData</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Create a comma separated list from an array of objects
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "sAjaxSource": "sources/deep.txt",
         *        "aoColumns": [
         *          { "mData": "engine" },
         *          { "mData": "browser" },
         *          {
         *            "mData": "platform",
         *            "mRender": "[, ].name"
         *          }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Use as a function to create a link from the data source
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "aoColumnDefs": [
         *        {
         *          "aTargets": [ 0 ],
         *          "mData": "download_link",
         *          "mRender": function ( data, type, full ) {
         *            return '<a href="'+data+'">Download</a>';
         *          }
         *        ]
         *      } );
         *    } );
         */
        "mRender": null,


        /**
         * Change the cell type created for the column - either TD cells or TH cells. This
         * can be useful as TH cells have semantic meaning in the table body, allowing them
         * to act as a header for a row (you may wish to add scope='row' to the TH elements).
         *  @type string
         *  @default td
         *  @dtopt Columns
         *
         *  @example
         *    // Make the first column use TH cells
         *    $(document).ready( function() {
         *      var oTable = $('#example').dataTable( {
         *        "aoColumnDefs": [ {
         *          "aTargets": [ 0 ],
         *          "sCellType": "th"
         *        } ]
         *      } );
         *    } );
         */
        "sCellType": "td",


        /**
         * Class to give to each cell in this column.
         *  @type string
         *  @default <i>Empty string</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "sClass": "my_class", "aTargets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "sClass": "my_class" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sClass": "",

        /**
         * When DataTables calculates the column widths to assign to each column,
         * it finds the longest string in each column and then constructs a
         * temporary table and reads the widths from that. The problem with this
         * is that "mmm" is much wider then "iiii", but the latter is a longer
         * string - thus the calculation can go wrong (doing it properly and putting
         * it into an DOM object and measuring that is horribly(!) slow). Thus as
         * a "work around" we provide this option. It will append its value to the
         * text that is found to be the longest string for the column - i.e. padding.
         * Generally you shouldn't need this, and it is not documented on the
         * general DataTables.net documentation
         *  @type string
         *  @default <i>Empty string<i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          null,
         *          null,
         *          null,
         *          {
         *            "sContentPadding": "mmm"
         *          }
         *        ]
         *      } );
         *    } );
         */
        "sContentPadding": "",


        /**
         * Allows a default value to be given for a column's data, and will be used
         * whenever a null data source is encountered (this can be because mData
         * is set to null, or because the data source itself is null).
         *  @type string
         *  @default null
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          {
         *            "mData": null,
         *            "sDefaultContent": "Edit",
         *            "aTargets": [ -1 ]
         *          }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          null,
         *          null,
         *          null,
         *          {
         *            "mData": null,
         *            "sDefaultContent": "Edit"
         *          }
         *        ]
         *      } );
         *    } );
         */
        "sDefaultContent": null,


        /**
         * This parameter is only used in DataTables' server-side processing. It can
         * be exceptionally useful to know what columns are being displayed on the
         * client side, and to map these to database fields. When defined, the names
         * also allow DataTables to reorder information from the server if it comes
         * back in an unexpected order (i.e. if you switch your columns around on the
         * client-side, your server-side code does not also need updating).
         *  @type string
         *  @default <i>Empty string</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "sName": "engine", "aTargets": [ 0 ] },
         *          { "sName": "browser", "aTargets": [ 1 ] },
         *          { "sName": "platform", "aTargets": [ 2 ] },
         *          { "sName": "version", "aTargets": [ 3 ] },
         *          { "sName": "grade", "aTargets": [ 4 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "sName": "engine" },
         *          { "sName": "browser" },
         *          { "sName": "platform" },
         *          { "sName": "version" },
         *          { "sName": "grade" }
         *        ]
         *      } );
         *    } );
         */
        "sName": "",


        /**
         * Defines a data source type for the sorting which can be used to read
         * real-time information from the table (updating the internally cached
         * version) prior to sorting. This allows sorting to occur on user editable
         * elements such as form inputs.
         *  @type string
         *  @default std
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "sSortDataType": "dom-text", "aTargets": [ 2, 3 ] },
         *          { "sType": "numeric", "aTargets": [ 3 ] },
         *          { "sSortDataType": "dom-select", "aTargets": [ 4 ] },
         *          { "sSortDataType": "dom-checkbox", "aTargets": [ 5 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          null,
         *          null,
         *          { "sSortDataType": "dom-text" },
         *          { "sSortDataType": "dom-text", "sType": "numeric" },
         *          { "sSortDataType": "dom-select" },
         *          { "sSortDataType": "dom-checkbox" }
         *        ]
         *      } );
         *    } );
         */
        "sSortDataType": "std",


        /**
         * The title of this column.
         *  @type string
         *  @default null <i>Derived from the 'TH' value for this column in the
         *    original HTML table.</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "sTitle": "My column title", "aTargets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "sTitle": "My column title" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sTitle": null,


        /**
         * The type allows you to specify how the data for this column will be sorted.
         * Four types (string, numeric, date and html (which will strip HTML tags
         * before sorting)) are currently available. Note that only date formats
         * understood by Javascript's Date() object will be accepted as type date. For
         * example: "Mar 26, 2008 5:03 PM". May take the values: 'string', 'numeric',
         * 'date' or 'html' (by default). Further types can be adding through
         * plug-ins.
         *  @type string
         *  @default null <i>Auto-detected from raw data</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "sType": "html", "aTargets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "sType": "html" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sType": null,


        /**
         * Defining the width of the column, this parameter may take any CSS value
         * (3em, 20px etc). DataTables apples 'smart' widths to columns which have not
         * been given a specific width through this interface ensuring that the table
         * remains readable.
         *  @type string
         *  @default null <i>Automatic</i>
         *  @dtopt Columns
         *
         *  @example
         *    // Using aoColumnDefs
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumnDefs": [
         *          { "sWidth": "20%", "aTargets": [ 0 ] }
         *        ]
         *      } );
         *    } );
         *
         *  @example
         *    // Using aoColumns
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "aoColumns": [
         *          { "sWidth": "20%" },
         *          null,
         *          null,
         *          null,
         *          null
         *        ]
         *      } );
         *    } );
         */
        "sWidth": null
    };



    /**
     * DataTables settings object - this holds all the information needed for a
     * given table, including configuration, data and current application of the
     * table options. DataTables does not have a single instance for each DataTable
     * with the settings attached to that instance, but rather instances of the
     * DataTable "class" are created on-the-fly as needed (typically by a
     * $().dataTable() call) and the settings object is then applied to that
     * instance.
     *
     * Note that this object is related to {@link DataTable.defaults} but this
     * one is the internal data store for DataTables's cache of columns. It should
     * NOT be manipulated outside of DataTables. Any configuration should be done
     * through the initialisation options.
     *  @namespace
     *  @todo Really should attach the settings object to individual instances so we
     *    don't need to create new instances on each $().dataTable() call (if the
     *    table already exists). It would also save passing oSettings around and
     *    into every single function. However, this is a very significant
     *    architecture change for DataTables and will almost certainly break
     *    backwards compatibility with older installations. This is something that
     *    will be done in 2.0.
     */
    DataTable.models.oSettings = {
        /**
         * Primary features of DataTables and their enablement state.
         *  @namespace
         */
        "oFeatures": {

            /**
             * Flag to say if DataTables should automatically try to calculate the
             * optimum table and columns widths (true) or not (false).
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bAutoWidth": null,

            /**
             * Delay the creation of TR and TD elements until they are actually
             * needed by a driven page draw. This can give a significant speed
             * increase for Ajax source and Javascript source data, but makes no
             * difference at all fro DOM and server-side processing tables.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bDeferRender": null,

            /**
             * Enable filtering on the table or not. Note that if this is disabled
             * then there is no filtering at all on the table, including fnFilter.
             * To just remove the filtering input use sDom and remove the 'f' option.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bFilter": null,

            /**
             * Table information element (the 'Showing x of y records' div) enable
             * flag.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bInfo": null,

            /**
             * Present a user control allowing the end user to change the page size
             * when pagination is enabled.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bLengthChange": null,

            /**
             * Pagination enabled or not. Note that if this is disabled then length
             * changing must also be disabled.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bPaginate": null,

            /**
             * Processing indicator enable flag whenever DataTables is enacting a
             * user request - typically an Ajax request for server-side processing.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bProcessing": null,

            /**
             * Server-side processing enabled flag - when enabled DataTables will
             * get all data from the server for every draw - there is no filtering,
             * sorting or paging done on the client-side.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bServerSide": null,

            /**
             * Sorting enablement flag.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bSort": null,

            /**
             * Apply a class to the columns which are being sorted to provide a
             * visual highlight or not. This can slow things down when enabled since
             * there is a lot of DOM interaction.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bSortClasses": null,

            /**
             * State saving enablement flag.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bStateSave": null
        },


        /**
         * Scrolling settings for a table.
         *  @namespace
         */
        "oScroll": {
            /**
             * Indicate if DataTables should be allowed to set the padding / margin
             * etc for the scrolling header elements or not. Typically you will want
             * this.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bAutoCss": null,

            /**
             * When the table is shorter in height than sScrollY, collapse the
             * table container down to the height of the table (when true).
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bCollapse": null,

            /**
             * Infinite scrolling enablement flag. Now deprecated in favour of
             * using the Scroller plug-in.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type boolean
             */
            "bInfinite": null,

            /**
             * Width of the scrollbar for the web-browser's platform. Calculated
             * during table initialisation.
             *  @type int
             *  @default 0
             */
            "iBarWidth": 0,

            /**
             * Space (in pixels) between the bottom of the scrolling container and
             * the bottom of the scrolling viewport before the next page is loaded
             * when using infinite scrolling.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type int
             */
            "iLoadGap": null,

            /**
             * Viewport width for horizontal scrolling. Horizontal scrolling is
             * disabled if an empty string.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             */
            "sX": null,

            /**
             * Width to expand the table to when using x-scrolling. Typically you
             * should not need to use this.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             *  @deprecated
             */
            "sXInner": null,

            /**
             * Viewport height for vertical scrolling. Vertical scrolling is disabled
             * if an empty string.
             * Note that this parameter will be set by the initialisation routine. To
             * set a default use {@link DataTable.defaults}.
             *  @type string
             */
            "sY": null
        },

        /**
         * Language information for the table.
         *  @namespace
         *  @extends DataTable.defaults.oLanguage
         */
        "oLanguage": {
            /**
             * Information callback function. See
             * {@link DataTable.defaults.fnInfoCallback}
             *  @type function
             *  @default null
             */
            "fnInfoCallback": null
        },

        /**
         * Browser support parameters
         *  @namespace
         */
        "oBrowser": {
            /**
             * Indicate if the browser incorrectly calculates width:100% inside a
             * scrolling element (IE6/7)
             *  @type boolean
             *  @default false
             */
            "bScrollOversize": false
        },

        /**
         * Array referencing the nodes which are used for the features. The
         * parameters of this object match what is allowed by sDom - i.e.
         *   <ul>
         *     <li>'l' - Length changing</li>
         *     <li>'f' - Filtering input</li>
         *     <li>'t' - The table!</li>
         *     <li>'i' - Information</li>
         *     <li>'p' - Pagination</li>
         *     <li>'r' - pRocessing</li>
         *   </ul>
         *  @type array
         *  @default []
         */
        "aanFeatures": [],

        /**
         * Store data information - see {@link DataTable.models.oRow} for detailed
         * information.
         *  @type array
         *  @default []
         */
        "aoData": [],

        /**
         * Array of indexes which are in the current display (after filtering etc)
         *  @type array
         *  @default []
         */
        "aiDisplay": [],

        /**
         * Array of indexes for display - no filtering
         *  @type array
         *  @default []
         */
        "aiDisplayMaster": [],

        /**
         * Store information about each column that is in use
         *  @type array
         *  @default []
         */
        "aoColumns": [],

        /**
         * Store information about the table's header
         *  @type array
         *  @default []
         */
        "aoHeader": [],

        /**
         * Store information about the table's footer
         *  @type array
         *  @default []
         */
        "aoFooter": [],

        /**
         * Search data array for regular expression searching
         *  @type array
         *  @default []
         */
        "asDataSearch": [],

        /**
         * Store the applied global search information in case we want to force a
         * research or compare the old search to a new one.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @namespace
         *  @extends DataTable.models.oSearch
         */
        "oPreviousSearch": {},

        /**
         * Store the applied search for each column - see
         * {@link DataTable.models.oSearch} for the format that is used for the
         * filtering information for each column.
         *  @type array
         *  @default []
         */
        "aoPreSearchCols": [],

        /**
         * Sorting that is applied to the table. Note that the inner arrays are
         * used in the following manner:
         * <ul>
         *   <li>Index 0 - column number</li>
         *   <li>Index 1 - current sorting direction</li>
         *   <li>Index 2 - index of asSorting for this column</li>
         * </ul>
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @todo These inner arrays should really be objects
         */
        "aaSorting": null,

        /**
         * Sorting that is always applied to the table (i.e. prefixed in front of
         * aaSorting).
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array|null
         *  @default null
         */
        "aaSortingFixed": null,

        /**
         * Classes to use for the striping of a table.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @default []
         */
        "asStripeClasses": null,

        /**
         * If restoring a table - we should restore its striping classes as well
         *  @type array
         *  @default []
         */
        "asDestroyStripes": [],

        /**
         * If restoring a table - we should restore its width
         *  @type int
         *  @default 0
         */
        "sDestroyWidth": 0,

        /**
         * Callback functions array for every time a row is inserted (i.e. on a draw).
         *  @type array
         *  @default []
         */
        "aoRowCallback": [],

        /**
         * Callback functions for the header on each draw.
         *  @type array
         *  @default []
         */
        "aoHeaderCallback": [],

        /**
         * Callback function for the footer on each draw.
         *  @type array
         *  @default []
         */
        "aoFooterCallback": [],

        /**
         * Array of callback functions for draw callback functions
         *  @type array
         *  @default []
         */
        "aoDrawCallback": [],

        /**
         * Array of callback functions for row created function
         *  @type array
         *  @default []
         */
        "aoRowCreatedCallback": [],

        /**
         * Callback functions for just before the table is redrawn. A return of
         * false will be used to cancel the draw.
         *  @type array
         *  @default []
         */
        "aoPreDrawCallback": [],

        /**
         * Callback functions for when the table has been initialised.
         *  @type array
         *  @default []
         */
        "aoInitComplete": [],


        /**
         * Callbacks for modifying the settings to be stored for state saving, prior to
         * saving state.
         *  @type array
         *  @default []
         */
        "aoStateSaveParams": [],

        /**
         * Callbacks for modifying the settings that have been stored for state saving
         * prior to using the stored values to restore the state.
         *  @type array
         *  @default []
         */
        "aoStateLoadParams": [],

        /**
         * Callbacks for operating on the settings object once the saved state has been
         * loaded
         *  @type array
         *  @default []
         */
        "aoStateLoaded": [],

        /**
         * Cache the table ID for quick access
         *  @type string
         *  @default <i>Empty string</i>
         */
        "sTableId": "",

        /**
         * The TABLE node for the main table
         *  @type node
         *  @default null
         */
        "nTable": null,

        /**
         * Permanent ref to the thead element
         *  @type node
         *  @default null
         */
        "nTHead": null,

        /**
         * Permanent ref to the tfoot element - if it exists
         *  @type node
         *  @default null
         */
        "nTFoot": null,

        /**
         * Permanent ref to the tbody element
         *  @type node
         *  @default null
         */
        "nTBody": null,

        /**
         * Cache the wrapper node (contains all DataTables controlled elements)
         *  @type node
         *  @default null
         */
        "nTableWrapper": null,

        /**
         * Indicate if when using server-side processing the loading of data
         * should be deferred until the second draw.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         *  @default false
         */
        "bDeferLoading": false,

        /**
         * Indicate if all required information has been read in
         *  @type boolean
         *  @default false
         */
        "bInitialised": false,

        /**
         * Information about open rows. Each object in the array has the parameters
         * 'nTr' and 'nParent'
         *  @type array
         *  @default []
         */
        "aoOpenRows": [],

        /**
         * Dictate the positioning of DataTables' control elements - see
         * {@link DataTable.model.oInit.sDom}.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default null
         */
        "sDom": null,

        /**
         * Which type of pagination should be used.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default two_button
         */
        "sPaginationType": "two_button",

        /**
         * The cookie duration (for bStateSave) in seconds.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type int
         *  @default 0
         */
        "iCookieDuration": 0,

        /**
         * The cookie name prefix.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default <i>Empty string</i>
         */
        "sCookiePrefix": "",

        /**
         * Callback function for cookie creation.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type function
         *  @default null
         */
        "fnCookieCallback": null,

        /**
         * Array of callback functions for state saving. Each array element is an
         * object with the following parameters:
         *   <ul>
         *     <li>function:fn - function to call. Takes two parameters, oSettings
         *       and the JSON string to save that has been thus far created. Returns
         *       a JSON string to be inserted into a json object
         *       (i.e. '"param": [ 0, 1, 2]')</li>
         *     <li>string:sName - name of callback</li>
         *   </ul>
         *  @type array
         *  @default []
         */
        "aoStateSave": [],

        /**
         * Array of callback functions for state loading. Each array element is an
         * object with the following parameters:
         *   <ul>
         *     <li>function:fn - function to call. Takes two parameters, oSettings
         *       and the object stored. May return false to cancel state loading</li>
         *     <li>string:sName - name of callback</li>
         *   </ul>
         *  @type array
         *  @default []
         */
        "aoStateLoad": [],

        /**
         * State that was loaded from the cookie. Useful for back reference
         *  @type object
         *  @default null
         */
        "oLoadedState": null,

        /**
         * Source url for AJAX data for the table.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         *  @default null
         */
        "sAjaxSource": null,

        /**
         * Property from a given object from which to read the table data from. This
         * can be an empty string (when not server-side processing), in which case
         * it is  assumed an an array is given directly.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         */
        "sAjaxDataProp": null,

        /**
         * Note if draw should be blocked while getting data
         *  @type boolean
         *  @default true
         */
        "bAjaxDataGet": true,

        /**
         * The last jQuery XHR object that was used for server-side data gathering.
         * This can be used for working with the XHR information in one of the
         * callbacks
         *  @type object
         *  @default null
         */
        "jqXHR": null,

        /**
         * Function to get the server-side data.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type function
         */
        "fnServerData": null,

        /**
         * Functions which are called prior to sending an Ajax request so extra
         * parameters can easily be sent to the server
         *  @type array
         *  @default []
         */
        "aoServerParams": [],

        /**
         * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
         * required).
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type string
         */
        "sServerMethod": null,

        /**
         * Format numbers for display.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type function
         */
        "fnFormatNumber": null,

        /**
         * List of options that can be used for the user selectable length menu.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type array
         *  @default []
         */
        "aLengthMenu": null,

        /**
         * Counter for the draws that the table does. Also used as a tracker for
         * server-side processing
         *  @type int
         *  @default 0
         */
        "iDraw": 0,

        /**
         * Indicate if a redraw is being done - useful for Ajax
         *  @type boolean
         *  @default false
         */
        "bDrawing": false,

        /**
         * Draw index (iDraw) of the last error when parsing the returned data
         *  @type int
         *  @default -1
         */
        "iDrawError": -1,

        /**
         * Paging display length
         *  @type int
         *  @default 10
         */
        "_iDisplayLength": 10,

        /**
         * Paging start point - aiDisplay index
         *  @type int
         *  @default 0
         */
        "_iDisplayStart": 0,

        /**
         * Paging end point - aiDisplay index. Use fnDisplayEnd rather than
         * this property to get the end point
         *  @type int
         *  @default 10
         *  @private
         */
        "_iDisplayEnd": 10,

        /**
         * Server-side processing - number of records in the result set
         * (i.e. before filtering), Use fnRecordsTotal rather than
         * this property to get the value of the number of records, regardless of
         * the server-side processing setting.
         *  @type int
         *  @default 0
         *  @private
         */
        "_iRecordsTotal": 0,

        /**
         * Server-side processing - number of records in the current display set
         * (i.e. after filtering). Use fnRecordsDisplay rather than
         * this property to get the value of the number of records, regardless of
         * the server-side processing setting.
         *  @type boolean
         *  @default 0
         *  @private
         */
        "_iRecordsDisplay": 0,

        /**
         * Flag to indicate if jQuery UI marking and classes should be used.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bJUI": null,

        /**
         * The classes to use for the table
         *  @type object
         *  @default {}
         */
        "oClasses": {},

        /**
         * Flag attached to the settings object so you can check in the draw
         * callback if filtering has been done in the draw. Deprecated in favour of
         * events.
         *  @type boolean
         *  @default false
         *  @deprecated
         */
        "bFiltered": false,

        /**
         * Flag attached to the settings object so you can check in the draw
         * callback if sorting has been done in the draw. Deprecated in favour of
         * events.
         *  @type boolean
         *  @default false
         *  @deprecated
         */
        "bSorted": false,

        /**
         * Indicate that if multiple rows are in the header and there is more than
         * one unique cell per column, if the top one (true) or bottom one (false)
         * should be used for sorting / title by DataTables.
         * Note that this parameter will be set by the initialisation routine. To
         * set a default use {@link DataTable.defaults}.
         *  @type boolean
         */
        "bSortCellsTop": null,

        /**
         * Initialisation object that is used for the table
         *  @type object
         *  @default null
         */
        "oInit": null,

        /**
         * Destroy callback functions - for plug-ins to attach themselves to the
         * destroy so they can clean up markup and events.
         *  @type array
         *  @default []
         */
        "aoDestroyCallback": [],


        /**
         * Get the number of records in the current record set, before filtering
         *  @type function
         */
        "fnRecordsTotal": function ()
        {
            if ( this.oFeatures.bServerSide ) {
                return parseInt(this._iRecordsTotal, 10);
            } else {
                return this.aiDisplayMaster.length;
            }
        },

        /**
         * Get the number of records in the current record set, after filtering
         *  @type function
         */
        "fnRecordsDisplay": function ()
        {
            if ( this.oFeatures.bServerSide ) {
                return parseInt(this._iRecordsDisplay, 10);
            } else {
                return this.aiDisplay.length;
            }
        },

        /**
         * Set the display end point - aiDisplay index
         *  @type function
         *  @todo Should do away with _iDisplayEnd and calculate it on-the-fly here
         */
        "fnDisplayEnd": function ()
        {
            if ( this.oFeatures.bServerSide ) {
                if ( this.oFeatures.bPaginate === false || this._iDisplayLength == -1 ) {
                    return this._iDisplayStart+this.aiDisplay.length;
                } else {
                    return Math.min( this._iDisplayStart+this._iDisplayLength,
                        this._iRecordsDisplay );
                }
            } else {
                return this._iDisplayEnd;
            }
        },

        /**
         * The DataTables object for this table
         *  @type object
         *  @default null
         */
        "oInstance": null,

        /**
         * Unique identifier for each instance of the DataTables object. If there
         * is an ID on the table node, then it takes that value, otherwise an
         * incrementing internal counter is used.
         *  @type string
         *  @default null
         */
        "sInstance": null,

        /**
         * tabindex attribute value that is added to DataTables control elements, allowing
         * keyboard navigation of the table and its controls.
         */
        "iTabIndex": 0,

        /**
         * DIV container for the footer scrolling table if scrolling
         */
        "nScrollHead": null,

        /**
         * DIV container for the footer scrolling table if scrolling
         */
        "nScrollFoot": null
    };

    /**
     * Extension object for DataTables that is used to provide all extension options.
     *
     * Note that the <i>DataTable.ext</i> object is available through
     * <i>jQuery.fn.dataTable.ext</i> where it may be accessed and manipulated. It is
     * also aliased to <i>jQuery.fn.dataTableExt</i> for historic reasons.
     *  @namespace
     *  @extends DataTable.models.ext
     */
    DataTable.ext = $.extend( true, {}, DataTable.models.ext );

    $.extend( DataTable.ext.oStdClasses, {
        "sTable": "dataTable",

        /* Two buttons buttons */
        "sPagePrevEnabled": "paginate_enabled_previous",
        "sPagePrevDisabled": "paginate_disabled_previous",
        "sPageNextEnabled": "paginate_enabled_next",
        "sPageNextDisabled": "paginate_disabled_next",
        "sPageJUINext": "",
        "sPageJUIPrev": "",

        /* Full numbers paging buttons */
        "sPageButton": "paginate_button",
        "sPageButtonActive": "paginate_active",
        "sPageButtonStaticDisabled": "paginate_button paginate_button_disabled",
        "sPageFirst": "first",
        "sPagePrevious": "previous",
        "sPageNext": "next",
        "sPageLast": "last",

        /* Striping classes */
        "sStripeOdd": "odd",
        "sStripeEven": "even",

        /* Empty row */
        "sRowEmpty": "dataTables_empty",

        /* Features */
        "sWrapper": "dataTables_wrapper",
        "sFilter": "dataTables_filter",
        "sInfo": "dataTables_info",
        "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
        "sLength": "dataTables_length",
        "sProcessing": "dataTables_processing",

        /* Sorting */
        "sSortAsc": "sorting_asc",
        "sSortDesc": "sorting_desc",
        "sSortable": "sorting", /* Sortable in both directions */
        "sSortableAsc": "sorting_asc_disabled",
        "sSortableDesc": "sorting_desc_disabled",
        "sSortableNone": "sorting_disabled",
        "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
        "sSortJUIAsc": "",
        "sSortJUIDesc": "",
        "sSortJUI": "",
        "sSortJUIAscAllowed": "",
        "sSortJUIDescAllowed": "",
        "sSortJUIWrapper": "",
        "sSortIcon": "",

        /* Scrolling */
        "sScrollWrapper": "dataTables_scroll",
        "sScrollHead": "dataTables_scrollHead",
        "sScrollHeadInner": "dataTables_scrollHeadInner",
        "sScrollBody": "dataTables_scrollBody",
        "sScrollFoot": "dataTables_scrollFoot",
        "sScrollFootInner": "dataTables_scrollFootInner",

        /* Misc */
        "sFooterTH": "",
        "sJUIHeader": "",
        "sJUIFooter": ""
    } );


    $.extend( DataTable.ext.oJUIClasses, DataTable.ext.oStdClasses, {
        /* Two buttons buttons */
        "sPagePrevEnabled": "fg-button ui-button ui-state-default ui-corner-left",
        "sPagePrevDisabled": "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
        "sPageNextEnabled": "fg-button ui-button ui-state-default ui-corner-right",
        "sPageNextDisabled": "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
        "sPageJUINext": "ui-icon ui-icon-circle-arrow-e",
        "sPageJUIPrev": "ui-icon ui-icon-circle-arrow-w",

        /* Full numbers paging buttons */
        "sPageButton": "fg-button ui-button ui-state-default",
        "sPageButtonActive": "fg-button ui-button ui-state-default ui-state-disabled",
        "sPageButtonStaticDisabled": "fg-button ui-button ui-state-default ui-state-disabled",
        "sPageFirst": "first ui-corner-tl ui-corner-bl",
        "sPageLast": "last ui-corner-tr ui-corner-br",

        /* Features */
        "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
            "ui-buttonset-multi paging_", /* Note that the type is postfixed */

        /* Sorting */
        "sSortAsc": "ui-state-default",
        "sSortDesc": "ui-state-default",
        "sSortable": "ui-state-default",
        "sSortableAsc": "ui-state-default",
        "sSortableDesc": "ui-state-default",
        "sSortableNone": "ui-state-default",
        "sSortJUIAsc": "kt-right ui-icon ui-icon-triangle-1-n",
        "sSortJUIDesc": "kt-right ui-icon ui-icon-triangle-1-s",
        "sSortJUI": "kt-right ui-icon ui-icon-carat-2-n-s",
        "sSortJUIAscAllowed": "kt-right ui-icon ui-icon-carat-1-n",
        "sSortJUIDescAllowed": "kt-right ui-icon ui-icon-carat-1-s",
        "sSortJUIWrapper": "DataTables_sort_wrapper",
        "sSortIcon": "DataTables_sort_icon",

        /* Scrolling */
        "sScrollHead": "dataTables_scrollHead ui-state-default",
        "sScrollFoot": "dataTables_scrollFoot ui-state-default",

        /* Misc */
        "sFooterTH": "ui-state-default",
        "sJUIHeader": "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix",
        "sJUIFooter": "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix"
    } );

    /*
     * Variable: oPagination
     * Purpose:
     * Scope:    jQuery.fn.dataTableExt
     */
    $.extend( DataTable.ext.oPagination, {
        /*
         * Variable: two_button
         * Purpose:  Standard two button (forward/back) pagination
         * Scope:    jQuery.fn.dataTableExt.oPagination
         */
        "two_button": {
            /*
             * Function: oPagination.two_button.fnInit
             * Purpose:  Initialise dom elements required for pagination with forward/back buttons only
             * Returns:  -
             * Inputs:   object:oSettings - dataTables settings object
             *           node:nPaging - the DIV which contains this pagination control
             *           function:fnCallbackDraw - draw function which must be called on update
             */
            "fnInit": function ( oSettings, nPaging, fnCallbackDraw )
            {
                var oLang = oSettings.oLanguage.oPaginate;
                var oClasses = oSettings.oClasses;
                var fnClickHandler = function ( e ) {
                    if ( oSettings.oApi._fnPageChange( oSettings, e.data.action ) )
                    {
                        fnCallbackDraw( oSettings );
                    }
                };

                var sAppend = (!oSettings.bJUI) ?
                    '<a class="'+oSettings.oClasses.sPagePrevDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oLang.sPrevious+'</a>'+
                    '<a class="'+oSettings.oClasses.sPageNextDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oLang.sNext+'</a>'
                    :
                    '<a class="'+oSettings.oClasses.sPagePrevDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oSettings.oClasses.sPageJUIPrev+'"></span></a>'+
                    '<a class="'+oSettings.oClasses.sPageNextDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oSettings.oClasses.sPageJUINext+'"></span></a>';
                $(nPaging).append( sAppend );

                var els = $('a', nPaging);
                var nPrevious = els[0],
                    nNext = els[1];

                oSettings.oApi._fnBindAction( nPrevious, {action: "previous"}, fnClickHandler );
                oSettings.oApi._fnBindAction( nNext,     {action: "next"},     fnClickHandler );

                /* ID the first elements only */
                if ( !oSettings.aanFeatures.p )
                {
                    nPaging.id = oSettings.sTableId+'_paginate';
                    nPrevious.id = oSettings.sTableId+'_previous';
                    nNext.id = oSettings.sTableId+'_next';

                    nPrevious.setAttribute('aria-controls', oSettings.sTableId);
                    nNext.setAttribute('aria-controls', oSettings.sTableId);
                }
            },

            /*
             * Function: oPagination.two_button.fnUpdate
             * Purpose:  Update the two button pagination at the end of the draw
             * Returns:  -
             * Inputs:   object:oSettings - dataTables settings object
             *           function:fnCallbackDraw - draw function to call on page change
             */
            "fnUpdate": function ( oSettings, fnCallbackDraw )
            {
                if ( !oSettings.aanFeatures.p )
                {
                    return;
                }

                var oClasses = oSettings.oClasses;
                var an = oSettings.aanFeatures.p;
                var nNode;

                /* Loop over each instance of the pager */
                for ( var i=0, iLen=an.length ; i<iLen ; i++ )
                {
                    nNode = an[i].firstChild;
                    if ( nNode )
                    {
                        /* Previous page */
                        nNode.className = ( oSettings._iDisplayStart === 0 ) ?
                            oClasses.sPagePrevDisabled : oClasses.sPagePrevEnabled;

                        /* Next page */
                        nNode = nNode.nextSibling;
                        nNode.className = ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) ?
                            oClasses.sPageNextDisabled : oClasses.sPageNextEnabled;
                    }
                }
            }
        },


        /*
         * Variable: iFullNumbersShowPages
         * Purpose:  Change the number of pages which can be seen
         * Scope:    jQuery.fn.dataTableExt.oPagination
         */
        "iFullNumbersShowPages": 5,

        /*
         * Variable: full_numbers
         * Purpose:  Full numbers pagination
         * Scope:    jQuery.fn.dataTableExt.oPagination
         */
        "full_numbers": {
            /*
             * Function: oPagination.full_numbers.fnInit
             * Purpose:  Initialise dom elements required for pagination with a list of the pages
             * Returns:  -
             * Inputs:   object:oSettings - dataTables settings object
             *           node:nPaging - the DIV which contains this pagination control
             *           function:fnCallbackDraw - draw function which must be called on update
             */
            "fnInit": function ( oSettings, nPaging, fnCallbackDraw )
            {
                var oLang = oSettings.oLanguage.oPaginate;
                var oClasses = oSettings.oClasses;
                var fnClickHandler = function ( e ) {
                    if ( oSettings.oApi._fnPageChange( oSettings, e.data.action ) )
                    {
                        fnCallbackDraw( oSettings );
                    }
                };

                $(nPaging).append(
                    '<a  tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageFirst+'">'+oLang.sFirst+'</a>'+
                    '<a  tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPagePrevious+'">'+oLang.sPrevious+'</a>'+
                    '<span></span>'+
                    '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageNext+'">'+oLang.sNext+'</a>'+
                    '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageLast+'">'+oLang.sLast+'</a>'
                );
                var els = $('a', nPaging);
                var nFirst = els[0],
                    nPrev = els[1],
                    nNext = els[2],
                    nLast = els[3];

                oSettings.oApi._fnBindAction( nFirst, {action: "first"},    fnClickHandler );
                oSettings.oApi._fnBindAction( nPrev,  {action: "previous"}, fnClickHandler );
                oSettings.oApi._fnBindAction( nNext,  {action: "next"},     fnClickHandler );
                oSettings.oApi._fnBindAction( nLast,  {action: "last"},     fnClickHandler );

                /* ID the first elements only */
                if ( !oSettings.aanFeatures.p )
                {
                    nPaging.id = oSettings.sTableId+'_paginate';
                    nFirst.id =oSettings.sTableId+'_first';
                    nPrev.id =oSettings.sTableId+'_previous';
                    nNext.id =oSettings.sTableId+'_next';
                    nLast.id =oSettings.sTableId+'_last';
                }
            },

            /*
             * Function: oPagination.full_numbers.fnUpdate
             * Purpose:  Update the list of page buttons shows
             * Returns:  -
             * Inputs:   object:oSettings - dataTables settings object
             *           function:fnCallbackDraw - draw function to call on page change
             */
            "fnUpdate": function ( oSettings, fnCallbackDraw )
            {
                if ( !oSettings.aanFeatures.p )
                {
                    return;
                }

                var iPageCount = DataTable.ext.oPagination.iFullNumbersShowPages;
                var iPageCountHalf = Math.floor(iPageCount / 2);
                var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
                var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
                var sList = "";
                var iStartButton, iEndButton, i, iLen;
                var oClasses = oSettings.oClasses;
                var anButtons, anStatic, nPaginateList, nNode;
                var an = oSettings.aanFeatures.p;
                var fnBind = function (j) {
                    oSettings.oApi._fnBindAction( this, {"page": j+iStartButton-1}, function(e) {
                        /* Use the information in the element to jump to the required page */
                        oSettings.oApi._fnPageChange( oSettings, e.data.page );
                        fnCallbackDraw( oSettings );
                        e.preventDefault();
                    } );
                };

                /* Pages calculation */
                if ( oSettings._iDisplayLength === -1 )
                {
                    iStartButton = 1;
                    iEndButton = 1;
                    iCurrentPage = 1;
                }
                else if (iPages < iPageCount)
                {
                    iStartButton = 1;
                    iEndButton = iPages;
                }
                else if (iCurrentPage <= iPageCountHalf)
                {
                    iStartButton = 1;
                    iEndButton = iPageCount;
                }
                else if (iCurrentPage >= (iPages - iPageCountHalf))
                {
                    iStartButton = iPages - iPageCount + 1;
                    iEndButton = iPages;
                }
                else
                {
                    iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
                    iEndButton = iStartButton + iPageCount - 1;
                }


                /* Build the dynamic list */
                for ( i=iStartButton ; i<=iEndButton ; i++ )
                {
                    sList += (iCurrentPage !== i) ?
                        '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+'">'+oSettings.fnFormatNumber(i)+'</a>' :
                        '<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButtonActive+'">'+oSettings.fnFormatNumber(i)+'</a>';
                }

                /* Loop over each instance of the pager */
                for ( i=0, iLen=an.length ; i<iLen ; i++ )
                {
                    nNode = an[i];
                    if ( !nNode.hasChildNodes() )
                    {
                        continue;
                    }

                    /* Build up the dynamic list first - html and listeners */
                    $('span:eq(0)', nNode)
                        .html( sList )
                        .children('a').each( fnBind );

                    /* Update the permanent button's classes */
                    anButtons = nNode.getElementsByTagName('a');
                    anStatic = [
                        anButtons[0], anButtons[1],
                        anButtons[anButtons.length-2], anButtons[anButtons.length-1]
                    ];

                    $(anStatic).removeClass( oClasses.sPageButton+" "+oClasses.sPageButtonActive+" "+oClasses.sPageButtonStaticDisabled );
                    $([anStatic[0], anStatic[1]]).addClass(
                        (iCurrentPage==1) ?
                            oClasses.sPageButtonStaticDisabled :
                            oClasses.sPageButton
                    );
                    $([anStatic[2], anStatic[3]]).addClass(
                        (iPages===0 || iCurrentPage===iPages || oSettings._iDisplayLength===-1) ?
                            oClasses.sPageButtonStaticDisabled :
                            oClasses.sPageButton
                    );
                }
            }
        }
    } );

    $.extend( DataTable.ext.oSort, {
        /*
         * text sorting
         */
        "string-pre": function ( a )
        {
            if ( typeof a != 'string' ) {
                a = (a !== null && a.toString) ? a.toString() : '';
            }
            return a.toLowerCase();
        },

        "string-asc": function ( x, y )
        {
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        },

        "string-desc": function ( x, y )
        {
            return ((x < y) ? 1 : ((x > y) ? -1 : 0));
        },


        /*
         * html sorting (ignore html tags)
         */
        "html-pre": function ( a )
        {
            return a.replace( /<.*?>/g, "" ).toLowerCase();
        },

        "html-asc": function ( x, y )
        {
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        },

        "html-desc": function ( x, y )
        {
            return ((x < y) ? 1 : ((x > y) ? -1 : 0));
        },


        /*
         * date sorting
         */
        "date-pre": function ( a )
        {
            var x = Date.parse( a );

            if ( isNaN(x) || x==="" )
            {
                x = Date.parse( "01/01/1970 00:00:00" );
            }
            return x;
        },

        "date-asc": function ( x, y )
        {
            return x - y;
        },

        "date-desc": function ( x, y )
        {
            return y - x;
        },


        /*
         * numerical sorting
         */
        "numeric-pre": function ( a )
        {
            return (a=="-" || a==="") ? 0 : a*1;
        },

        "numeric-asc": function ( x, y )
        {
            return x - y;
        },

        "numeric-desc": function ( x, y )
        {
            return y - x;
        }
    } );


    $.extend( DataTable.ext.aTypes, [
        /*
         * Function: -
         * Purpose:  Check to see if a string is numeric
         * Returns:  string:'numeric' or null
         * Inputs:   mixed:sText - string to check
         */
        function ( sData )
        {
            /* Allow zero length strings as a number */
            if ( typeof sData === 'number' )
            {
                return 'numeric';
            }
            else if ( typeof sData !== 'string' )
            {
                return null;
            }

            var sValidFirstChars = "0123456789-";
            var sValidChars = "0123456789.";
            var Char;
            var bDecimal = false;

            /* Check for a valid first char (no period and allow negatives) */
            Char = sData.charAt(0);
            if (sValidFirstChars.indexOf(Char) == -1)
            {
                return null;
            }

            /* Check all the other characters are valid */
            for ( var i=1 ; i<sData.length ; i++ )
            {
                Char = sData.charAt(i);
                if (sValidChars.indexOf(Char) == -1)
                {
                    return null;
                }

                /* Only allowed one decimal place... */
                if ( Char == "." )
                {
                    if ( bDecimal )
                    {
                        return null;
                    }
                    bDecimal = true;
                }
            }

            return 'numeric';
        },

        /*
         * Function: -
         * Purpose:  Check to see if a string is actually a formatted date
         * Returns:  string:'date' or null
         * Inputs:   string:sText - string to check
         */
        function ( sData )
        {
            var iParse = Date.parse(sData);
            if ( (iParse !== null && !isNaN(iParse)) || (typeof sData === 'string' && sData.length === 0) )
            {
                return 'date';
            }
            return null;
        },

        /*
         * Function: -
         * Purpose:  Check to see if a string should be treated as an HTML string
         * Returns:  string:'html' or null
         * Inputs:   string:sText - string to check
         */
        function ( sData )
        {
            if ( typeof sData === 'string' && sData.indexOf('<') != -1 && sData.indexOf('>') != -1 )
            {
                return 'html';
            }
            return null;
        }
    ] );


    // jQuery aliases
    $.fn.DataTable = DataTable;
    $.fn.dataTable = DataTable;
    $.fn.dataTableSettings = DataTable.settings;
    $.fn.dataTableExt = DataTable.ext;


    // Information about events fired by DataTables - for documentation.
    /**
     * Draw event, fired whenever the table is redrawn on the page, at the same point as
     * fnDrawCallback. This may be useful for binding events or performing calculations when
     * the table is altered at all.
     *  @name DataTable#draw
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Filter event, fired when the filtering applied to the table (using the build in global
     * global filter, or column filters) is altered.
     *  @name DataTable#filter
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Page change event, fired when the paging of the table is altered.
     *  @name DataTable#page
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * Sort event, fired when the sorting applied to the table is altered.
     *  @name DataTable#sort
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */

    /**
     * DataTables initialisation complete event, fired when the table is fully drawn,
     * including Ajax data loaded, if Ajax data is required.
     *  @name DataTable#init
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used</li></ol>
     */

    /**
     * State save event, fired when the table has changed state a new state save is required.
     * This method allows modification of the state saving object prior to actually doing the
     * save, including addition or other state properties (for plug-ins) or modification
     * of a DataTables core property.
     *  @name DataTable#stateSaveParams
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The state information to be saved
     */

    /**
     * State load event, fired when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state - allowing modification
     * of the saved state is required or loading of state for a plug-in.
     *  @name DataTable#stateLoadParams
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The saved state information
     */

    /**
     * State loaded event, fired when state has been loaded from stored data and the settings
     * object has been modified by the loaded data.
     *  @name DataTable#stateLoaded
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {object} json The saved state information
     */

    /**
     * Processing event, fired when DataTables is doing some kind of processing (be it,
     * sort, filter or anything else). Can be used to indicate to the end user that
     * there is something happening, or that something has finished.
     *  @name DataTable#processing
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} oSettings DataTables settings object
     *  @param {boolean} bShow Flag for if DataTables is doing processing or not
     */

    /**
     * Ajax (XHR) event, fired whenever an Ajax request is completed from a request to
     * made to the server for new data (note that this trigger is called in fnServerData,
     * if you override fnServerData and which to use this event, you need to trigger it in
     * you success function).
     *  @name DataTable#xhr
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     *  @param {object} json JSON returned from the server
     */

    /**
     * Destroy event, fired when the DataTable is destroyed by calling fnDestroy or passing
     * the bDestroy:true parameter in the initialisation object. This can be used to remove
     * bound events, added DOM nodes, etc.
     *  @name DataTable#destroy
     *  @event
     *  @param {event} e jQuery event object
     *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
     */
}));

}(window, document));


/* jquery.sparkline 1.6 - http://omnipotent.net/jquery.sparkline/ 
** Licensed under the New BSD License - see above site for details */

(function($){var defaults={common:{type:'line',lineColor:'#00f',fillColor:'#cdf',defaultPixelsPerValue:3,width:'auto',height:'auto',composite:false,tagValuesAttribute:'values',tagOptionsPrefix:'spark',enableTagOptions:false},line:{spotColor:'#f80',spotRadius:1.5,minSpotColor:'#f80',maxSpotColor:'#f80',lineWidth:1,normalRangeMin:undefined,normalRangeMax:undefined,normalRangeColor:'#ccc',drawNormalOnTop:false,chartRangeMin:undefined,chartRangeMax:undefined,chartRangeMinX:undefined,chartRangeMaxX:undefined},bar:{barColor:'#00f',negBarColor:'#f44',zeroColor:undefined,nullColor:undefined,zeroAxis:undefined,barWidth:4,barSpacing:1,chartRangeMax:undefined,chartRangeMin:undefined,chartRangeClip:false,colorMap:undefined},tristate:{barWidth:4,barSpacing:1,posBarColor:'#6f6',negBarColor:'#f44',zeroBarColor:'#999',colorMap:{}},discrete:{lineHeight:'auto',thresholdColor:undefined,thresholdValue:0,chartRangeMax:undefined,chartRangeMin:undefined,chartRangeClip:false},bullet:{targetColor:'red',targetWidth:3,performanceColor:'blue',rangeColors:['#D3DAFE','#A8B6FF','#7F94FF'],base:undefined},pie:{sliceColors:['#f00','#0f0','#00f']},box:{raw:false,boxLineColor:'black',boxFillColor:'#cdf',whiskerColor:'black',outlierLineColor:'#333',outlierFillColor:'white',medianColor:'red',showOutliers:true,outlierIQR:1.5,spotRadius:1.5,target:undefined,targetColor:'#4a2',chartRangeMax:undefined,chartRangeMin:undefined}};var VCanvas_base,VCanvas_canvas,VCanvas_vml;$.fn.simpledraw=function(width,height,use_existing){if(use_existing&&this[0].VCanvas){return this[0].VCanvas;}
if(width===undefined){width=$(this).innerWidth();}
if(height===undefined){height=$(this).innerHeight();}
if($.browser.hasCanvas){return new VCanvas_canvas(width,height,this);}else if($.browser.msie){return new VCanvas_vml(width,height,this);}else{return false;}};var pending=[];$.fn.sparkline=function(uservalues,userOptions){return this.each(function(){var options=new $.fn.sparkline.options(this,userOptions);var render=function(){var values,width,height;if(uservalues==='html'||uservalues===undefined){var vals=this.getAttribute(options.get('tagValuesAttribute'));if(vals===undefined||vals===null){vals=$(this).html();}
values=vals.replace(/(^\s*<!--)|(-->\s*$)|\s+/g,'').split(',');}else{values=uservalues;}
width=options.get('width')=='auto'?values.length*options.get('defaultPixelsPerValue'):options.get('width');if(options.get('height')=='auto'){if(!options.get('composite')||!this.VCanvas){var tmp=document.createElement('span');tmp.innerHTML='a';$(this).html(tmp);height=$(tmp).innerHeight();$(tmp).remove();}}else{height=options.get('height');}
$.fn.sparkline[options.get('type')].call(this,values,options,width,height);};if(($(this).html()&&$(this).is(':hidden'))||($.fn.jquery<"1.3.0"&&$(this).parents().is(':hidden'))||!$(this).parents('body').length){pending.push([this,render]);}else{render.call(this);}});};$.fn.sparkline.defaults=defaults;$.sparkline_display_visible=function(){for(var i=pending.length-1;i>=0;i--){var el=pending[i][0];if($(el).is(':visible')&&!$(el).parents().is(':hidden')){pending[i][1].call(el);pending.splice(i,1);}}};var UNSET_OPTION={};var normalizeValue=function(val){switch(val){case'undefined':val=undefined;break;case'null':val=null;break;case'true':val=true;break;case'false':val=false;break;default:var nf=parseFloat(val);if(val==nf){val=nf;}}
return val;};$.fn.sparkline.options=function(tag,userOptions){var extendedOptions;this.userOptions=userOptions=userOptions||{};this.tag=tag;this.tagValCache={};var defaults=$.fn.sparkline.defaults;var base=defaults.common;this.tagOptionsPrefix=userOptions.enableTagOptions&&(userOptions.tagOptionsPrefix||base.tagOptionsPrefix);var tagOptionType=this.getTagSetting('type');if(tagOptionType===UNSET_OPTION){extendedOptions=defaults[userOptions.type||base.type];}else{extendedOptions=defaults[tagOptionType];}
this.mergedOptions=$.extend({},base,extendedOptions,userOptions);};$.fn.sparkline.options.prototype.getTagSetting=function(key){var val,i,prefix=this.tagOptionsPrefix;if(prefix===false||prefix===undefined){return UNSET_OPTION;}
if(this.tagValCache.hasOwnProperty(key)){val=this.tagValCache.key;}else{val=this.tag.getAttribute(prefix+key);if(val===undefined||val===null){val=UNSET_OPTION;}else if(val.substr(0,1)=='['){val=val.substr(1,val.length-2).split(',');for(i=val.length;i--;){val[i]=normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g,''));}}else if(val.substr(0,1)=='{'){var pairs=val.substr(1,val.length-2).split(',');val={};for(i=pairs.length;i--;){var keyval=pairs[i].split(':',2);val[keyval[0].replace(/(^\s*)|(\s*$)/g,'')]=normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g,''));}}else{val=normalizeValue(val);}
this.tagValCache.key=val;}
return val;};$.fn.sparkline.options.prototype.get=function(key){var tagOption=this.getTagSetting(key);if(tagOption!==UNSET_OPTION){return tagOption;}
return this.mergedOptions[key];};$.fn.sparkline.line=function(values,options,width,height){var xvalues=[],yvalues=[],yminmax=[];for(var i=0;i<values.length;i++){var val=values[i];var isstr=typeof(values[i])=='string';var isarray=typeof(values[i])=='object'&&values[i]instanceof Array;var sp=isstr&&values[i].split(':');if(isstr&&sp.length==2){xvalues.push(Number(sp[0]));yvalues.push(Number(sp[1]));yminmax.push(Number(sp[1]));}else if(isarray){xvalues.push(val[0]);yvalues.push(val[1]);yminmax.push(val[1]);}else{xvalues.push(i);if(values[i]===null||values[i]=='null'){yvalues.push(null);}else{yvalues.push(Number(val));yminmax.push(Number(val));}}}
if(options.get('xvalues')){xvalues=options.get('xvalues');}
var maxy=Math.max.apply(Math,yminmax);var maxyval=maxy;var miny=Math.min.apply(Math,yminmax);var minyval=miny;var maxx=Math.max.apply(Math,xvalues);var minx=Math.min.apply(Math,xvalues);var normalRangeMin=options.get('normalRangeMin');var normalRangeMax=options.get('normalRangeMax');if(normalRangeMin!==undefined){if(normalRangeMin<miny){miny=normalRangeMin;}
if(normalRangeMax>maxy){maxy=normalRangeMax;}}
if(options.get('chartRangeMin')!==undefined&&(options.get('chartRangeClip')||options.get('chartRangeMin')<miny)){miny=options.get('chartRangeMin');}
if(options.get('chartRangeMax')!==undefined&&(options.get('chartRangeClip')||options.get('chartRangeMax')>maxy)){maxy=options.get('chartRangeMax');}
if(options.get('chartRangeMinX')!==undefined&&(options.get('chartRangeClipX')||options.get('chartRangeMinX')<minx)){minx=options.get('chartRangeMinX');}
if(options.get('chartRangeMaxX')!==undefined&&(options.get('chartRangeClipX')||options.get('chartRangeMaxX')>maxx)){maxx=options.get('chartRangeMaxX');}
var rangex=maxx-minx===0?1:maxx-minx;var rangey=maxy-miny===0?1:maxy-miny;var vl=yvalues.length-1;if(vl<1){this.innerHTML='';return;}
var target=$(this).simpledraw(width,height,options.get('composite'));if(target){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;var canvas_top=0;var canvas_left=0;var spotRadius=options.get('spotRadius');if(spotRadius&&(canvas_width<(spotRadius*4)||canvas_height<(spotRadius*4))){spotRadius=0;}
if(spotRadius){if(options.get('minSpotColor')||(options.get('spotColor')&&yvalues[vl]==miny)){canvas_height-=Math.ceil(spotRadius);}
if(options.get('maxSpotColor')||(options.get('spotColor')&&yvalues[vl]==maxy)){canvas_height-=Math.ceil(spotRadius);canvas_top+=Math.ceil(spotRadius);}
if(options.get('minSpotColor')||options.get('maxSpotColor')&&(yvalues[0]==miny||yvalues[0]==maxy)){canvas_left+=Math.ceil(spotRadius);canvas_width-=Math.ceil(spotRadius);}
if(options.get('spotColor')||(options.get('minSpotColor')||options.get('maxSpotColor')&&(yvalues[vl]==miny||yvalues[vl]==maxy))){canvas_width-=Math.ceil(spotRadius);}}
canvas_height--;var drawNormalRange=function(){if(normalRangeMin!==undefined){var ytop=canvas_top+Math.round(canvas_height-(canvas_height*((normalRangeMax-miny)/rangey)));var height=Math.round((canvas_height*(normalRangeMax-normalRangeMin))/rangey);target.drawRect(canvas_left,ytop,canvas_width,height,undefined,options.get('normalRangeColor'));}};if(!options.get('drawNormalOnTop')){drawNormalRange();}
var path=[];var paths=[path];var x,y,vlen=yvalues.length;for(i=0;i<vlen;i++){x=xvalues[i];y=yvalues[i];if(y===null){if(i){if(yvalues[i-1]!==null){path=[];paths.push(path);}}}else{if(y<miny){y=miny;}
if(y>maxy){y=maxy;}
if(!path.length){path.push([canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+canvas_height]);}
path.push([canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((y-miny)/rangey)))]);}}
var lineshapes=[];var fillshapes=[];var plen=paths.length;for(i=0;i<plen;i++){path=paths[i];if(!path.length){continue;}
if(options.get('fillColor')){path.push([path[path.length-1][0],canvas_top+canvas_height-1]);fillshapes.push(path.slice(0));path.pop();}
if(path.length>2){path[0]=[path[0][0],path[1][1]];}
lineshapes.push(path);}
plen=fillshapes.length;for(i=0;i<plen;i++){target.drawShape(fillshapes[i],undefined,options.get('fillColor'));}
if(options.get('drawNormalOnTop')){drawNormalRange();}
plen=lineshapes.length;for(i=0;i<plen;i++){target.drawShape(lineshapes[i],options.get('lineColor'),undefined,options.get('lineWidth'));}
if(spotRadius&&options.get('spotColor')){target.drawCircle(canvas_left+Math.round(xvalues[xvalues.length-1]*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((yvalues[vl]-miny)/rangey))),spotRadius,undefined,options.get('spotColor'));}
if(maxy!=minyval){if(spotRadius&&options.get('minSpotColor')){x=xvalues[$.inArray(minyval,yvalues)];target.drawCircle(canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((minyval-miny)/rangey))),spotRadius,undefined,options.get('minSpotColor'));}
if(spotRadius&&options.get('maxSpotColor')){x=xvalues[$.inArray(maxyval,yvalues)];target.drawCircle(canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((maxyval-miny)/rangey))),spotRadius,undefined,options.get('maxSpotColor'));}}}else{this.innerHTML='';}};$.fn.sparkline.bar=function(values,options,width,height){width=(values.length*options.get('barWidth'))+((values.length-1)*options.get('barSpacing'));var num_values=[];for(var i=0,vlen=values.length;i<vlen;i++){if(values[i]=='null'||values[i]===null){values[i]=null;}else{values[i]=Number(values[i]);num_values.push(Number(values[i]));}}
var max=Math.max.apply(Math,num_values),min=Math.min.apply(Math,num_values);if(options.get('chartRangeMin')!==undefined&&(options.get('chartRangeClip')||options.get('chartRangeMin')<min)){min=options.get('chartRangeMin');}
if(options.get('chartRangeMax')!==undefined&&(options.get('chartRangeClip')||options.get('chartRangeMax')>max)){max=options.get('chartRangeMax');}
var zeroAxis=options.get('zeroAxis');if(zeroAxis===undefined){zeroAxis=min<0;}
var range=max-min===0?1:max-min;var colorMapByIndex,colorMapByValue;if($.isArray(options.get('colorMap'))){colorMapByIndex=options.get('colorMap');colorMapByValue=null;}else{colorMapByIndex=null;colorMapByValue=options.get('colorMap');}
var target=$(this).simpledraw(width,height,options.get('composite'));if(target){var color,canvas_height=target.pixel_height,yzero=min<0&&zeroAxis?canvas_height-Math.round(canvas_height*(Math.abs(min)/range))-1:canvas_height-1;for(i=values.length;i--;){var x=i*(options.get('barWidth')+options.get('barSpacing')),y,val=values[i];if(val===null){if(options.get('nullColor')){color=options.get('nullColor');val=(zeroAxis&&min<0)?0:min;height=1;y=(zeroAxis&&min<0)?yzero:canvas_height-height;}else{continue;}}else{if(val<min){val=min;}
if(val>max){val=max;}
color=(val<0)?options.get('negBarColor'):options.get('barColor');if(zeroAxis&&min<0){height=Math.round(canvas_height*((Math.abs(val)/range)))+1;y=(val<0)?yzero:yzero-height;}else{height=Math.round(canvas_height*((val-min)/range))+1;y=canvas_height-height;}
if(val===0&&options.get('zeroColor')!==undefined){color=options.get('zeroColor');}
if(colorMapByValue&&colorMapByValue[val]){color=colorMapByValue[val];}else if(colorMapByIndex&&colorMapByIndex.length>i){color=colorMapByIndex[i];}
if(color===null){continue;}}
target.drawRect(x,y,options.get('barWidth')-1,height-1,color,color);}}else{this.innerHTML='';}};$.fn.sparkline.tristate=function(values,options,width,height){values=$.map(values,Number);width=(values.length*options.get('barWidth'))+((values.length-1)*options.get('barSpacing'));var colorMapByIndex,colorMapByValue;if($.isArray(options.get('colorMap'))){colorMapByIndex=options.get('colorMap');colorMapByValue=null;}else{colorMapByIndex=null;colorMapByValue=options.get('colorMap');}
var target=$(this).simpledraw(width,height,options.get('composite'));if(target){var canvas_height=target.pixel_height,half_height=Math.round(canvas_height/2);for(var i=values.length;i--;){var x=i*(options.get('barWidth')+options.get('barSpacing')),y,color;if(values[i]<0){y=half_height;height=half_height-1;color=options.get('negBarColor');}else if(values[i]>0){y=0;height=half_height-1;color=options.get('posBarColor');}else{y=half_height-1;height=2;color=options.get('zeroBarColor');}
if(colorMapByValue&&colorMapByValue[values[i]]){color=colorMapByValue[values[i]];}else if(colorMapByIndex&&colorMapByIndex.length>i){color=colorMapByIndex[i];}
if(color===null){continue;}
target.drawRect(x,y,options.get('barWidth')-1,height-1,color,color);}}else{this.innerHTML='';}};$.fn.sparkline.discrete=function(values,options,width,height){values=$.map(values,Number);width=options.get('width')=='auto'?values.length*2:width;var interval=Math.floor(width/values.length);var target=$(this).simpledraw(width,height,options.get('composite'));if(target){var canvas_height=target.pixel_height,line_height=options.get('lineHeight')=='auto'?Math.round(canvas_height*0.3):options.get('lineHeight'),pheight=canvas_height-line_height,min=Math.min.apply(Math,values),max=Math.max.apply(Math,values);if(options.get('chartRangeMin')!==undefined&&(options.get('chartRangeClip')||options.get('chartRangeMin')<min)){min=options.get('chartRangeMin');}
if(options.get('chartRangeMax')!==undefined&&(options.get('chartRangeClip')||options.get('chartRangeMax')>max)){max=options.get('chartRangeMax');}
var range=max-min;for(var i=values.length;i--;){var val=values[i];if(val<min){val=min;}
if(val>max){val=max;}
var x=(i*interval),ytop=Math.round(pheight-pheight*((val-min)/range));target.drawLine(x,ytop,x,ytop+line_height,(options.get('thresholdColor')&&val<options.get('thresholdValue'))?options.get('thresholdColor'):options.get('lineColor'));}}else{this.innerHTML='';}};$.fn.sparkline.bullet=function(values,options,width,height){values=$.map(values,Number);width=options.get('width')=='auto'?'4.0em':width;var target=$(this).simpledraw(width,height,options.get('composite'));if(target&&values.length>1){var canvas_width=target.pixel_width-Math.ceil(options.get('targetWidth')/2),canvas_height=target.pixel_height,min=Math.min.apply(Math,values),max=Math.max.apply(Math,values);if(options.get('base')===undefined){min=min<0?min:0;}else{min=options.get('base');}
var range=max-min;for(var i=2,vlen=values.length;i<vlen;i++){var rangeval=values[i],rangewidth=Math.round(canvas_width*((rangeval-min)/range));target.drawRect(0,0,rangewidth-1,canvas_height-1,options.get('rangeColors')[i-2],options.get('rangeColors')[i-2]);}
var perfval=values[1],perfwidth=Math.round(canvas_width*((perfval-min)/range));target.drawRect(0,Math.round(canvas_height*0.3),perfwidth-1,Math.round(canvas_height*0.4)-1,options.get('performanceColor'),options.get('performanceColor'));var targetval=values[0],x=Math.round(canvas_width*((targetval-min)/range)-(options.get('targetWidth')/2)),targettop=Math.round(canvas_height*0.10),targetheight=canvas_height-(targettop*2);target.drawRect(x,targettop,options.get('targetWidth')-1,targetheight-1,options.get('targetColor'),options.get('targetColor'));}else{this.innerHTML='';}};$.fn.sparkline.pie=function(values,options,width,height){values=$.map(values,Number);width=options.get('width')=='auto'?height:width;var target=$(this).simpledraw(width,height,options.get('composite'));if(target&&values.length>1){var canvas_width=target.pixel_width,canvas_height=target.pixel_height,radius=Math.floor(Math.min(canvas_width,canvas_height)/2),total=0,next=0,circle=2*Math.PI;for(var i=values.length;i--;){total+=values[i];}
if(options.get('offset')){next+=(2*Math.PI)*(options.get('offset')/360);}
var vlen=values.length;for(i=0;i<vlen;i++){var start=next;var end=next;if(total>0){end=next+(circle*(values[i]/total));}
target.drawPieSlice(radius,radius,radius,start,end,undefined,options.get('sliceColors')[i%options.get('sliceColors').length]);next=end;}}};var quartile=function(values,q){if(q==2){var vl2=Math.floor(values.length/2);return values.length%2?values[vl2]:(values[vl2]+values[vl2+1])/2;}else{var vl4=Math.floor(values.length/4);return values.length%2?(values[vl4*q]+values[vl4*q+1])/2:values[vl4*q];}};$.fn.sparkline.box=function(values,options,width,height){values=$.map(values,Number);width=options.get('width')=='auto'?'4.0em':width;var minvalue=options.get('chartRangeMin')===undefined?Math.min.apply(Math,values):options.get('chartRangeMin'),maxvalue=options.get('chartRangeMax')===undefined?Math.max.apply(Math,values):options.get('chartRangeMax'),target=$(this).simpledraw(width,height,options.get('composite')),vlen=values.length,lwhisker,loutlier,q1,q2,q3,rwhisker,routlier;if(target&&values.length>1){var canvas_width=target.pixel_width,canvas_height=target.pixel_height;if(options.get('raw')){if(options.get('showOutliers')&&values.length>5){loutlier=values[0];lwhisker=values[1];q1=values[2];q2=values[3];q3=values[4];rwhisker=values[5];routlier=values[6];}else{lwhisker=values[0];q1=values[1];q2=values[2];q3=values[3];rwhisker=values[4];}}else{values.sort(function(a,b){return a-b;});q1=quartile(values,1);q2=quartile(values,2);q3=quartile(values,3);var iqr=q3-q1;if(options.get('showOutliers')){lwhisker=undefined;rwhisker=undefined;for(var i=0;i<vlen;i++){if(lwhisker===undefined&&values[i]>q1-(iqr*options.get('outlierIQR'))){lwhisker=values[i];}
if(values[i]<q3+(iqr*options.get('outlierIQR'))){rwhisker=values[i];}}
loutlier=values[0];routlier=values[vlen-1];}else{lwhisker=values[0];rwhisker=values[vlen-1];}}
var unitsize=canvas_width/(maxvalue-minvalue+1),canvas_left=0;if(options.get('showOutliers')){canvas_left=Math.ceil(options.get('spotRadius'));canvas_width-=2*Math.ceil(options.get('spotRadius'));unitsize=canvas_width/(maxvalue-minvalue+1);if(loutlier<lwhisker){target.drawCircle((loutlier-minvalue)*unitsize+canvas_left,canvas_height/2,options.get('spotRadius'),options.get('outlierLineColor'),options.get('outlierFillColor'));}
if(routlier>rwhisker){target.drawCircle((routlier-minvalue)*unitsize+canvas_left,canvas_height/2,options.get('spotRadius'),options.get('outlierLineColor'),options.get('outlierFillColor'));}}
target.drawRect(Math.round((q1-minvalue)*unitsize+canvas_left),Math.round(canvas_height*0.1),Math.round((q3-q1)*unitsize),Math.round(canvas_height*0.8),options.get('boxLineColor'),options.get('boxFillColor'));target.drawLine(Math.round((lwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),Math.round((q1-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),options.get('lineColor'));target.drawLine(Math.round((lwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/4),Math.round((lwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height-canvas_height/4),options.get('whiskerColor'));target.drawLine(Math.round((rwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),Math.round((q3-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),options.get('lineColor'));target.drawLine(Math.round((rwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/4),Math.round((rwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height-canvas_height/4),options.get('whiskerColor'));target.drawLine(Math.round((q2-minvalue)*unitsize+canvas_left),Math.round(canvas_height*0.1),Math.round((q2-minvalue)*unitsize+canvas_left),Math.round(canvas_height*0.9),options.get('medianColor'));if(options.get('target')){var size=Math.ceil(options.get('spotRadius'));target.drawLine(Math.round((options.get('target')-minvalue)*unitsize+canvas_left),Math.round((canvas_height/2)-size),Math.round((options.get('target')-minvalue)*unitsize+canvas_left),Math.round((canvas_height/2)+size),options.get('targetColor'));target.drawLine(Math.round((options.get('target')-minvalue)*unitsize+canvas_left-size),Math.round(canvas_height/2),Math.round((options.get('target')-minvalue)*unitsize+canvas_left+size),Math.round(canvas_height/2),options.get('targetColor'));}}else{this.innerHTML='';}};if($.browser.msie&&!document.namespaces.v){document.namespaces.add('v','urn:schemas-microsoft-com:vml','#default#VML');}
if($.browser.hasCanvas===undefined){var t=document.createElement('canvas');$.browser.hasCanvas=t.getContext!==undefined;}
VCanvas_base=function(width,height,target){};VCanvas_base.prototype={init:function(width,height,target){this.width=width;this.height=height;this.target=target;if(target[0]){target=target[0];}
target.VCanvas=this;},drawShape:function(path,lineColor,fillColor,lineWidth){alert('drawShape not implemented');},drawLine:function(x1,y1,x2,y2,lineColor,lineWidth){return this.drawShape([[x1,y1],[x2,y2]],lineColor,lineWidth);},drawCircle:function(x,y,radius,lineColor,fillColor){alert('drawCircle not implemented');},drawPieSlice:function(x,y,radius,startAngle,endAngle,lineColor,fillColor){alert('drawPieSlice not implemented');},drawRect:function(x,y,width,height,lineColor,fillColor){alert('drawRect not implemented');},getElement:function(){return this.canvas;},_insert:function(el,target){$(target).html(el);}};VCanvas_canvas=function(width,height,target){return this.init(width,height,target);};VCanvas_canvas.prototype=$.extend(new VCanvas_base(),{_super:VCanvas_base.prototype,init:function(width,height,target){this._super.init(width,height,target);this.canvas=document.createElement('canvas');if(target[0]){target=target[0];}
target.VCanvas=this;$(this.canvas).css({display:'inline-block',width:width,height:height,verticalAlign:'top'});this._insert(this.canvas,target);this.pixel_height=$(this.canvas).height();this.pixel_width=$(this.canvas).width();this.canvas.width=this.pixel_width;this.canvas.height=this.pixel_height;$(this.canvas).css({width:this.pixel_width,height:this.pixel_height});},_getContext:function(lineColor,fillColor,lineWidth){var context=this.canvas.getContext('2d');if(lineColor!==undefined){context.strokeStyle=lineColor;}
context.lineWidth=lineWidth===undefined?1:lineWidth;if(fillColor!==undefined){context.fillStyle=fillColor;}
return context;},drawShape:function(path,lineColor,fillColor,lineWidth){var context=this._getContext(lineColor,fillColor,lineWidth);context.beginPath();context.moveTo(path[0][0]+0.5,path[0][1]+0.5);for(var i=1,plen=path.length;i<plen;i++){context.lineTo(path[i][0]+0.5,path[i][1]+0.5);}
if(lineColor!==undefined){context.stroke();}
if(fillColor!==undefined){context.fill();}},drawCircle:function(x,y,radius,lineColor,fillColor){var context=this._getContext(lineColor,fillColor);context.beginPath();context.arc(x,y,radius,0,2*Math.PI,false);if(lineColor!==undefined){context.stroke();}
if(fillColor!==undefined){context.fill();}},drawPieSlice:function(x,y,radius,startAngle,endAngle,lineColor,fillColor){var context=this._getContext(lineColor,fillColor);context.beginPath();context.moveTo(x,y);context.arc(x,y,radius,startAngle,endAngle,false);context.lineTo(x,y);context.closePath();if(lineColor!==undefined){context.stroke();}
if(fillColor){context.fill();}},drawRect:function(x,y,width,height,lineColor,fillColor){return this.drawShape([[x,y],[x+width,y],[x+width,y+height],[x,y+height],[x,y]],lineColor,fillColor);}});VCanvas_vml=function(width,height,target){return this.init(width,height,target);};VCanvas_vml.prototype=$.extend(new VCanvas_base(),{_super:VCanvas_base.prototype,init:function(width,height,target){this._super.init(width,height,target);if(target[0]){target=target[0];}
target.VCanvas=this;this.canvas=document.createElement('span');$(this.canvas).css({display:'inline-block',position:'relative',overflow:'hidden',width:width,height:height,margin:'0px',padding:'0px',verticalAlign:'top'});this._insert(this.canvas,target);this.pixel_height=$(this.canvas).height();this.pixel_width=$(this.canvas).width();this.canvas.width=this.pixel_width;this.canvas.height=this.pixel_height;var groupel='<v:group coordorigin="0 0" coordsize="'+this.pixel_width+' '+this.pixel_height+'"'+' style="position:absolute;top:0;left:0;width:'+this.pixel_width+'px;height='+this.pixel_height+'px;"></v:group>';this.canvas.insertAdjacentHTML('beforeEnd',groupel);this.group=$(this.canvas).children()[0];},drawShape:function(path,lineColor,fillColor,lineWidth){var vpath=[];for(var i=0,plen=path.length;i<plen;i++){vpath[i]=''+(path[i][0])+','+(path[i][1]);}
var initial=vpath.splice(0,1);lineWidth=lineWidth===undefined?1:lineWidth;var stroke=lineColor===undefined?' stroked="false" ':' strokeWeight="'+lineWidth+'" strokeColor="'+lineColor+'" ';var fill=fillColor===undefined?' filled="false"':' fillColor="'+fillColor+'" filled="true" ';var closed=vpath[0]==vpath[vpath.length-1]?'x ':'';var vel='<v:shape coordorigin="0 0" coordsize="'+this.pixel_width+' '+this.pixel_height+'" '+
stroke+
fill+' style="position:absolute;left:0px;top:0px;height:'+this.pixel_height+'px;width:'+this.pixel_width+'px;padding:0px;margin:0px;" '+' path="m '+initial+' l '+vpath.join(', ')+' '+closed+'e">'+' </v:shape>';this.group.insertAdjacentHTML('beforeEnd',vel);},drawCircle:function(x,y,radius,lineColor,fillColor){x-=radius+1;y-=radius+1;var stroke=lineColor===undefined?' stroked="false" ':' strokeWeight="1" strokeColor="'+lineColor+'" ';var fill=fillColor===undefined?' filled="false"':' fillColor="'+fillColor+'" filled="true" ';var vel='<v:oval '+
stroke+
fill+' style="position:absolute;top:'+y+'px; left:'+x+'px; width:'+(radius*2)+'px; height:'+(radius*2)+'px"></v:oval>';this.group.insertAdjacentHTML('beforeEnd',vel);},drawPieSlice:function(x,y,radius,startAngle,endAngle,lineColor,fillColor){if(startAngle==endAngle){return;}
if((endAngle-startAngle)==(2*Math.PI)){startAngle=0.0;endAngle=(2*Math.PI);}
var startx=x+Math.round(Math.cos(startAngle)*radius);var starty=y+Math.round(Math.sin(startAngle)*radius);var endx=x+Math.round(Math.cos(endAngle)*radius);var endy=y+Math.round(Math.sin(endAngle)*radius);if(startx==endx&&starty==endy&&(endAngle-startAngle)<Math.PI){return;}
var vpath=[x-radius,y-radius,x+radius,y+radius,startx,starty,endx,endy];var stroke=lineColor===undefined?' stroked="false" ':' strokeWeight="1" strokeColor="'+lineColor+'" ';var fill=fillColor===undefined?' filled="false"':' fillColor="'+fillColor+'" filled="true" ';var vel='<v:shape coordorigin="0 0" coordsize="'+this.pixel_width+' '+this.pixel_height+'" '+
stroke+
fill+' style="position:absolute;left:0px;top:0px;height:'+this.pixel_height+'px;width:'+this.pixel_width+'px;padding:0px;margin:0px;" '+' path="m '+x+','+y+' wa '+vpath.join(', ')+' x e">'+' </v:shape>';this.group.insertAdjacentHTML('beforeEnd',vel);},drawRect:function(x,y,width,height,lineColor,fillColor){return this.drawShape([[x,y],[x,y+height],[x+width,y+height],[x+width,y],[x,y]],lineColor,fillColor);}});})(jQuery);
/**
 * jQuery.ScrollTo - Easy element scrolling using jQuery.
 * Copyright (c) 2007-2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 9/11/2008
 * @author Ariel Flesler
 * @version 1.4
 *
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 */
;(function(h){var m=h.scrollTo=function(b,c,g){h(window).scrollTo(b,c,g)};m.defaults={axis:'y',duration:1};m.window=function(b){return h(window).scrollable()};h.fn.scrollable=function(){return this.map(function(){var b=this.parentWindow||this.defaultView,c=this.nodeName=='#document'?b.frameElement||b:this,g=c.contentDocument||(c.contentWindow||c).document,i=c.setInterval;return c.nodeName=='IFRAME'||i&&h.browser.safari?g.body:i?g.documentElement:this})};h.fn.scrollTo=function(r,j,a){if(typeof j=='object'){a=j;j=0}if(typeof a=='function')a={onAfter:a};a=h.extend({},m.defaults,a);j=j||a.speed||a.duration;a.queue=a.queue&&a.axis.length>1;if(a.queue)j/=2;a.offset=n(a.offset);a.over=n(a.over);return this.scrollable().each(function(){var k=this,o=h(k),d=r,l,e={},p=o.is('html,body');switch(typeof d){case'number':case'string':if(/^([+-]=)?\d+(px)?$/.test(d)){d=n(d);break}d=h(d,this);case'object':if(d.is||d.style)l=(d=h(d)).offset()}h.each(a.axis.split(''),function(b,c){var g=c=='x'?'Left':'Top',i=g.toLowerCase(),f='scroll'+g,s=k[f],t=c=='x'?'Width':'Height',v=t.toLowerCase();if(l){e[f]=l[i]+(p?0:s-o.offset()[i]);if(a.margin){e[f]-=parseInt(d.css('margin'+g))||0;e[f]-=parseInt(d.css('border'+g+'Width'))||0}e[f]+=a.offset[i]||0;if(a.over[i])e[f]+=d[v]()*a.over[i]}else e[f]=d[i];if(/^\d+$/.test(e[f]))e[f]=e[f]<=0?0:Math.min(e[f],u(t));if(!b&&a.queue){if(s!=e[f])q(a.onAfterFirst);delete e[f]}});q(a.onAfter);function q(b){o.animate(e,j,a.easing,b&&function(){b.call(this,r,a)})};function u(b){var c='scroll'+b,g=k.ownerDocument;return p?Math.max(g.documentElement[c],g.body[c]):k[c]}}).end()};function n(b){return typeof b=='object'?b:{top:b,left:b}}})(jQuery);
/*
 * jQuery Text Overflow v0.7
 *
 * Licensed under the new BSD License.
 * Copyright 2009-2010, Bram Stein
 * All rights reserved.
 */
(function(c){var b=document.documentElement.style,d=("textOverflow" in b||"OTextOverflow" in b),a=function(f,i){var h=0,e=[],g=function(j){var l=0,k;if(h>i){return}for(l=0;l<j.length;l+=1){if(j[l].nodeType===1){k=j[l].cloneNode(false);e[e.length-1].appendChild(k);e.push(k);g(j[l].childNodes);e.pop()}else{if(j[l].nodeType===3){if(h+j[l].length<i){e[e.length-1].appendChild(j[l].cloneNode(false))}else{k=j[l].cloneNode(false);k.textContent=c.trim(k.textContent.substring(0,i-h));e[e.length-1].appendChild(k)}h+=j[l].length}else{e.appendChild(j[l].cloneNode(false))}}}};e.push(f.cloneNode(false));g(f.childNodes);return c(e.pop().childNodes)};c.extend(c.fn,{textOverflow:function(g,e){var f=g||"&#x2026;";if(!d){return this.each(function(){var l=c(this),m=l.clone(),p=l.clone(),k=l.text(),h=l.width(),n=0,o=0,j=k.length,i=function(){if(h!==l.width()){l.replaceWith(p);l=p;p=l.clone();l.textOverflow(g,false);h=l.width()}};l.after(m.hide().css({position:"absolute",width:"auto",overflow:"visible","max-width":"inherit"}));if(m.width()>h){while(n<j){o=Math.floor(n+((j-n)/2));m.empty().append(a(p.get(0),o)).append(f);if(m.width()<h){n=o+1}else{j=o}}if(n<k.length){l.empty().append(a(p.get(0),n-1)).append(f)}}m.remove();if(e){setInterval(i,200)}})}else{return this}}})})(jQuery);
(function(jQuery){var nfLocales=new Hashtable();var nfLocalesLikeUS=['ae','au','ca','cn','eg','gb','hk','il','in','jp','sk','th','tw','us'];var nfLocalesLikeDE=['at','br','de','dk','es','gr','it','nl','pt','tr','vn'];var nfLocalesLikeFR=['cz','fi','fr','ru','se','pl'];var nfLocalesLikeCH=['ch'];var nfLocaleFormatting=[[".",","],[",","."],[","," "],[".","'"]];var nfAllLocales=[nfLocalesLikeUS,nfLocalesLikeDE,nfLocalesLikeFR,nfLocalesLikeCH]
function FormatData(dec,group,neg){this.dec=dec;this.group=group;this.neg=neg;};function init(){for(var localeGroupIdx in nfAllLocales){localeGroup=nfAllLocales[localeGroupIdx];for(var i=0;i<localeGroup.length;i++){nfLocales.put(localeGroup[i],localeGroupIdx);}}};function formatCodes(locale){if(nfLocales.size()==0)
init();var dec=".";var group=",";var neg="-";var codesIndex=nfLocales.get(locale);if(codesIndex){var codes=nfLocaleFormatting[codesIndex];if(codes){dec=codes[0];group=codes[1];}}
return new FormatData(dec,group,neg);};jQuery.fn.formatNumber=function(options,writeBack,giveReturnValue){return this.each(function(){if(writeBack==null)
writeBack=true;if(giveReturnValue==null)
giveReturnValue=true;var text;if(jQuery(this).is(":input"))
text=new String(jQuery(this).val());else
text=new String(jQuery(this).text());var returnString=jQuery.formatNumber(text,options);if(writeBack){if(jQuery(this).is(":input"))
jQuery(this).val(returnString);else
jQuery(this).text(returnString);}
if(giveReturnValue)
return returnString;});};jQuery.formatNumber=function(numberString,options){var options=jQuery.extend({},jQuery.fn.formatNumber.defaults,options);var formatData=formatCodes(options.locale.toLowerCase());var dec=formatData.dec;var group=formatData.group;var neg=formatData.neg;var validFormat="0#-,.";var prefix="";var negativeInFront=false;for(var i=0;i<options.format.length;i++){if(validFormat.indexOf(options.format.charAt(i))==-1)
prefix=prefix+options.format.charAt(i);else
if(i==0&&options.format.charAt(i)=='-'){negativeInFront=true;continue;}
else
break;}
var suffix="";for(var i=options.format.length-1;i>=0;i--){if(validFormat.indexOf(options.format.charAt(i))==-1)
suffix=options.format.charAt(i)+suffix;else
break;}
options.format=options.format.substring(prefix.length);options.format=options.format.substring(0,options.format.length-suffix.length);var number=new Number(numberString);return jQuery._formatNumber(number,options,suffix,prefix,negativeInFront);};jQuery._formatNumber=function(number,options,suffix,prefix,negativeInFront){var options=jQuery.extend({},jQuery.fn.formatNumber.defaults,options);var formatData=formatCodes(options.locale.toLowerCase());var dec=formatData.dec;var group=formatData.group;var neg=formatData.neg;var forcedToZero=false;if(isNaN(number)){if(options.nanForceZero==true){number=0;forcedToZero=true;}else
return null;}
if(suffix=="%")
number=number*100;var returnString="";if(options.format.indexOf(".")>-1){var decimalPortion=dec;var decimalFormat=options.format.substring(options.format.lastIndexOf(".")+1);if(options.round==true)
number=new Number(number.toFixed(decimalFormat.length));else{var numStr=number.toString();numStr=numStr.substring(0,numStr.lastIndexOf('.')+decimalFormat.length+1);number=new Number(numStr);}
var decimalValue=number%1;var decimalString=new String(decimalValue.toFixed(decimalFormat.length));decimalString=decimalString.substring(decimalString.lastIndexOf(".")+1);for(var i=0;i<decimalFormat.length;i++){if(decimalFormat.charAt(i)=='#'&&decimalString.charAt(i)!='0'){decimalPortion+=decimalString.charAt(i);continue;}else if(decimalFormat.charAt(i)=='#'&&decimalString.charAt(i)=='0'){var notParsed=decimalString.substring(i);if(notParsed.match('[1-9]')){decimalPortion+=decimalString.charAt(i);continue;}else
break;}else if(decimalFormat.charAt(i)=="0")
decimalPortion+=decimalString.charAt(i);}
returnString+=decimalPortion}else
number=Math.round(number);var ones=Math.floor(number);if(number<0)
ones=Math.ceil(number);var onesFormat="";if(options.format.indexOf(".")==-1)
onesFormat=options.format;else
onesFormat=options.format.substring(0,options.format.indexOf("."));var onePortion="";if(!(ones==0&&onesFormat.substr(-1,1)=='#')||forcedToZero){var oneText=new String(Math.abs(ones));var groupLength=9999;if(onesFormat.lastIndexOf(",")!=-1)
groupLength=onesFormat.length-onesFormat.lastIndexOf(",")-1;var groupCount=0;for(var i=oneText.length-1;i>-1;i--){onePortion=oneText.charAt(i)+onePortion;groupCount++;if(groupCount==groupLength&&i!=0){onePortion=group+onePortion;groupCount=0;}}}
returnString=onePortion+returnString;if(number<0&&negativeInFront&&prefix.length>0)
prefix=neg+prefix;else if(number<0)
returnString=neg+returnString;if(!options.decimalSeparatorAlwaysShown){if(returnString.lastIndexOf(dec)==returnString.length-1){returnString=returnString.substring(0,returnString.length-1);}}
returnString=prefix+returnString+suffix;return returnString;};jQuery.fn.parseNumber=function(options,writeBack,giveReturnValue){if(writeBack==null)
writeBack=true;if(giveReturnValue==null)
giveReturnValue=true;var text;if(jQuery(this).is(":input"))
text=new String(jQuery(this).val());else
text=new String(jQuery(this).text());var number=jQuery.parseNumber(text,options);if(number){if(writeBack){if(jQuery(this).is(":input"))
jQuery(this).val(number.toString());else
jQuery(this).text(number.toString());}
if(giveReturnValue)
return number;}};jQuery.parseNumber=function(numberString,options){var options=jQuery.extend({},jQuery.fn.parseNumber.defaults,options);var formatData=formatCodes(options.locale.toLowerCase());var dec=formatData.dec;var group=formatData.group;var neg=formatData.neg;var valid="1234567890.-";while(numberString.indexOf(group)>-1)
numberString=numberString.replace(group,'');numberString=numberString.replace(dec,".").replace(neg,"-");var validText="";var hasPercent=false;if(numberString.charAt(numberString.length-1)=="%")
hasPercent=true;for(var i=0;i<numberString.length;i++){if(valid.indexOf(numberString.charAt(i))>-1)
validText=validText+numberString.charAt(i);}
var number=new Number(validText);if(hasPercent){number=number/100;number=number.toFixed(validText.length-1);}
return number;};jQuery.fn.parseNumber.defaults={locale:"us",decimalSeparatorAlwaysShown:false};jQuery.fn.formatNumber.defaults={format:"#,###.00",locale:"us",decimalSeparatorAlwaysShown:false,nanForceZero:true,round:true};})(jQuery);
/*
 * jQuery treeTable Plugin 2.3.0
 * http://ludo.cubicphuse.nl/jquery-plugins/treeTable/
 *
 * Copyright 2010, Ludo van den Boom
 * Dual licensed under the MIT or GPL Version 2 licenses.
 */
(function($) {
  // Helps to make options available to all functions
  // TODO: This gives problems when there are both expandable and non-expandable
  // trees on a page. The options shouldn't be global to all these instances!
  var options;
  var defaultPaddingLeft;
  
  $.fn.treeTable = function(opts) {
    options = $.extend({}, $.fn.treeTable.defaults, opts);
    
    return this.each(function() {
      $(this).addClass("treeTable").find("tbody tr").each(function() {
        // Initialize root nodes only if possible
        if(!options.expandable || $(this)[0].className.search(options.childPrefix) == -1) {
          // To optimize performance of indentation, I retrieve the padding-left
          // value of the first root node. This way I only have to call +css+ 
          // once.
          if (isNaN(defaultPaddingLeft)) {
            defaultPaddingLeft = parseInt($($(this).children("td")[options.treeColumn]).css('padding-left'), 10);
          }
          
          initialize($(this));
        } else if(options.initialState == "collapsed") {
          this.style.display = "none"; // Performance! $(this).hide() is slow...
        }
      });
    });
  };
  
  $.fn.treeTable.defaults = {
    childPrefix: "child-of-",
    clickableNodeNames: false,
    expandable: true,
    indent: 19,
    initialState: "collapsed",
    treeColumn: 0
  };
  
  // Recursively hide all node's children in a tree
  $.fn.collapse = function() {
    $(this).addClass("collapsed");
    
    childrenOf($(this)).each(function() {
      if(!$(this).hasClass("collapsed")) {
        $(this).collapse();
      }
      
      this.style.display = "none"; // Performance! $(this).hide() is slow...
    });
    
    return this;
  };
  
  // Recursively show all node's children in a tree
  $.fn.expand = function() {
    $(this).removeClass("collapsed").addClass("expanded");
    
    childrenOf($(this)).each(function() {
      initialize($(this));
      
      if($(this).is(".expanded.parent")) {
        $(this).expand();
      }
      
      // this.style.display = "table-row"; // Unfortunately this is not possible with IE :-(
      $(this).show();
    });
    
    return this;
  };

  // Reveal a node by expanding all ancestors
  $.fn.reveal = function() {
    $(ancestorsOf($(this)).reverse()).each(function() {
      initialize($(this));
      $(this).expand().show();
    });
    
    return this;
  };

  // Add an entire branch to +destination+
  $.fn.appendBranchTo = function(destination) {
    var node = $(this);
    var parent = parentOf(node);
    
    var ancestorNames = $.map(ancestorsOf($(destination)), function(a) { return a.id; });
    
    // Conditions:
    // 1: +node+ should not be inserted in a location in a branch if this would
    //    result in +node+ being an ancestor of itself.
    // 2: +node+ should not have a parent OR the destination should not be the
    //    same as +node+'s current parent (this last condition prevents +node+
    //    from being moved to the same location where it already is).
    // 3: +node+ should not be inserted as a child of +node+ itself.
    if($.inArray(node[0].id, ancestorNames) == -1 && (!parent || (destination.id != parent[0].id)) && destination.id != node[0].id) {
      indent(node, ancestorsOf(node).length * options.indent * -1); // Remove indentation
      
      if(parent) { node.removeClass(options.childPrefix + parent[0].id); }
      
      node.addClass(options.childPrefix + destination.id);
      move(node, destination); // Recursively move nodes to new location
      indent(node, ancestorsOf(node).length * options.indent);
    }
    
    return this;
  };
  
  // Add reverse() function from JS Arrays
  $.fn.reverse = function() {
    return this.pushStack(this.get().reverse(), arguments);
  };
  
  // Toggle an entire branch
  $.fn.toggleBranch = function() {
    if($(this).hasClass("collapsed")) {
      $(this).expand();
    } else {
      $(this).removeClass("expanded").collapse();
    }
    
    return this;
  };
  
  // === Private functions
  
  function ancestorsOf(node) {
    var ancestors = [];
    while(node = parentOf(node)) {
      ancestors[ancestors.length] = node[0];
    }
    return ancestors;
  };
  
  function childrenOf(node) {
    return $("table.treeTable tbody tr." + options.childPrefix + node[0].id);
  };
  
  function getPaddingLeft(node) {
    var paddingLeft = parseInt(node[0].style.paddingLeft, 10);
    return (isNaN(paddingLeft)) ? defaultPaddingLeft : paddingLeft;
  }
  
  function indent(node, value) {
    var cell = $(node.children("td")[options.treeColumn]);
    cell[0].style.paddingLeft = getPaddingLeft(cell) + value + "px";
    
    childrenOf(node).each(function() {
      indent($(this), value);
    });
  };
  
  function initialize(node) {
    if(!node.hasClass("initialized")) {
      node.addClass("initialized");
      
      var childNodes = childrenOf(node);
      
      if(!node.hasClass("parent") && childNodes.length > 0) {
        node.addClass("parent");
      }
      
      if(node.hasClass("parent")) {
        var cell = $(node.children("td")[options.treeColumn]);
        var padding = getPaddingLeft(cell) + options.indent;
        
        childNodes.each(function() {
          $(this).children("td")[options.treeColumn].style.paddingLeft = padding + "px";
        });
        
        if(options.expandable) {
          cell.prepend('<span style="margin-left: -' + options.indent + 'px; padding-left: ' + options.indent + 'px" class="expander"></span>');
          $(cell[0].firstChild).click(function() { node.toggleBranch(); });
          
          if(options.clickableNodeNames) {
            cell[0].style.cursor = "pointer";
            $(cell).click(function(e) {
              // Don't double-toggle if the click is on the existing expander icon
              if (e.target.className != 'expander') {
                node.toggleBranch();
              }
            });
          }
          
          // Check for a class set explicitly by the user, otherwise set the default class
          if(!(node.hasClass("expanded") || node.hasClass("collapsed"))) {
            node.addClass(options.initialState);
          }

          if(node.hasClass("expanded")) {
            node.expand();
          }
        }
      }
    }
  };
  
  function move(node, destination) {
    node.insertAfter(destination);
    childrenOf(node).reverse().each(function() { move($(this), node[0]); });
  };
  
  function parentOf(node) {
    var classNames = node[0].className.split(' ');
    
    for(key in classNames) {
      if(classNames[key].match(options.childPrefix)) {
        return $("#" + classNames[key].substring(9));
      }
    }
  };
})(jQuery);

/*
 * Inline Form Validation Engine 2.1, jQuery plugin
 *
 * Copyright(c) 2010, Cedric Dugas
 * http://www.position-absolute.com
 *
 * 2.0 Rewrite by Olivier Refalo
 * http://www.crionics.com
 *
 * Form validation engine allowing custom regex rules to be added.
 * Licensed under the MIT License
 */
(function($) {

    var methods = {

        /**
         * Kind of the constructor, called before any action
         * @param {Map} user options
         */
        init: function(options) {
            var form = this;
            if (!form.data('jqv') || form.data('jqv') == null ) {
                methods._saveOptions(form, options);

                // bind all formError elements to close on click
                $(".formError").live("click", function() {
                    $(this).fadeOut(150, function() {

                        // remove prompt once invisible
                        $(this).remove();
                    });
                });
            }
        },
        /**
         * Attachs jQuery.validationEngine to form.submit and field.blur events
         * Takes an optional params: a list of options
         * ie. jQuery("#formID1").validationEngine('attach', {promptPosition : "centerRight"});
         */
        attach: function(userOptions) {
            var form = this;
            var options;

            if(userOptions)
                options = methods._saveOptions(form, userOptions);
            else
                options = form.data('jqv');

            if (!options.binded) {
          if (options.bindMethod == "bind"){
                        // bind fields
                        form.find("[class*=validate]:not([type=checkbox])").bind(options.validationEventTrigger, methods._onFieldEvent);
                        form.find("[class*=validate][type=checkbox]").bind("click", methods._onFieldEvent);

                        // bind form.submit
                        form.bind("submit", methods._onSubmitEvent);
          } else if (options.bindMethod == "live") {
                        // bind fields with LIVE (for persistant state)
                        form.find("[class*=validate]:not([type=checkbox])").live(options.validationEventTrigger, methods._onFieldEvent);
                        form.find("[class*=validate][type=checkbox]").live("click", methods._onFieldEvent);

                        // bind form.submit
                        form.live("submit", methods._onSubmitEvent);
          }

                options.binded = true;
            }

        },
        /**
         * Unregisters any bindings that may point to jQuery.validaitonEngine
         */
        detach: function() {
            var form = this;
            var options = form.data('jqv');
            if (options.binded) {

                // unbind fields
                form.find("[class*=validate]").not("[type=checkbox]").unbind(options.validationEventTrigger, methods._onFieldEvent);
                form.find("[class*=validate][type=checkbox]").unbind("click", methods._onFieldEvent);
                // unbind form.submit
                form.unbind("submit", methods.onAjaxFormComplete);


                // unbind live fields (kill)
                form.find("[class*=validate]").not("[type=checkbox]").die(options.validationEventTrigger, methods._onFieldEvent);
                form.find("[class*=validate][type=checkbox]").die("click", methods._onFieldEvent);
                // unbind form.submit
                form.die("submit", methods.onAjaxFormComplete);

                form.removeData('jqv');
            }
        },
        /**
         * Validates the form fields, shows prompts accordingly.
         * Note: There is no ajax form validation with this method, only field ajax validation are evaluated
         *
         * @return true if the form validates, false if it fails
         */
        validate: function() {
            return methods._validateFields(this);
        },
        /**
         * Validates one field, shows prompt accordingly.
         * Note: There is no ajax form validation with this method, only field ajax validation are evaluated
         *
         * @return true if the form validates, false if it fails
         */
        validateField: function(el) {
            var options = $(this).data('jqv');
            return methods._validateField($(el), options);
        },
        /**
         * Validates the form fields, shows prompts accordingly.
         * Note: this methods performs fields and form ajax validations(if setup)
         *
         * @return true if the form validates, false if it fails, undefined if ajax is used for form validation
         */
        validateform: function() {
            return methods._onSubmitEvent.call(this);
        },
        /**
         * Displays a prompt on a element.
         * Note that the element needs an id!
         *
         * @param {String} promptText html text to display type
         * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
         * @param {String} possible values topLeft, topRight, bottomLeft, centerRight, bottomRight
         */
        showPrompt: function(promptText, type, promptPosition, showArrow) {

            var form = this.closest('form');
            var options = form.data('jqv');
            // No option, take default one
      if(!options) options = methods._saveOptions(this, options);
            if(promptPosition)
                options.promptPosition=promptPosition;
            options.showArrow = showArrow==true;

            methods._showPrompt(this, promptText, type, false, options);
        },
        /**
         * Closes all error prompts on the page
         */
        hidePrompt: function() {
            var promptClass =  "."+ methods._getClassName($(this).attr("id")) + "formError"
            $(promptClass).fadeTo("fast", 0.3, function() {
                $(this).remove();
            });
        },
        /**
         * Closes form error prompts, CAN be invidual
         */
        hide: function() {
          if($(this).is("form")){
             var closingtag = "parentForm"+$(this).attr('id');
          }else{

            var closingtag = $(this).attr('id') +"formError"
          }
            $('.'+closingtag).fadeTo("fast", 0.3, function() {
                $(this).remove();
            });
        },
        /**
         * Closes all error prompts on the page
         */
        hideAll: function() {
            $('.formError').fadeTo("fast", 0.3, function() {
                $(this).remove();
            });
        },
        /**
         * Typically called when user exists a field using tab or a mouse click, triggers a field
         * validation
         */
        _onFieldEvent: function() {
            var field = $(this);
            var form = field.closest('form');
            var options = form.data('jqv');
            // validate the current field
            methods._validateField(field, options);
        },
        /**
         * Called when the form is submited, shows prompts accordingly
         *
         * @param {jqObject}
         *            form
         * @return false if form submission needs to be cancelled
         */
        _onSubmitEvent: function() {
            var form = $(this);
      var options = form.data('jqv');

      // validate each field (- skip field ajax validation, no necessary since we will perform an ajax form validation)
            var r=methods._validateFields(form, true);

            if (r && options.ajaxFormValidation) {
                methods._validateFormWithAjax(form, options);
                return false;
            }

            if(options.onValidationComplete) {
                options.onValidationComplete(form, r);
                return false;
            }
            return r;
        },

        /**
         * Return true if the ajax field validations passed so far
         * @param {Object} options
         * @return true, is all ajax validation passed so far (remember ajax is async)
         */
        _checkAjaxStatus: function(options) {
            var status = true;
            $.each(options.ajaxValidCache, function(key, value) {
                if (!value) {
                    status = false;
                    // break the each
                    return false;
                }
            });
            return status;
        },
        /**
         * Validates form fields, shows prompts accordingly
         *
         * @param {jqObject}
         *            form
         * @param {skipAjaxFieldValidation}
         *            boolean - when set to true, ajax field validation is skipped, typically used when the submit button is clicked
         *
         * @return true if form is valid, false if not, undefined if ajax form validation is done
         */
        _validateFields: function(form, skipAjaxValidation) {
            var options = form.data('jqv');

            // this variable is set to true if an error is found
            var errorFound = false;

      // Trigger hook, start validation
      form.trigger("jqv.form.validating")
            // first, evaluate status of non ajax fields
            form.find('[class*=validate]').not(':hidden').each( function() {
                var field = $(this);
                errorFound |= methods._validateField(field, options, skipAjaxValidation);
            });
            // second, check to see if all ajax calls completed ok
            // errorFound |= !methods._checkAjaxStatus(options);

            // thrird, check status and scroll the container accordingly
      form.trigger("jqv.form.result", [errorFound])

            if (errorFound) {

                if (options.scroll) {

                    // get the position of the first error, there should be at least one, no need to check this
                    //var destination = form.find(".formError:not('.greenPopup'):first").offset().top;

                    // look for the visually top prompt
                    var destination = Number.MAX_VALUE;

                    var lst = $(".formError:not('.greenPopup')");
                    for (var i = 0; i < lst.length; i++) {
                        var d = $(lst[i]).offset().top;
                        if (d < destination)
                            destination = d;
                    }

                    if (!options.isOverflown)
                        $("html:not(:animated),body:not(:animated)").animate({
                            scrollTop: destination
                        }, 1100);
                    else {
                        var overflowDIV = $(options.overflownDIV);
                        var scrollContainerScroll = overflowDIV.scrollTop();
                        var scrollContainerPos = -parseInt(overflowDIV.offset().top);

                        destination += scrollContainerScroll + scrollContainerPos - 5;
                        var scrollContainer = $(options.overflownDIV + ":not(:animated)");

                        scrollContainer.animate({
                            scrollTop: destination
                        }, 1100);
                    }
                }
                return false;
            }
            return true;
        },
        /**
         * This method is called to perform an ajax form validation.
         * During this process all the (field, value) pairs are sent to the server which returns a list of invalid fields or true
         *
         * @param {jqObject} form
         * @param {Map} options
         */
        _validateFormWithAjax: function(form, options) {

            var data = form.serialize();
      var url = (options.ajaxFormValidationURL) ? options.ajaxFormValidationURL : form.attr("action");
            $.ajax({
                type: "GET",
                url: url,
                cache: false,
                dataType: "json",
                data: data,
                form: form,
                methods: methods,
                options: options,
                beforeSend: function() {
                    return options.onBeforeAjaxFormValidation(form, options);
                },
                error: function(data, transport) {
                    methods._ajaxError(data, transport);
                },
                success: function(json) {

                    if (json !== true) {

                        // getting to this case doesn't necessary means that the form is invalid
                        // the server may return green or closing prompt actions
                        // this flag helps figuring it out
                        var errorInForm=false;
                        for (var i = 0; i < json.length; i++) {
                            var value = json[i];

                            var errorFieldId = value[0];
                            var errorField = $($("#" + errorFieldId)[0]);

                            // make sure we found the element
                            if (errorField.length == 1) {

                                // promptText or selector
                                var msg = value[2];
                // if the field is valid
                                if (value[1] == true) {

                                    if (msg == ""  || !msg){
                                        // if for some reason, status==true and error="", just close the prompt
                                        methods._closePrompt(errorField);
                                    } else {
                                        // the field is valid, but we are displaying a green prompt
                                        if (options.allrules[msg]) {
                                            var txt = options.allrules[msg].alertTextOk;
                                            if (txt)
                                                msg = txt;
                                        }
                                        methods._showPrompt(errorField, msg, "pass", false, options, true);
                                    }

                                } else {
                                    // the field is invalid, show the red error prompt
                                    errorInForm|=true;
                                    if (options.allrules[msg]) {
                                        var txt = options.allrules[msg].alertText;
                                        if (txt)
                                            msg = txt;
                                    }
                                    methods._showPrompt(errorField, msg, "", false, options, true);
                                }
                            }
                        }
                        options.onAjaxFormComplete(!errorInForm, form, json, options);
                    } else
                        options.onAjaxFormComplete(true, form, "", options);
                }
            });

        },
        /**
         * Validates field, shows prompts accordingly
         *
         * @param {jqObject}
         *            field
         * @param {Array[String]}
         *            field's validation rules
         * @param {Map}
         *            user options
         * @return true if field is valid
         */
        _validateField: function(field, options, skipAjaxValidation) {
            if (!field.attr("id"))
                $.error("jQueryValidate: an ID attribute is required for this field: " + field.attr("name") + " class:" +
                field.attr("class"));

            var rulesParsing = field.attr('class');
            var getRules = /validate\[(.*)\]/.exec(rulesParsing);
            if (!getRules)
                return false;
            var str = getRules[1];
            var rules = str.split(/\[|,|\]/);

            // true if we ran the ajax validation, tells the logic to stop messing with prompts
            var isAjaxValidator = false;
            var fieldName = field.attr("name");
            var promptText = "";
      var required = false;
            options.isError = false;
            options.showArrow = true;
            optional = false;

            for (var i = 0; i < rules.length; i++) {

                var errorMsg = undefined;
                switch (rules[i]) {

                    case "optional":
                        optional = true;
                        break;
                    case "required":
                        required = true;
                        errorMsg = methods._required(field, rules, i, options);
                        break;
                    case "custom":
                        errorMsg = methods._customRegex(field, rules, i, options);
                        break;
                    case "ajax":
                        // ajax has its own prompts handling technique
            if(!skipAjaxValidation){
              methods._ajax(field, rules, i, options);
                          isAjaxValidator = true;
            }
                        break;
                    case "minSize":
                        errorMsg = methods._minSize(field, rules, i, options);
                        break;
                    case "maxSize":
                        errorMsg = methods._maxSize(field, rules, i, options);
                        break;
                    case "min":
                        errorMsg = methods._min(field, rules, i, options);
                        break;
                    case "max":
                        errorMsg = methods._max(field, rules, i, options);
                        break;
                    case "past":
                        errorMsg = methods._past(field, rules, i, options);
                        break;
                    case "future":
                        errorMsg = methods._future(field, rules, i, options);
                        break;
                    case "maxCheckbox":
                        errorMsg = methods._maxCheckbox(field, rules, i, options);
                        field = $($("input[name='" + fieldName + "']"));
                        break;
                    case "minCheckbox":
                        errorMsg = methods._minCheckbox(field, rules, i, options);
                        field = $($("input[name='" + fieldName + "']"));
                        break;
                    case "equals":
                        errorMsg = methods._equals(field, rules, i, options);
                        break;
                    case "funcCall":
                        errorMsg = methods._funcCall(field, rules, i, options);
                        break;

                    default:
                    //$.error("jQueryValidator rule not found"+rules[i]);
                }
                if (errorMsg !== undefined) {
                    promptText += errorMsg + "<br/>";
                    options.isError = true;

                }

            }
            // If the rules required is not added, an empty field is not validated
            if(!required){
              if(field.val() == "") options.isError = false;
            }
            // Hack for radio/checkbox group button, the validation go into the
            // first radio/checkbox of the group
            var fieldType = field.attr("type");

            if ((fieldType == "radio" || fieldType == "checkbox") && $("input[name='" + fieldName + "']").size() > 1) {
                field = $($("input[name='" + fieldName + "'][type!=hidden]:first"));
                options.showArrow = false;
            }

            if (options.isError){

                methods._showPrompt(field, promptText, "", false, options);
            }else{
        if (!isAjaxValidator) methods._closePrompt(field);
      }
      field.closest('form').trigger("jqv.field.error", [field, options.isError, promptText])
            return options.isError;
        },
        /**
         * Required validation
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _required: function(field, rules, i, options) {
            switch (field.attr("type")) {
                case "text":
                case "password":
                case "textarea":
                case "file":
                default:
                    if (!field.val())
                        return options.allrules[rules[i]].alertText;
                    break;
                case "radio":
                case "checkbox":
                    var name = field.attr("name");
                    if ($("input[name='" + name + "']:checked").size() == 0) {

                        if ($("input[name='" + name + "']").size() == 1)
                            return options.allrules[rules[i]].alertTextCheckboxe;
                        else
                            return options.allrules[rules[i]].alertTextCheckboxMultiple;
                    }
                    break;
                // required for <select>
                case "select-one":
                    // added by paul@kinetek.net for select boxes, Thank you
                    if (!field.val())
                        return options.allrules[rules[i]].alertText;
                    break;
                case "select-multiple":
                    // added by paul@kinetek.net for select boxes, Thank you
                    if (!field.find("option:selected").val())
                        return options.allrules[rules[i]].alertText;
                    break;
            }
        },
        /**
         * Validate Regex rules
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _customRegex: function(field, rules, i, options) {
            var customRule = rules[i + 1];
      var rule = options.allrules[customRule];
      if(!rule) {
        alert("jqv:custom rule not found "+customRule);
        return;
      }

      var ex=rule.regex;
      if(!ex) {
        alert("jqv:custom regex not found "+customRule);
        return;
      }
            var pattern = new RegExp(ex);

            if (!pattern.test(field.attr('value')))
                return options.allrules[customRule].alertText;
        },
        /**
         * Validate custom function outside of the engine scope
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _funcCall: function(field, rules, i, options) {
            var functionName = rules[i + 1];
            var fn = window[functionName];
            if (typeof(fn) == 'function')
                return fn(field, rules, i, options);

        },
        /**
         * Field match
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _equals: function(field, rules, i, options) {
            var equalsField = rules[i + 1];

            if (field.attr('value') != $("#" + equalsField).attr('value'))
                return options.allrules.equals.alertText;
        },
        /**
         * Check the maximum size (in characters)
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _maxSize: function(field, rules, i, options) {
            var max = rules[i + 1];
            var len = field.attr('value').length;

            if (len > max) {
                var rule = options.allrules.maxSize;
                return rule.alertText + max + rule.alertText2;
            }
        },
        /**
         * Check the minimum size (in characters)
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _minSize: function(field, rules, i, options) {
            var min = rules[i + 1];
            var len = field.attr('value').length;

            if (len < min) {
                var rule = options.allrules.minSize;
                return rule.alertText + min + rule.alertText2;
            }
        },
        /**
         * Check number minimum value
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _min: function(field, rules, i, options) {
            var min = parseFloat(rules[i + 1]);
            var len = parseFloat(field.attr('value'));

            if (len < min) {
                var rule = options.allrules.min;
                if (rule.alertText2) return rule.alertText + min + rule.alertText2;
                return rule.alertText + min;
            }
        },
        /**
         * Check number maximum value
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _max: function(field, rules, i, options) {
            var max = parseFloat(rules[i + 1]);
            var len = parseFloat(field.attr('value'));

            if (len >max ) {
                var rule = options.allrules.max;
                if (rule.alertText2) return rule.alertText + max + rule.alertText2;
                //orefalo: to review, also do the translations
                return rule.alertText + max;
            }
        },
        /**
         * Checks date is in the past
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _past: function(field, rules, i, options) {

            var p=rules[i + 1];
            var pdate = (p.toLowerCase() == "now")? new Date():methods._parseDate(p);
            var vdate = methods._parseDate(field.attr('value'));

            if (vdate < pdate ) {
                var rule = options.allrules.past;
                if (rule.alertText2) return rule.alertText + methods._dateToString(pdate) + rule.alertText2;
                return rule.alertText + methods._dateToString(pdate);
            }
        },
        /**
         * Checks date is in the future
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _future: function(field, rules, i, options) {

            var p=rules[i + 1];
            var pdate = (p.toLowerCase() == "now")? new Date():methods._parseDate(p);
            var vdate = methods._parseDate(field.attr('value'));

            if (vdate > pdate ) {
                var rule = options.allrules.future;
                if (rule.alertText2) return rule.alertText + methods._dateToString(pdate) + rule.alertText2;
                return rule.alertText + methods._dateToString(pdate);
            }
        },
        /**
         * Max number of checkbox selected
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _maxCheckbox: function(field, rules, i, options) {

            var nbCheck = rules[i + 1];
            var groupname = field.attr("name");
            var groupSize = $("input[name='" + groupname + "']:checked").size();
            if (groupSize > nbCheck) {
                options.showArrow = false;
                if (options.allrules.maxCheckbox.alertText2) return options.allrules.maxCheckbox.alertText + " " + nbCheck + " " + options.allrules.maxCheckbox.alertText2;
                return options.allrules.maxCheckbox.alertText;
            }
        },
        /**
         * Min number of checkbox selected
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return an error string if validation failed
         */
        _minCheckbox: function(field, rules, i, options) {

            var nbCheck = rules[i + 1];
            var groupname = field.attr("name");
            var groupSize = $("input[name='" + groupname + "']:checked").size();
            if (groupSize < nbCheck) {
                options.showArrow = false;
                return options.allrules.minCheckbox.alertText + " " + nbCheck + " " +
                options.allrules.minCheckbox.alertText2;
            }
        },
        /**
         * Ajax field validation
         *
         * @param {jqObject} field
         * @param {Array[String]} rules
         * @param {int} i rules index
         * @param {Map}
         *            user options
         * @return nothing! the ajax validator handles the prompts itself
         */
        _ajax: function(field, rules, i, options) {


            var errorSelector = rules[i + 1];
            var rule = options.allrules[errorSelector];
            var extraData = rule.extraData;
            var extraDataDynamic = rule.extraDataDynamic;

            if (!extraData)
                extraData = "";

            if (extraDataDynamic) {
              var tmpData = [];
              var domIds = String(extraDataDynamic).split(",");
              for (var i = 0; i < domIds.length; i++) {
                var id = domIds[i];
                if ($(id).length) {
                  var inputValue = field.closest("form").find(id).attr("value");
                  var keyValue = id.replace('#', '') + '=' + escape(inputValue);
                  tmpData.push(keyValue);
                }
              }
              extraDataDynamic = tmpData.join("&");
            } else {
              extraDataDynamic = "";
            }

            if (!options.isError) {
                $.ajax({
                    type: "GET",
                    url: rule.url,
                    cache: false,
                    dataType: "json",
                    data: "fieldId=" + field.attr("id") + "&fieldValue=" + field.attr("value") + "&extraData=" + extraData + "&" + extraDataDynamic,
                    field: field,
                    rule: rule,
                    methods: methods,
                    options: options,
                    beforeSend: function() {
                        // build the loading prompt
                        var loadingText = rule.alertTextLoad;
                        if (loadingText)
                            methods._showPrompt(field, loadingText, "load", true, options);
                    },
                    error: function(data, transport) {
                        methods._ajaxError(data, transport);
                    },
                    success: function(json) {

                        // asynchronously called on success, data is the json answer from the server
                        var errorFieldId = json[0];
                        var errorField = $($("#" + errorFieldId)[0]);
                        // make sure we found the element
                        if (errorField.length == 1) {
                            var status = json[1];
              // read the optional msg from the server
              var msg = json[2];
                            if (!status) {
                                // Houston we got a problem - display an red prompt
                                options.ajaxValidCache[errorFieldId] = false;
                                options.isError = true;

                // resolve the msg prompt
                if(msg) {
                  if (options.allrules[msg]) {
                                      var txt = options.allrules[msg].alertText;
                                      if (txt)
                                        msg = txt;
                                    }
                }
                else
                                    msg = rule.alertText;

                methods._showPrompt(errorField, msg, "", true, options);
                            } else {
                                if (options.ajaxValidCache[errorFieldId] !== undefined)
                                    options.ajaxValidCache[errorFieldId] = true;

                                // resolves the msg prompt
                if(msg) {
                  if (options.allrules[msg]) {
                          var txt = options.allrules[msg].alertTextOk;
                          if (txt)
                            msg = txt;
                      }
                }
                else
                      msg = rule.alertTextOk;

                // see if we should display a green prompt
                                if (msg)
                                    methods._showPrompt(errorField, msg, "pass", true, options);
                                else
                                    methods._closePrompt(errorField);
                            }
                        }
                    }
                });
            }
        },
        /**
         * Common method to handle ajax errors
         *
         * @param {Object} data
         * @param {Object} transport
         */
        _ajaxError: function(data, transport) {
            if(data.status == 0 && transport == null)
                alert("The page is not served from a server! ajax call failed");
            else if(typeof console != "undefined")
                console.log("Ajax error: " + data.status + " " + transport);
        },
        /**
         * date -> string
         *
         * @param {Object} date
         */
        _dateToString: function(date) {

            return date.getFullYear()+"-"+(date.getMonth()+1)+"-"+date.getDate();
        },
        /**
         * Parses an ISO date
         * @param {String} d
         */
        _parseDate: function(d) {

            var dateParts = d.split("-");
            if(dateParts==d)
                dateParts = d.split("/");
            return new Date(dateParts[0], (dateParts[1] - 1) ,dateParts[2]);
        },
        /**
         * Builds or updates a prompt with the given information
         *
         * @param {jqObject} field
         * @param {String} promptText html text to display type
         * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
         * @param {boolean} ajaxed - use to mark fields than being validated with ajax
         * @param {Map} options user options
         */
        _showPrompt: function(field, promptText, type, ajaxed, options, ajaxform) {
            var prompt = methods._getPrompt(field);
      // The ajax submit errors are not see has an error in the form,
      // When the form errors are returned, the engine see 2 bubbles, but those are ebing closed by the engine at the same time
      // Because no error was found befor submitting
      if(ajaxform) prompt = false;
            if (prompt)
                methods._updatePrompt(field, prompt, promptText, type, ajaxed, options);
            else
                methods._buildPrompt(field, promptText, type, ajaxed, options);
        },
        /**
         * Builds and shades a prompt for the given field.
         *
         * @param {jqObject} field
         * @param {String} promptText html text to display type
         * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
         * @param {boolean} ajaxed - use to mark fields than being validated with ajax
         * @param {Map} options user options
         */
        _buildPrompt: function(field, promptText, type, ajaxed, options) {

            // create the prompt
            var prompt = $('<div>');
            prompt.addClass(methods._getClassName(field.attr("id")) + "formError");
            // add a class name to identify the parent form of the prompt
            if(field.is(":input")) prompt.addClass("parentForm"+methods._getClassName(field.parents('form').attr("id")));
            prompt.addClass("formError");

            switch (type) {
                case "pass":
                    prompt.addClass("greenPopup");
                    break;
                case "load":
                    prompt.addClass("blackPopup");
            }
            if (ajaxed)
                prompt.addClass("ajaxed");

            // create the prompt content
            var promptContent = $('<div>').addClass("formErrorContent").html(promptText).appendTo(prompt);
            // create the css arrow pointing at the field
            // note that there is no triangle on max-checkbox and radio
            if (options.showArrow) {
                var arrow = $('<div>').addClass("formErrorArrow");

                switch (options.promptPosition) {
                    case "bottomLeft":
                    case "bottomRight":
                        prompt.find(".formErrorContent").before(arrow);
                        arrow.addClass("formErrorArrowBottom").html('<div class="line1"><!-- --></div><div class="line2"><!-- --></div><div class="line3"><!-- --></div><div class="line4"><!-- --></div><div class="line5"><!-- --></div><div class="line6"><!-- --></div><div class="line7"><!-- --></div><div class="line8"><!-- --></div><div class="line9"><!-- --></div><div class="line10"><!-- --></div>');
                        break;
                    case "topLeft":
                    case "topRight":
                        arrow.html('<div class="line10"><!-- --></div><div class="line9"><!-- --></div><div class="line8"><!-- --></div><div class="line7"><!-- --></div><div class="line6"><!-- --></div><div class="line5"><!-- --></div><div class="line4"><!-- --></div><div class="line3"><!-- --></div><div class="line2"><!-- --></div><div class="line1"><!-- --></div>');
                        prompt.append(arrow);
                        break;
                }
            }

            //Cedric: Needed if a container is in position:relative
            // insert prompt in the form or in the overflown container?
            if (options.isOverflown)
              field.before(prompt);
            else
               $("body").append(prompt);

            var pos = methods._calculatePosition(field, prompt, options);
            prompt.css({
                "top": pos.callerTopPosition,
                "left": pos.callerleftPosition,
                "marginTop": pos.marginTopSize,
                "opacity": 0
            });

            return prompt.animate({
                "opacity": 0.87
            });

        },
        /**
         * Updates the prompt text field - the field for which the prompt
         * @param {jqObject} field
         * @param {String} promptText html text to display type
         * @param {String} type the type of bubble: 'pass' (green), 'load' (black) anything else (red)
         * @param {boolean} ajaxed - use to mark fields than being validated with ajax
         * @param {Map} options user options
         */
        _updatePrompt: function(field, prompt, promptText, type, ajaxed, options) {

            if (prompt) {
                if (type == "pass")
                    prompt.addClass("greenPopup");
                else
                    prompt.removeClass("greenPopup");

                if (type == "load")
                    prompt.addClass("blackPopup");
                else
                    prompt.removeClass("blackPopup");

                if (ajaxed)
                    prompt.addClass("ajaxed");
                else
                    prompt.removeClass("ajaxed");

                prompt.find(".formErrorContent").html(promptText);

                var pos = methods._calculatePosition(field, prompt, options);
                prompt.animate({
                    "top": pos.callerTopPosition,
                    "marginTop": pos.marginTopSize
                });
            }
        },
        /**
         * Closes the prompt associated with the given field
         *
         * @param {jqObject}
         *            field
         */
        _closePrompt: function(field) {

            var prompt = methods._getPrompt(field);
            if (prompt)
                prompt.fadeTo("fast", 0, function() {
                    prompt.remove();
                });
        },
        closePrompt: function(field) {
            return methods._closePrompt(field);
        },
        /**
         * Returns the error prompt matching the field if any
         *
         * @param {jqObject}
         *            field
         * @return undefined or the error prompt (jqObject)
         */
        _getPrompt: function(field) {

            var className = "." + methods._getClassName(field.attr("id")) + "formError";
            var match = $(className)[0];
            if (match)
                return $(match);
        },
        /**
         * Calculates prompt position
         *
         * @param {jqObject}
         *            field
         * @param {jqObject}
         *            the prompt
         * @param {Map}
         *            options
         * @return positions
         */
        _calculatePosition: function(field, promptElmt, options) {

            var promptTopPosition, promptleftPosition, marginTopSize;
            var fieldWidth = field.width();
            var promptHeight = promptElmt.height();

            var overflow = options.isOverflown;
            if (overflow) {
                // is the form contained in an overflown container?
                promptTopPosition = promptleftPosition = 0;
                // compensation for the arrow
                marginTopSize = -promptHeight;
            } else {
                var offset = field.offset();
                promptTopPosition = offset.top;
                promptleftPosition = offset.left;
                marginTopSize = 0;
            }

            switch (options.promptPosition) {

                default:
                case "topRight":
                    if (overflow)
                        // Is the form contained in an overflown container?
                        promptleftPosition += fieldWidth - 30;
                    else {
                        promptleftPosition += fieldWidth - 30;
                        promptTopPosition += -promptHeight;
                    }
                    break;
                case "topLeft":
                    promptTopPosition += -promptHeight - 10;
                    break;
                case "centerRight":
                    promptleftPosition += fieldWidth + 13;
                    break;
                case "bottomLeft":
                    promptTopPosition = promptTopPosition + field.height() + 15;
                    break;
                case "bottomRight":
                    promptleftPosition += fieldWidth - 30;
                    promptTopPosition += field.height() + 5;
            }

            return {
                "callerTopPosition": promptTopPosition + "px",
                "callerleftPosition": promptleftPosition + "px",
                "marginTopSize": marginTopSize + "px"
            };
        },
        /**
         * Saves the user options and variables in the form.data
         *
         * @param {jqObject}
         *            form - the form where the user option should be saved
         * @param {Map}
         *            options - the user options
         * @return the user options (extended from the defaults)
         */
        _saveOptions: function(form, options) {

            // is there a language localisation ?
            if ($.validationEngineLanguage)
                var allRules = $.validationEngineLanguage.allRules;
            else
                $.error("jQuery.validationEngine rules are not loaded, plz add localization files to the page");

            var userOptions = $.extend({

                // Name of the event triggering field validation
                validationEventTrigger: "blur",
                // Automatically scroll viewport to the first error
                scroll: true,
                // Opening box position, possible locations are: topLeft,
                // topRight, bottomLeft, centerRight, bottomRight
                promptPosition: "topRight",
                bindMethod:"bind",
        // internal, automatically set to true when it parse a _ajax rule
        inlineAjax: false,
                // if set to true, the form data is sent asynchronously via ajax to the form.action url (get)
                ajaxFormValidation: false,
                // Ajax form validation callback method: boolean onComplete(form, status, errors, options)
                // retuns false if the form.submit event needs to be canceled.
        ajaxFormValidationURL: false,
                // The url to send the submit ajax validation (default to action)
                onAjaxFormComplete: $.noop,
                // called right before the ajax call, may return false to cancel
                onBeforeAjaxFormValidation: $.noop,
                // Stops form from submitting and execute function assiciated with it
                onValidationComplete: false,

                // Used when the form is displayed within a scrolling DIV
                isOverflown: false,
                overflownDIV: "",

                // --- Internals DO NOT TOUCH or OVERLOAD ---
                // validation rules and i18
                allrules: allRules,
                // true when form and fields are binded
                binded: false,
                // set to true, when the prompt arrow needs to be displayed
                showArrow: true,
                // did one of the validation fail ? kept global to stop further ajax validations
                isError: false,
                // Caches field validation status, typically only bad status are created.
                // the array is used during ajax form validation to detect issues early and prevent an expensive submit
                ajaxValidCache: {}

            }, options);

            form.data('jqv', userOptions);
            return userOptions;
        },

        /**
         * Removes forbidden characters from class name
         * @param {String} className
         */
        _getClassName: function(className) {
          return className.replace(":","_").replace(".","_");
        }
    };

    /**
     * Plugin entry point.
     * You may pass an action as a parameter or a list of options.
     * if none, the init and attach methods are being called.
     * Remember: if you pass options, the attached method is NOT called automatically
     *
     * @param {String}
     *            method (optional) action
     */
    $.fn.validationEngine = function(method) {

        var form = $(this);
      if(!form[0]) return false;  // stop here if the form does not exist

        if (typeof(method) == 'string' && method.charAt(0) != '_' && methods[method]) {

            // make sure init is called once
            if(method != "showPrompt" && method != "hidePrompt" && method != "hide" && method != "hideAll")
              methods.init.apply(form);

            return methods[method].apply(form, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method == 'object' || !method) {
            // default constructor with or without arguments
      methods.init.apply(form, arguments);
            return methods.attach.apply(form);
        } else {
            $.error('Method ' + method + ' does not exist in jQuery.validationEngine');
        }
    };
})(jQuery);
(function($){
    $.fn.validationEngineLanguage = function(){
    };
    $.validationEngineLanguage = {
        newLang: function(){
            $.validationEngineLanguage.allRules = {
                "required": { // Add your regex rules here, you can take telephone as an example
                    "regex": "none",
                    "alertText": "* This field is required",
                    "alertTextCheckboxMultiple": "* Please select an option",
                    "alertTextCheckboxe": "* This checkbox is required"
                },
                "minSize": {
                    "regex": "none",
                    "alertText": "* Minimum ",
                    "alertText2": " characters allowed"
                },
                "maxSize": {
                    "regex": "none",
                    "alertText": "* Maximum ",
                    "alertText2": " characters allowed"
                },
                "min": {
                    "regex": "none",
                    "alertText": "* Minimum value is "
                },
                "max": {
                    "regex": "none",
                    "alertText": "* Maximum value is "
                },
                "past": {
                    "regex": "none",
                    "alertText": "* Date prior to "
                },
                "future": {
                    "regex": "none",
                    "alertText": "* Date past "
                },
                "maxCheckbox": {
                    "regex": "none",
                    "alertText": "* Maximum ",
                    "alertText2": " options allowed"
                },
                "minCheckbox": {
                    "regex": "none",
                    "alertText": "* Please select ",
                    "alertText2": " options"
                },
                "equals": {
                    "regex": "none",
                    "alertText": "* Fields do not match"
                },
                "phone": {
                    // credit: jquery.h5validate.js / orefalo
                    "regex": /^([\+][0-9]{1,3}[ \.\-])?([\(]{1}[0-9]{2,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
                    "alertText": "* Invalid phone number"
                },
                "email": {
                    // Shamelessly lifted from Scott Gonzalez via the Bassistance Validation plugin http://projects.scottsplayground.com/email_address_validation/
                    "regex": /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
                    "alertText": "* Invalid email address"
                },
                "integer": {
                    "regex": /^[\-\+]?\d+$/,
                    "alertText": "* Not a valid integer"
                },
                "number": {
                    // Number, including positive, negative, and floating decimal. credit: orefalo
                    "regex": /^[\-\+]?(([0-9]+)([\.,]([0-9]+))?|([\.,]([0-9]+))?)$/,
                    "alertText": "* Invalid floating decimal number"
                },
                "date": {
                    "regex": /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/,
                    "alertText": "* Invalid date, must be in YYYY-MM-DD format"
                },
                "ipv4": {
                    "regex": /^((([01]?[0-9]{1,2})|(2[0-4][0-9])|(25[0-5]))[.]){3}(([0-1]?[0-9]{1,2})|(2[0-4][0-9])|(25[0-5]))$/,
                    "alertText": "* Invalid IP address"
                },
                "url": {
                    "regex": /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,
                    "alertText": "* Invalid URL"
                },
                "onlyNumberSp": {
                    "regex": /^[0-9\ ]+$/,
                    "alertText": "* Numbers only"
                },
                "onlyLetterSp": {
                    "regex": /^[a-zA-Z\ \']+$/,
                    "alertText": "* Letters only"
                },
                "onlyLetterNumber": {
                    "regex": /^[0-9a-zA-Z]+$/,
                    "alertText": "* No special characters allowed"
                },
                // --- CUSTOM RULES -- Those are specific to the demos, they can be removed or changed to your likings
                "ajaxUserCall": {
                    "url": "ajaxValidateFieldUser",
                    // you may want to pass extra data on the ajax call
                    "extraData": "name=eric",
                    "alertText": "* This user is already taken",
                    "alertTextLoad": "* Validating, please wait"
                },
        "ajaxUserCallPhp": {
                    "url": "phpajax/ajaxValidateFieldUser.php",
                    // you may want to pass extra data on the ajax call
                    "extraData": "name=eric",
                    // if you provide an "alertTextOk", it will show as a green prompt when the field validates
                    "alertTextOk": "* This username is available",
                    "alertText": "* This user is already taken",
                    "alertTextLoad": "* Validating, please wait"
                },
                "ajaxNameCall": {
                    // remote json service location
                    "url": "ajaxValidateFieldName",
                    // error
                    "alertText": "* This name is already taken",
                    // if you provide an "alertTextOk", it will show as a green prompt when the field validates
                    "alertTextOk": "* This name is available",
                    // speaks by itself
                    "alertTextLoad": "* Validating, please wait"
                },
         "ajaxNameCallPhp": {
                      // remote json service location
                      "url": "phpajax/ajaxValidateFieldName.php",
                      // error
                      "alertText": "* This name is already taken",
                      // speaks by itself
                      "alertTextLoad": "* Validating, please wait"
                  },
                "validate2fields": {
                    "alertText": "* Please input HELLO"
                }
            };

        }
    };
    $.validationEngineLanguage.newLang();
})(jQuery);
/**
 * jQuery-csv (jQuery Plugin)
 * version: 0.71 (2012-11-19)
 *
 * This document is licensed as free software under the terms of the
 * MIT License: http://www.opensource.org/licenses/mit-license.php
 *
 * Acknowledgements:
 * The original design and influence to implement this library as a jquery
 * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).
 * If you're looking to use native JSON.Stringify but want additional backwards
 * compatibility for browsers that don't support it, I highly recommend you
 * check it out.
 *
 * A special thanks goes out to rwk@acm.org for providing a lot of valuable
 * feedback to the project including the core for the new FSM
 * (Finite State Machine) parsers. If you're looking for a stable TSV parser
 * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).

 * For legal purposes I'll include the "NO WARRANTY EXPRESSED OR IMPLIED.
 * USE AT YOUR OWN RISK.". Which, in 'layman's terms' means, by using this
 * library you are accepting responsibility if it breaks your code.
 *
 * Legal jargon aside, I will do my best to provide a useful and stable core
 * that can effectively be built on.
 *
 * Copyrighted 2012 by Evan Plaice.
 */

RegExp.escape= function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};

(function( $ ) {
  'use strict'
  /**
   * jQuery.csv.defaults
   * Encapsulates the method paramater defaults for the CSV plugin module.
   */

  $.csv = {
    defaults: {
      separator:',',
      delimiter:'"',
      headers:true
    },

    hooks: {
      castToScalar: function(value, state) {
        var hasDot = /\./;
        if (isNaN(value)) {
          return value;
        } else {
          if (hasDot.test(value)) {
            return parseFloat(value);
          } else {
            var integer = parseInt(value);
            if(isNaN(integer)) {
              return null;
            } else {
              return integer;
            }
          }
        }
      }
    },

    parsers: {
      parse: function(csv, options) {
        // cache settings
        var separator = options.separator;
        var delimiter = options.delimiter;

        // set initial state if it's missing
        if(!options.state.rowNum) {
          options.state.rowNum = 1;
        }
        if(!options.state.colNum) {
          options.state.colNum = 1;
        }

        // clear initial state
        var data = [];
        var entry = [];
        var state = 0;
        var value = ''
        var exit = false;

        function endOfEntry() {
          // reset the state
          state = 0;
          value = '';

          // if 'start' hasn't been met, don't output
          if(options.start && options.state.rowNum < options.start) {
            // update global state
            entry = [];
            options.state.rowNum++;
            options.state.colNum = 1;
            return;
          }
          
          if(options.onParseEntry === undefined) {
            // onParseEntry hook not set
            data.push(entry);
          } else {
            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook
            // false skips the row, configurable through a hook
            if(hookVal !== false) {
              data.push(hookVal);
            }
          }
          //console.log('entry:' + entry);
          
          // cleanup
          entry = [];

          // if 'end' is met, stop parsing
          if(options.end && options.state.rowNum >= options.end) {
            exit = true;
          }
          
          // update global state
          options.state.rowNum++;
          options.state.colNum = 1;
        }

        function endOfValue() {
          if(options.onParseValue === undefined) {
            // onParseValue hook not set
            entry.push(value);
          } else {
            var hook = options.onParseValue(value, options.state); // onParseValue Hook
            // false skips the row, configurable through a hook
            if(hook !== false) {
              entry.push(hook);
            }
          }
          //console.log('value:' + value);
          // reset the state
          value = '';
          state = 0;
          // update global state
          options.state.colNum++;
        }

        // escape regex-specific control chars
        var escSeparator = RegExp.escape(separator);
        var escDelimiter = RegExp.escape(delimiter);

        // compile the regEx str using the custom delimiter/separator
        var match = /(D|S|\n|\r|[^DS\r\n]+)/;
        var matchSrc = match.source;
        matchSrc = matchSrc.replace(/S/g, escSeparator);
        matchSrc = matchSrc.replace(/D/g, escDelimiter);
        match = RegExp(matchSrc, 'gm');

        // put on your fancy pants...
        // process control chars individually, use look-ahead on non-control chars
        csv.replace(match, function (m0) {
          if(exit) {
            return;
          }
          switch (state) {
            // the start of a value
            case 0:
              // null last value
              if (m0 === separator) {
                value += '';
                endOfValue();
                break;
              }
              // opening delimiter
              if (m0 === delimiter) {
                state = 1;
                break;
              }
              // null last value
              if (m0 === '\n') {
                endOfValue();
                endOfEntry();
                break;
              }
              // phantom carriage return
              if (/^\r$/.test(m0)) {
                break;
              }
              // un-delimited value
              value += m0;
              state = 3;
              break;

            // delimited input
            case 1:
              // second delimiter? check further
              if (m0 === delimiter) {
                state = 2;
                break;
              }
              // delimited data
              value += m0;
              state = 1;
              break;

            // delimiter found in delimited input
            case 2:
              // escaped delimiter?
              if (m0 === delimiter) {
                value += m0;
                state = 1;
                break;
              }
              // null value
              if (m0 === separator) {
                endOfValue();
                break;
              }
              // end of entry
              if (m0 === '\n') {
                endOfValue();
                endOfEntry();
                break;
              }
              // phantom carriage return
              if (/^\r$/.test(m0)) {
                break;
              }
              // broken paser?
              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');

            // un-delimited input
            case 3:
              // null last value
              if (m0 === separator) {
                endOfValue();
                break;
              }
              // end of entry
              if (m0 === '\n') {
                endOfValue();
                endOfEntry();
                break;
              }
              // phantom carriage return
              if (/^\r$/.test(m0)) {
                break;
              }
              if (m0 === delimiter) {
              // non-compliant data
                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');
              }
              // broken parser?
              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');
            default:
              // shenanigans
              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');
          }
          //console.log('val:' + m0 + ' state:' + state);
        });

        // submit the last entry
        // ignore null last line
        if(entry.length !== 0) {
          endOfValue();
          endOfEntry();
        }

        return data;
      },

      // a csv-specific line splitter
      splitLines: function(csv, options) {
        // cache settings
        var separator = options.separator;
        var delimiter = options.delimiter;

        // set initial state if it's missing
        if(!options.state.rowNum) {
          options.state.rowNum = 1;
        }

        // clear initial state
        var entries = [];
        var state = 0;
        var entry = '';
        var exit = false;

        function endOfLine() {          
          // reset the state
          state = 0;
          
          // if 'start' hasn't been met, don't output
          if(options.start && options.state.rowNum < options.start) {
            // update global state
            entry = '';
            options.state.rowNum++;
            return;
          }
          
          if(options.onParseEntry === undefined) {
            // onParseEntry hook not set
            entries.push(entry);
          } else {
            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook
            // false skips the row, configurable through a hook
            if(hookVal !== false) {
              entries.push(hookVal);
            }
          }

          // cleanup
          entry = '';

          // if 'end' is met, stop parsing
          if(options.end && options.state.rowNum >= options.end) {
            exit = true;
          }
          
          // update global state
          options.state.rowNum++;
        }

        // escape regex-specific control chars
        var escSeparator = RegExp.escape(separator);
        var escDelimiter = RegExp.escape(delimiter);

        // compile the regEx str using the custom delimiter/separator
        var match = /(D|S|\n|\r|[^DS\r\n]+)/;
        var matchSrc = match.source;
        matchSrc = matchSrc.replace(/S/g, escSeparator);
        matchSrc = matchSrc.replace(/D/g, escDelimiter);
        match = RegExp(matchSrc, 'gm');
        
        // put on your fancy pants...
        // process control chars individually, use look-ahead on non-control chars
        csv.replace(match, function (m0) {
          if(exit) {
            return;
          }
          switch (state) {
            // the start of a value/entry
            case 0:
              // null value
              if (m0 === separator) {
                entry += m0;
                state = 0;
                break;
              }
              // opening delimiter
              if (m0 === delimiter) {
                entry += m0;
                state = 1;
                break;
              }
              // end of line
              if (m0 === '\n') {
                endOfLine();
                break;
              }
              // phantom carriage return
              if (/^\r$/.test(m0)) {
                break;
              }
              // un-delimit value
              entry += m0;
              state = 3;
              break;

            // delimited input
            case 1:
              // second delimiter? check further
              if (m0 === delimiter) {
                entry += m0;
                state = 2;
                break;
              }
              // delimited data
              entry += m0;
              state = 1;
              break;

            // delimiter found in delimited input
            case 2:
              // escaped delimiter?
              var prevChar = entry.substr(entry.length - 1);
              if (m0 === delimiter && prevChar === delimiter) {
                entry += m0;
                state = 1;
                break;
              }
              // end of value
              if (m0 === separator) {
                entry += m0;
                state = 0;
                break;
              }
              // end of line
              if (m0 === '\n') {
                endOfLine();
                break;
              }
              // phantom carriage return
              if (m0 === '\r') {
                break;
              }
              // broken paser?
              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');

            // un-delimited input
            case 3:
              // null value
              if (m0 === separator) {
                entry += m0;
                state = 0;
                break;
              }
              // end of line
              if (m0 === '\n') {
                endOfLine();
                break;
              }
              // phantom carriage return
              if (m0 === '\r') {
                break;
              }
              // non-compliant data
              if (m0 === delimiter) {
                throw new Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');
              }
              // broken parser?
              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');
            default:
              // shenanigans
              throw new Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');
          }
          //console.log('val:' + m0 + ' state:' + state);
        });

        // submit the last entry
        // ignore null last line
        if(entry !== '') {
          endOfLine();
        }

        return entries;
      },

      // a csv entry parser
      parseEntry: function(csv, options) {
        // cache settings
        var separator = options.separator;
        var delimiter = options.delimiter;
        
        // set initial state if it's missing
        if(!options.state.rowNum) {
          options.state.rowNum = 1;
        }
        if(!options.state.colNum) {
          options.state.colNum = 1;
        }

        // clear initial state
        var entry = [];
        var state = 0;
        var value = '';

        function endOfValue() {
          if(options.onParseValue === undefined) {
            // onParseValue hook not set
            entry.push(value);
          } else {
            var hook = options.onParseValue(value, options.state); // onParseValue Hook
            // false skips the value, configurable through a hook
            if(hook !== false) {
              entry.push(hook);
            }
          }
          // reset the state
          value = '';
          state = 0;
          // update global state
          options.state.colNum++;
        }

        // checked for a cached regEx first
        if(!options.match) {
          // escape regex-specific control chars
          var escSeparator = RegExp.escape(separator);
          var escDelimiter = RegExp.escape(delimiter);
          
          // compile the regEx str using the custom delimiter/separator
          var match = /(D|S|\n|\r|[^DS\r\n]+)/;
          var matchSrc = match.source;
          matchSrc = matchSrc.replace(/S/g, escSeparator);
          matchSrc = matchSrc.replace(/D/g, escDelimiter);
          options.match = RegExp(matchSrc, 'gm');
        }

        // put on your fancy pants...
        // process control chars individually, use look-ahead on non-control chars
        csv.replace(options.match, function (m0) {
          switch (state) {
            // the start of a value
            case 0:
              // null last value
              if (m0 === separator) {
                value += '';
                endOfValue();
                break;
              }
              // opening delimiter
              if (m0 === delimiter) {
                state = 1;
                break;
              }
              // skip un-delimited new-lines
              if (m0 === '\n' || m0 === '\r') {
                break;
              }
              // un-delimited value
              value += m0;
              state = 3;
              break;

            // delimited input
            case 1:
              // second delimiter? check further
              if (m0 === delimiter) {
                state = 2;
                break;
              }
              // delimited data
              value += m0;
              state = 1;
              break;

            // delimiter found in delimited input
            case 2:
              // escaped delimiter?
              if (m0 === delimiter) {
                value += m0;
                state = 1;
                break;
              }
              // null value
              if (m0 === separator) {
                endOfValue();
                break;
              }
              // skip un-delimited new-lines
              if (m0 === '\n' || m0 === '\r') {
                break;
              }
              // broken paser?
              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');

            // un-delimited input
            case 3:
              // null last value
              if (m0 === separator) {
                endOfValue();
                break;
              }
              // skip un-delimited new-lines
              if (m0 === '\n' || m0 === '\r') {
                break;
              }
              // non-compliant data
              if (m0 === delimiter) {
                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');
              }
              // broken parser?
              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');
            default:
              // shenanigans
              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');
          }
          //console.log('val:' + m0 + ' state:' + state);
        });

        // submit the last value
        endOfValue();

        return entry;
      }
    },

    /**
     * $.csv.toArray(csv)
     * Converts a CSV entry string to a javascript array.
     *
     * @param {Array} csv The string containing the CSV data.
     * @param {Object} [options] An object containing user-defined options.
     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).
     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(").
     *
     * This method deals with simple CSV strings only. It's useful if you only
     * need to parse a single entry. If you need to parse more than one line,
     * use $.csv2Array instead.
     */
    toArray: function(csv, options, callback) {
      var options = (options !== undefined ? options : {});
      var config = {};
      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);
      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;
      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;
      var state = (options.state !== undefined ? options.state : {});

      // setup
      var options = {
        delimiter: config.delimiter,
        separator: config.separator,
        onParseEntry: options.onParseEntry,
        onParseValue: options.onParseValue,
        state: state
      }

      var entry = $.csv.parsers.parseEntry(csv, options);

      // push the value to a callback if one is defined
      if(!config.callback) {
        return entry;
      } else {
        config.callback('', entry);
      }
    },

    /**
     * $.csv.toArrays(csv)
     * Converts a CSV string to a javascript array.
     *
     * @param {String} csv The string containing the raw CSV data.
     * @param {Object} [options] An object containing user-defined options.
     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).
     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(").
     *
     * This method deals with multi-line CSV. The breakdown is simple. The first
     * dimension of the array represents the line (or entry/row) while the second
     * dimension contains the values (or values/columns).
     */
    toArrays: function(csv, options, callback) {
      var options = (options !== undefined ? options : {});
      var config = {};
      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);
      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;
      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;
      
      // setup
      var data = [];
      var options = {
        delimiter: config.delimiter,
        separator: config.separator,
        onParseEntry: options.onParseEntry,
        onParseValue: options.onParseValue,
        start: options.start,
        end: options.end,
        state: {
          rowNum: 1,
          colNum: 1
        }
      };

      // break the data down to lines
      data = $.csv.parsers.parse(csv, options);

      // push the value to a callback if one is defined
      if(!config.callback) {
        return data;
      } else {
        config.callback('', data);
      }
    },

    /**
     * $.csv.toObjects(csv)
     * Converts a CSV string to a javascript object.
     * @param {String} csv The string containing the raw CSV data.
     * @param {Object} [options] An object containing user-defined options.
     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).
     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(").
     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.
     *
     * This method deals with multi-line CSV strings. Where the headers line is
     * used as the key for each value per entry.
     */
    toObjects: function(csv, options, callback) {
      var options = (options !== undefined ? options : {});
      var config = {};
      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);
      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;
      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;
      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;
      options.start = 'start' in options ? options.start : 1;
      
      // account for headers
      if(config.headers) {
        options.start++;
      }
      if(options.end && config.headers) {
        options.end++;
      }
      
      // setup
      var lines = [];
      var data = [];
      
      var options = {
        delimiter: config.delimiter,
        separator: config.separator,
        onParseEntry: options.onParseEntry,
        onParseValue: options.onParseValue,
        start: options.start,
        end: options.end,
        state: {
          rowNum: 1,
          colNum: 1
        },
        match: false
      };

      // fetch the headers
      var headerOptions = {
        delimiter: config.delimiter,
        separator: config.separator,
        start: 1,
        end: 1,
        state: {
          rowNum:1,
          colNum:1
        }
      }
      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);
      var headers = $.csv.toArray(headerLine[0], options);

      // fetch the data
      var lines = $.csv.parsers.splitLines(csv, options);
      
      // reset the state for re-use
      options.state.colNum = 1;
      if(headers){
        options.state.rowNum = 2;
      } else {
        options.state.rowNum = 1;
      }
      
      // convert data to objects
      for(var i=0, len=lines.length; i<len; i++) {
        var entry = $.csv.toArray(lines[i], options);
        var object = {};
        for(var j in headers) {
          object[headers[j]] = entry[j];
        }
        data.push(object);
        
        // update row state
        options.state.rowNum++;
      }

      // push the value to a callback if one is defined
      if(!config.callback) {
        return data;
      } else {
        config.callback('', data);
      }
    },

     /**
     * $.csv.fromArrays(arrays)
     * Converts a javascript array to a CSV String.
     *
     * @param {Array} array An array containing an array of CSV entries.
     * @param {Object} [options] An object containing user-defined options.
     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).
     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(").
     *
     * This method generates a CSV file from an array of arrays (representing entries).
     */
    fromArrays: function(arrays, options, callback) {
      var options = (options !== undefined ? options : {});
      var config = {};
      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);
      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;
      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;
      config.escaper = 'escaper' in options ? options.escaper : $.csv.defaults.escaper;
      config.experimental = 'experimental' in options ? options.experimental : false;

      if(!config.experimental) {
        throw new Error('not implemented');
      }

      var output = [];
      for(i in arrays) {
        output.push(arrays[i]);
      }

      // push the value to a callback if one is defined
      if(!config.callback) {
        return output;
      } else {
        config.callback('', output);
      }
    },

    /**
     * $.csv.fromObjects(objects)
     * Converts a javascript dictionary to a CSV string.
     * @param {Object} objects An array of objects containing the data.
     * @param {Object} [options] An object containing user-defined options.
     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).
     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(").
     *
     * This method generates a CSV file from an array of objects (name:value pairs).
     * It starts by detecting the headers and adding them as the first line of
     * the CSV file, followed by a structured dump of the data.
     */
    fromObjects2CSV: function(objects, options, callback) {
      var options = (options !== undefined ? options : {});
      var config = {};
      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);
      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;
      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;
      config.experimental = 'experimental' in options ? options.experimental : false;

      if(!config.experimental) {
        throw new Error('not implemented');
      }

      var output = [];
      for(i in objects) {
        output.push(arrays[i]);
      }

      // push the value to a callback if one is defined
      if(!config.callback) {
        return output;
      } else {
        config.callback('', output);
      }
    }
  };

  // Maintenance code to maintain backward-compatibility
  // Will be removed in release 1.0
  $.csvEntry2Array = $.csv.toArray;
  $.csv2Array = $.csv.toArrays;
  $.csv2Dictionary = $.csv.toObjects;

})( jQuery );

/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.widget.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){if(a.cleanData){var c=a.cleanData;a.cleanData=function(b){for(var d=0,e;(e=b[d])!=null;d++)try{a(e).triggerHandler("remove")}catch(f){}c(b)}}else{var d=a.fn.remove;a.fn.remove=function(b,c){return this.each(function(){return c||(!b||a.filter(b,[this]).length)&&a("*",this).add([this]).each(function(){try{a(this).triggerHandler("remove")}catch(b){}}),d.call(a(this),b,c)})}}a.widget=function(b,c,d){var e=b.split(".")[0],f;b=b.split(".")[1],f=e+"-"+b,d||(d=c,c=a.Widget),a.expr[":"][f]=function(c){return!!a.data(c,b)},a[e]=a[e]||{},a[e][b]=function(a,b){arguments.length&&this._createWidget(a,b)};var g=new c;g.options=a.extend(!0,{},g.options),a[e][b].prototype=a.extend(!0,g,{namespace:e,widgetName:b,widgetEventPrefix:a[e][b].prototype.widgetEventPrefix||b,widgetBaseClass:f},d),a.widget.bridge(b,a[e][b])},a.widget.bridge=function(c,d){a.fn[c]=function(e){var f=typeof e=="string",g=Array.prototype.slice.call(arguments,1),h=this;return e=!f&&g.length?a.extend.apply(null,[!0,e].concat(g)):e,f&&e.charAt(0)==="_"?h:(f?this.each(function(){var d=a.data(this,c),f=d&&a.isFunction(d[e])?d[e].apply(d,g):d;if(f!==d&&f!==b)return h=f,!1}):this.each(function(){var b=a.data(this,c);b?b.option(e||{})._init():a.data(this,c,new d(e,this))}),h)}},a.Widget=function(a,b){arguments.length&&this._createWidget(a,b)},a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:!1},_createWidget:function(b,c){a.data(c,this.widgetName,this),this.element=a(c),this.options=a.extend(!0,{},this.options,this._getCreateOptions(),b);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()}),this._create(),this._trigger("create"),this._init()},_getCreateOptions:function(){return a.metadata&&a.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName),this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled")},widget:function(){return this.element},option:function(c,d){var e=c;if(arguments.length===0)return a.extend({},this.options);if(typeof c=="string"){if(d===b)return this.options[c];e={},e[c]=d}return this._setOptions(e),this},_setOptions:function(b){var c=this;return a.each(b,function(a,b){c._setOption(a,b)}),this},_setOption:function(a,b){return this.options[a]=b,a==="disabled"&&this.widget()[b?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",b),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_trigger:function(b,c,d){var e,f,g=this.options[b];d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent;if(f)for(e in f)e in c||(c[e]=f[e]);return this.element.trigger(c,d),!(a.isFunction(g)&&g.call(this.element[0],c,d)===!1||c.isDefaultPrevented())}}})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.highlight.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.highlight=function(b){return this.queue(function(){var c=a(this),d=["backgroundImage","backgroundColor","opacity"],e=a.effects.setMode(c,b.options.mode||"show"),f={backgroundColor:c.css("backgroundColor")};e=="hide"&&(f.opacity=0),a.effects.save(c,d),c.show().css({backgroundImage:"none",backgroundColor:b.options.color||"#ffff99"}).animate(f,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),e=="show"&&!a.support.opacity&&this.style.removeAttribute("filter"),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.effects.shake.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.effects.shake=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"effect"),f=b.options.direction||"left",g=b.options.distance||20,h=b.options.times||3,i=b.duration||b.options.duration||140;a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var j=f=="up"||f=="down"?"top":"left",k=f=="up"||f=="left"?"pos":"neg",l={},m={},n={};l[j]=(k=="pos"?"-=":"+=")+g,m[j]=(k=="pos"?"+=":"-=")+g*2,n[j]=(k=="pos"?"-=":"+=")+g*2,c.animate(l,i,b.options.easing);for(var p=1;p<h;p++)c.animate(m,i,b.options.easing).animate(n,i,b.options.easing);c.animate(m,i,b.options.easing).animate(l,i/2,b.options.easing,function(){a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)}),c.queue("fx",function(){c.dequeue()}),c.dequeue()})}})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.autocomplete.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){var c=0;a.widget("ui.autocomplete",{options:{appendTo:"body",autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var b=this,c=this.element[0].ownerDocument,d;this.isMultiLine=this.element.is("textarea"),this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(b.options.disabled||b.element.propAttr("readOnly"))return;d=!1;var e=a.ui.keyCode;switch(c.keyCode){case e.PAGE_UP:b._move("previousPage",c);break;case e.PAGE_DOWN:b._move("nextPage",c);break;case e.UP:b._keyEvent("previous",c);break;case e.DOWN:b._keyEvent("next",c);break;case e.ENTER:case e.NUMPAD_ENTER:b.menu.active&&(d=!0,c.preventDefault());case e.TAB:if(!b.menu.active)return;b.menu.select(c);break;case e.ESCAPE:b.element.val(b.term),b.close(c);break;default:clearTimeout(b.searching),b.searching=setTimeout(function(){b.term!=b.element.val()&&(b.selectedItem=null,b.search(null,c))},b.options.delay)}}).bind("keypress.autocomplete",function(a){d&&(d=!1,a.preventDefault())}).bind("focus.autocomplete",function(){if(b.options.disabled)return;b.selectedItem=null,b.previous=b.element.val()}).bind("blur.autocomplete",function(a){if(b.options.disabled)return;clearTimeout(b.searching),b.closing=setTimeout(function(){b.close(a),b._change(a)},150)}),this._initSource(),this.menu=a("<ul></ul>").addClass("ui-autocomplete").appendTo(a(this.options.appendTo||"body",c)[0]).mousedown(function(c){var d=b.menu.element[0];a(c.target).closest(".ui-menu-item").length||setTimeout(function(){a(document).one("mousedown",function(c){c.target!==b.element[0]&&c.target!==d&&!a.ui.contains(d,c.target)&&b.close()})},1),setTimeout(function(){clearTimeout(b.closing)},13)}).menu({focus:function(a,c){var d=c.item.data("item.autocomplete");!1!==b._trigger("focus",a,{item:d})&&/^key/.test(a.originalEvent.type)&&b.element.val(d.value)},selected:function(a,d){var e=d.item.data("item.autocomplete"),f=b.previous;b.element[0]!==c.activeElement&&(b.element.focus(),b.previous=f,setTimeout(function(){b.previous=f,b.selectedItem=e},1)),!1!==b._trigger("select",a,{item:e})&&b.element.val(e.value),b.term=b.element.val(),b.close(a),b.selectedItem=e},blur:function(a,c){b.menu.element.is(":visible")&&b.element.val()!==b.term&&b.element.val(b.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu"),a.fn.bgiframe&&this.menu.element.bgiframe(),b.beforeunloadHandler=function(){b.element.removeAttr("autocomplete")},a(window).bind("beforeunload",b.beforeunloadHandler)},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup"),this.menu.element.remove(),a(window).unbind("beforeunload",this.beforeunloadHandler),a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments),b==="source"&&this._initSource(),b==="appendTo"&&this.menu.element.appendTo(a(c||"body",this.element[0].ownerDocument)[0]),b==="disabled"&&c&&this.xhr&&this.xhr.abort()},_initSource:function(){var b=this,c,d;a.isArray(this.options.source)?(c=this.options.source,this.source=function(b,d){d(a.ui.autocomplete.filter(c,b.term))}):typeof this.options.source=="string"?(d=this.options.source,this.source=function(c,e){b.xhr&&b.xhr.abort(),b.xhr=a.ajax({url:d,data:c,dataType:"json",success:function(a,b){e(a)},error:function(){e([])}})}):this.source=this.options.source},search:function(a,b){a=a!=null?a:this.element.val(),this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)===!1)return;return this._search(a)},_search:function(a){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.source({term:a},this._response())},_response:function(){var a=this,b=++c;return function(d){b===c&&a.__response(d),a.pending--,a.pending||a.element.removeClass("ui-autocomplete-loading")}},__response:function(a){!this.options.disabled&&a&&a.length?(a=this._normalize(a),this._suggest(a),this._trigger("open")):this.close()},close:function(a){clearTimeout(this.closing),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.deactivate(),this._trigger("close",a))},_change:function(a){this.previous!==this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(b){return b.length&&b[0].label&&b[0].value?b:a.map(b,function(b){return typeof b=="string"?{label:b,value:b}:a.extend({label:b.label||b.value,value:b.value||b.label},b)})},_suggest:function(b){var c=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(c,b),this.menu.deactivate(),this.menu.refresh(),c.show(),this._resizeMenu(),c.position(a.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(new a.Event("mouseover"))},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(b,c){var d=this;a.each(c,function(a,c){d._renderItem(b,c)})},_renderItem:function(b,c){return a("<li></li>").data("item.autocomplete",c).append(a("<a></a>").text(c.label)).appendTo(b)},_move:function(a,b){if(!this.menu.element.is(":visible")){this.search(null,b);return}if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term),this.menu.deactivate();return}this.menu[a](b)},widget:function(){return this.menu.element},_keyEvent:function(a,b){if(!this.isMultiLine||this.menu.element.is(":visible"))this._move(a,b),b.preventDefault()}}),a.extend(a.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")},filter:function(b,c){var d=new RegExp(a.ui.autocomplete.escapeRegex(c),"i");return a.grep(b,function(a){return d.test(a.label||a.value||a)})}})})(jQuery),function(a){a.widget("ui.menu",{_create:function(){var b=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(c){if(!a(c.target).closest(".ui-menu-item a").length)return;c.preventDefault(),b.select(c)}),this.refresh()},refresh:function(){var b=this,c=this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem");c.children("a").addClass("ui-corner-all").attr("tabindex",-1).mouseenter(function(c){b.activate(c,a(this).parent())}).mouseleave(function(){b.deactivate()})},activate:function(a,b){this.deactivate();if(this.hasScroll()){var c=b.offset().top-this.element.offset().top,d=this.element.scrollTop(),e=this.element.height();c<0?this.element.scrollTop(d+c):c>=e&&this.element.scrollTop(d+c-e+b.height())}this.active=b.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end(),this._trigger("focus",a,{item:b})},deactivate:function(){if(!this.active)return;this.active.children("a").removeClass("ui-state-hover").removeAttr("id"),this._trigger("blur"),this.active=null},next:function(a){this.move("next",".ui-menu-item:first",a)},previous:function(a){this.move("prev",".ui-menu-item:last",a)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(a,b,c){if(!this.active){this.activate(c,this.element.children(b));return}var d=this.active[a+"All"](".ui-menu-item").eq(0);d.length?this.activate(c,d):this.activate(c,this.element.children(b))},nextPage:function(b){if(this.hasScroll()){if(!this.active||this.last()){this.activate(b,this.element.children(".ui-menu-item:first"));return}var c=this.active.offset().top,d=this.element.height(),e=this.element.children(".ui-menu-item").filter(function(){var b=a(this).offset().top-c-d+a(this).height();return b<10&&b>-10});e.length||(e=this.element.children(".ui-menu-item:last")),this.activate(b,e)}else this.activate(b,this.element.children(".ui-menu-item").filter(!this.active||this.last()?":first":":last"))},previousPage:function(b){if(this.hasScroll()){if(!this.active||this.first()){this.activate(b,this.element.children(".ui-menu-item:last"));return}var c=this.active.offset().top,d=this.element.height(),e=this.element.children(".ui-menu-item").filter(function(){var b=a(this).offset().top-c+d-a(this).height();return b<10&&b>-10});e.length||(e=this.element.children(".ui-menu-item:first")),this.activate(b,e)}else this.activate(b,this.element.children(".ui-menu-item").filter(!this.active||this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element[a.fn.prop?"prop":"attr"]("scrollHeight")},select:function(a){this._trigger("selected",a,{item:this.active})}})}(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.position.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.ui=a.ui||{};var c=/left|center|right/,d=/top|center|bottom/,e="center",f={},g=a.fn.position,h=a.fn.offset;a.fn.position=function(b){if(!b||!b.of)return g.apply(this,arguments);b=a.extend({},b);var h=a(b.of),i=h[0],j=(b.collision||"flip").split(" "),k=b.offset?b.offset.split(" "):[0,0],l,m,n;return i.nodeType===9?(l=h.width(),m=h.height(),n={top:0,left:0}):i.setTimeout?(l=h.width(),m=h.height(),n={top:h.scrollTop(),left:h.scrollLeft()}):i.preventDefault?(b.at="left top",l=m=0,n={top:b.of.pageY,left:b.of.pageX}):(l=h.outerWidth(),m=h.outerHeight(),n=h.offset()),a.each(["my","at"],function(){var a=(b[this]||"").split(" ");a.length===1&&(a=c.test(a[0])?a.concat([e]):d.test(a[0])?[e].concat(a):[e,e]),a[0]=c.test(a[0])?a[0]:e,a[1]=d.test(a[1])?a[1]:e,b[this]=a}),j.length===1&&(j[1]=j[0]),k[0]=parseInt(k[0],10)||0,k.length===1&&(k[1]=k[0]),k[1]=parseInt(k[1],10)||0,b.at[0]==="right"?n.left+=l:b.at[0]===e&&(n.left+=l/2),b.at[1]==="bottom"?n.top+=m:b.at[1]===e&&(n.top+=m/2),n.left+=k[0],n.top+=k[1],this.each(function(){var c=a(this),d=c.outerWidth(),g=c.outerHeight(),h=parseInt(a.curCSS(this,"marginLeft",!0))||0,i=parseInt(a.curCSS(this,"marginTop",!0))||0,o=d+h+(parseInt(a.curCSS(this,"marginRight",!0))||0),p=g+i+(parseInt(a.curCSS(this,"marginBottom",!0))||0),q=a.extend({},n),r;b.my[0]==="right"?q.left-=d:b.my[0]===e&&(q.left-=d/2),b.my[1]==="bottom"?q.top-=g:b.my[1]===e&&(q.top-=g/2),f.fractions||(q.left=Math.round(q.left),q.top=Math.round(q.top)),r={left:q.left-h,top:q.top-i},a.each(["left","top"],function(c,e){a.ui.position[j[c]]&&a.ui.position[j[c]][e](q,{targetWidth:l,targetHeight:m,elemWidth:d,elemHeight:g,collisionPosition:r,collisionWidth:o,collisionHeight:p,offset:k,my:b.my,at:b.at})}),a.fn.bgiframe&&c.bgiframe(),c.offset(a.extend(q,{using:b.using}))})},a.ui.position={fit:{left:function(b,c){var d=a(window),e=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft();b.left=e>0?b.left-e:Math.max(b.left-c.collisionPosition.left,b.left)},top:function(b,c){var d=a(window),e=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop();b.top=e>0?b.top-e:Math.max(b.top-c.collisionPosition.top,b.top)}},flip:{left:function(b,c){if(c.at[0]===e)return;var d=a(window),f=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft(),g=c.my[0]==="left"?-c.elemWidth:c.my[0]==="right"?c.elemWidth:0,h=c.at[0]==="left"?c.targetWidth:-c.targetWidth,i=-2*c.offset[0];b.left+=c.collisionPosition.left<0?g+h+i:f>0?g+h+i:0},top:function(b,c){if(c.at[1]===e)return;var d=a(window),f=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop(),g=c.my[1]==="top"?-c.elemHeight:c.my[1]==="bottom"?c.elemHeight:0,h=c.at[1]==="top"?c.targetHeight:-c.targetHeight,i=-2*c.offset[1];b.top+=c.collisionPosition.top<0?g+h+i:f>0?g+h+i:0}}},a.offset.setOffset||(a.offset.setOffset=function(b,c){/static/.test(a.curCSS(b,"position"))&&(b.style.position="relative");var d=a(b),e=d.offset(),f=parseInt(a.curCSS(b,"top",!0),10)||0,g=parseInt(a.curCSS(b,"left",!0),10)||0,h={top:c.top-e.top+f,left:c.left-e.left+g};"using"in c?c.using.call(b,h):d.css(h)},a.fn.offset=function(b){var c=this[0];return!c||!c.ownerDocument?null:b?a.isFunction(b)?this.each(function(c){a(this).offset(b.call(this,c,a(this).offset()))}):this.each(function(){a.offset.setOffset(this,b)}):h.call(this)}),function(){var b=document.getElementsByTagName("body")[0],c=document.createElement("div"),d,e,g,h,i;d=document.createElement(b?"div":"body"),g={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},b&&a.extend(g,{position:"absolute",left:"-1000px",top:"-1000px"});for(var j in g)d.style[j]=g[j];d.appendChild(c),e=b||document.documentElement,e.insertBefore(d,e.firstChild),c.style.cssText="position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;",h=a(c).offset(function(a,b){return b}).offset(),d.innerHTML="",e.removeChild(d),i=h.top+h.left+(b?2e3:0),f.fractions=i>21&&i<22}()})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.mouse.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){var c=!1;a(document).mouseup(function(a){c=!1}),a.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var b=this;this.element.bind("mousedown."+this.widgetName,function(a){return b._mouseDown(a)}).bind("click."+this.widgetName,function(c){if(!0===a.data(c.target,b.widgetName+".preventClickEvent"))return a.removeData(c.target,b.widgetName+".preventClickEvent"),c.stopImmediatePropagation(),!1}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),a(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(b){if(c)return;this._mouseStarted&&this._mouseUp(b),this._mouseDownEvent=b;var d=this,e=b.which==1,f=typeof this.options.cancel=="string"&&b.target.nodeName?a(b.target).closest(this.options.cancel).length:!1;if(!e||f||!this._mouseCapture(b))return!0;this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){d.mouseDelayMet=!0},this.options.delay));if(this._mouseDistanceMet(b)&&this._mouseDelayMet(b)){this._mouseStarted=this._mouseStart(b)!==!1;if(!this._mouseStarted)return b.preventDefault(),!0}return!0===a.data(b.target,this.widgetName+".preventClickEvent")&&a.removeData(b.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(a){return d._mouseMove(a)},this._mouseUpDelegate=function(a){return d._mouseUp(a)},a(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),b.preventDefault(),c=!0,!0},_mouseMove:function(b){return!a.browser.msie||document.documentMode>=9||!!b.button?this._mouseStarted?(this._mouseDrag(b),b.preventDefault()):(this._mouseDistanceMet(b)&&this._mouseDelayMet(b)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,b)!==!1,this._mouseStarted?this._mouseDrag(b):this._mouseUp(b)),!this._mouseStarted):this._mouseUp(b)},_mouseUp:function(b){return a(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,b.target==this._mouseDownEvent.target&&a.data(b.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(b)),!1},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(a){return this.mouseDelayMet},_mouseStart:function(a){},_mouseDrag:function(a){},_mouseStop:function(a){},_mouseCapture:function(a){return!0}})})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.slider.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){var c=5;a.widget("ui.slider",a.ui.mouse,{widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null},_create:function(){var b=this,d=this.options,e=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f="<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",g=d.values&&d.values.length||1,h=[];this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"+(d.disabled?" ui-slider-disabled ui-disabled":"")),this.range=a([]),d.range&&(d.range===!0&&(d.values||(d.values=[this._valueMin(),this._valueMin()]),d.values.length&&d.values.length!==2&&(d.values=[d.values[0],d.values[0]])),this.range=a("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(d.range==="min"||d.range==="max"?" ui-slider-range-"+d.range:"")));for(var i=e.length;i<g;i+=1)h.push(f);this.handles=e.add(a(h.join("")).appendTo(b.element)),this.handle=this.handles.eq(0),this.handles.add(this.range).filter("a").click(function(a){a.preventDefault()}).hover(function(){d.disabled||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}).focus(function(){d.disabled?a(this).blur():(a(".ui-slider .ui-state-focus").removeClass("ui-state-focus"),a(this).addClass("ui-state-focus"))}).blur(function(){a(this).removeClass("ui-state-focus")}),this.handles.each(function(b){a(this).data("index.ui-slider-handle",b)}),this.handles.keydown(function(d){var e=a(this).data("index.ui-slider-handle"),f,g,h,i;if(b.options.disabled)return;switch(d.keyCode){case a.ui.keyCode.HOME:case a.ui.keyCode.END:case a.ui.keyCode.PAGE_UP:case a.ui.keyCode.PAGE_DOWN:case a.ui.keyCode.UP:case a.ui.keyCode.RIGHT:case a.ui.keyCode.DOWN:case a.ui.keyCode.LEFT:d.preventDefault();if(!b._keySliding){b._keySliding=!0,a(this).addClass("ui-state-active"),f=b._start(d,e);if(f===!1)return}}i=b.options.step,b.options.values&&b.options.values.length?g=h=b.values(e):g=h=b.value();switch(d.keyCode){case a.ui.keyCode.HOME:h=b._valueMin();break;case a.ui.keyCode.END:h=b._valueMax();break;case a.ui.keyCode.PAGE_UP:h=b._trimAlignValue(g+(b._valueMax()-b._valueMin())/c);break;case a.ui.keyCode.PAGE_DOWN:h=b._trimAlignValue(g-(b._valueMax()-b._valueMin())/c);break;case a.ui.keyCode.UP:case a.ui.keyCode.RIGHT:if(g===b._valueMax())return;h=b._trimAlignValue(g+i);break;case a.ui.keyCode.DOWN:case a.ui.keyCode.LEFT:if(g===b._valueMin())return;h=b._trimAlignValue(g-i)}b._slide(d,e,h)}).keyup(function(c){var d=a(this).data("index.ui-slider-handle");b._keySliding&&(b._keySliding=!1,b._stop(c,d),b._change(c,d),a(this).removeClass("ui-state-active"))}),this._refreshValue(),this._animateOff=!1},destroy:function(){return this.handles.remove(),this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider"),this._mouseDestroy(),this},_mouseCapture:function(b){var c=this.options,d,e,f,g,h,i,j,k,l;return c.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),d={x:b.pageX,y:b.pageY},e=this._normValueFromMouse(d),f=this._valueMax()-this._valueMin()+1,h=this,this.handles.each(function(b){var c=Math.abs(e-h.values(b));f>c&&(f=c,g=a(this),i=b)}),c.range===!0&&this.values(1)===c.min&&(i+=1,g=a(this.handles[i])),j=this._start(b,i),j===!1?!1:(this._mouseSliding=!0,h._handleIndex=i,g.addClass("ui-state-active").focus(),k=g.offset(),l=!a(b.target).parents().andSelf().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:b.pageX-k.left-g.width()/2,top:b.pageY-k.top-g.height()/2-(parseInt(g.css("borderTopWidth"),10)||0)-(parseInt(g.css("borderBottomWidth"),10)||0)+(parseInt(g.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(b,i,e),this._animateOff=!0,!0))},_mouseStart:function(a){return!0},_mouseDrag:function(a){var b={x:a.pageX,y:a.pageY},c=this._normValueFromMouse(b);return this._slide(a,this._handleIndex,c),!1},_mouseStop:function(a){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(a,this._handleIndex),this._change(a,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b,c,d,e,f;return this.orientation==="horizontal"?(b=this.elementSize.width,c=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(b=this.elementSize.height,c=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),d=c/b,d>1&&(d=1),d<0&&(d=0),this.orientation==="vertical"&&(d=1-d),e=this._valueMax()-this._valueMin(),f=this._valueMin()+d*e,this._trimAlignValue(f)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};return this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("start",a,c)},_slide:function(a,b,c){var d,e,f;this.options.values&&this.options.values.length?(d=this.values(b?0:1),this.options.values.length===2&&this.options.range===!0&&(b===0&&c>d||b===1&&c<d)&&(c=d),c!==this.values(b)&&(e=this.values(),e[b]=c,f=this._trigger("slide",a,{handle:this.handles[b],value:c,values:e}),d=this.values(b?0:1),f!==!1&&this.values(b,c,!0))):c!==this.value()&&(f=this._trigger("slide",a,{handle:this.handles[b],value:c}),f!==!1&&this.value(c))},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=this._trimAlignValue(a),this._refreshValue(),this._change(null,0);return}return this._value()},values:function(b,c){var d,e,f;if(arguments.length>1){this.options.values[b]=this._trimAlignValue(c),this._refreshValue(),this._change(null,b);return}if(!arguments.length)return this._values();if(!a.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(b):this.value();d=this.options.values,e=arguments[0];for(f=0;f<d.length;f+=1)d[f]=this._trimAlignValue(e[f]),this._change(null,f);this._refreshValue()},_setOption:function(b,c){var d,e=0;a.isArray(this.options.values)&&(e=this.options.values.length),a.Widget.prototype._setOption.apply(this,arguments);switch(b){case"disabled":c?(this.handles.filter(".ui-state-focus").blur(),this.handles.removeClass("ui-state-hover"),this.handles.propAttr("disabled",!0),this.element.addClass("ui-disabled")):(this.handles.propAttr("disabled",!1),this.element.removeClass("ui-disabled"));break;case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue();break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":this._animateOff=!0,this._refreshValue();for(d=0;d<e;d+=1)this._change(null,d);this._animateOff=!1}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a),a},_values:function(a){var b,c,d;if(arguments.length)return b=this.options.values[a],b=this._trimAlignValue(b),b;c=this.options.values.slice();for(d=0;d<c.length;d+=1)c[d]=this._trimAlignValue(c[d]);return c},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b,d=a-c;return Math.abs(c)*2>=b&&(d+=c>0?b:-b),parseFloat(d.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var b=this.options.range,c=this.options,d=this,e=this._animateOff?!1:c.animate,f,g={},h,i,j,k;this.options.values&&this.options.values.length?this.handles.each(function(b,i){f=(d.values(b)-d._valueMin())/(d._valueMax()-d._valueMin())*100,g[d.orientation==="horizontal"?"left":"bottom"]=f+"%",a(this).stop(1,1)[e?"animate":"css"](g,c.animate),d.options.range===!0&&(d.orientation==="horizontal"?(b===0&&d.range.stop(1,1)[e?"animate":"css"]({left:f+"%"},c.animate),b===1&&d.range[e?"animate":"css"]({width:f-h+"%"},{queue:!1,duration:c.animate})):(b===0&&d.range.stop(1,1)[e?"animate":"css"]({bottom:f+"%"},c.animate),b===1&&d.range[e?"animate":"css"]({height:f-h+"%"},{queue:!1,duration:c.animate}))),h=f}):(i=this.value(),j=this._valueMin(),k=this._valueMax(),f=k!==j?(i-j)/(k-j)*100:0,g[d.orientation==="horizontal"?"left":"bottom"]=f+"%",this.handle.stop(1,1)[e?"animate":"css"](g,c.animate),b==="min"&&this.orientation==="horizontal"&&this.range.stop(1,1)[e?"animate":"css"]({width:f+"%"},c.animate),b==="max"&&this.orientation==="horizontal"&&this.range[e?"animate":"css"]({width:100-f+"%"},{queue:!1,duration:c.animate}),b==="min"&&this.orientation==="vertical"&&this.range.stop(1,1)[e?"animate":"css"]({height:f+"%"},c.animate),b==="max"&&this.orientation==="vertical"&&this.range[e?"animate":"css"]({height:100-f+"%"},{queue:!1,duration:c.animate}))}}),a.extend(a.ui.slider,{version:"1.8.21"})})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.draggable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.draggable",a.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1},_create:function(){this.options.helper=="original"&&!/^(?:r|a|f)/.test(this.element.css("position"))&&(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},destroy:function(){if(!this.element.data("draggable"))return;return this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy(),this},_mouseCapture:function(b){var c=this.options;return this.helper||c.disabled||a(b.target).is(".ui-resizable-handle")?!1:(this.handle=this._getHandle(b),this.handle?(c.iframeFix&&a(c.iframeFix===!0?"iframe":c.iframeFix).each(function(){a('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(a(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(b){var c=this.options;return this.helper=this._createHelper(b),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),a.ui.ddmanager&&(a.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},a.extend(this.offset,{click:{left:b.pageX-this.offset.left,top:b.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(b),this.originalPageX=b.pageX,this.originalPageY=b.pageY,c.cursorAt&&this._adjustOffsetFromHelper(c.cursorAt),c.containment&&this._setContainment(),this._trigger("start",b)===!1?(this._clear(),!1):(this._cacheHelperProportions(),a.ui.ddmanager&&!c.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b),this._mouseDrag(b,!0),a.ui.ddmanager&&a.ui.ddmanager.dragStart(this,b),!0)},_mouseDrag:function(b,c){this.position=this._generatePosition(b),this.positionAbs=this._convertPositionTo("absolute");if(!c){var d=this._uiHash();if(this._trigger("drag",b,d)===!1)return this._mouseUp({}),!1;this.position=d.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";return a.ui.ddmanager&&a.ui.ddmanager.drag(this,b),!1},_mouseStop:function(b){var c=!1;a.ui.ddmanager&&!this.options.dropBehaviour&&(c=a.ui.ddmanager.drop(this,b)),this.dropped&&(c=this.dropped,this.dropped=!1);var d=this.element[0],e=!1;while(d&&(d=d.parentNode))d==document&&(e=!0);if(!e&&this.options.helper==="original")return!1;if(this.options.revert=="invalid"&&!c||this.options.revert=="valid"&&c||this.options.revert===!0||a.isFunction(this.options.revert)&&this.options.revert.call(this.element,c)){var f=this;a(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){f._trigger("stop",b)!==!1&&f._clear()})}else this._trigger("stop",b)!==!1&&this._clear();return!1},_mouseUp:function(b){return this.options.iframeFix===!0&&a("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),a.ui.ddmanager&&a.ui.ddmanager.dragStop(this,b),a.ui.mouse.prototype._mouseUp.call(this,b)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(b){var c=!this.options.handle||!a(this.options.handle,this.element).length?!0:!1;return a(this.options.handle,this.element).find("*").andSelf().each(function(){this==b.target&&(c=!0)}),c},_createHelper:function(b){var c=this.options,d=a.isFunction(c.helper)?a(c.helper.apply(this.element[0],[b])):c.helper=="clone"?this.element.clone().removeAttr("id"):this.element;return d.parents("body").length||d.appendTo(c.appendTo=="parent"?this.element[0].parentNode:c.appendTo),d[0]!=this.element[0]&&!/(fixed|absolute)/.test(d.css("position"))&&d.css("position","absolute"),d},_adjustOffsetFromHelper:function(b){typeof b=="string"&&(b=b.split(" ")),a.isArray(b)&&(b={left:+b[0],top:+b[1]||0}),"left"in b&&(this.offset.click.left=b.left+this.margins.left),"right"in b&&(this.offset.click.left=this.helperProportions.width-b.right+this.margins.left),"top"in b&&(this.offset.click.top=b.top+this.margins.top),"bottom"in b&&(this.offset.click.top=this.helperProportions.height-b.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var b=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&a.ui.contains(this.scrollParent[0],this.offsetParent[0])&&(b.left+=this.scrollParent.scrollLeft(),b.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&a.browser.msie)b={top:0,left:0};return{top:b.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:b.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var b=this.options;b.containment=="parent"&&(b.containment=this.helper[0].parentNode);if(b.containment=="document"||b.containment=="window")this.containment=[b.containment=="document"?0:a(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,b.containment=="document"?0:a(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,(b.containment=="document"?0:a(window).scrollLeft())+a(b.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(b.containment=="document"?0:a(window).scrollTop())+(a(b.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(b.containment)&&b.containment.constructor!=Array){var c=a(b.containment),d=c[0];if(!d)return;var e=c.offset(),f=a(d).css("overflow")!="hidden";this.containment=[(parseInt(a(d).css("borderLeftWidth"),10)||0)+(parseInt(a(d).css("paddingLeft"),10)||0),(parseInt(a(d).css("borderTopWidth"),10)||0)+(parseInt(a(d).css("paddingTop"),10)||0),(f?Math.max(d.scrollWidth,d.offsetWidth):d.offsetWidth)-(parseInt(a(d).css("borderLeftWidth"),10)||0)-(parseInt(a(d).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(f?Math.max(d.scrollHeight,d.offsetHeight):d.offsetHeight)-(parseInt(a(d).css("borderTopWidth"),10)||0)-(parseInt(a(d).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=c}else b.containment.constructor==Array&&(this.containment=b.containment)},_convertPositionTo:function(b,c){c||(c=this.position);var d=b=="absolute"?1:-1,e=this.options,f=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,g=/(html|body)/i.test(f[0].tagName);return{top:c.top+this.offset.relative.top*d+this.offset.parent.top*d-(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():g?0:f.scrollTop())*d),left:c.left+this.offset.relative.left*d+this.offset.parent.left*d-(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():g?0:f.scrollLeft())*d)}},_generatePosition:function(b){var c=this.options,d=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(d[0].tagName),f=b.pageX,g=b.pageY;if(this.originalPosition){var h;if(this.containment){if(this.relative_container){var i=this.relative_container.offset();h=[this.containment[0]+i.left,this.containment[1]+i.top,this.containment[2]+i.left,this.containment[3]+i.top]}else h=this.containment;b.pageX-this.offset.click.left<h[0]&&(f=h[0]+this.offset.click.left),b.pageY-this.offset.click.top<h[1]&&(g=h[1]+this.offset.click.top),b.pageX-this.offset.click.left>h[2]&&(f=h[2]+this.offset.click.left),b.pageY-this.offset.click.top>h[3]&&(g=h[3]+this.offset.click.top)}if(c.grid){var j=c.grid[1]?this.originalPageY+Math.round((g-this.originalPageY)/c.grid[1])*c.grid[1]:this.originalPageY;g=h?j-this.offset.click.top<h[1]||j-this.offset.click.top>h[3]?j-this.offset.click.top<h[1]?j+c.grid[1]:j-c.grid[1]:j:j;var k=c.grid[0]?this.originalPageX+Math.round((f-this.originalPageX)/c.grid[0])*c.grid[0]:this.originalPageX;f=h?k-this.offset.click.left<h[0]||k-this.offset.click.left>h[2]?k-this.offset.click.left<h[0]?k+c.grid[0]:k-c.grid[0]:k:k}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:d.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:d.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(b,c,d){return d=d||this._uiHash(),a.ui.plugin.call(this,b,[c,d]),b=="drag"&&(this.positionAbs=this._convertPositionTo("absolute")),a.Widget.prototype._trigger.call(this,b,c,d)},plugins:{},_uiHash:function(a){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),a.extend(a.ui.draggable,{version:"1.8.21"}),a.ui.plugin.add("draggable","connectToSortable",{start:function(b,c){var d=a(this).data("draggable"),e=d.options,f=a.extend({},c,{item:d.element});d.sortables=[],a(e.connectToSortable).each(function(){var c=a.data(this,"sortable");c&&!c.options.disabled&&(d.sortables.push({instance:c,shouldRevert:c.options.revert}),c.refreshPositions(),c._trigger("activate",b,f))})},stop:function(b,c){var d=a(this).data("draggable"),e=a.extend({},c,{item:d.element});a.each(d.sortables,function(){this.instance.isOver?(this.instance.isOver=0,d.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=!0),this.instance._mouseStop(b),this.instance.options.helper=this.instance.options._helper,d.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",b,e))})},drag:function(b,c){var d=a(this).data("draggable"),e=this,f=function(b){var c=this.offset.click.top,d=this.offset.click.left,e=this.positionAbs.top,f=this.positionAbs.left,g=b.height,h=b.width,i=b.top,j=b.left;return a.ui.isOver(e+c,f+d,i,j,g,h)};a.each(d.sortables,function(f){this.instance.positionAbs=d.positionAbs,this.instance.helperProportions=d.helperProportions,this.instance.offset.click=d.offset.click,this.instance._intersectsWith(this.instance.containerCache)?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=a(e).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return c.helper[0]},b.target=this.instance.currentItem[0],this.instance._mouseCapture(b,!0),this.instance._mouseStart(b,!0,!0),this.instance.offset.click.top=d.offset.click.top,this.instance.offset.click.left=d.offset.click.left,this.instance.offset.parent.left-=d.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=d.offset.parent.top-this.instance.offset.parent.top,d._trigger("toSortable",b),d.dropped=this.instance.element,d.currentItem=d.element,this.instance.fromOutside=d),this.instance.currentItem&&this.instance._mouseDrag(b)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",b,this.instance._uiHash(this.instance)),this.instance._mouseStop(b,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),d._trigger("fromSortable",b),d.dropped=!1)})}}),a.ui.plugin.add("draggable","cursor",{start:function(b,c){var d=a("body"),e=a(this).data("draggable").options;d.css("cursor")&&(e._cursor=d.css("cursor")),d.css("cursor",e.cursor)},stop:function(b,c){var d=a(this).data("draggable").options;d._cursor&&a("body").css("cursor",d._cursor)}}),a.ui.plugin.add("draggable","opacity",{start:function(b,c){var d=a(c.helper),e=a(this).data("draggable").options;d.css("opacity")&&(e._opacity=d.css("opacity")),d.css("opacity",e.opacity)},stop:function(b,c){var d=a(this).data("draggable").options;d._opacity&&a(c.helper).css("opacity",d._opacity)}}),a.ui.plugin.add("draggable","scroll",{start:function(b,c){var d=a(this).data("draggable");d.scrollParent[0]!=document&&d.scrollParent[0].tagName!="HTML"&&(d.overflowOffset=d.scrollParent.offset())},drag:function(b,c){var d=a(this).data("draggable"),e=d.options,f=!1;if(d.scrollParent[0]!=document&&d.scrollParent[0].tagName!="HTML"){if(!e.axis||e.axis!="x")d.overflowOffset.top+d.scrollParent[0].offsetHeight-b.pageY<e.scrollSensitivity?d.scrollParent[0].scrollTop=f=d.scrollParent[0].scrollTop+e.scrollSpeed:b.pageY-d.overflowOffset.top<e.scrollSensitivity&&(d.scrollParent[0].scrollTop=f=d.scrollParent[0].scrollTop-e.scrollSpeed);if(!e.axis||e.axis!="y")d.overflowOffset.left+d.scrollParent[0].offsetWidth-b.pageX<e.scrollSensitivity?d.scrollParent[0].scrollLeft=f=d.scrollParent[0].scrollLeft+e.scrollSpeed:b.pageX-d.overflowOffset.left<e.scrollSensitivity&&(d.scrollParent[0].scrollLeft=f=d.scrollParent[0].scrollLeft-e.scrollSpeed)}else{if(!e.axis||e.axis!="x")b.pageY-a(document).scrollTop()<e.scrollSensitivity?f=a(document).scrollTop(a(document).scrollTop()-e.scrollSpeed):a(window).height()-(b.pageY-a(document).scrollTop())<e.scrollSensitivity&&(f=a(document).scrollTop(a(document).scrollTop()+e.scrollSpeed));if(!e.axis||e.axis!="y")b.pageX-a(document).scrollLeft()<e.scrollSensitivity?f=a(document).scrollLeft(a(document).scrollLeft()-e.scrollSpeed):a(window).width()-(b.pageX-a(document).scrollLeft())<e.scrollSensitivity&&(f=a(document).scrollLeft(a(document).scrollLeft()+e.scrollSpeed))}f!==!1&&a.ui.ddmanager&&!e.dropBehaviour&&a.ui.ddmanager.prepareOffsets(d,b)}}),a.ui.plugin.add("draggable","snap",{start:function(b,c){var d=a(this).data("draggable"),e=d.options;d.snapElements=[],a(e.snap.constructor!=String?e.snap.items||":data(draggable)":e.snap).each(function(){var b=a(this),c=b.offset();this!=d.element[0]&&d.snapElements.push({item:this,width:b.outerWidth(),height:b.outerHeight(),top:c.top,left:c.left})})},drag:function(b,c){var d=a(this).data("draggable"),e=d.options,f=e.snapTolerance,g=c.offset.left,h=g+d.helperProportions.width,i=c.offset.top,j=i+d.helperProportions.height;for(var k=d.snapElements.length-1;k>=0;k--){var l=d.snapElements[k].left,m=l+d.snapElements[k].width,n=d.snapElements[k].top,o=n+d.snapElements[k].height;if(!(l-f<g&&g<m+f&&n-f<i&&i<o+f||l-f<g&&g<m+f&&n-f<j&&j<o+f||l-f<h&&h<m+f&&n-f<i&&i<o+f||l-f<h&&h<m+f&&n-f<j&&j<o+f)){d.snapElements[k].snapping&&d.options.snap.release&&d.options.snap.release.call(d.element,b,a.extend(d._uiHash(),{snapItem:d.snapElements[k].item})),d.snapElements[k].snapping=!1;continue}if(e.snapMode!="inner"){var p=Math.abs(n-j)<=f,q=Math.abs(o-i)<=f,r=Math.abs(l-h)<=f,s=Math.abs(m-g)<=f;p&&(c.position.top=d._convertPositionTo("relative",{top:n-d.helperProportions.height,left:0}).top-d.margins.top),q&&(c.position.top=d._convertPositionTo("relative",{top:o,left:0}).top-d.margins.top),r&&(c.position.left=d._convertPositionTo("relative",{top:0,left:l-d.helperProportions.width}).left-d.margins.left),s&&(c.position.left=d._convertPositionTo("relative",{top:0,left:m}).left-d.margins.left)}var t=p||q||r||s;if(e.snapMode!="outer"){var p=Math.abs(n-i)<=f,q=Math.abs(o-j)<=f,r=Math.abs(l-g)<=f,s=Math.abs(m-h)<=f;p&&(c.position.top=d._convertPositionTo("relative",{top:n,left:0}).top-d.margins.top),q&&(c.position.top=d._convertPositionTo("relative",{top:o-d.helperProportions.height,left:0}).top-d.margins.top),r&&(c.position.left=d._convertPositionTo("relative",{top:0,left:l}).left-d.margins.left),s&&(c.position.left=d._convertPositionTo("relative",{top:0,left:m-d.helperProportions.width}).left-d.margins.left)}!d.snapElements[k].snapping&&(p||q||r||s||t)&&d.options.snap.snap&&d.options.snap.snap.call(d.element,b,a.extend(d._uiHash(),{snapItem:d.snapElements[k].item})),d.snapElements[k].snapping=p||q||r||s||t}}}),a.ui.plugin.add("draggable","stack",{start:function(b,c){var d=a(this).data("draggable").options,e=a.makeArray(a(d.stack)).sort(function(b,c){return(parseInt(a(b).css("zIndex"),10)||0)-(parseInt(a(c).css("zIndex"),10)||0)});if(!e.length)return;var f=parseInt(e[0].style.zIndex)||0;a(e).each(function(a){this.style.zIndex=f+a}),this[0].style.zIndex=f+e.length}}),a.ui.plugin.add("draggable","zIndex",{start:function(b,c){var d=a(c.helper),e=a(this).data("draggable").options;d.css("zIndex")&&(e._zIndex=d.css("zIndex")),d.css("zIndex",e.zIndex)},stop:function(b,c){var d=a(this).data("draggable").options;d._zIndex&&a(c.helper).css("zIndex",d._zIndex)}})})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.sortable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.sortable",a.ui.mouse,{widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3},_create:function(){var a=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?a.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},destroy:function(){a.Widget.prototype.destroy.call(this),this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var b=this.items.length-1;b>=0;b--)this.items[b].item.removeData(this.widgetName+"-item");return this},_setOption:function(b,c){b==="disabled"?(this.options[b]=c,this.widget()[c?"addClass":"removeClass"]("ui-sortable-disabled")):a.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(b,c){var d=this;if(this.reverting)return!1;if(this.options.disabled||this.options.type=="static")return!1;this._refreshItems(b);var e=null,f=this,g=a(b.target).parents().each(function(){if(a.data(this,d.widgetName+"-item")==f)return e=a(this),!1});a.data(b.target,d.widgetName+"-item")==f&&(e=a(b.target));if(!e)return!1;if(this.options.handle&&!c){var h=!1;a(this.options.handle,e).find("*").andSelf().each(function(){this==b.target&&(h=!0)});if(!h)return!1}return this.currentItem=e,this._removeCurrentsFromItems(),!0},_mouseStart:function(b,c,d){var e=this.options,f=this;this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(b),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},a.extend(this.offset,{click:{left:b.pageX-this.offset.left,top:b.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(b),this.originalPageX=b.pageX,this.originalPageY=b.pageY,e.cursorAt&&this._adjustOffsetFromHelper(e.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!=this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),e.containment&&this._setContainment(),e.cursor&&(a("body").css("cursor")&&(this._storedCursor=a("body").css("cursor")),a("body").css("cursor",e.cursor)),e.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",e.opacity)),e.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",e.zIndex)),this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",b,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions();if(!d)for(var g=this.containers.length-1;g>=0;g--)this.containers[g]._trigger("activate",b,f._uiHash(this));return a.ui.ddmanager&&(a.ui.ddmanager.current=this),a.ui.ddmanager&&!e.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(b),!0},_mouseDrag:function(b){this.position=this._generatePosition(b),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs);if(this.options.scroll){var c=this.options,d=!1;this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-b.pageY<c.scrollSensitivity?this.scrollParent[0].scrollTop=d=this.scrollParent[0].scrollTop+c.scrollSpeed:b.pageY-this.overflowOffset.top<c.scrollSensitivity&&(this.scrollParent[0].scrollTop=d=this.scrollParent[0].scrollTop-c.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-b.pageX<c.scrollSensitivity?this.scrollParent[0].scrollLeft=d=this.scrollParent[0].scrollLeft+c.scrollSpeed:b.pageX-this.overflowOffset.left<c.scrollSensitivity&&(this.scrollParent[0].scrollLeft=d=this.scrollParent[0].scrollLeft-c.scrollSpeed)):(b.pageY-a(document).scrollTop()<c.scrollSensitivity?d=a(document).scrollTop(a(document).scrollTop()-c.scrollSpeed):a(window).height()-(b.pageY-a(document).scrollTop())<c.scrollSensitivity&&(d=a(document).scrollTop(a(document).scrollTop()+c.scrollSpeed)),b.pageX-a(document).scrollLeft()<c.scrollSensitivity?d=a(document).scrollLeft(a(document).scrollLeft()-c.scrollSpeed):a(window).width()-(b.pageX-a(document).scrollLeft())<c.scrollSensitivity&&(d=a(document).scrollLeft(a(document).scrollLeft()+c.scrollSpeed))),d!==!1&&a.ui.ddmanager&&!c.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(var e=this.items.length-1;e>=0;e--){var f=this.items[e],g=f.item[0],h=this._intersectsWithPointer(f);if(!h)continue;if(g!=this.currentItem[0]&&this.placeholder[h==1?"next":"prev"]()[0]!=g&&!a.ui.contains(this.placeholder[0],g)&&(this.options.type=="semi-dynamic"?!a.ui.contains(this.element[0],g):!0)){this.direction=h==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(f))this._rearrange(b,f);else break;this._trigger("change",b,this._uiHash());break}}return this._contactContainers(b),a.ui.ddmanager&&a.ui.ddmanager.drag(this,b),this._trigger("sort",b,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(b,c){if(!b)return;a.ui.ddmanager&&!this.options.dropBehaviour&&a.ui.ddmanager.drop(this,b);if(this.options.revert){var d=this,e=d.placeholder.offset();d.reverting=!0,a(this.helper).animate({left:e.left-this.offset.parent.left-d.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:e.top-this.offset.parent.top-d.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){d._clear(b)})}else this._clear(b,c);return!1},cancel:function(){var b=this;if(this.dragging){this._mouseUp({target:null}),this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("deactivate",null,b._uiHash(this)),this.containers[c].containerCache.over&&(this.containers[c]._trigger("out",null,b._uiHash(this)),this.containers[c].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),a.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?a(this.domPosition.prev).after(this.currentItem):a(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(b){var c=this._getItemsAsjQuery(b&&b.connected),d=[];return b=b||{},a(c).each(function(){var c=(a(b.item||this).attr(b.attribute||"id")||"").match(b.expression||/(.+)[-=_](.+)/);c&&d.push((b.key||c[1]+"[]")+"="+(b.key&&b.expression?c[1]:c[2]))}),!d.length&&b.key&&d.push(b.key+"="),d.join("&")},toArray:function(b){var c=this._getItemsAsjQuery(b&&b.connected),d=[];return b=b||{},c.each(function(){d.push(a(b.item||this).attr(b.attribute||"id")||"")}),d},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,d=this.positionAbs.top,e=d+this.helperProportions.height,f=a.left,g=f+a.width,h=a.top,i=h+a.height,j=this.offset.click.top,k=this.offset.click.left,l=d+j>h&&d+j<i&&b+k>f&&b+k<g;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>a[this.floating?"width":"height"]?l:f<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<g&&h<d+this.helperProportions.height/2&&e-this.helperProportions.height/2<i},_intersectsWithPointer:function(b){var c=this.options.axis==="x"||a.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,b.top,b.height),d=this.options.axis==="y"||a.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,b.left,b.width),e=c&&d,f=this._getDragVerticalDirection(),g=this._getDragHorizontalDirection();return e?this.floating?g&&g=="right"||f=="down"?2:1:f&&(f=="down"?2:1):!1},_intersectsWithSides:function(b){var c=a.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,b.top+b.height/2,b.height),d=a.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,b.left+b.width/2,b.width),e=this._getDragVerticalDirection(),f=this._getDragHorizontalDirection();return this.floating&&f?f=="right"&&d||f=="left"&&!d:e&&(e=="down"&&c||e=="up"&&!c)},_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){return this._refreshItems(a),this.refreshPositions(),this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(b){var c=this,d=[],e=[],f=this._connectWith();if(f&&b)for(var g=f.length-1;g>=0;g--){var h=a(f[g]);for(var i=h.length-1;i>=0;i--){var j=a.data(h[i],this.widgetName);j&&j!=this&&!j.options.disabled&&e.push([a.isFunction(j.options.items)?j.options.items.call(j.element):a(j.options.items,j.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),j])}}e.push([a.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):a(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]);for(var g=e.length-1;g>=0;g--)e[g][0].each(function(){d.push(this)});return a(d)},_removeCurrentsFromItems:function(){var a=this.currentItem.find(":data("+this.widgetName+"-item)");for(var b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(b){this.items=[],this.containers=[this];var c=this.items,d=this,e=[[a.isFunction(this.options.items)?this.options.items.call(this.element[0],b,{item:this.currentItem}):a(this.options.items,this.element),this]],f=this._connectWith();if(f&&this.ready)for(var g=f.length-1;g>=0;g--){var h=a(f[g]);for(var i=h.length-1;i>=0;i--){var j=a.data(h[i],this.widgetName);j&&j!=this&&!j.options.disabled&&(e.push([a.isFunction(j.options.items)?j.options.items.call(j.element[0],b,{item:this.currentItem}):a(j.options.items,j.element),j]),this.containers.push(j))}}for(var g=e.length-1;g>=0;g--){var k=e[g][1],l=e[g][0];for(var i=0,m=l.length;i<m;i++){var n=a(l[i]);n.data(this.widgetName+"-item",k),c.push({item:n,instance:k,width:0,height:0,left:0,top:0})}}},refreshPositions:function(b){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());for(var c=this.items.length-1;c>=0;c--){var d=this.items[c];if(d.instance!=this.currentContainer&&this.currentContainer&&d.item[0]!=this.currentItem[0])continue;var e=this.options.toleranceElement?a(this.options.toleranceElement,d.item):d.item;b||(d.width=e.outerWidth(),d.height=e.outerHeight());var f=e.offset();d.left=f.left,d.top=f.top}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(var c=this.containers.length-1;c>=0;c--){var f=this.containers[c].element.offset();this.containers[c].containerCache.left=f.left,this.containers[c].containerCache.top=f.top,this.containers[c].containerCache.width=this.containers[c].element.outerWidth(),this.containers[c].containerCache.height=this.containers[c].element.outerHeight()}return this},_createPlaceholder:function(b){var c=b||this,d=c.options;if(!d.placeholder||d.placeholder.constructor==String){var e=d.placeholder;d.placeholder={element:function(){var b=a(document.createElement(c.currentItem[0].nodeName)).addClass(e||c.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];return e||(b.style.visibility="hidden"),b},update:function(a,b){if(e&&!d.forcePlaceholderSize)return;b.height()||b.height(c.currentItem.innerHeight()-parseInt(c.currentItem.css("paddingTop")||0,10)-parseInt(c.currentItem.css("paddingBottom")||0,10)),b.width()||b.width(c.currentItem.innerWidth()-parseInt(c.currentItem.css("paddingLeft")||0,10)-parseInt(c.currentItem.css("paddingRight")||0,10))}}}c.placeholder=a(d.placeholder.element.call(c.element,c.currentItem)),c.currentItem.after(c.placeholder),d.placeholder.update(c,c.placeholder)},_contactContainers:function(b){var c=null,d=null;for(var e=this.containers.length-1;e>=0;e--){if(a.ui.contains(this.currentItem[0],this.containers[e].element[0]))continue;if(this._intersectsWith(this.containers[e].containerCache)){if(c&&a.ui.contains(this.containers[e].element[0],c.element[0]))continue;c=this.containers[e],d=e}else this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",b,this._uiHash(this)),this.containers[e].containerCache.over=0)}if(!c)return;if(this.containers.length===1)this.containers[d]._trigger("over",b,this._uiHash(this)),this.containers[d].containerCache.over=1;else if(this.currentContainer!=this.containers[d]){var f=1e4,g=null,h=this.positionAbs[this.containers[d].floating?"left":"top"];for(var i=this.items.length-1;i>=0;i--){if(!a.ui.contains(this.containers[d].element[0],this.items[i].item[0]))continue;var j=this.containers[d].floating?this.items[i].item.offset().left:this.items[i].item.offset().top;Math.abs(j-h)<f&&(f=Math.abs(j-h),g=this.items[i],this.direction=j-h>0?"down":"up")}if(!g&&!this.options.dropOnEmpty)return;this.currentContainer=this.containers[d],g?this._rearrange(b,g,null,!0):this._rearrange(b,null,this.containers[d].element,!0),this._trigger("change",b,this._uiHash()),this.containers[d]._trigger("change",b,this._uiHash(this)),this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[d]._trigger("over",b,this._uiHash(this)),this.containers[d].containerCache.over=1}},_createHelper:function(b){var c=this.options,d=a.isFunction(c.helper)?a(c.helper.apply(this.element[0],[b,this.currentItem])):c.helper=="clone"?this.currentItem.clone():this.currentItem;return d.parents("body").length||a(c.appendTo!="parent"?c.appendTo:this.currentItem[0].parentNode)[0].appendChild(d[0]),d[0]==this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(d[0].style.width==""||c.forceHelperSize)&&d.width(this.currentItem.width()),(d[0].style.height==""||c.forceHelperSize)&&d.height(this.currentItem.height()),d},_adjustOffsetFromHelper:function(b){typeof b=="string"&&(b=b.split(" ")),a.isArray(b)&&(b={left:+b[0],top:+b[1]||0}),"left"in b&&(this.offset.click.left=b.left+this.margins.left),"right"in b&&(this.offset.click.left=this.helperProportions.width-b.right+this.margins.left),"top"in b&&(this.offset.click.top=b.top+this.margins.top),"bottom"in b&&(this.offset.click.top=this.helperProportions.height-b.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var b=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&a.ui.contains(this.scrollParent[0],this.offsetParent[0])&&(b.left+=this.scrollParent.scrollLeft(),b.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&a.browser.msie)b={top:0,left:0};return{top:b.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:b.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var b=this.options;b.containment=="parent"&&(b.containment=this.helper[0].parentNode);if(b.containment=="document"||b.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,a(b.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a(b.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(b.containment)){var c=a(b.containment)[0],d=a(b.containment).offset(),e=a(c).css("overflow")!="hidden";this.containment=[d.left+(parseInt(a(c).css("borderLeftWidth"),10)||0)+(parseInt(a(c).css("paddingLeft"),10)||0)-this.margins.left,d.top+(parseInt(a(c).css("borderTopWidth"),10)||0)+(parseInt(a(c).css("paddingTop"),10)||0)-this.margins.top,d.left+(e?Math.max(c.scrollWidth,c.offsetWidth):c.offsetWidth)-(parseInt(a(c).css("borderLeftWidth"),10)||0)-(parseInt(a(c).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,d.top+(e?Math.max(c.scrollHeight,c.offsetHeight):c.offsetHeight)-(parseInt(a(c).css("borderTopWidth"),10)||0)-(parseInt(a(c).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(b,c){c||(c=this.position);var d=b=="absolute"?1:-1,e=this.options,f=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,g=/(html|body)/i.test(f[0].tagName);return{top:c.top+this.offset.relative.top*d+this.offset.parent.top*d-(a.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():g?0:f.scrollTop())*d),left:c.left+this.offset.relative.left*d+this.offset.parent.left*d-(a.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():g?0:f.scrollLeft())*d)}},_generatePosition:function(b){var c=this.options,d=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(d[0].tagName);this.cssPosition=="relative"&&(this.scrollParent[0]==document||this.scrollParent[0]==this.offsetParent[0])&&(this.offset.relative=this._getRelativeOffset());var f=b.pageX,g=b.pageY;if(this.originalPosition){this.containment&&(b.pageX-this.offset.click.left<this.containment[0]&&(f=this.containment[0]+this.offset.click.left),b.pageY-this.offset.click.top<this.containment[1]&&(g=this.containment[1]+this.offset.click.top),b.pageX-this.offset.click.left>this.containment[2]&&(f=this.containment[2]+this.offset.click.left),b.pageY-this.offset.click.top>this.containment[3]&&(g=this.containment[3]+this.offset.click.top));if(c.grid){var h=this.originalPageY+Math.round((g-this.originalPageY)/c.grid[1])*c.grid[1];g=this.containment?h-this.offset.click.top<this.containment[1]||h-this.offset.click.top>this.containment[3]?h-this.offset.click.top<this.containment[1]?h+c.grid[1]:h-c.grid[1]:h:h;var i=this.originalPageX+Math.round((f-this.originalPageX)/c.grid[0])*c.grid[0];f=this.containment?i-this.offset.click.left<this.containment[0]||i-this.offset.click.left>this.containment[2]?i-this.offset.click.left<this.containment[0]?i+c.grid[0]:i-c.grid[0]:i:i}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(a.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:d.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(a.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:d.scrollLeft())}},_rearrange:function(a,b,c,d){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],this.direction=="down"?b.item[0]:b.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var e=this,f=this.counter;window.setTimeout(function(){f==e.counter&&e.refreshPositions(!d)},0)},_clear:function(b,c){this.reverting=!1;var d=[],e=this;!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var f in this._storedCSS)if(this._storedCSS[f]=="auto"||this._storedCSS[f]=="static")this._storedCSS[f]="";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!c&&d.push(function(a){this._trigger("receive",a,this._uiHash(this.fromOutside))}),(this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!c&&d.push(function(a){this._trigger("update",a,this._uiHash())});if(!a.ui.contains(this.element[0],this.currentItem[0])){c||d.push(function(a){this._trigger("remove",a,this._uiHash())});for(var f=this.containers.length-1;f>=0;f--)a.ui.contains(this.containers[f].element[0],this.currentItem[0])&&!c&&(d.push(function(a){return function(b){a._trigger("receive",b,this._uiHash(this))}}.call(this,this.containers[f])),d.push(function(a){return function(b){a._trigger("update",b,this._uiHash(this))}}.call(this,this.containers[f])))}for(var f=this.containers.length-1;f>=0;f--)c||d.push(function(a){return function(b){a._trigger("deactivate",b,this._uiHash(this))}}.call(this,this.containers[f])),this.containers[f].containerCache.over&&(d.push(function(a){return function(b){a._trigger("out",b,this._uiHash(this))}}.call(this,this.containers[f])),this.containers[f].containerCache.over=0);this._storedCursor&&a("body").css("cursor",this._storedCursor),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex),this.dragging=!1;if(this.cancelHelperRemoval){if(!c){this._trigger("beforeStop",b,this._uiHash());for(var f=0;f<d.length;f++)d[f].call(this,b);this._trigger("stop",b,this._uiHash())}return!1}c||this._trigger("beforeStop",b,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!=this.currentItem[0]&&this.helper.remove(),this.helper=null;if(!c){for(var f=0;f<d.length;f++)d[f].call(this,b);this._trigger("stop",b,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){a.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(b){var c=b||this;return{helper:c.helper,placeholder:c.placeholder||a([]),position:c.position,originalPosition:c.originalPosition,offset:c.positionAbs,item:c.currentItem,sender:b?b.element:null}}}),a.extend(a.ui.sortable,{version:"1.8.21"})})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.droppable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.droppable",{widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect"},_create:function(){var b=this.options,c=b.accept;this.isover=0,this.isout=1,this.accept=a.isFunction(c)?c:function(a){return a.is(c)},this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight},a.ui.ddmanager.droppables[b.scope]=a.ui.ddmanager.droppables[b.scope]||[],a.ui.ddmanager.droppables[b.scope].push(this),b.addClasses&&this.element.addClass("ui-droppable")},destroy:function(){var b=a.ui.ddmanager.droppables[this.options.scope];for(var c=0;c<b.length;c++)b[c]==this&&b.splice(c,1);return this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable"),this},_setOption:function(b,c){b=="accept"&&(this.accept=a.isFunction(c)?c:function(a){return a.is(c)}),a.Widget.prototype._setOption.apply(this,arguments)},_activate:function(b){var c=a.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),c&&this._trigger("activate",b,this.ui(c))},_deactivate:function(b){var c=a.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),c&&this._trigger("deactivate",b,this.ui(c))},_over:function(b){var c=a.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return;this.accept.call(this.element[0],c.currentItem||c.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",b,this.ui(c)))},_out:function(b){var c=a.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return;this.accept.call(this.element[0],c.currentItem||c.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",b,this.ui(c)))},_drop:function(b,c){var d=c||a.ui.ddmanager.current;if(!d||(d.currentItem||d.element)[0]==this.element[0])return!1;var e=!1;return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var b=a.data(this,"droppable");if(b.options.greedy&&!b.options.disabled&&b.options.scope==d.options.scope&&b.accept.call(b.element[0],d.currentItem||d.element)&&a.ui.intersect(d,a.extend(b,{offset:b.element.offset()}),b.options.tolerance))return e=!0,!1}),e?!1:this.accept.call(this.element[0],d.currentItem||d.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",b,this.ui(d)),this.element):!1},ui:function(a){return{draggable:a.currentItem||a.element,helper:a.helper,position:a.position,offset:a.positionAbs}}}),a.extend(a.ui.droppable,{version:"1.8.21"}),a.ui.intersect=function(b,c,d){if(!c.offset)return!1;var e=(b.positionAbs||b.position.absolute).left,f=e+b.helperProportions.width,g=(b.positionAbs||b.position.absolute).top,h=g+b.helperProportions.height,i=c.offset.left,j=i+c.proportions.width,k=c.offset.top,l=k+c.proportions.height;switch(d){case"fit":return i<=e&&f<=j&&k<=g&&h<=l;case"intersect":return i<e+b.helperProportions.width/2&&f-b.helperProportions.width/2<j&&k<g+b.helperProportions.height/2&&h-b.helperProportions.height/2<l;case"pointer":var m=(b.positionAbs||b.position.absolute).left+(b.clickOffset||b.offset.click).left,n=(b.positionAbs||b.position.absolute).top+(b.clickOffset||b.offset.click).top,o=a.ui.isOver(n,m,k,i,c.proportions.height,c.proportions.width);return o;case"touch":return(g>=k&&g<=l||h>=k&&h<=l||g<k&&h>l)&&(e>=i&&e<=j||f>=i&&f<=j||e<i&&f>j);default:return!1}},a.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(b,c){var d=a.ui.ddmanager.droppables[b.options.scope]||[],e=c?c.type:null,f=(b.currentItem||b.element).find(":data(droppable)").andSelf();g:for(var h=0;h<d.length;h++){if(d[h].options.disabled||b&&!d[h].accept.call(d[h].element[0],b.currentItem||b.element))continue;for(var i=0;i<f.length;i++)if(f[i]==d[h].element[0]){d[h].proportions.height=0;continue g}d[h].visible=d[h].element.css("display")!="none";if(!d[h].visible)continue;e=="mousedown"&&d[h]._activate.call(d[h],c),d[h].offset=d[h].element.offset(),d[h].proportions={width:d[h].element[0].offsetWidth,height:d[h].element[0].offsetHeight}}},drop:function(b,c){var d=!1;return a.each(a.ui.ddmanager.droppables[b.options.scope]||[],function(){if(!this.options)return;!this.options.disabled&&this.visible&&a.ui.intersect(b,this,this.options.tolerance)&&(d=this._drop.call(this,c)||d),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],b.currentItem||b.element)&&(this.isout=1,this.isover=0,this._deactivate.call(this,c))}),d},dragStart:function(b,c){b.element.parents(":not(body,html)").bind("scroll.droppable",function(){b.options.refreshPositions||a.ui.ddmanager.prepareOffsets(b,c)})},drag:function(b,c){b.options.refreshPositions&&a.ui.ddmanager.prepareOffsets(b,c),a.each(a.ui.ddmanager.droppables[b.options.scope]||[],function(){if(this.options.disabled||this.greedyChild||!this.visible)return;var d=a.ui.intersect(b,this,this.options.tolerance),e=!d&&this.isover==1?"isout":d&&this.isover==0?"isover":null;if(!e)return;var f;if(this.options.greedy){var g=this.element.parents(":data(droppable):eq(0)");g.length&&(f=a.data(g[0],"droppable"),f.greedyChild=e=="isover"?1:0)}f&&e=="isover"&&(f.isover=0,f.isout=1,f._out.call(f,c)),this[e]=1,this[e=="isout"?"isover":"isout"]=0,this[e=="isover"?"_over":"_out"].call(this,c),f&&e=="isout"&&(f.isout=0,f.isover=1,f._over.call(f,c))})},dragStop:function(b,c){b.element.parents(":not(body,html)").unbind("scroll.droppable"),b.options.refreshPositions||a.ui.ddmanager.prepareOffsets(b,c)}}})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.resizable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.resizable",a.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1e3},_create:function(){var b=this,c=this.options;this.element.addClass("ui-resizable"),a.extend(this,{_aspectRatio:!!c.aspectRatio,aspectRatio:c.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:c.helper||c.ghost||c.animate?c.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(a('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("resizable",this.element.data("resizable")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=c.handles||(a(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se");if(this.handles.constructor==String){this.handles=="all"&&(this.handles="n,e,s,w,se,sw,ne,nw");var d=this.handles.split(",");this.handles={};for(var e=0;e<d.length;e++){var f=a.trim(d[e]),g="ui-resizable-"+f,h=a('<div class="ui-resizable-handle '+g+'"></div>');h.css({zIndex:c.zIndex}),"se"==f&&h.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[f]=".ui-resizable-"+f,this.element.append(h)}}this._renderAxis=function(b){b=b||this.element;for(var c in this.handles){this.handles[c].constructor==String&&(this.handles[c]=a(this.handles[c],this.element).show());if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var d=a(this.handles[c],this.element),e=0;e=/sw|ne|nw|se|n|s/.test(c)?d.outerHeight():d.outerWidth();var f=["padding",/ne|nw|n/.test(c)?"Top":/se|sw|s/.test(c)?"Bottom":/^e$/.test(c)?"Right":"Left"].join("");b.css(f,e),this._proportionallyResize()}if(!a(this.handles[c]).length)continue}},this._renderAxis(this.element),this._handles=a(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){if(!b.resizing){if(this.className)var a=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=a&&a[1]?a[1]:"se"}}),c.autoHide&&(this._handles.hide(),a(this.element).addClass("ui-resizable-autohide").hover(function(){if(c.disabled)return;a(this).removeClass("ui-resizable-autohide"),b._handles.show()},function(){if(c.disabled)return;b.resizing||(a(this).addClass("ui-resizable-autohide"),b._handles.hide())})),this._mouseInit()},destroy:function(){this._mouseDestroy();var b=function(b){a(b).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){b(this.element);var c=this.element;c.after(this.originalElement.css({position:c.css("position"),width:c.outerWidth(),height:c.outerHeight(),top:c.css("top"),left:c.css("left")})).remove()}return this.originalElement.css("resize",this.originalResizeStyle),b(this.originalElement),this},_mouseCapture:function(b){var c=!1;for(var d in this.handles)a(this.handles[d])[0]==b.target&&(c=!0);return!this.options.disabled&&c},_mouseStart:function(b){var d=this.options,e=this.element.position(),f=this.element;this.resizing=!0,this.documentScroll={top:a(document).scrollTop(),left:a(document).scrollLeft()},(f.is(".ui-draggable")||/absolute/.test(f.css("position")))&&f.css({position:"absolute",top:e.top,left:e.left}),this._renderProxy();var g=c(this.helper.css("left")),h=c(this.helper.css("top"));d.containment&&(g+=a(d.containment).scrollLeft()||0,h+=a(d.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:g,top:h},this.size=this._helper?{width:f.outerWidth(),height:f.outerHeight()}:{width:f.width(),height:f.height()},this.originalSize=this._helper?{width:f.outerWidth(),height:f.outerHeight()}:{width:f.width(),height:f.height()},this.originalPosition={left:g,top:h},this.sizeDiff={width:f.outerWidth()-f.width(),height:f.outerHeight()-f.height()},this.originalMousePosition={left:b.pageX,top:b.pageY},this.aspectRatio=typeof d.aspectRatio=="number"?d.aspectRatio:this.originalSize.width/this.originalSize.height||1;var i=a(".ui-resizable-"+this.axis).css("cursor");return a("body").css("cursor",i=="auto"?this.axis+"-resize":i),f.addClass("ui-resizable-resizing"),this._propagate("start",b),!0},_mouseDrag:function(b){var c=this.helper,d=this.options,e={},f=this,g=this.originalMousePosition,h=this.axis,i=b.pageX-g.left||0,j=b.pageY-g.top||0,k=this._change[h];if(!k)return!1;var l=k.apply(this,[b,i,j]),m=a.browser.msie&&a.browser.version<7,n=this.sizeDiff;this._updateVirtualBoundaries(b.shiftKey);if(this._aspectRatio||b.shiftKey)l=this._updateRatio(l,b);return l=this._respectSize(l,b),this._propagate("resize",b),c.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"}),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),this._updateCache(l),this._trigger("resize",b,this.ui()),!1},_mouseStop:function(b){this.resizing=!1;var c=this.options,d=this;if(this._helper){var e=this._proportionallyResizeElements,f=e.length&&/textarea/i.test(e[0].nodeName),g=f&&a.ui.hasScroll(e[0],"left")?0:d.sizeDiff.height,h=f?0:d.sizeDiff.width,i={width:d.helper.width()-h,height:d.helper.height()-g},j=parseInt(d.element.css("left"),10)+(d.position.left-d.originalPosition.left)||null,k=parseInt(d.element.css("top"),10)+(d.position.top-d.originalPosition.top)||null;c.animate||this.element.css(a.extend(i,{top:k,left:j})),d.helper.height(d.size.height),d.helper.width(d.size.width),this._helper&&!c.animate&&this._proportionallyResize()}return a("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",b),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(a){var b=this.options,c,e,f,g,h;h={minWidth:d(b.minWidth)?b.minWidth:0,maxWidth:d(b.maxWidth)?b.maxWidth:Infinity,minHeight:d(b.minHeight)?b.minHeight:0,maxHeight:d(b.maxHeight)?b.maxHeight:Infinity};if(this._aspectRatio||a)c=h.minHeight*this.aspectRatio,f=h.minWidth/this.aspectRatio,e=h.maxHeight*this.aspectRatio,g=h.maxWidth/this.aspectRatio,c>h.minWidth&&(h.minWidth=c),f>h.minHeight&&(h.minHeight=f),e<h.maxWidth&&(h.maxWidth=e),g<h.maxHeight&&(h.maxHeight=g);this._vBoundaries=h},_updateCache:function(a){var b=this.options;this.offset=this.helper.offset(),d(a.left)&&(this.position.left=a.left),d(a.top)&&(this.position.top=a.top),d(a.height)&&(this.size.height=a.height),d(a.width)&&(this.size.width=a.width)},_updateRatio:function(a,b){var c=this.options,e=this.position,f=this.size,g=this.axis;return d(a.height)?a.width=a.height*this.aspectRatio:d(a.width)&&(a.height=a.width/this.aspectRatio),g=="sw"&&(a.left=e.left+(f.width-a.width),a.top=null),g=="nw"&&(a.top=e.top+(f.height-a.height),a.left=e.left+(f.width-a.width)),a},_respectSize:function(a,b){var c=this.helper,e=this._vBoundaries,f=this._aspectRatio||b.shiftKey,g=this.axis,h=d(a.width)&&e.maxWidth&&e.maxWidth<a.width,i=d(a.height)&&e.maxHeight&&e.maxHeight<a.height,j=d(a.width)&&e.minWidth&&e.minWidth>a.width,k=d(a.height)&&e.minHeight&&e.minHeight>a.height;j&&(a.width=e.minWidth),k&&(a.height=e.minHeight),h&&(a.width=e.maxWidth),i&&(a.height=e.maxHeight);var l=this.originalPosition.left+this.originalSize.width,m=this.position.top+this.size.height,n=/sw|nw|w/.test(g),o=/nw|ne|n/.test(g);j&&n&&(a.left=l-e.minWidth),h&&n&&(a.left=l-e.maxWidth),k&&o&&(a.top=m-e.minHeight),i&&o&&(a.top=m-e.maxHeight);var p=!a.width&&!a.height;return p&&!a.left&&a.top?a.top=null:p&&!a.top&&a.left&&(a.left=null),a},_proportionallyResize:function(){var b=this.options;if(!this._proportionallyResizeElements.length)return;var c=this.helper||this.element;for(var d=0;d<this._proportionallyResizeElements.length;d++){var e=this._proportionallyResizeElements[d];if(!this.borderDif){var f=[e.css("borderTopWidth"),e.css("borderRightWidth"),e.css("borderBottomWidth"),e.css("borderLeftWidth")],g=[e.css("paddingTop"),e.css("paddingRight"),e.css("paddingBottom"),e.css("paddingLeft")];this.borderDif=a.map(f,function(a,b){var c=parseInt(a,10)||0,d=parseInt(g[b],10)||0;return c+d})}if(!a.browser.msie||!a(c).is(":hidden")&&!a(c).parents(":hidden").length)e.css({height:c.height()-this.borderDif[0]-this.borderDif[2]||0,width:c.width()-this.borderDif[1]-this.borderDif[3]||0});else continue}},_renderProxy:function(){var b=this.element,c=this.options;this.elementOffset=b.offset();if(this._helper){this.helper=this.helper||a('<div style="overflow:hidden;"></div>');var d=a.browser.msie&&a.browser.version<7,e=d?1:0,f=d?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+f,height:this.element.outerHeight()+f,position:"absolute",left:this.elementOffset.left-e+"px",top:this.elementOffset.top-e+"px",zIndex:++c.zIndex}),this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(a,b,c){return{width:this.originalSize.width+b}},w:function(a,b,c){var d=this.options,e=this.originalSize,f=this.originalPosition;return{left:f.left+b,width:e.width-b}},n:function(a,b,c){var d=this.options,e=this.originalSize,f=this.originalPosition;return{top:f.top+c,height:e.height-c}},s:function(a,b,c){return{height:this.originalSize.height+c}},se:function(b,c,d){return a.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,c,d]))},sw:function(b,c,d){return a.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,c,d]))},ne:function(b,c,d){return a.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,c,d]))},nw:function(b,c,d){return a.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,c,d]))}},_propagate:function(b,c){a.ui.plugin.call(this,b,[c,this.ui()]),b!="resize"&&this._trigger(b,c,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),a.extend(a.ui.resizable,{version:"1.8.21"}),a.ui.plugin.add("resizable","alsoResize",{start:function(b,c){var d=a(this).data("resizable"),e=d.options,f=function(b){a(b).each(function(){var b=a(this);b.data("resizable-alsoresize",{width:parseInt(b.width(),10),height:parseInt(b.height(),10),left:parseInt(b.css("left"),10),top:parseInt(b.css("top"),10)})})};typeof e.alsoResize=="object"&&!e.alsoResize.parentNode?e.alsoResize.length?(e.alsoResize=e.alsoResize[0],f(e.alsoResize)):a.each(e.alsoResize,function(a){f(a)}):f(e.alsoResize)},resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.originalSize,g=d.originalPosition,h={height:d.size.height-f.height||0,width:d.size.width-f.width||0,top:d.position.top-g.top||0,left:d.position.left-g.left||0},i=function(b,d){a(b).each(function(){var b=a(this),e=a(this).data("resizable-alsoresize"),f={},g=d&&d.length?d:b.parents(c.originalElement[0]).length?["width","height"]:["width","height","top","left"];a.each(g,function(a,b){var c=(e[b]||0)+(h[b]||0);c&&c>=0&&(f[b]=c||null)}),b.css(f)})};typeof e.alsoResize=="object"&&!e.alsoResize.nodeType?a.each(e.alsoResize,function(a,b){i(a,b)}):i(e.alsoResize)},stop:function(b,c){a(this).removeData("resizable-alsoresize")}}),a.ui.plugin.add("resizable","animate",{stop:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d._proportionallyResizeElements,g=f.length&&/textarea/i.test(f[0].nodeName),h=g&&a.ui.hasScroll(f[0],"left")?0:d.sizeDiff.height,i=g?0:d.sizeDiff.width,j={width:d.size.width-i,height:d.size.height-h},k=parseInt(d.element.css("left"),10)+(d.position.left-d.originalPosition.left)||null,l=parseInt(d.element.css("top"),10)+(d.position.top-d.originalPosition.top)||null;d.element.animate(a.extend(j,l&&k?{top:l,left:k}:{}),{duration:e.animateDuration,easing:e.animateEasing,step:function(){var c={width:parseInt(d.element.css("width"),10),height:parseInt(d.element.css("height"),10),top:parseInt(d.element.css("top"),10),left:parseInt(d.element.css("left"),10)};f&&f.length&&a(f[0]).css({width:c.width,height:c.height}),d._updateCache(c),d._propagate("resize",b)}})}}),a.ui.plugin.add("resizable","containment",{start:function(b,d){var e=a(this).data("resizable"),f=e.options,g=e.element,h=f.containment,i=h instanceof a?h.get(0):/parent/.test(h)?g.parent().get(0):h;if(!i)return;e.containerElement=a(i);if(/document/.test(h)||h==document)e.containerOffset={left:0,top:0},e.containerPosition={left:0,top:0},e.parentData={element:a(document),left:0,top:0,width:a(document).width(),height:a(document).height()||document.body.parentNode.scrollHeight};else{var j=a(i),k=[];a(["Top","Right","Left","Bottom"]).each(function(a,b){k[a]=c(j.css("padding"+b))}),e.containerOffset=j.offset(),e.containerPosition=j.position(),e.containerSize={height:j.innerHeight()-k[3],width:j.innerWidth()-k[1]};var l=e.containerOffset,m=e.containerSize.height,n=e.containerSize.width,o=a.ui.hasScroll(i,"left")?i.scrollWidth:n,p=a.ui.hasScroll(i)?i.scrollHeight:m;e.parentData={element:i,left:l.left,top:l.top,width:o,height:p}}},resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.containerSize,g=d.containerOffset,h=d.size,i=d.position,j=d._aspectRatio||b.shiftKey,k={top:0,left:0},l=d.containerElement;l[0]!=document&&/static/.test(l.css("position"))&&(k=g),i.left<(d._helper?g.left:0)&&(d.size.width=d.size.width+(d._helper?d.position.left-g.left:d.position.left-k.left),j&&(d.size.height=d.size.width/d.aspectRatio),d.position.left=e.helper?g.left:0),i.top<(d._helper?g.top:0)&&(d.size.height=d.size.height+(d._helper?d.position.top-g.top:d.position.top),j&&(d.size.width=d.size.height*d.aspectRatio),d.position.top=d._helper?g.top:0),d.offset.left=d.parentData.left+d.position.left,d.offset.top=d.parentData.top+d.position.top;var m=Math.abs((d._helper?d.offset.left-k.left:d.offset.left-k.left)+d.sizeDiff.width),n=Math.abs((d._helper?d.offset.top-k.top:d.offset.top-g.top)+d.sizeDiff.height),o=d.containerElement.get(0)==d.element.parent().get(0),p=/relative|absolute/.test(d.containerElement.css("position"));o&&p&&(m-=d.parentData.left),m+d.size.width>=d.parentData.width&&(d.size.width=d.parentData.width-m,j&&(d.size.height=d.size.width/d.aspectRatio)),n+d.size.height>=d.parentData.height&&(d.size.height=d.parentData.height-n,j&&(d.size.width=d.size.height*d.aspectRatio))},stop:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.position,g=d.containerOffset,h=d.containerPosition,i=d.containerElement,j=a(d.helper),k=j.offset(),l=j.outerWidth()-d.sizeDiff.width,m=j.outerHeight()-d.sizeDiff.height;d._helper&&!e.animate&&/relative/.test(i.css("position"))&&a(this).css({left:k.left-h.left-g.left,width:l,height:m}),d._helper&&!e.animate&&/static/.test(i.css("position"))&&a(this).css({left:k.left-h.left-g.left,width:l,height:m})}}),a.ui.plugin.add("resizable","ghost",{start:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.size;d.ghost=d.originalElement.clone(),d.ghost.css({opacity:.25,display:"block",position:"relative",height:f.height,width:f.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof e.ghost=="string"?e.ghost:""),d.ghost.appendTo(d.helper)},resize:function(b,c){var d=a(this).data("resizable"),e=d.options;d.ghost&&d.ghost.css({position:"relative",height:d.size.height,width:d.size.width})},stop:function(b,c){var d=a(this).data("resizable"),e=d.options;d.ghost&&d.helper&&d.helper.get(0).removeChild(d.ghost.get(0))}}),a.ui.plugin.add("resizable","grid",{resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.size,g=d.originalSize,h=d.originalPosition,i=d.axis,j=e._aspectRatio||b.shiftKey;e.grid=typeof e.grid=="number"?[e.grid,e.grid]:e.grid;var k=Math.round((f.width-g.width)/(e.grid[0]||1))*(e.grid[0]||1),l=Math.round((f.height-g.height)/(e.grid[1]||1))*(e.grid[1]||1);/^(se|s|e)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l):/^(ne)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l,d.position.top=h.top-l):/^(sw)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l,d.position.left=h.left-k):(d.size.width=g.width+k,d.size.height=g.height+l,d.position.top=h.top-l,d.position.left=h.left-k)}});var c=function(a){return parseInt(a,10)||0},d=function(a){return!isNaN(parseInt(a,10))}})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.datepicker.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function($,undefined){function Datepicker(){this.debug=!1,this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},$.extend(this._defaults,this.regional[""]),this.dpDiv=bindHover($('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}function bindHover(a){var b="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return a.bind("mouseout",function(a){var c=$(a.target).closest(b);if(!c.length)return;c.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover")}).bind("mouseover",function(c){var d=$(c.target).closest(b);if($.datepicker._isDisabledDatepicker(instActive.inline?a.parent()[0]:instActive.input[0])||!d.length)return;d.parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),d.addClass("ui-state-hover"),d.hasClass("ui-datepicker-prev")&&d.addClass("ui-datepicker-prev-hover"),d.hasClass("ui-datepicker-next")&&d.addClass("ui-datepicker-next-hover")})}function extendRemove(a,b){$.extend(a,b);for(var c in b)if(b[c]==null||b[c]==undefined)a[c]=b[c];return a}function isArray(a){return a&&($.browser.safari&&typeof a=="object"&&a.length||a.constructor&&a.constructor.toString().match(/\Array\(\)/))}$.extend($.ui,{datepicker:{version:"1.8.21"}});var PROP_NAME="datepicker",dpuuid=(new Date).getTime(),instActive;$.extend(Datepicker.prototype,{markerClassName:"hasDatepicker",maxRows:4,log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(a){return extendRemove(this._defaults,a||{}),this},_attachDatepicker:function(target,settings){var inlineSettings=null;for(var attrName in this._defaults){var attrValue=target.getAttribute("date:"+attrName);if(attrValue){inlineSettings=inlineSettings||{};try{inlineSettings[attrName]=eval(attrValue)}catch(err){inlineSettings[attrName]=attrValue}}}var nodeName=target.nodeName.toLowerCase(),inline=nodeName=="div"||nodeName=="span";target.id||(this.uuid+=1,target.id="dp"+this.uuid);var inst=this._newInst($(target),inline);inst.settings=$.extend({},settings||{},inlineSettings||{}),nodeName=="input"?this._connectDatepicker(target,inst):inline&&this._inlineDatepicker(target,inst)},_newInst:function(a,b){var c=a[0].id.replace(/([^A-Za-z0-9_-])/g,"\\\\$1");return{id:c,input:a,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:b,dpDiv:b?bindHover($('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')):this.dpDiv}},_connectDatepicker:function(a,b){var c=$(a);b.append=$([]),b.trigger=$([]);if(c.hasClass(this.markerClassName))return;this._attachments(c,b),c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",function(a,c,d){b.settings[c]=d}).bind("getData.datepicker",function(a,c){return this._get(b,c)}),this._autoSize(b),$.data(a,PROP_NAME,b),b.settings.disabled&&this._disableDatepicker(a)},_attachments:function(a,b){var c=this._get(b,"appendText"),d=this._get(b,"isRTL");b.append&&b.append.remove(),c&&(b.append=$('<span class="'+this._appendClass+'">'+c+"</span>"),a[d?"before":"after"](b.append)),a.unbind("focus",this._showDatepicker),b.trigger&&b.trigger.remove();var e=this._get(b,"showOn");(e=="focus"||e=="both")&&a.focus(this._showDatepicker);if(e=="button"||e=="both"){var f=this._get(b,"buttonText"),g=this._get(b,"buttonImage");b.trigger=$(this._get(b,"buttonImageOnly")?$("<img/>").addClass(this._triggerClass).attr({src:g,alt:f,title:f}):$('<button type="button"></button>').addClass(this._triggerClass).html(g==""?f:$("<img/>").attr({src:g,alt:f,title:f}))),a[d?"before":"after"](b.trigger),b.trigger.click(function(){return $.datepicker._datepickerShowing&&$.datepicker._lastInput==a[0]?$.datepicker._hideDatepicker():$.datepicker._datepickerShowing&&$.datepicker._lastInput!=a[0]?($.datepicker._hideDatepicker(),$.datepicker._showDatepicker(a[0])):$.datepicker._showDatepicker(a[0]),!1})}},_autoSize:function(a){if(this._get(a,"autoSize")&&!a.inline){var b=new Date(2009,11,20),c=this._get(a,"dateFormat");if(c.match(/[DM]/)){var d=function(a){var b=0,c=0;for(var d=0;d<a.length;d++)a[d].length>b&&(b=a[d].length,c=d);return c};b.setMonth(d(this._get(a,c.match(/MM/)?"monthNames":"monthNamesShort"))),b.setDate(d(this._get(a,c.match(/DD/)?"dayNames":"dayNamesShort"))+20-b.getDay())}a.input.attr("size",this._formatDate(a,b).length)}},_inlineDatepicker:function(a,b){var c=$(a);if(c.hasClass(this.markerClassName))return;c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker",function(a,c,d){b.settings[c]=d}).bind("getData.datepicker",function(a,c){return this._get(b,c)}),$.data(a,PROP_NAME,b),this._setDate(b,this._getDefaultDate(b),!0),this._updateDatepicker(b),this._updateAlternate(b),b.settings.disabled&&this._disableDatepicker(a),b.dpDiv.css("display","block")},_dialogDatepicker:function(a,b,c,d,e){var f=this._dialogInst;if(!f){this.uuid+=1;var g="dp"+this.uuid;this._dialogInput=$('<input type="text" id="'+g+'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>'),this._dialogInput.keydown(this._doKeyDown),$("body").append(this._dialogInput),f=this._dialogInst=this._newInst(this._dialogInput,!1),f.settings={},$.data(this._dialogInput[0],PROP_NAME,f)}extendRemove(f.settings,d||{}),b=b&&b.constructor==Date?this._formatDate(f,b):b,this._dialogInput.val(b),this._pos=e?e.length?e:[e.pageX,e.pageY]:null;if(!this._pos){var h=document.documentElement.clientWidth,i=document.documentElement.clientHeight,j=document.documentElement.scrollLeft||document.body.scrollLeft,k=document.documentElement.scrollTop||document.body.scrollTop;this._pos=[h/2-100+j,i/2-150+k]}return this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),f.settings.onSelect=c,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),$.blockUI&&$.blockUI(this.dpDiv),$.data(this._dialogInput[0],PROP_NAME,f),this},_destroyDatepicker:function(a){var b=$(a),c=$.data(a,PROP_NAME);if(!b.hasClass(this.markerClassName))return;var d=a.nodeName.toLowerCase();$.removeData(a,PROP_NAME),d=="input"?(c.append.remove(),c.trigger.remove(),b.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):(d=="div"||d=="span")&&b.removeClass(this.markerClassName).empty()},_enableDatepicker:function(a){var b=$(a),c=$.data(a,PROP_NAME);if(!b.hasClass(this.markerClassName))return;var d=a.nodeName.toLowerCase();if(d=="input")a.disabled=!1,c.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""});else if(d=="div"||d=="span"){var e=b.children("."+this._inlineClass);e.children().removeClass("ui-state-disabled"),e.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled")}this._disabledInputs=$.map(this._disabledInputs,function(b){return b==a?null:b})},_disableDatepicker:function(a){var b=$(a),c=$.data(a,PROP_NAME);if(!b.hasClass(this.markerClassName))return;var d=a.nodeName.toLowerCase();if(d=="input")a.disabled=!0,c.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"});else if(d=="div"||d=="span"){var e=b.children("."+this._inlineClass);e.children().addClass("ui-state-disabled"),e.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled","disabled")}this._disabledInputs=$.map(this._disabledInputs,function(b){return b==a?null:b}),this._disabledInputs[this._disabledInputs.length]=a},_isDisabledDatepicker:function(a){if(!a)return!1;for(var b=0;b<this._disabledInputs.length;b++)if(this._disabledInputs[b]==a)return!0;return!1},_getInst:function(a){try{return $.data(a,PROP_NAME)}catch(b){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(a,b,c){var d=this._getInst(a);if(arguments.length==2&&typeof b=="string")return b=="defaults"?$.extend({},$.datepicker._defaults):d?b=="all"?$.extend({},d.settings):this._get(d,b):null;var e=b||{};typeof b=="string"&&(e={},e[b]=c);if(d){this._curInst==d&&this._hideDatepicker();var f=this._getDateDatepicker(a,!0),g=this._getMinMaxDate(d,"min"),h=this._getMinMaxDate(d,"max");extendRemove(d.settings,e),g!==null&&e.dateFormat!==undefined&&e.minDate===undefined&&(d.settings.minDate=this._formatDate(d,g)),h!==null&&e.dateFormat!==undefined&&e.maxDate===undefined&&(d.settings.maxDate=this._formatDate(d,h)),this._attachments($(a),d),this._autoSize(d),this._setDate(d,f),this._updateAlternate(d),this._updateDatepicker(d)}},_changeDatepicker:function(a,b,c){this._optionDatepicker(a,b,c)},_refreshDatepicker:function(a){var b=this._getInst(a);b&&this._updateDatepicker(b)},_setDateDatepicker:function(a,b){var c=this._getInst(a);c&&(this._setDate(c,b),this._updateDatepicker(c),this._updateAlternate(c))},_getDateDatepicker:function(a,b){var c=this._getInst(a);return c&&!c.inline&&this._setDateFromField(c,b),c?this._getDate(c):null},_doKeyDown:function(a){var b=$.datepicker._getInst(a.target),c=!0,d=b.dpDiv.is(".ui-datepicker-rtl");b._keyEvent=!0;if($.datepicker._datepickerShowing)switch(a.keyCode){case 9:$.datepicker._hideDatepicker(),c=!1;break;case 13:var e=$("td."+$.datepicker._dayOverClass+":not(."+$.datepicker._currentClass+")",b.dpDiv);e[0]&&$.datepicker._selectDay(a.target,b.selectedMonth,b.selectedYear,e[0]);var f=$.datepicker._get(b,"onSelect");if(f){var g=$.datepicker._formatDate(b);f.apply(b.input?b.input[0]:null,[g,b])}else $.datepicker._hideDatepicker();return!1;case 27:$.datepicker._hideDatepicker();break;case 33:$.datepicker._adjustDate(a.target,a.ctrlKey?-$.datepicker._get(b,"stepBigMonths"):-$.datepicker._get(b,"stepMonths"),"M");break;case 34:$.datepicker._adjustDate(a.target,a.ctrlKey?+$.datepicker._get(b,"stepBigMonths"):+$.datepicker._get(b,"stepMonths"),"M");break;case 35:(a.ctrlKey||a.metaKey)&&$.datepicker._clearDate(a.target),c=a.ctrlKey||a.metaKey;break;case 36:(a.ctrlKey||a.metaKey)&&$.datepicker._gotoToday(a.target),c=a.ctrlKey||a.metaKey;break;case 37:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,d?1:-1,"D"),c=a.ctrlKey||a.metaKey,a.originalEvent.altKey&&$.datepicker._adjustDate(a.target,a.ctrlKey?-$.datepicker._get(b,"stepBigMonths"):-$.datepicker._get(b,"stepMonths"),"M");break;case 38:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,-7,"D"),c=a.ctrlKey||a.metaKey;break;case 39:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,d?-1:1,"D"),c=a.ctrlKey||a.metaKey,a.originalEvent.altKey&&$.datepicker._adjustDate(a.target,a.ctrlKey?+$.datepicker._get(b,"stepBigMonths"):+$.datepicker._get(b,"stepMonths"),"M");break;case 40:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,7,"D"),c=a.ctrlKey||a.metaKey;break;default:c=!1}else a.keyCode==36&&a.ctrlKey?$.datepicker._showDatepicker(this):c=!1;c&&(a.preventDefault(),a.stopPropagation())},_doKeyPress:function(a){var b=$.datepicker._getInst(a.target);if($.datepicker._get(b,"constrainInput")){var c=$.datepicker._possibleChars($.datepicker._get(b,"dateFormat")),d=String.fromCharCode(a.charCode==undefined?a.keyCode:a.charCode);return a.ctrlKey||a.metaKey||d<" "||!c||c.indexOf(d)>-1}},_doKeyUp:function(a){var b=$.datepicker._getInst(a.target);if(b.input.val()!=b.lastVal)try{var c=$.datepicker.parseDate($.datepicker._get(b,"dateFormat"),b.input?b.input.val():null,$.datepicker._getFormatConfig(b));c&&($.datepicker._setDateFromField(b),$.datepicker._updateAlternate(b),$.datepicker._updateDatepicker(b))}catch(d){$.datepicker.log(d)}return!0},_showDatepicker:function(a){a=a.target||a,a.nodeName.toLowerCase()!="input"&&(a=$("input",a.parentNode)[0]);if($.datepicker._isDisabledDatepicker(a)||$.datepicker._lastInput==a)return;var b=$.datepicker._getInst(a);$.datepicker._curInst&&$.datepicker._curInst!=b&&($.datepicker._curInst.dpDiv.stop(!0,!0),b&&$.datepicker._datepickerShowing&&$.datepicker._hideDatepicker($.datepicker._curInst.input[0]));var c=$.datepicker._get(b,"beforeShow"),d=c?c.apply(a,[a,b]):{};if(d===!1)return;extendRemove(b.settings,d),b.lastVal=null,$.datepicker._lastInput=a,$.datepicker._setDateFromField(b),$.datepicker._inDialog&&(a.value=""),$.datepicker._pos||($.datepicker._pos=$.datepicker._findPos(a),$.datepicker._pos[1]+=a.offsetHeight);var e=!1;$(a).parents().each(function(){return e|=$(this).css("position")=="fixed",!e}),e&&$.browser.opera&&($.datepicker._pos[0]-=document.documentElement.scrollLeft,$.datepicker._pos[1]-=document.documentElement.scrollTop);var f={left:$.datepicker._pos[0],top:$.datepicker._pos[1]};$.datepicker._pos=null,b.dpDiv.empty(),b.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),$.datepicker._updateDatepicker(b),f=$.datepicker._checkOffset(b,f,e),b.dpDiv.css({position:$.datepicker._inDialog&&$.blockUI?"static":e?"fixed":"absolute",display:"none",left:f.left+"px",top:f.top+"px"});if(!b.inline){var g=$.datepicker._get(b,"showAnim"),h=$.datepicker._get(b,"duration"),i=function(){var a=b.dpDiv.find("iframe.ui-datepicker-cover");if(!!a.length){var c=$.datepicker._getBorders(b.dpDiv);a.css({left:-c[0],top:-c[1],width:b.dpDiv.outerWidth(),height:b.dpDiv.outerHeight()})}};b.dpDiv.zIndex($(a).zIndex()+1),$.datepicker._datepickerShowing=!0,$.effects&&$.effects[g]?b.dpDiv.show(g,$.datepicker._get(b,"showOptions"),h,i):b.dpDiv[g||"show"](g?h:null,i),(!g||!h)&&i(),b.input.is(":visible")&&!b.input.is(":disabled")&&b.input.focus(),$.datepicker._curInst=b}},_updateDatepicker:function(a){var b=this;b.maxRows=4;var c=$.datepicker._getBorders(a.dpDiv);instActive=a,a.dpDiv.empty().append(this._generateHTML(a));var d=a.dpDiv.find("iframe.ui-datepicker-cover");!d.length||d.css({left:-c[0],top:-c[1],width:a.dpDiv.outerWidth(),height:a.dpDiv.outerHeight()}),a.dpDiv.find("."+this._dayOverClass+" a").mouseover();var e=this._getNumberOfMonths(a),f=e[1],g=17;a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),f>1&&a.dpDiv.addClass("ui-datepicker-multi-"+f).css("width",g*f+"em"),a.dpDiv[(e[0]!=1||e[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi"),a.dpDiv[(this._get(a,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),a==$.datepicker._curInst&&$.datepicker._datepickerShowing&&a.input&&a.input.is(":visible")&&!a.input.is(":disabled")&&a.input[0]!=document.activeElement&&a.input.focus();if(a.yearshtml){var h=a.yearshtml;setTimeout(function(){h===a.yearshtml&&a.yearshtml&&a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml),h=a.yearshtml=null},0)}},_getBorders:function(a){var b=function(a){return{thin:1,medium:2,thick:3}[a]||a};return[parseFloat(b(a.css("border-left-width"))),parseFloat(b(a.css("border-top-width")))]},_checkOffset:function(a,b,c){var d=a.dpDiv.outerWidth(),e=a.dpDiv.outerHeight(),f=a.input?a.input.outerWidth():0,g=a.input?a.input.outerHeight():0,h=document.documentElement.clientWidth+$(document).scrollLeft(),i=document.documentElement.clientHeight+$(document).scrollTop();return b.left-=this._get(a,"isRTL")?d-f:0,b.left-=c&&b.left==a.input.offset().left?$(document).scrollLeft():0,b.top-=c&&b.top==a.input.offset().top+g?$(document).scrollTop():0,b.left-=Math.min(b.left,b.left+d>h&&h>d?Math.abs(b.left+d-h):0),b.top-=Math.min(b.top,b.top+e>i&&i>e?Math.abs(e+g):0),b},_findPos:function(a){var b=this._getInst(a),c=this._get(b,"isRTL");while(a&&(a.type=="hidden"||a.nodeType!=1||$.expr.filters.hidden(a)))a=a[c?"previousSibling":"nextSibling"];var d=$(a).offset();return[d.left,d.top]},_hideDatepicker:function(a){var b=this._curInst;if(!b||a&&b!=$.data(a,PROP_NAME))return;if(this._datepickerShowing){var c=this._get(b,"showAnim"),d=this._get(b,"duration"),e=function(){$.datepicker._tidyDialog(b)};$.effects&&$.effects[c]?b.dpDiv.hide(c,$.datepicker._get(b,"showOptions"),d,e):b.dpDiv[c=="slideDown"?"slideUp":c=="fadeIn"?"fadeOut":"hide"](c?d:null,e),c||e(),this._datepickerShowing=!1;var f=this._get(b,"onClose");f&&f.apply(b.input?b.input[0]:null,[b.input?b.input.val():"",b]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),$.blockUI&&($.unblockUI(),$("body").append(this.dpDiv))),this._inDialog=!1}},_tidyDialog:function(a){a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(a){if(!$.datepicker._curInst)return;var b=$(a.target),c=$.datepicker._getInst(b[0]);(b[0].id!=$.datepicker._mainDivId&&b.parents("#"+$.datepicker._mainDivId).length==0&&!b.hasClass($.datepicker.markerClassName)&&!b.closest("."+$.datepicker._triggerClass).length&&$.datepicker._datepickerShowing&&(!$.datepicker._inDialog||!$.blockUI)||b.hasClass($.datepicker.markerClassName)&&$.datepicker._curInst!=c)&&$.datepicker._hideDatepicker()},_adjustDate:function(a,b,c){var d=$(a),e=this._getInst(d[0]);if(this._isDisabledDatepicker(d[0]))return;this._adjustInstDate(e,b+(c=="M"?this._get(e,"showCurrentAtPos"):0),c),this._updateDatepicker(e)},_gotoToday:function(a){var b=$(a),c=this._getInst(b[0]);if(this._get(c,"gotoCurrent")&&c.currentDay)c.selectedDay=c.currentDay,c.drawMonth=c.selectedMonth=c.currentMonth,c.drawYear=c.selectedYear=c.currentYear;else{var d=new Date;c.selectedDay=d.getDate(),c.drawMonth=c.selectedMonth=d.getMonth(),c.drawYear=c.selectedYear=d.getFullYear()}this._notifyChange(c),this._adjustDate(b)},_selectMonthYear:function(a,b,c){var d=$(a),e=this._getInst(d[0]);e["selected"+(c=="M"?"Month":"Year")]=e["draw"+(c=="M"?"Month":"Year")]=parseInt(b.options[b.selectedIndex].value,10),this._notifyChange(e),this._adjustDate(d)},_selectDay:function(a,b,c,d){var e=$(a);if($(d).hasClass(this._unselectableClass)||this._isDisabledDatepicker(e[0]))return;var f=this._getInst(e[0]);f.selectedDay=f.currentDay=$("a",d).html(),f.selectedMonth=f.currentMonth=b,f.selectedYear=f.currentYear=c,this._selectDate(a,this._formatDate(f,f.currentDay,f.currentMonth,f.currentYear))},_clearDate:function(a){var b=$(a),c=this._getInst(b[0]);this._selectDate(b,"")},_selectDate:function(a,b){var c=$(a),d=this._getInst(c[0]);b=b!=null?b:this._formatDate(d),d.input&&d.input.val(b),this._updateAlternate(d);var e=this._get(d,"onSelect");e?e.apply(d.input?d.input[0]:null,[b,d]):d.input&&d.input.trigger("change"),d.inline?this._updateDatepicker(d):(this._hideDatepicker(),this._lastInput=d.input[0],typeof d.input[0]!="object"&&d.input.focus(),this._lastInput=null)},_updateAlternate:function(a){var b=this._get(a,"altField");if(b){var c=this._get(a,"altFormat")||this._get(a,"dateFormat"),d=this._getDate(a),e=this.formatDate(c,d,this._getFormatConfig(a));$(b).each(function(){$(this).val(e)})}},noWeekends:function(a){var b=a.getDay();return[b>0&&b<6,""]},iso8601Week:function(a){var b=new Date(a.getTime());b.setDate(b.getDate()+4-(b.getDay()||7));var c=b.getTime();return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1},parseDate:function(a,b,c){if(a==null||b==null)throw"Invalid arguments";b=typeof b=="object"?b.toString():b+"";if(b=="")return null;var d=(c?c.shortYearCutoff:null)||this._defaults.shortYearCutoff;d=typeof d!="string"?d:(new Date).getFullYear()%100+parseInt(d,10);var e=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,f=(c?c.dayNames:null)||this._defaults.dayNames,g=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,h=(c?c.monthNames:null)||this._defaults.monthNames,i=-1,j=-1,k=-1,l=-1,m=!1,n=function(b){var c=s+1<a.length&&a.charAt(s+1)==b;return c&&s++,c},o=function(a){var c=n(a),d=a=="@"?14:a=="!"?20:a=="y"&&c?4:a=="o"?3:2,e=new RegExp("^\\d{1,"+d+"}"),f=b.substring(r).match(e);if(!f)throw"Missing number at position "+r;return r+=f[0].length,parseInt(f[0],10)},p=function(a,c,d){var e=$.map(n(a)?d:c,function(a,b){return[[b,a]]}).sort(function(a,b){return-(a[1].length-b[1].length)}),f=-1;$.each(e,function(a,c){var d=c[1];if(b.substr(r,d.length).toLowerCase()==d.toLowerCase())return f=c[0],r+=d.length,!1});if(f!=-1)return f+1;throw"Unknown name at position "+r},q=function(){if(b.charAt(r)!=a.charAt(s))throw"Unexpected literal at position "+r;r++},r=0;for(var s=0;s<a.length;s++)if(m)a.charAt(s)=="'"&&!n("'")?m=!1:q();else switch(a.charAt(s)){case"d":k=o("d");break;case"D":p("D",e,f);break;case"o":l=o("o");break;case"m":j=o("m");break;case"M":j=p("M",g,h);break;case"y":i=o("y");break;case"@":var t=new Date(o("@"));i=t.getFullYear(),j=t.getMonth()+1,k=t.getDate();break;case"!":var t=new Date((o("!")-this._ticksTo1970)/1e4);i=t.getFullYear(),j=t.getMonth()+1,k=t.getDate();break;case"'":n("'")?q():m=!0;break;default:q()}if(r<b.length)throw"Extra/unparsed characters found in date: "+b.substring(r);i==-1?i=(new Date).getFullYear():i<100&&(i+=(new Date).getFullYear()-(new Date).getFullYear()%100+(i<=d?0:-100));if(l>-1){j=1,k=l;do{var u=this._getDaysInMonth(i,j-1);if(k<=u)break;j++,k-=u}while(!0)}var t=this._daylightSavingAdjust(new Date(i,j-1,k));if(t.getFullYear()!=i||t.getMonth()+1!=j||t.getDate()!=k)throw"Invalid date";return t},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1e7,formatDate:function(a,b,c){if(!b)return"";var d=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,e=(c?c.dayNames:null)||this._defaults.dayNames,f=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,g=(c?c.monthNames:null)||this._defaults.monthNames,h=function(b){var c=m+1<a.length&&a.charAt(m+1)==b;return c&&m++,c},i=function(a,b,c){var d=""+b;if(h(a))while(d.length<c)d="0"+d;return d},j=function(a,b,c,d){return h(a)?d[b]:c[b]},k="",l=!1;if(b)for(var m=0;m<a.length;m++)if(l)a.charAt(m)=="'"&&!h("'")?l=!1:k+=a.charAt(m);else switch(a.charAt(m)){case"d":k+=i("d",b.getDate(),2);break;case"D":k+=j("D",b.getDay(),d,e);break;case"o":k+=i("o",Math.round(((new Date(b.getFullYear(),b.getMonth(),b.getDate())).getTime()-(new Date(b.getFullYear(),0,0)).getTime())/864e5),3);break;case"m":k+=i("m",b.getMonth()+1,2);break;case"M":k+=j("M",b.getMonth(),f,g);break;case"y":k+=h("y")?b.getFullYear():(b.getYear()%100<10?"0":"")+b.getYear()%100;break;case"@":k+=b.getTime();break;case"!":k+=b.getTime()*1e4+this._ticksTo1970;break;case"'":h("'")?k+="'":l=!0;break;default:k+=a.charAt(m)}return k},_possibleChars:function(a){var b="",c=!1,d=function(b){var c=e+1<a.length&&a.charAt(e+1)==b;return c&&e++,c};for(var e=0;e<a.length;e++)if(c)a.charAt(e)=="'"&&!d("'")?c=!1:b+=a.charAt(e);else switch(a.charAt(e)){case"d":case"m":case"y":case"@":b+="0123456789";break;case"D":case"M":return null;case"'":d("'")?b+="'":c=!0;break;default:b+=a.charAt(e)}return b},_get:function(a,b){return a.settings[b]!==undefined?a.settings[b]:this._defaults[b]},_setDateFromField:function(a,b){if(a.input.val()==a.lastVal)return;var c=this._get(a,"dateFormat"),d=a.lastVal=a.input?a.input.val():null,e,f;e=f=this._getDefaultDate(a);var g=this._getFormatConfig(a);try{e=this.parseDate(c,d,g)||f}catch(h){this.log(h),d=b?"":d}a.selectedDay=e.getDate(),a.drawMonth=a.selectedMonth=e.getMonth(),a.drawYear=a.selectedYear=e.getFullYear(),a.currentDay=d?e.getDate():0,a.currentMonth=d?e.getMonth():0,a.currentYear=d?e.getFullYear():0,this._adjustInstDate(a)},_getDefaultDate:function(a){return this._restrictMinMax(a,this._determineDate(a,this._get(a,"defaultDate"),new Date))},_determineDate:function(a,b,c){var d=function(a){var b=new Date;return b.setDate(b.getDate()+a),b},e=function(b){try{return $.datepicker.parseDate($.datepicker._get(a,"dateFormat"),b,$.datepicker._getFormatConfig(a))}catch(c){}var d=(b.toLowerCase().match(/^c/)?$.datepicker._getDate(a):null)||new Date,e=d.getFullYear(),f=d.getMonth(),g=d.getDate(),h=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,i=h.exec(b);while(i){switch(i[2]||"d"){case"d":case"D":g+=parseInt(i[1],10);break;case"w":case"W":g+=parseInt(i[1],10)*7;break;case"m":case"M":f+=parseInt(i[1],10),g=Math.min(g,$.datepicker._getDaysInMonth(e,f));break;case"y":case"Y":e+=parseInt(i[1],10),g=Math.min(g,$.datepicker._getDaysInMonth(e,f))}i=h.exec(b)}return new Date(e,f,g)},f=b==null||b===""?c:typeof b=="string"?e(b):typeof b=="number"?isNaN(b)?c:d(b):new Date(b.getTime());return f=f&&f.toString()=="Invalid Date"?c:f,f&&(f.setHours(0),f.setMinutes(0),f.setSeconds(0),f.setMilliseconds(0)),this._daylightSavingAdjust(f)},_daylightSavingAdjust:function(a){return a?(a.setHours(a.getHours()>12?a.getHours()+2:0),a):null},_setDate:function(a,b,c){var d=!b,e=a.selectedMonth,f=a.selectedYear,g=this._restrictMinMax(a,this._determineDate(a,b,new Date));a.selectedDay=a.currentDay=g.getDate(),a.drawMonth=a.selectedMonth=a.currentMonth=g.getMonth(),a.drawYear=a.selectedYear=a.currentYear=g.getFullYear(),(e!=a.selectedMonth||f!=a.selectedYear)&&!c&&this._notifyChange(a),this._adjustInstDate(a),a.input&&a.input.val(d?"":this._formatDate(a))},_getDate:function(a){var b=!a.currentYear||a.input&&a.input.val()==""?null:this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return b},_generateHTML:function(a){var b=new Date;b=this._daylightSavingAdjust(new Date(b.getFullYear(),b.getMonth(),b.getDate()));var c=this._get(a,"isRTL"),d=this._get(a,"showButtonPanel"),e=this._get(a,"hideIfNoPrevNext"),f=this._get(a,"navigationAsDateFormat"),g=this._getNumberOfMonths(a),h=this._get(a,"showCurrentAtPos"),i=this._get(a,"stepMonths"),j=g[0]!=1||g[1]!=1,k=this._daylightSavingAdjust(a.currentDay?new Date(a.currentYear,a.currentMonth,a.currentDay):new Date(9999,9,9)),l=this._getMinMaxDate(a,"min"),m=this._getMinMaxDate(a,"max"),n=a.drawMonth-h,o=a.drawYear;n<0&&(n+=12,o--);if(m){var p=this._daylightSavingAdjust(new Date(m.getFullYear(),m.getMonth()-g[0]*g[1]+1,m.getDate()));p=l&&p<l?l:p;while(this._daylightSavingAdjust(new Date(o,n,1))>p)n--,n<0&&(n=11,o--)}a.drawMonth=n,a.drawYear=o;var q=this._get(a,"prevText");q=f?this.formatDate(q,this._daylightSavingAdjust(new Date(o,n-i,1)),this._getFormatConfig(a)):q;var r=this._canAdjustMonth(a,-1,o,n)?'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_'+dpuuid+".datepicker._adjustDate('#"+a.id+"', -"+i+", 'M');\""+' title="'+q+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+q+"</span></a>":e?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+q+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+q+"</span></a>",s=this._get(a,"nextText");s=f?this.formatDate(s,this._daylightSavingAdjust(new Date(o,n+i,1)),this._getFormatConfig(a)):s;var t=this._canAdjustMonth(a,1,o,n)?'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_'+dpuuid+".datepicker._adjustDate('#"+a.id+"', +"+i+", 'M');\""+' title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>":e?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>",u=this._get(a,"currentText"),v=this._get(a,"gotoCurrent")&&a.currentDay?k:b;u=f?this.formatDate(u,v,this._getFormatConfig(a)):u;var w=a.inline?"":'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_'+dpuuid+'.datepicker._hideDatepicker();">'+this._get(a,"closeText")+"</button>",x=d?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(c?w:"")+(this._isInRange(a,v)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_'+dpuuid+".datepicker._gotoToday('#"+a.id+"');\""+">"+u+"</button>":"")+(c?"":w)+"</div>":"",y=parseInt(this._get(a,"firstDay"),10);y=isNaN(y)?0:y;var z=this._get(a,"showWeek"),A=this._get(a,"dayNames"),B=this._get(a,"dayNamesShort"),C=this._get(a,"dayNamesMin"),D=this._get(a,"monthNames"),E=this._get(a,"monthNamesShort"),F=this._get(a,"beforeShowDay"),G=this._get(a,"showOtherMonths"),H=this._get(a,"selectOtherMonths"),I=this._get(a,"calculateWeek")||this.iso8601Week,J=this._getDefaultDate(a),K="";for(var L=0;L<g[0];L++){var M="";this.maxRows=4;for(var N=0;N<g[1];N++){var O=this._daylightSavingAdjust(new Date(o,n,a.selectedDay)),P=" ui-corner-all",Q="";if(j){Q+='<div class="ui-datepicker-group';if(g[1]>1)switch(N){case 0:Q+=" ui-datepicker-group-first",P=" ui-corner-"+(c?"right":"left");break;case g[1]-1:Q+=" ui-datepicker-group-last",P=" ui-corner-"+(c?"left":"right");break;default:Q+=" ui-datepicker-group-middle",P=""}Q+='">'}Q+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+P+'">'+(/all|left/.test(P)&&L==0?c?t:r:"")+(/all|right/.test(P)&&L==0?c?r:t:"")+this._generateMonthYearHeader(a,n,o,l,m,L>0||N>0,D,E)+'</div><table class="ui-datepicker-calendar"><thead>'+"<tr>";var R=z?'<th class="ui-datepicker-week-col">'+this._get(a,"weekHeader")+"</th>":"";for(var S=0;S<7;S++){var T=(S+y)%7;R+="<th"+((S+y+6)%7>=5?' class="ui-datepicker-week-end"':"")+">"+'<span title="'+A[T]+'">'+C[T]+"</span></th>"}Q+=R+"</tr></thead><tbody>";var U=this._getDaysInMonth(o,n);o==a.selectedYear&&n==a.selectedMonth&&(a.selectedDay=Math.min(a.selectedDay,U));var V=(this._getFirstDayOfMonth(o,n)-y+7)%7,W=Math.ceil((V+U)/7),X=j?this.maxRows>W?this.maxRows:W:W;this.maxRows=X;var Y=this._daylightSavingAdjust(new Date(o,n,1-V));for(var Z=0;Z<X;Z++){Q+="<tr>";var _=z?'<td class="ui-datepicker-week-col">'+this._get(a,"calculateWeek")(Y)+"</td>":"";for(var S=0;S<7;S++){var ba=F?F.apply(a.input?a.input[0]:null,[Y]):[!0,""],bb=Y.getMonth()!=n,bc=bb&&!H||!ba[0]||l&&Y<l||m&&Y>m;_+='<td class="'+((S+y+6)%7>=5?" ui-datepicker-week-end":"")+(bb?" ui-datepicker-other-month":"")+(Y.getTime()==O.getTime()&&n==a.selectedMonth&&a._keyEvent||J.getTime()==Y.getTime()&&J.getTime()==O.getTime()?" "+this._dayOverClass:"")+(bc?" "+this._unselectableClass+" ui-state-disabled":"")+(bb&&!G?"":" "+ba[1]+(Y.getTime()==k.getTime()?" "+this._currentClass:"")+(Y.getTime()==b.getTime()?" ui-datepicker-today":""))+'"'+((!bb||G)&&ba[2]?' title="'+ba[2]+'"':"")+(bc?"":' onclick="DP_jQuery_'+dpuuid+".datepicker._selectDay('#"+a.id+"',"+Y.getMonth()+","+Y.getFullYear()+', this);return false;"')+">"+(bb&&!G?"&#xa0;":bc?'<span class="ui-state-default">'+Y.getDate()+"</span>":'<a class="ui-state-default'+(Y.getTime()==b.getTime()?" ui-state-highlight":"")+(Y.getTime()==k.getTime()?" ui-state-active":"")+(bb?" ui-priority-secondary":"")+'" href="#">'+Y.getDate()+"</a>")+"</td>",Y.setDate(Y.getDate()+1),Y=this._daylightSavingAdjust(Y)}Q+=_+"</tr>"}n++,n>11&&(n=0,o++),Q+="</tbody></table>"+(j?"</div>"+(g[0]>0&&N==g[1]-1?'<div class="ui-datepicker-row-break"></div>':""):""),M+=Q}K+=M}return K+=x+($.browser.msie&&parseInt($.browser.version,10)<7&&!a.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':""),a._keyEvent=!1,K},_generateMonthYearHeader:function(a,b,c,d,e,f,g,h){var i=this._get(a,"changeMonth"),j=this._get(a,"changeYear"),k=this._get(a,"showMonthAfterYear"),l='<div class="ui-datepicker-title">',m="";if(f||!i)m+='<span class="ui-datepicker-month">'+g[b]+"</span>";else{var n=d&&d.getFullYear()==c,o=e&&e.getFullYear()==c;m+='<select class="ui-datepicker-month" onchange="DP_jQuery_'+dpuuid+".datepicker._selectMonthYear('#"+a.id+"', this, 'M');\" "+">";for(var p=0;p<12;p++)(!n||p>=d.getMonth())&&(!o||p<=e.getMonth())&&(m+='<option value="'+p+'"'+(p==b?' selected="selected"':"")+">"+h[p]+"</option>");m+="</select>"}k||(l+=m+(f||!i||!j?"&#xa0;":""));if(!a.yearshtml){a.yearshtml="";if(f||!j)l+='<span class="ui-datepicker-year">'+c+"</span>";else{var q=this._get(a,"yearRange").split(":"),r=(new Date).getFullYear(),s=function(a){var b=a.match(/c[+-].*/)?c+parseInt(a.substring(1),10):a.match(/[+-].*/)?r+parseInt(a,10):parseInt(a,10);return isNaN(b)?r:b},t=s(q[0]),u=Math.max(t,s(q[1]||""));t=d?Math.max(t,d.getFullYear()):t,u=e?Math.min(u,e.getFullYear()):u,a.yearshtml+='<select class="ui-datepicker-year" onchange="DP_jQuery_'+dpuuid+".datepicker._selectMonthYear('#"+a.id+"', this, 'Y');\" "+">";for(;t<=u;t++)a.yearshtml+='<option value="'+t+'"'+(t==c?' selected="selected"':"")+">"+t+"</option>";a.yearshtml+="</select>",l+=a.yearshtml,a.yearshtml=null}}return l+=this._get(a,"yearSuffix"),k&&(l+=(f||!i||!j?"&#xa0;":"")+m),l+="</div>",l},_adjustInstDate:function(a,b,c){var d=a.drawYear+(c=="Y"?b:0),e=a.drawMonth+(c=="M"?b:0),f=Math.min(a.selectedDay,this._getDaysInMonth(d,e))+(c=="D"?b:0),g=this._restrictMinMax(a,this._daylightSavingAdjust(new Date(d,e,f)));a.selectedDay=g.getDate(),a.drawMonth=a.selectedMonth=g.getMonth(),a.drawYear=a.selectedYear=g.getFullYear(),(c=="M"||c=="Y")&&this._notifyChange(a)},_restrictMinMax:function(a,b){var c=this._getMinMaxDate(a,"min"),d=this._getMinMaxDate(a,"max"),e=c&&b<c?c:b;return e=d&&e>d?d:e,e},_notifyChange:function(a){var b=this._get(a,"onChangeMonthYear");b&&b.apply(a.input?a.input[0]:null,[a.selectedYear,a.selectedMonth+1,a])},_getNumberOfMonths:function(a){var b=this._get(a,"numberOfMonths");return b==null?[1,1]:typeof b=="number"?[1,b]:b},_getMinMaxDate:function(a,b){return this._determineDate(a,this._get(a,b+"Date"),null)},_getDaysInMonth:function(a,b){return 32-this._daylightSavingAdjust(new Date(a,b,32)).getDate()},_getFirstDayOfMonth:function(a,b){return(new Date(a,b,1)).getDay()},_canAdjustMonth:function(a,b,c,d){var e=this._getNumberOfMonths(a),f=this._daylightSavingAdjust(new Date(c,d+(b<0?b:e[0]*e[1]),1));return b<0&&f.setDate(this._getDaysInMonth(f.getFullYear(),f.getMonth())),this._isInRange(a,f)},_isInRange:function(a,b){var c=this._getMinMaxDate(a,"min"),d=this._getMinMaxDate(a,"max");return(!c||b.getTime()>=c.getTime())&&(!d||b.getTime()<=d.getTime())},_getFormatConfig:function(a){var b=this._get(a,"shortYearCutoff");return b=typeof b!="string"?b:(new Date).getFullYear()%100+parseInt(b,10),{shortYearCutoff:b,dayNamesShort:this._get(a,"dayNamesShort"),dayNames:this._get(a,"dayNames"),monthNamesShort:this._get(a,"monthNamesShort"),monthNames:this._get(a,"monthNames")}},_formatDate:function(a,b,c,d){b||(a.currentDay=a.selectedDay,a.currentMonth=a.selectedMonth,a.currentYear=a.selectedYear);var e=b?typeof b=="object"?b:this._daylightSavingAdjust(new Date(d,c,b)):this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return this.formatDate(this._get(a,"dateFormat"),e,this._getFormatConfig(a))}}),$.fn.datepicker=function(a){if(!this.length)return this;$.datepicker.initialized||($(document).mousedown($.datepicker._checkExternalClick).find("body").append($.datepicker.dpDiv),$.datepicker.initialized=!0);var b=Array.prototype.slice.call(arguments,1);return typeof a!="string"||a!="isDisabled"&&a!="getDate"&&a!="widget"?a=="option"&&arguments.length==2&&typeof arguments[1]=="string"?$.datepicker["_"+a+"Datepicker"].apply($.datepicker,[this[0]].concat(b)):this.each(function(){typeof a=="string"?$.datepicker["_"+a+"Datepicker"].apply($.datepicker,[this].concat(b)):$.datepicker._attachDatepicker(this,a)}):$.datepicker["_"+a+"Datepicker"].apply($.datepicker,[this[0]].concat(b))},$.datepicker=new Datepicker,$.datepicker.initialized=!1,$.datepicker.uuid=(new Date).getTime(),$.datepicker.version="1.8.21",window["DP_jQuery_"+dpuuid]=$})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.selectable.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){a.widget("ui.selectable",a.ui.mouse,{options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch"},_create:function(){var b=this;this.element.addClass("ui-selectable"),this.dragged=!1;var c;this.refresh=function(){c=a(b.options.filter,b.element[0]),c.addClass("ui-selectee"),c.each(function(){var b=a(this),c=b.offset();a.data(this,"selectable-item",{element:this,$element:b,left:c.left,top:c.top,right:c.left+b.outerWidth(),bottom:c.top+b.outerHeight(),startselected:!1,selected:b.hasClass("ui-selected"),selecting:b.hasClass("ui-selecting"),unselecting:b.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=c.addClass("ui-selectee"),this._mouseInit(),this.helper=a("<div class='ui-selectable-helper'></div>")},destroy:function(){return this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable"),this._mouseDestroy(),this},_mouseStart:function(b){var c=this;this.opos=[b.pageX,b.pageY];if(this.options.disabled)return;var d=this.options;this.selectees=a(d.filter,this.element[0]),this._trigger("start",b),a(d.appendTo).append(this.helper),this.helper.css({left:b.clientX,top:b.clientY,width:0,height:0}),d.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var d=a.data(this,"selectable-item");d.startselected=!0,!b.metaKey&&!b.ctrlKey&&(d.$element.removeClass("ui-selected"),d.selected=!1,d.$element.addClass("ui-unselecting"),d.unselecting=!0,c._trigger("unselecting",b,{unselecting:d.element}))}),a(b.target).parents().andSelf().each(function(){var d=a.data(this,"selectable-item");if(d){var e=!b.metaKey&&!b.ctrlKey||!d.$element.hasClass("ui-selected");return d.$element.removeClass(e?"ui-unselecting":"ui-selected").addClass(e?"ui-selecting":"ui-unselecting"),d.unselecting=!e,d.selecting=e,d.selected=e,e?c._trigger("selecting",b,{selecting:d.element}):c._trigger("unselecting",b,{unselecting:d.element}),!1}})},_mouseDrag:function(b){var c=this;this.dragged=!0;if(this.options.disabled)return;var d=this.options,e=this.opos[0],f=this.opos[1],g=b.pageX,h=b.pageY;if(e>g){var i=g;g=e,e=i}if(f>h){var i=h;h=f,f=i}return this.helper.css({left:e,top:f,width:g-e,height:h-f}),this.selectees.each(function(){var i=a.data(this,"selectable-item");if(!i||i.element==c.element[0])return;var j=!1;d.tolerance=="touch"?j=!(i.left>g||i.right<e||i.top>h||i.bottom<f):d.tolerance=="fit"&&(j=i.left>e&&i.right<g&&i.top>f&&i.bottom<h),j?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,c._trigger("selecting",b,{selecting:i.element}))):(i.selecting&&((b.metaKey||b.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),c._trigger("unselecting",b,{unselecting:i.element}))),i.selected&&!b.metaKey&&!b.ctrlKey&&!i.startselected&&(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,c._trigger("unselecting",b,{unselecting:i.element})))}),!1},_mouseStop:function(b){var c=this;this.dragged=!1;var d=this.options;return a(".ui-unselecting",this.element[0]).each(function(){var d=a.data(this,"selectable-item");d.$element.removeClass("ui-unselecting"),d.unselecting=!1,d.startselected=!1,c._trigger("unselected",b,{unselected:d.element})}),a(".ui-selecting",this.element[0]).each(function(){var d=a.data(this,"selectable-item");d.$element.removeClass("ui-selecting").addClass("ui-selected"),d.selecting=!1,d.selected=!0,d.startselected=!0,c._trigger("selected",b,{selected:d.element})}),this._trigger("stop",b),this.helper.remove(),!1}}),a.extend(a.ui.selectable,{version:"1.8.21"})})(jQuery);
/*! jQuery UI - v1.8.21 - 2012-06-05
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.dialog.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){var c="ui-dialog ui-widget ui-widget-content ui-corner-all ",d={buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},e={maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},f=a.attrFn||{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0,click:!0};a.widget("ui.dialog",{options:{autoOpen:!0,buttons:{},closeOnEscape:!0,closeText:"close",dialogClass:"",draggable:!0,hide:null,height:"auto",maxHeight:!1,maxWidth:!1,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",collision:"fit",using:function(b){var c=a(this).css(b).offset().top;c<0&&a(this).css("top",b.top-c)}},resizable:!0,show:null,stack:!0,title:"",width:300,zIndex:1e3},_create:function(){this.originalTitle=this.element.attr("title"),typeof this.originalTitle!="string"&&(this.originalTitle=""),this.options.title=this.options.title||this.originalTitle;var b=this,d=b.options,e=d.title||"&#160;",f=a.ui.dialog.getTitleId(b.element),g=(b.uiDialog=a("<div></div>")).appendTo(document.body).hide().addClass(c+d.dialogClass).css({zIndex:d.zIndex}).attr("tabIndex",-1).css("outline",0).keydown(function(c){d.closeOnEscape&&!c.isDefaultPrevented()&&c.keyCode&&c.keyCode===a.ui.keyCode.ESCAPE&&(b.close(c),c.preventDefault())}).attr({role:"dialog","aria-labelledby":f}).mousedown(function(a){b.moveToTop(!1,a)}),h=b.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g),i=(b.uiDialogTitlebar=a("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),j=a('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role","button").hover(function(){j.addClass("ui-state-hover")},function(){j.removeClass("ui-state-hover")}).focus(function(){j.addClass("ui-state-focus")}).blur(function(){j.removeClass("ui-state-focus")}).click(function(a){return b.close(a),!1}).appendTo(i),k=(b.uiDialogTitlebarCloseText=a("<span></span>")).addClass("ui-icon ui-icon-closethick").text(d.closeText).appendTo(j),l=a("<span></span>").addClass("ui-dialog-title").attr("id",f).html(e).prependTo(i);a.isFunction(d.beforeclose)&&!a.isFunction(d.beforeClose)&&(d.beforeClose=d.beforeclose),i.find("*").add(i).disableSelection(),d.draggable&&a.fn.draggable&&b._makeDraggable(),d.resizable&&a.fn.resizable&&b._makeResizable(),b._createButtons(d.buttons),b._isOpen=!1,a.fn.bgiframe&&g.bgiframe()},_init:function(){this.options.autoOpen&&this.open()},destroy:function(){var a=this;return a.overlay&&a.overlay.destroy(),a.uiDialog.hide(),a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body"),a.uiDialog.remove(),a.originalTitle&&a.element.attr("title",a.originalTitle),a},widget:function(){return this.uiDialog},close:function(b){var c=this,d,e;if(!1===c._trigger("beforeClose",b))return;return c.overlay&&c.overlay.destroy(),c.uiDialog.unbind("keypress.ui-dialog"),c._isOpen=!1,c.options.hide?c.uiDialog.hide(c.options.hide,function(){c._trigger("close",b)}):(c.uiDialog.hide(),c._trigger("close",b)),a.ui.dialog.overlay.resize(),c.options.modal&&(d=0,a(".ui-dialog").each(function(){this!==c.uiDialog[0]&&(e=a(this).css("z-index"),isNaN(e)||(d=Math.max(d,e)))}),a.ui.dialog.maxZ=d),c},isOpen:function(){return this._isOpen},moveToTop:function(b,c){var d=this,e=d.options,f;return e.modal&&!b||!e.stack&&!e.modal?d._trigger("focus",c):(e.zIndex>a.ui.dialog.maxZ&&(a.ui.dialog.maxZ=e.zIndex),d.overlay&&(a.ui.dialog.maxZ+=1,d.overlay.$el.css("z-index",a.ui.dialog.overlay.maxZ=a.ui.dialog.maxZ)),f={scrollTop:d.element.scrollTop(),scrollLeft:d.element.scrollLeft()},a.ui.dialog.maxZ+=1,d.uiDialog.css("z-index",a.ui.dialog.maxZ),d.element.attr(f),d._trigger("focus",c),d)},open:function(){if(this._isOpen)return;var b=this,c=b.options,d=b.uiDialog;return b.overlay=c.modal?new a.ui.dialog.overlay(b):null,b._size(),b._position(c.position),d.show(c.show),b.moveToTop(!0),c.modal&&d.bind("keydown.ui-dialog",function(b){if(b.keyCode!==a.ui.keyCode.TAB)return;var c=a(":tabbable",this),d=c.filter(":first"),e=c.filter(":last");if(b.target===e[0]&&!b.shiftKey)return d.focus(1),!1;if(b.target===d[0]&&b.shiftKey)return e.focus(1),!1}),a(b.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus(),b._isOpen=!0,b._trigger("open"),b},_createButtons:function(b){var c=this,d=!1,e=a("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),g=a("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);c.uiDialog.find(".ui-dialog-buttonpane").remove(),typeof b=="object"&&b!==null&&a.each(b,function(){return!(d=!0)}),d&&(a.each(b,function(b,d){d=a.isFunction(d)?{click:d,text:b}:d;var e=a('<button type="button"></button>').click(function(){d.click.apply(c.element[0],arguments)}).appendTo(g);a.each(d,function(a,b){if(a==="click")return;a in f?e[a](b):e.attr(a,b)}),a.fn.button&&e.button()}),e.appendTo(c.uiDialog))},_makeDraggable:function(){function f(a){return{position:a.position,offset:a.offset}}var b=this,c=b.options,d=a(document),e;b.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(d,g){e=c.height==="auto"?"auto":a(this).height(),a(this).height(a(this).height()).addClass("ui-dialog-dragging"),b._trigger("dragStart",d,f(g))},drag:function(a,c){b._trigger("drag",a,f(c))},stop:function(g,h){c.position=[h.position.left-d.scrollLeft(),h.position.top-d.scrollTop()],a(this).removeClass("ui-dialog-dragging").height(e),b._trigger("dragStop",g,f(h)),a.ui.dialog.overlay.resize()}})},_makeResizable:function(c){function h(a){return{originalPosition:a.originalPosition,originalSize:a.originalSize,position:a.position,size:a.size}}c=c===b?this.options.resizable:c;var d=this,e=d.options,f=d.uiDialog.css("position"),g=typeof c=="string"?c:"n,e,s,w,se,sw,ne,nw";d.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:d.element,maxWidth:e.maxWidth,maxHeight:e.maxHeight,minWidth:e.minWidth,minHeight:d._minHeight(),handles:g,start:function(b,c){a(this).addClass("ui-dialog-resizing"),d._trigger("resizeStart",b,h(c))},resize:function(a,b){d._trigger("resize",a,h(b))},stop:function(b,c){a(this).removeClass("ui-dialog-resizing"),e.height=a(this).height(),e.width=a(this).width(),d._trigger("resizeStop",b,h(c)),a.ui.dialog.overlay.resize()}}).css("position",f).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var a=this.options;return a.height==="auto"?a.minHeight:Math.min(a.minHeight,a.height)},_position:function(b){var c=[],d=[0,0],e;if(b){if(typeof b=="string"||typeof b=="object"&&"0"in b)c=b.split?b.split(" "):[b[0],b[1]],c.length===1&&(c[1]=c[0]),a.each(["left","top"],function(a,b){+c[a]===c[a]&&(d[a]=c[a],c[a]=b)}),b={my:c.join(" "),at:c.join(" "),offset:d.join(" ")};b=a.extend({},a.ui.dialog.prototype.options.position,b)}else b=a.ui.dialog.prototype.options.position;e=this.uiDialog.is(":visible"),e||this.uiDialog.show(),this.uiDialog.css({top:0,left:0}).position(a.extend({of:window},b)),e||this.uiDialog.hide()},_setOptions:function(b){var c=this,f={},g=!1;a.each(b,function(a,b){c._setOption(a,b),a in d&&(g=!0),a in e&&(f[a]=b)}),g&&this._size(),this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",f)},_setOption:function(b,d){var e=this,f=e.uiDialog;switch(b){case"beforeclose":b="beforeClose";break;case"buttons":e._createButtons(d);break;case"closeText":e.uiDialogTitlebarCloseText.text(""+d);break;case"dialogClass":f.removeClass(e.options.dialogClass).addClass(c+d);break;case"disabled":d?f.addClass("ui-dialog-disabled"):f.removeClass("ui-dialog-disabled");break;case"draggable":var g=f.is(":data(draggable)");g&&!d&&f.draggable("destroy"),!g&&d&&e._makeDraggable();break;case"position":e._position(d);break;case"resizable":var h=f.is(":data(resizable)");h&&!d&&f.resizable("destroy"),h&&typeof d=="string"&&f.resizable("option","handles",d),!h&&d!==!1&&e._makeResizable(d);break;case"title":a(".ui-dialog-title",e.uiDialogTitlebar).html(""+(d||"&#160;"))}a.Widget.prototype._setOption.apply(e,arguments)},_size:function(){var b=this.options,c,d,e=this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0}),b.minWidth>b.width&&(b.width=b.minWidth),c=this.uiDialog.css({height:"auto",width:b.width}).height(),d=Math.max(0,b.minHeight-c);if(b.height==="auto")if(a.support.minHeight)this.element.css({minHeight:d,height:"auto"});else{this.uiDialog.show();var f=this.element.css("height","auto").height();e||this.uiDialog.hide(),this.element.height(Math.max(f,d))}else this.element.height(Math.max(b.height-c,0));this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())}}),a.extend(a.ui.dialog,{version:"1.8.21",uuid:0,maxZ:0,getTitleId:function(a){var b=a.attr("id");return b||(this.uuid+=1,b=this.uuid),"ui-dialog-title-"+b},overlay:function(b){this.$el=a.ui.dialog.overlay.create(b)}}),a.extend(a.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:a.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(a){return a+".dialog-overlay"}).join(" "),create:function(b){this.instances.length===0&&(setTimeout(function(){a.ui.dialog.overlay.instances.length&&a(document).bind(a.ui.dialog.overlay.events,function(b){if(a(b.target).zIndex()<a.ui.dialog.overlay.maxZ)return!1})},1),a(document).bind("keydown.dialog-overlay",function(c){b.options.closeOnEscape&&!c.isDefaultPrevented()&&c.keyCode&&c.keyCode===a.ui.keyCode.ESCAPE&&(b.close(c),c.preventDefault())}),a(window).bind("resize.dialog-overlay",a.ui.dialog.overlay.resize));var c=(this.oldInstances.pop()||a("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({width:this.width(),height:this.height()});return a.fn.bgiframe&&c.bgiframe(),this.instances.push(c),c},destroy:function(b){var c=a.inArray(b,this.instances);c!=-1&&this.oldInstances.push(this.instances.splice(c,1)[0]),this.instances.length===0&&a([document,window]).unbind(".dialog-overlay"),b.remove();var d=0;a.each(this.instances,function(){d=Math.max(d,this.css("z-index"))}),this.maxZ=d},height:function(){var b,c;return a.browser.msie&&a.browser.version<7?(b=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),c=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight),b<c?a(window).height()+"px":b+"px"):a(document).height()+"px"},width:function(){var b,c;return a.browser.msie?(b=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth),c=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth),b<c?a(window).width()+"px":b+"px"):a(document).width()+"px"},resize:function(){var b=a([]);a.each(a.ui.dialog.overlay.instances,function(){b=b.add(this)}),b.css({width:0,height:0}).css({width:a.ui.dialog.overlay.width(),height:a.ui.dialog.overlay.height()})}}),a.extend(a.ui.dialog.overlay.prototype,{destroy:function(){a.ui.dialog.overlay.destroy(this.$el)}})})(jQuery);
// Copyright (c) 2009 Daniel Wachsstock
// MIT license:
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:

// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
(function($){
// create the master widget
$.widget("ui.widget",{
	// Aspect Oriented Programming tools from Justin Palmer's article
	yield: null,
	returnValues: { },
	before: function(method, f) {
		var original = this[method];
		this[method] = function() {
			f.apply(this, arguments);
			return original.apply(this, arguments);
		};
	},
	after: function(method, f) {
		var original = this[method];
		this[method] = function() {
			this.returnValues[method] = original.apply(this, arguments);
			return f.apply(this, arguments);
		}
	},
	around: function(method, f) {
		var original = this[method];
		this[method] = function() {
			var tmp = this.yield;
			this.yield = original;
			var ret = f.apply(this, arguments);
			this.yield = tmp;
			return ret;
		}
	}
});

// from http://groups.google.com/group/comp.lang.javascript/msg/e04726a66face2a2 and
// http://webreflection.blogspot.com/2008/10/big-douglas-begetobject-revisited.html
var object = (function(F){
	return (function(o){
			F.prototype = o;
			return new F();
	});
})(function (){});

// create a widget subclass
var OVERRIDE = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/; 
$.ui.widget.subclass = function subclass(name){
	$.widget(name); // Slightly inefficient to create a widget only to discard its prototype, but it's not too bad
	name = name.split('.');
	var widget = $[name[0]][name[1]], superclass = this, superproto = superclass.prototype;
	
	
	var proto = arguments[0] = widget.prototype = object(superproto); // inherit from the superclass
	$.extend.apply(null, arguments); // and add other add-in methods to the prototype
	widget.subclass = subclass;

	// Subtle point: we want to call superclass init and destroy if they exist
	// (otherwise the user of this function would have to keep track of all that)
	for (key in proto) if (proto.hasOwnProperty(key)) switch (key){
		case '_create':
			var create = proto._create;
			proto._create = function(){
				superproto._create.apply(this);
				create.apply(this);
			};
		break;
		case '_init':
			var init = proto._init;
			proto._init = function(){
				superproto._init.apply(this);
				init.apply(this);
			};
		break;
		case 'destroy':
			var destroy = proto.destroy;
			proto.destroy = function(){
				destroy.apply(this);
				superproto.destroy.apply(this);
			};
		break;
		case 'options':
			var options = proto.options;
			proto.options = $.extend ({}, superproto.options, options);
		break;
		default:
			if ($.isFunction(proto[key]) && $.isFunction(superproto[key]) && OVERRIDE.test(proto[key])){
				proto[key] = (function(name, fn){
					return function() {
						var tmp = this._super;
						this._super = superproto[name];
						try { var ret = fn.apply(this, arguments); }   
						finally { this._super = tmp; }					
						return ret;
					};
				})(key, proto[key]);
			}
		break;
	}
};
})(jQuery);
(function(a){function g(a){a.setFullYear(2001),a.setMonth(0),a.setDate(0);return a}function f(a,b){if(a){var c=a.split(b.separator),d=parseFloat(c[0]),e=parseFloat(c[1]);b.show24Hours||(d===12&&a.indexOf("AM")!==-1?d=0:d!==12&&a.indexOf("PM")!==-1&&(d+=12));var f=new Date(0,0,0,d,e,0);return g(f)}return null}function e(a,b){return typeof a=="object"?g(a):f(a,b)}function d(a){return(a<10?"0":"")+a}function c(a,b){var c=a.getHours(),e=b.show24Hours?c:(c+11)%12+1,f=a.getMinutes();return d(e)+b.separator+d(f)+(b.show24Hours?"":c<12?" AM":" PM")}function b(b,c,d,e){b.value=a(c).text(),a(b).change(),a.browser.msie||b.focus(),d.hide()}a.fn.timePicker=function(b){var c=a.extend({},a.fn.timePicker.defaults,b);return this.each(function(){a.timePicker(this,c)})},a.timePicker=function(b,c){var d=a(b)[0];return d.timePicker||(d.timePicker=new jQuery._timePicker(d,c))},a.timePicker.version="0.3",a._timePicker=function(d,h){var i=!1,j=!1,k=e(h.startTime,h),l=e(h.endTime,h),m="selected",n="li."+m;a(d).attr("autocomplete","OFF");var o=[],p=new Date(k);while(p<=l)o[o.length]=c(p,h),p=new Date(p.setMinutes(p.getMinutes()+h.step));var q=a('<div class="time-picker'+(h.show24Hours?"":" time-picker-12hours")+'"></div>'),r=a("<ul></ul>");for(var s=0;s<o.length;s++)r.append("<li>"+o[s]+"</li>");q.append(r),q.appendTo("body").hide(),q.mouseover(function(){i=!0}).mouseout(function(){i=!1}),a("li",r).mouseover(function(){j||(a(n,q).removeClass(m),a(this).addClass(m))}).mousedown(function(){i=!0}).click(function(){b(d,this,q,h),i=!1});var t=function(){if(q.is(":visible"))return!1;a("li",q).removeClass(m);var b=a(d).offset();q.css({top:b.top+d.offsetHeight,left:b.left}),q.show();var e=d.value?f(d.value,h):k,i=k.getHours()*60+k.getMinutes(),j=e.getHours()*60+e.getMinutes()-i,n=Math.round(j/h.step),o=g(new Date(0,0,0,0,n*h.step+i,0));o=k<o&&o<=l?o:k;var p=a("li:contains("+c(o,h)+")",q);p.length&&(p.addClass(m),q[0].scrollTop=p[0].offsetTop);return!0};a(d).focus(t).click(t),a(d).blur(function(){i||q.hide()});var u=a.browser.opera||a.browser.mozilla?"keypress":"keydown";a(d)[u](function(c){var e;j=!0;var f=q[0].scrollTop;switch(c.keyCode){case 38:if(t())return!1;e=a(n,r);var g=e.prev().addClass(m)[0];g?(e.removeClass(m),g.offsetTop<f&&(q[0].scrollTop=f-g.offsetHeight)):(e.removeClass(m),g=a("li:last",r).addClass(m)[0],q[0].scrollTop=g.offsetTop-g.offsetHeight);return!1;case 40:if(t())return!1;e=a(n,r);var i=e.next().addClass(m)[0];i?(e.removeClass(m),i.offsetTop+i.offsetHeight>f+q[0].offsetHeight&&(q[0].scrollTop=f+i.offsetHeight)):(e.removeClass(m),i=a("li:first",r).addClass(m)[0],q[0].scrollTop=0);return!1;case 13:if(q.is(":visible")){var k=a(n,r)[0];b(d,k,q,h)}return!1;case 27:q.hide();return!1}return!0}),a(d).keyup(function(a){j=!1}),this.getTime=function(){return f(d.value,h)},this.setTime=function(b){d.value=c(e(b,h),h),a(d).change()}},a.fn.timePicker.defaults={step:30,startTime:new Date(0,0,0,0,0,0),endTime:new Date(0,0,0,23,30,0),separator:":",show24Hours:!0}})(jQuery);
(function(){if (!Date.now) Date.now = function() {
  return +new Date;
};
try {
  document.createElement("div").style.setProperty("opacity", 0, "");
} catch (error) {
  var d3_style_prototype = CSSStyleDeclaration.prototype,
      d3_style_setProperty = d3_style_prototype.setProperty;
  d3_style_prototype.setProperty = function(name, value, priority) {
    d3_style_setProperty.call(this, name, value + "", priority);
  };
}
d3 = {version: "2.9.6"}; // semver
function d3_class(ctor, properties) {
  try {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  } catch (e) {
    ctor.prototype = properties;
  }
}
var d3_array = d3_arraySlice; // conversion for NodeLists

function d3_arrayCopy(pseudoarray) {
  var i = -1, n = pseudoarray.length, array = [];
  while (++i < n) array.push(pseudoarray[i]);
  return array;
}

function d3_arraySlice(pseudoarray) {
  return Array.prototype.slice.call(pseudoarray);
}

try {
  d3_array(document.documentElement.childNodes)[0].nodeType;
} catch(e) {
  d3_array = d3_arrayCopy;
}

var d3_arraySubclass = [].__proto__?

// Until ECMAScript supports array subclassing, prototype injection works well.
function(array, prototype) {
  array.__proto__ = prototype;
}:

// And if your browser doesn't support __proto__, we'll use direct extension.
function(array, prototype) {
  for (var property in prototype) array[property] = prototype[property];
};
d3.map = function(object) {
  var map = new d3_Map;
  for (var key in object) map.set(key, object[key]);
  return map;
};

function d3_Map() {}

d3_class(d3_Map, {
  has: function(key) {
    return d3_map_prefix + key in this;
  },
  get: function(key) {
    return this[d3_map_prefix + key];
  },
  set: function(key, value) {
    return this[d3_map_prefix + key] = value;
  },
  remove: function(key) {
    key = d3_map_prefix + key;
    return key in this && delete this[key];
  },
  keys: function() {
    var keys = [];
    this.forEach(function(key) { keys.push(key); });
    return keys;
  },
  values: function() {
    var values = [];
    this.forEach(function(key, value) { values.push(value); });
    return values;
  },
  entries: function() {
    var entries = [];
    this.forEach(function(key, value) { entries.push({key: key, value: value}); });
    return entries;
  },
  forEach: function(f) {
    for (var key in this) {
      if (key.charCodeAt(0) === d3_map_prefixCode) {
        f.call(this, key.substring(1), this[key]);
      }
    }
  }
});

var d3_map_prefix = "\0", // prevent collision with built-ins
    d3_map_prefixCode = d3_map_prefix.charCodeAt(0);
function d3_identity(d) {
  return d;
}
function d3_this() {
  return this;
}
function d3_true() {
  return true;
}
function d3_functor(v) {
  return typeof v === "function" ? v : function() { return v; };
}

d3.functor = d3_functor;
// Copies a variable number of methods from source to target.
d3.rebind = function(target, source) {
  var i = 1, n = arguments.length, method;
  while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
  return target;
};

// Method is assumed to be a standard D3 getter-setter:
// If passed with no arguments, gets the value.
// If passed with arguments, sets the value and returns the target.
function d3_rebind(target, source, method) {
  return function() {
    var value = method.apply(source, arguments);
    return arguments.length ? target : value;
  };
}
d3.ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};
d3.descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};
d3.mean = function(array, f) {
  var n = array.length,
      a,
      m = 0,
      i = -1,
      j = 0;
  if (arguments.length === 1) {
    while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;
  } else {
    while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;
  }
  return j ? m : undefined;
};
d3.median = function(array, f) {
  if (arguments.length > 1) array = array.map(f);
  array = array.filter(d3_number);
  return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;
};
d3.min = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
    while (++i < n) if ((b = array[i]) != null && a > b) a = b;
  } else {
    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
  }
  return a;
};
d3.max = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;
  if (arguments.length === 1) {
    while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;
    while (++i < n) if ((b = array[i]) != null && b > a) a = b;
  } else {
    while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
  }
  return a;
};
d3.extent = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b,
      c;
  if (arguments.length === 1) {
    while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;
    while (++i < n) if ((b = array[i]) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  } else {
    while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;
    while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  }
  return [a, c];
};
d3.random = {
  normal: function(mean, deviation) {
    if (arguments.length < 2) deviation = 1;
    if (arguments.length < 1) mean = 0;
    return function() {
      var x, y, r;
      do {
        x = Math.random() * 2 - 1;
        y = Math.random() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);
      return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
};
function d3_number(x) {
  return x != null && !isNaN(x);
}
d3.sum = function(array, f) {
  var s = 0,
      n = array.length,
      a,
      i = -1;

  if (arguments.length === 1) {
    while (++i < n) if (!isNaN(a = +array[i])) s += a;
  } else {
    while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;
  }

  return s;
};
// R-7 per <http://en.wikipedia.org/wiki/Quantile>
d3.quantile = function(values, p) {
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = values[h - 1],
      e = H - h;
  return e ? v + e * (values[h] - v) : v;
};
d3.transpose = function(matrix) {
  return d3.zip.apply(d3, matrix);
};
d3.zip = function() {
  if (!(n = arguments.length)) return [];
  for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {
    for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {
      zip[j] = arguments[j][i];
    }
  }
  return zips;
};

function d3_zipLength(d) {
  return d.length;
}
d3.bisector = function(f) {
  return {
    left: function(a, x, lo, hi) {
      if (arguments.length < 3) lo = 0;
      if (arguments.length < 4) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >> 1;
        if (f.call(a, a[mid], mid) < x) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (arguments.length < 3) lo = 0;
      if (arguments.length < 4) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >> 1;
        if (x < f.call(a, a[mid], mid)) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
};

var d3_bisector = d3.bisector(function(d) { return d; });
d3.bisectLeft = d3_bisector.left;
d3.bisect = d3.bisectRight = d3_bisector.right;
d3.first = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i < n) {
    if (f.call(array, a, b = array[i]) > 0) {
      a = b;
    }
  }
  return a;
};
d3.last = function(array, f) {
  var i = 0,
      n = array.length,
      a = array[0],
      b;
  if (arguments.length === 1) f = d3.ascending;
  while (++i < n) {
    if (f.call(array, a, b = array[i]) <= 0) {
      a = b;
    }
  }
  return a;
};
d3.nest = function() {
  var nest = {},
      keys = [],
      sortKeys = [],
      sortValues,
      rollup;

  function map(array, depth) {
    if (depth >= keys.length) return rollup
        ? rollup.call(nest, array) : (sortValues
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        object,
        valuesByKey = new d3_Map,
        values,
        o = {};

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
        values.push(object);
      } else {
        valuesByKey.set(keyValue, [object]);
      }
    }

    valuesByKey.forEach(function(keyValue) {
      o[keyValue] = map(valuesByKey.get(keyValue), depth);
    });

    return o;
  }

  function entries(map, depth) {
    if (depth >= keys.length) return map;

    var a = [],
        sortKey = sortKeys[depth++],
        key;

    for (key in map) {
      a.push({key: key, values: entries(map[key], depth)});
    }

    if (sortKey) a.sort(function(a, b) {
      return sortKey(a.key, b.key);
    });

    return a;
  }

  nest.map = function(array) {
    return map(array, 0);
  };

  nest.entries = function(array) {
    return entries(map(array, 0), 0);
  };

  nest.key = function(d) {
    keys.push(d);
    return nest;
  };

  // Specifies the order for the most-recently specified key.
  // Note: only applies to entries. Map keys are unordered!
  nest.sortKeys = function(order) {
    sortKeys[keys.length - 1] = order;
    return nest;
  };

  // Specifies the order for leaf values.
  // Applies to both maps and entries array.
  nest.sortValues = function(order) {
    sortValues = order;
    return nest;
  };

  nest.rollup = function(f) {
    rollup = f;
    return nest;
  };

  return nest;
};
d3.keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};
d3.values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};
d3.entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};
d3.permute = function(array, indexes) {
  var permutes = [],
      i = -1,
      n = indexes.length;
  while (++i < n) permutes[i] = array[indexes[i]];
  return permutes;
};
d3.merge = function(arrays) {
  return Array.prototype.concat.apply([], arrays);
};
d3.split = function(array, f) {
  var arrays = [],
      values = [],
      value,
      i = -1,
      n = array.length;
  if (arguments.length < 2) f = d3_splitter;
  while (++i < n) {
    if (f.call(values, value = array[i], i)) {
      values = [];
    } else {
      if (!values.length) arrays.push(values);
      values.push(value);
    }
  }
  return arrays;
};

function d3_splitter(d) {
  return d == null;
}
function d3_collapse(s) {
  return s.replace(/^\s+|\s+$/g, "").replace(/\s+/g, " ");
}
d3.range = function(start, stop, step) {
  if (arguments.length < 3) {
    step = 1;
    if (arguments.length < 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step === Infinity) throw new Error("infinite range");
  var range = [],
       k = d3_range_integerScale(Math.abs(step)),
       i = -1,
       j;
  start *= k, stop *= k, step *= k;
  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);
  else while ((j = start + step * ++i) < stop) range.push(j / k);
  return range;
};

function d3_range_integerScale(x) {
  var k = 1;
  while (x * k % 1) k *= 10;
  return k;
}
d3.requote = function(s) {
  return s.replace(d3_requote_re, "\\$&");
};

var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
d3.round = function(x, n) {
  return n
      ? Math.round(x * (n = Math.pow(10, n))) / n
      : Math.round(x);
};
d3.xhr = function(url, mime, callback) {
  var req = new XMLHttpRequest;
  if (arguments.length < 3) callback = mime, mime = null;
  else if (mime && req.overrideMimeType) req.overrideMimeType(mime);
  req.open("GET", url, true);
  if (mime) req.setRequestHeader("Accept", mime);
  req.onreadystatechange = function() {
    if (req.readyState === 4) {
      var s = req.status;
      callback(!s && req.response || s >= 200 && s < 300 || s === 304 ? req : null);
    }
  };
  req.send(null);
};
d3.text = function(url, mime, callback) {
  function ready(req) {
    callback(req && req.responseText);
  }
  if (arguments.length < 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
d3.json = function(url, callback) {
  d3.text(url, "application/json", function(text) {
    callback(text ? JSON.parse(text) : null);
  });
};
d3.html = function(url, callback) {
  d3.text(url, "text/html", function(text) {
    if (text != null) { // Treat empty string as valid HTML.
      var range = document.createRange();
      range.selectNode(document.body);
      text = range.createContextualFragment(text);
    }
    callback(text);
  });
};
d3.xml = function(url, mime, callback) {
  function ready(req) {
    callback(req && req.responseXML);
  }
  if (arguments.length < 3) {
    callback = mime;
    mime = null;
  }
  d3.xhr(url, mime, ready);
};
var d3_nsPrefix = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

d3.ns = {
  prefix: d3_nsPrefix,
  qualify: function(name) {
    var i = name.indexOf(":"),
        prefix = name;
    if (i >= 0) {
      prefix = name.substring(0, i);
      name = name.substring(i + 1);
    }
    return d3_nsPrefix.hasOwnProperty(prefix)
        ? {space: d3_nsPrefix[prefix], local: name}
        : name;
  }
};
d3.dispatch = function() {
  var dispatch = new d3_dispatch,
      i = -1,
      n = arguments.length;
  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
  return dispatch;
};

function d3_dispatch() {}

d3_dispatch.prototype.on = function(type, listener) {
  var i = type.indexOf("."),
      name = "";

  // Extract optional namespace, e.g., "click.foo"
  if (i > 0) {
    name = type.substring(i + 1);
    type = type.substring(0, i);
  }

  return arguments.length < 2
      ? this[type].on(name)
      : this[type].on(name, listener);
};

function d3_dispatch_event(dispatch) {
  var listeners = [],
      listenerByName = new d3_Map;

  function event() {
    var z = listeners, // defensive reference
        i = -1,
        n = z.length,
        l;
    while (++i < n) if (l = z[i].on) l.apply(this, arguments);
    return dispatch;
  }

  event.on = function(name, listener) {
    var l = listenerByName.get(name),
        i;

    // return the current listener, if any
    if (arguments.length < 2) return l && l.on;

    // remove the old listener, if any (with copy-on-write)
    if (l) {
      l.on = null;
      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
      listenerByName.remove(name);
    }

    // add the new listener, if any
    if (listener) listeners.push(listenerByName.set(name, {on: listener}));

    return dispatch;
  };

  return event;
}
// TODO align
d3.format = function(specifier) {
  var match = d3_format_re.exec(specifier),
      fill = match[1] || " ",
      sign = match[3] || "",
      zfill = match[5],
      width = +match[6],
      comma = match[7],
      precision = match[8],
      type = match[9],
      scale = 1,
      suffix = "",
      integer = false;

  if (precision) precision = +precision.substring(1);

  if (zfill) {
    fill = "0"; // TODO align = "=";
    if (comma) width -= Math.floor((width - 1) / 4);
  }

  switch (type) {
    case "n": comma = true; type = "g"; break;
    case "%": scale = 100; suffix = "%"; type = "f"; break;
    case "p": scale = 100; suffix = "%"; type = "r"; break;
    case "d": integer = true; precision = 0; break;
    case "s": scale = -1; type = "r"; break;
  }

  // If no precision is specified for r, fallback to general notation.
  if (type == "r" && !precision) type = "g";

  type = d3_format_types.get(type) || d3_format_typeDefault;

  return function(value) {

    // Return the empty string for floats formatted as ints.
    if (integer && (value % 1)) return "";

    // Convert negative to positive, and record the sign prefix.
    var negative = (value < 0) && (value = -value) ? "\u2212" : sign;

    // Apply the scale, computing it from the value's exponent for si format.
    if (scale < 0) {
      var prefix = d3.formatPrefix(value, precision);
      value = prefix.scale(value);
      suffix = prefix.symbol;
    } else {
      value *= scale;
    }

    // Convert to the desired precision.
    value = type(value, precision);

    // If the fill character is 0, the sign and group is applied after the fill.
    if (zfill) {
      var length = value.length + negative.length;
      if (length < width) value = new Array(width - length + 1).join(fill) + value;
      if (comma) value = d3_format_group(value);
      value = negative + value;
    }

    // Otherwise (e.g., space-filling), the sign and group is applied before.
    else {
      if (comma) value = d3_format_group(value);
      value = negative + value;
      var length = value.length;
      if (length < width) value = new Array(width - length + 1).join(fill) + value;
    }

    return value + suffix;
  };
};

// [[fill]align][sign][#][0][width][,][.precision][type]
var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?(#)?(0)?([0-9]+)?(,)?(\.[0-9]+)?([a-zA-Z%])?/;

var d3_format_types = d3.map({
  g: function(x, p) { return x.toPrecision(p); },
  e: function(x, p) { return x.toExponential(p); },
  f: function(x, p) { return x.toFixed(p); },
  r: function(x, p) { return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p))); }
});

function d3_format_precision(x, p) {
  return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);
}

function d3_format_typeDefault(x) {
  return x + "";
}

// Apply comma grouping for thousands.
function d3_format_group(value) {
  var i = value.lastIndexOf("."),
      f = i >= 0 ? value.substring(i) : (i = value.length, ""),
      t = [];
  while (i > 0) t.push(value.substring(i -= 3, i + 3));
  return t.reverse().join(",") + f;
}
var d3_formatPrefixes = ["y","z","a","f","p","n","μ","m","","k","M","G","T","P","E","Z","Y"].map(d3_formatPrefix);

d3.formatPrefix = function(value, precision) {
  var i = 0;
  if (value) {
    if (value < 0) value *= -1;
    if (precision) value = d3.round(value, d3_format_precision(value, precision));
    i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
    i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
  }
  return d3_formatPrefixes[8 + i / 3];
};

function d3_formatPrefix(d, i) {
  var k = Math.pow(10, Math.abs(8 - i) * 3);
  return {
    scale: i > 8 ? function(d) { return d / k; } : function(d) { return d * k; },
    symbol: d
  };
}
/*
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * - Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var d3_ease_quad = d3_ease_poly(2),
    d3_ease_cubic = d3_ease_poly(3),
    d3_ease_default = function() { return d3_ease_identity; };

var d3_ease = d3.map({
  linear: d3_ease_default,
  poly: d3_ease_poly,
  quad: function() { return d3_ease_quad; },
  cubic: function() { return d3_ease_cubic; },
  sin: function() { return d3_ease_sin; },
  exp: function() { return d3_ease_exp; },
  circle: function() { return d3_ease_circle; },
  elastic: d3_ease_elastic,
  back: d3_ease_back,
  bounce: function() { return d3_ease_bounce; }
});

var d3_ease_mode = d3.map({
  "in": d3_ease_identity,
  "out": d3_ease_reverse,
  "in-out": d3_ease_reflect,
  "out-in": function(f) { return d3_ease_reflect(d3_ease_reverse(f)); }
});

d3.ease = function(name) {
  var i = name.indexOf("-"),
      t = i >= 0 ? name.substring(0, i) : name,
      m = i >= 0 ? name.substring(i + 1) : "in";
  t = d3_ease.get(t) || d3_ease_default;
  m = d3_ease_mode.get(m) || d3_ease_identity;
  return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));
};

function d3_ease_clamp(f) {
  return function(t) {
    return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
  };
}

function d3_ease_reverse(f) {
  return function(t) {
    return 1 - f(1 - t);
  };
}

function d3_ease_reflect(f) {
  return function(t) {
    return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));
  };
}

function d3_ease_identity(t) {
  return t;
}

function d3_ease_poly(e) {
  return function(t) {
    return Math.pow(t, e);
  };
}

function d3_ease_sin(t) {
  return 1 - Math.cos(t * Math.PI / 2);
}

function d3_ease_exp(t) {
  return Math.pow(2, 10 * (t - 1));
}

function d3_ease_circle(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function d3_ease_elastic(a, p) {
  var s;
  if (arguments.length < 2) p = 0.45;
  if (arguments.length < 1) { a = 1; s = p / 4; }
  else s = p / (2 * Math.PI) * Math.asin(1 / a);
  return function(t) {
    return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * Math.PI / p);
  };
}

function d3_ease_back(s) {
  if (!s) s = 1.70158;
  return function(t) {
    return t * t * ((s + 1) * t - s);
  };
}

function d3_ease_bounce(t) {
  return t < 1 / 2.75 ? 7.5625 * t * t
      : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75
      : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375
      : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
}
d3.event = null;

function d3_eventCancel() {
  d3.event.stopPropagation();
  d3.event.preventDefault();
}

function d3_eventSource() {
  var e = d3.event, s;
  while (s = e.sourceEvent) e = s;
  return e;
}

// Like d3.dispatch, but for custom events abstracting native UI events. These
// events have a target component (such as a brush), a target element (such as
// the svg:g element containing the brush) and the standard arguments `d` (the
// target element's data) and `i` (the selection index of the target element).
function d3_eventDispatch(target) {
  var dispatch = new d3_dispatch,
      i = 0,
      n = arguments.length;

  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);

  // Creates a dispatch context for the specified `thiz` (typically, the target
  // DOM element that received the source event) and `argumentz` (typically, the
  // data `d` and index `i` of the target element). The returned function can be
  // used to dispatch an event to any registered listeners; the function takes a
  // single argument as input, being the event to dispatch. The event must have
  // a "type" attribute which corresponds to a type registered in the
  // constructor. This context will automatically populate the "sourceEvent" and
  // "target" attributes of the event, as well as setting the `d3.event` global
  // for the duration of the notification.
  dispatch.of = function(thiz, argumentz) {
    return function(e1) {
      try {
        var e0 =
        e1.sourceEvent = d3.event;
        e1.target = target;
        d3.event = e1;
        dispatch[e1.type].apply(thiz, argumentz);
      } finally {
        d3.event = e0;
      }
    };
  };

  return dispatch;
}
d3.interpolate = function(a, b) {
  var i = d3.interpolators.length, f;
  while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
  return f;
};

d3.interpolateNumber = function(a, b) {
  b -= a;
  return function(t) { return a + b * t; };
};

d3.interpolateRound = function(a, b) {
  b -= a;
  return function(t) { return Math.round(a + b * t); };
};

d3.interpolateString = function(a, b) {
  var m, // current match
      i, // current index
      j, // current index (for coallescing)
      s0 = 0, // start index of current string prefix
      s1 = 0, // end index of current string prefix
      s = [], // string constants and placeholders
      q = [], // number interpolators
      n, // q.length
      o;

  // Reset our regular expression!
  d3_interpolate_number.lastIndex = 0;

  // Find all numbers in b.
  for (i = 0; m = d3_interpolate_number.exec(b); ++i) {
    if (m.index) s.push(b.substring(s0, s1 = m.index));
    q.push({i: s.length, x: m[0]});
    s.push(null);
    s0 = d3_interpolate_number.lastIndex;
  }
  if (s0 < b.length) s.push(b.substring(s0));

  // Find all numbers in a.
  for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {
    o = q[i];
    if (o.x == m[0]) { // The numbers match, so coallesce.
      if (o.i) {
        if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i - 1] += o.x;
          s.splice(o.i, 1);
          for (j = i + 1; j < n; ++j) q[j].i--;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i - 1] += o.x + s[o.i + 1];
          s.splice(o.i, 2);
          for (j = i + 1; j < n; ++j) q[j].i -= 2;
        }
      } else {
          if (s[o.i + 1] == null) { // This match is followed by another number.
          s[o.i] = o.x;
        } else { // This match is followed by a string, so coallesce twice.
          s[o.i] = o.x + s[o.i + 1];
          s.splice(o.i + 1, 1);
          for (j = i + 1; j < n; ++j) q[j].i--;
        }
      }
      q.splice(i, 1);
      n--;
      i--;
    } else {
      o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));
    }
  }

  // Remove any numbers in b not found in a.
  while (i < n) {
    o = q.pop();
    if (s[o.i + 1] == null) { // This match is followed by another number.
      s[o.i] = o.x;
    } else { // This match is followed by a string, so coallesce twice.
      s[o.i] = o.x + s[o.i + 1];
      s.splice(o.i + 1, 1);
    }
    n--;
  }

  // Special optimization for only a single match.
  if (s.length === 1) {
    return s[0] == null ? q[0].x : function() { return b; };
  }

  // Otherwise, interpolate each of the numbers and rejoin the string.
  return function(t) {
    for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  };
};

d3.interpolateTransform = function(a, b) {
  var s = [], // string constants and placeholders
      q = [], // number interpolators
      n,
      A = d3.transform(a),
      B = d3.transform(b),
      ta = A.translate,
      tb = B.translate,
      ra = A.rotate,
      rb = B.rotate,
      wa = A.skew,
      wb = B.skew,
      ka = A.scale,
      kb = B.scale;

  if (ta[0] != tb[0] || ta[1] != tb[1]) {
    s.push("translate(", null, ",", null, ")");
    q.push({i: 1, x: d3.interpolateNumber(ta[0], tb[0])}, {i: 3, x: d3.interpolateNumber(ta[1], tb[1])});
  } else if (tb[0] || tb[1]) {
    s.push("translate(" + tb + ")");
  } else {
    s.push("");
  }

  if (ra != rb) {
    if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360; // shortest path
    q.push({i: s.push(s.pop() + "rotate(", null, ")") - 2, x: d3.interpolateNumber(ra, rb)});
  } else if (rb) {
    s.push(s.pop() + "rotate(" + rb + ")");
  }

  if (wa != wb) {
    q.push({i: s.push(s.pop() + "skewX(", null, ")") - 2, x: d3.interpolateNumber(wa, wb)});
  } else if (wb) {
    s.push(s.pop() + "skewX(" + wb + ")");
  }

  if (ka[0] != kb[0] || ka[1] != kb[1]) {
    n = s.push(s.pop() + "scale(", null, ",", null, ")");
    q.push({i: n - 4, x: d3.interpolateNumber(ka[0], kb[0])}, {i: n - 2, x: d3.interpolateNumber(ka[1], kb[1])});
  } else if (kb[0] != 1 || kb[1] != 1) {
    s.push(s.pop() + "scale(" + kb + ")");
  }

  n = q.length;
  return function(t) {
    var i = -1, o;
    while (++i < n) s[(o = q[i]).i] = o.x(t);
    return s.join("");
  };
};

d3.interpolateRgb = function(a, b) {
  a = d3.rgb(a);
  b = d3.rgb(b);
  var ar = a.r,
      ag = a.g,
      ab = a.b,
      br = b.r - ar,
      bg = b.g - ag,
      bb = b.b - ab;
  return function(t) {
    return "#"
        + d3_rgb_hex(Math.round(ar + br * t))
        + d3_rgb_hex(Math.round(ag + bg * t))
        + d3_rgb_hex(Math.round(ab + bb * t));
  };
};

// interpolates HSL space, but outputs RGB string (for compatibility)
d3.interpolateHsl = function(a, b) {
  a = d3.hsl(a);
  b = d3.hsl(b);
  var h0 = a.h,
      s0 = a.s,
      l0 = a.l,
      h1 = b.h - h0,
      s1 = b.s - s0,
      l1 = b.l - l0;
  if (h1 > 180) h1 -= 360; else if (h1 < -180) h1 += 360; // shortest path
  return function(t) {
    return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t).toString();
  };
};

d3.interpolateArray = function(a, b) {
  var x = [],
      c = [],
      na = a.length,
      nb = b.length,
      n0 = Math.min(a.length, b.length),
      i;
  for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));
  for (; i < na; ++i) c[i] = a[i];
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < n0; ++i) c[i] = x[i](t);
    return c;
  };
};

d3.interpolateObject = function(a, b) {
  var i = {},
      c = {},
      k;
  for (k in a) {
    if (k in b) {
      i[k] = d3_interpolateByName(k)(a[k], b[k]);
    } else {
      c[k] = a[k];
    }
  }
  for (k in b) {
    if (!(k in a)) {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var d3_interpolate_number = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;

function d3_interpolateByName(n) {
  return n == "transform"
      ? d3.interpolateTransform
      : d3.interpolate;
}

d3.interpolators = [
  d3.interpolateObject,
  function(a, b) { return (b instanceof Array) && d3.interpolateArray(a, b); },
  function(a, b) { return (typeof a === "string" || typeof b === "string") && d3.interpolateString(a + "", b + ""); },
  function(a, b) { return (typeof b === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) : b instanceof d3_Rgb || b instanceof d3_Hsl) && d3.interpolateRgb(a, b); },
  function(a, b) { return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b); }
];
function d3_uninterpolateNumber(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return (x - a) * b; };
}

function d3_uninterpolateClamp(a, b) {
  b = b - (a = +a) ? 1 / (b - a) : 0;
  return function(x) { return Math.max(0, Math.min(1, (x - a) * b)); };
}
d3.rgb = function(r, g, b) {
  return arguments.length === 1
      ? (r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b)
      : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb))
      : d3_rgb(~~r, ~~g, ~~b);
};

function d3_rgb(r, g, b) {
  return new d3_Rgb(r, g, b);
}

function d3_Rgb(r, g, b) {
  this.r = r;
  this.g = g;
  this.b = b;
}

d3_Rgb.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  var r = this.r,
      g = this.g,
      b = this.b,
      i = 30;
  if (!r && !g && !b) return d3_rgb(i, i, i);
  if (r && r < i) r = i;
  if (g && g < i) g = i;
  if (b && b < i) b = i;
  return d3_rgb(
      Math.min(255, Math.floor(r / k)),
      Math.min(255, Math.floor(g / k)),
      Math.min(255, Math.floor(b / k)));
};

d3_Rgb.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_rgb(
      Math.floor(k * this.r),
      Math.floor(k * this.g),
      Math.floor(k * this.b));
};

d3_Rgb.prototype.hsl = function() {
  return d3_rgb_hsl(this.r, this.g, this.b);
};

d3_Rgb.prototype.toString = function() {
  return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
};

function d3_rgb_hex(v) {
  return v < 0x10
      ? "0" + Math.max(0, v).toString(16)
      : Math.min(255, v).toString(16);
}

function d3_rgb_parse(format, rgb, hsl) {
  var r = 0, // red channel; int in [0, 255]
      g = 0, // green channel; int in [0, 255]
      b = 0, // blue channel; int in [0, 255]
      m1, // CSS color specification match
      m2, // CSS color specification type (e.g., rgb)
      name;

  /* Handle hsl, rgb. */
  m1 = /([a-z]+)\((.*)\)/i.exec(format);
  if (m1) {
    m2 = m1[2].split(",");
    switch (m1[1]) {
      case "hsl": {
        return hsl(
          parseFloat(m2[0]), // degrees
          parseFloat(m2[1]) / 100, // percentage
          parseFloat(m2[2]) / 100 // percentage
        );
      }
      case "rgb": {
        return rgb(
          d3_rgb_parseNumber(m2[0]),
          d3_rgb_parseNumber(m2[1]),
          d3_rgb_parseNumber(m2[2])
        );
      }
    }
  }

  /* Named colors. */
  if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);

  /* Hexadecimal colors: #rgb and #rrggbb. */
  if (format != null && format.charAt(0) === "#") {
    if (format.length === 4) {
      r = format.charAt(1); r += r;
      g = format.charAt(2); g += g;
      b = format.charAt(3); b += b;
    } else if (format.length === 7) {
      r = format.substring(1, 3);
      g = format.substring(3, 5);
      b = format.substring(5, 7);
    }
    r = parseInt(r, 16);
    g = parseInt(g, 16);
    b = parseInt(b, 16);
  }

  return rgb(r, g, b);
}

function d3_rgb_hsl(r, g, b) {
  var min = Math.min(r /= 255, g /= 255, b /= 255),
      max = Math.max(r, g, b),
      d = max - min,
      h,
      s,
      l = (max + min) / 2;
  if (d) {
    s = l < .5 ? d / (max + min) : d / (2 - max - min);
    if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
    else if (g == max) h = (b - r) / d + 2;
    else h = (r - g) / d + 4;
    h *= 60;
  } else {
    s = h = 0;
  }
  return d3_hsl(h, s, l);
}

function d3_rgb_parseNumber(c) { // either integer or percentage
  var f = parseFloat(c);
  return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
}

var d3_rgb_names = d3.map({
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
});

d3_rgb_names.forEach(function(key, value) {
  d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));
});
d3.hsl = function(h, s, l) {
  return arguments.length === 1
      ? (h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l)
      : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl))
      : d3_hsl(+h, +s, +l);
};

function d3_hsl(h, s, l) {
  return new d3_Hsl(h, s, l);
}

function d3_Hsl(h, s, l) {
  this.h = h;
  this.s = s;
  this.l = l;
}

d3_Hsl.prototype.brighter = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, this.l / k);
};

d3_Hsl.prototype.darker = function(k) {
  k = Math.pow(0.7, arguments.length ? k : 1);
  return d3_hsl(this.h, this.s, k * this.l);
};

d3_Hsl.prototype.rgb = function() {
  return d3_hsl_rgb(this.h, this.s, this.l);
};

d3_Hsl.prototype.toString = function() {
  return this.rgb().toString();
};

function d3_hsl_rgb(h, s, l) {
  var m1,
      m2;

  /* Some simple corrections for h, s and l. */
  h = h % 360; if (h < 0) h += 360;
  s = s < 0 ? 0 : s > 1 ? 1 : s;
  l = l < 0 ? 0 : l > 1 ? 1 : l;

  /* From FvD 13.37, CSS Color Module Level 3 */
  m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
  m1 = 2 * l - m2;

  function v(h) {
    if (h > 360) h -= 360;
    else if (h < 0) h += 360;
    if (h < 60) return m1 + (m2 - m1) * h / 60;
    if (h < 180) return m2;
    if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
    return m1;
  }

  function vv(h) {
    return Math.round(v(h) * 255);
  }

  return d3_rgb(vv(h + 120), vv(h), vv(h - 120));
}
function d3_selection(groups) {
  d3_arraySubclass(groups, d3_selectionPrototype);
  return groups;
}

var d3_select = function(s, n) { return n.querySelector(s); },
    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },
    d3_selectRoot = document.documentElement,
    d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector,
    d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); };

// Prefer Sizzle, if available.
if (typeof Sizzle === "function") {
  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };
  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };
  d3_selectMatches = Sizzle.matchesSelector;
}

var d3_selectionPrototype = [];

d3.selection = function() {
  return d3_selectionRoot;
};

d3.selection.prototype = d3_selectionPrototype;
d3_selectionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      group,
      node;

  if (typeof selector !== "function") selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(subnode = selector.call(node, node.__data__, i));
        if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selector(selector) {
  return function() {
    return d3_select(selector, this);
  };
}
d3_selectionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      node;

  if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));
        subgroup.parentNode = node;
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selectorAll(selector) {
  return function() {
    return d3_selectAll(selector, this);
  };
}
d3_selectionPrototype.attr = function(name, value) {
  name = d3.ns.qualify(name);

  // If no value is specified, return the first value.
  if (arguments.length < 2) {
    var node = this.node();
    return name.local
        ? node.getAttributeNS(name.space, name.local)
        : node.getAttribute(name);
  }

  function attrNull() {
    this.removeAttribute(name);
  }

  function attrNullNS() {
    this.removeAttributeNS(name.space, name.local);
  }

  function attrConstant() {
    this.setAttribute(name, value);
  }

  function attrConstantNS() {
    this.setAttributeNS(name.space, name.local, value);
  }

  function attrFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttribute(name);
    else this.setAttribute(name, x);
  }

  function attrFunctionNS() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttributeNS(name.space, name.local);
    else this.setAttributeNS(name.space, name.local, x);
  }

  return this.each(value == null
      ? (name.local ? attrNullNS : attrNull) : (typeof value === "function"
      ? (name.local ? attrFunctionNS : attrFunction)
      : (name.local ? attrConstantNS : attrConstant)));
};
d3_selectionPrototype.classed = function(name, value) {
  var names = d3_collapse(name).split(" "),
      n = names.length,
      i = -1;
  if (arguments.length > 1) {
    while (++i < n) d3_selection_classed.call(this, names[i], value);
    return this;
  } else {
    while (++i < n) if (!d3_selection_classed.call(this, names[i])) return false;
    return true;
  }
};

function d3_selection_classed(name, value) {
  var re = new RegExp("(^|\\s+)" + d3.requote(name) + "(\\s+|$)", "g");

  // If no value is specified, return the first value.
  if (arguments.length < 2) {
    var node = this.node();
    if (c = node.classList) return c.contains(name);
    var c = node.className;
    re.lastIndex = 0;
    return re.test(c.baseVal != null ? c.baseVal : c);
  }

  function classedAdd() {
    if (c = this.classList) return c.add(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    re.lastIndex = 0;
    if (!re.test(cv)) {
      cv = d3_collapse(cv + " " + name);
      if (cb) c.baseVal = cv;
      else this.className = cv;
    }
  }

  function classedRemove() {
    if (c = this.classList) return c.remove(name);
    var c = this.className,
        cb = c.baseVal != null,
        cv = cb ? c.baseVal : c;
    cv = d3_collapse(cv.replace(re, " "));
    if (cb) c.baseVal = cv;
    else this.className = cv;
  }

  function classedFunction() {
    (value.apply(this, arguments)
        ? classedAdd
        : classedRemove).call(this);
  }

  return this.each(typeof value === "function"
      ? classedFunction : value
      ? classedAdd
      : classedRemove);
}
d3_selectionPrototype.style = function(name, value, priority) {
  if (arguments.length < 3) priority = "";

  // If no value is specified, return the first value.
  if (arguments.length < 2) return window
      .getComputedStyle(this.node(), null)
      .getPropertyValue(name);

  function styleNull() {
    this.style.removeProperty(name);
  }

  function styleConstant() {
    this.style.setProperty(name, value, priority);
  }

  function styleFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.style.removeProperty(name);
    else this.style.setProperty(name, x, priority);
  }

  return this.each(value == null
      ? styleNull : (typeof value === "function"
      ? styleFunction : styleConstant));
};
d3_selectionPrototype.property = function(name, value) {

  // If no value is specified, return the first value.
  if (arguments.length < 2) return this.node()[name];

  function propertyNull() {
    delete this[name];
  }

  function propertyConstant() {
    this[name] = value;
  }

  function propertyFunction() {
    var x = value.apply(this, arguments);
    if (x == null) delete this[name];
    else this[name] = x;
  }

  return this.each(value == null
      ? propertyNull : (typeof value === "function"
      ? propertyFunction : propertyConstant));
};
d3_selectionPrototype.text = function(value) {
  return arguments.length < 1
      ? this.node().textContent : this.each(typeof value === "function"
      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? "" : v; } : value == null
      ? function() { this.textContent = ""; }
      : function() { this.textContent = value; });
};
d3_selectionPrototype.html = function(value) {
  return arguments.length < 1
      ? this.node().innerHTML : this.each(typeof value === "function"
      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? "" : v; } : value == null
      ? function() { this.innerHTML = ""; }
      : function() { this.innerHTML = value; });
};
// TODO append(node)?
// TODO append(function)?
d3_selectionPrototype.append = function(name) {
  name = d3.ns.qualify(name);

  function append() {
    return this.appendChild(document.createElementNS(this.namespaceURI, name));
  }

  function appendNS() {
    return this.appendChild(document.createElementNS(name.space, name.local));
  }

  return this.select(name.local ? appendNS : append);
};
// TODO insert(node, function)?
// TODO insert(function, string)?
// TODO insert(function, function)?
d3_selectionPrototype.insert = function(name, before) {
  name = d3.ns.qualify(name);

  function insert() {
    return this.insertBefore(
        document.createElementNS(this.namespaceURI, name),
        d3_select(before, this));
  }

  function insertNS() {
    return this.insertBefore(
        document.createElementNS(name.space, name.local),
        d3_select(before, this));
  }

  return this.select(name.local ? insertNS : insert);
};
// TODO remove(selector)?
// TODO remove(node)?
// TODO remove(function)?
d3_selectionPrototype.remove = function() {
  return this.each(function() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  });
};
d3_selectionPrototype.data = function(value, key) {
  var i = -1,
      n = this.length,
      group,
      node;

  // If no value is specified, return the first value.
  if (!arguments.length) {
    value = new Array(n = (group = this[0]).length);
    while (++i < n) {
      if (node = group[i]) {
        value[i] = node.__data__;
      }
    }
    return value;
  }

  function bind(group, groupData) {
    var i,
        n = group.length,
        m = groupData.length,
        n0 = Math.min(n, m),
        n1 = Math.max(n, m),
        updateNodes = [],
        enterNodes = [],
        exitNodes = [],
        node,
        nodeData;

    if (key) {
      var nodeByKeyValue = new d3_Map,
          keyValues = [],
          keyValue,
          j = groupData.length;

      for (i = -1; ++i < n;) {
        keyValue = key.call(node = group[i], node.__data__, i);
        if (nodeByKeyValue.has(keyValue)) {
          exitNodes[j++] = node; // duplicate key
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
        keyValues.push(keyValue);
      }

      for (i = -1; ++i < m;) {
        keyValue = key.call(groupData, nodeData = groupData[i], i)
        if (nodeByKeyValue.has(keyValue)) {
          updateNodes[i] = node = nodeByKeyValue.get(keyValue);
          node.__data__ = nodeData;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
        nodeByKeyValue.remove(keyValue);
      }

      for (i = -1; ++i < n;) {
        if (nodeByKeyValue.has(keyValues[i])) {
          exitNodes[i] = group[i];
        }
      }
    } else {
      for (i = -1; ++i < n0;) {
        node = group[i];
        nodeData = groupData[i];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
          enterNodes[i] = exitNodes[i] = null;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
          updateNodes[i] = exitNodes[i] = null;
        }
      }
      for (; i < m; ++i) {
        enterNodes[i] = d3_selection_dataNode(groupData[i]);
        updateNodes[i] = exitNodes[i] = null;
      }
      for (; i < n1; ++i) {
        exitNodes[i] = group[i];
        enterNodes[i] = updateNodes[i] = null;
      }
    }

    enterNodes.update
        = updateNodes;

    enterNodes.parentNode
        = updateNodes.parentNode
        = exitNodes.parentNode
        = group.parentNode;

    enter.push(enterNodes);
    update.push(updateNodes);
    exit.push(exitNodes);
  }

  var enter = d3_selection_enter([]),
      update = d3_selection([]),
      exit = d3_selection([]);

  if (typeof value === "function") {
    while (++i < n) {
      bind(group = this[i], value.call(group, group.parentNode.__data__, i));
    }
  } else {
    while (++i < n) {
      bind(group = this[i], value);
    }
  }

  update.enter = function() { return enter; };
  update.exit = function() { return exit; };
  return update;
};

function d3_selection_dataNode(data) {
  return {__data__: data};
}
d3_selectionPrototype.datum =
d3_selectionPrototype.map = function(value) {
  return arguments.length < 1
      ? this.property("__data__")
      : this.property("__data__", value);
};
d3_selectionPrototype.filter = function(filter) {
  var subgroups = [],
      subgroup,
      group,
      node;

  if (typeof filter !== "function") filter = d3_selection_filter(filter);

  for (var j = 0, m = this.length; j < m; j++) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = 0, n = group.length; i < n; i++) {
      if ((node = group[i]) && filter.call(node, node.__data__, i)) {
        subgroup.push(node);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_filter(selector) {
  return function() {
    return d3_selectMatches(this, selector);
  };
}
d3_selectionPrototype.order = function() {
  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
};
d3_selectionPrototype.sort = function(comparator) {
  comparator = d3_selection_sortComparator.apply(this, arguments);
  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);
  return this.order();
};

function d3_selection_sortComparator(comparator) {
  if (!arguments.length) comparator = d3.ascending;
  return function(a, b) {
    return comparator(a && a.__data__, b && b.__data__);
  };
}
// type can be namespaced, e.g., "click.foo"
// listener can be null for removal
d3_selectionPrototype.on = function(type, listener, capture) {
  if (arguments.length < 3) capture = false;

  // parse the type specifier
  var name = "__on" + type, i = type.indexOf(".");
  if (i > 0) type = type.substring(0, i);

  // if called with only one argument, return the current listener
  if (arguments.length < 2) return (i = this.node()[name]) && i._;

  // remove the old event listener, and add the new event listener
  return this.each(function(d, i) {
    var node = this,
        o = node[name];

    // remove the old listener, if any (using the previously-set capture)
    if (o) {
      node.removeEventListener(type, o, o.$);
      delete node[name];
    }

    // add the new listener, if any (remembering the capture flag)
    if (listener) {
      node.addEventListener(type, node[name] = l, l.$ = capture);
      l._ = listener; // stash the unwrapped listener for get
    }

    // wrapped event listener that preserves i
    function l(e) {
      var o = d3.event; // Events can be reentrant (e.g., focus).
      d3.event = e;
      try {
        listener.call(node, node.__data__, i);
      } finally {
        d3.event = o;
      }
    }
  });
};
d3_selectionPrototype.each = function(callback) {
  return d3_selection_each(this, function(node, i, j) {
    callback.call(node, node.__data__, i, j);
  });
};

function d3_selection_each(groups, callback) {
  for (var j = 0, m = groups.length; j < m; j++) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
      if (node = group[i]) callback(node, i, j);
    }
  }
  return groups;
}
//
// Note: assigning to the arguments array simultaneously changes the value of
// the corresponding argument!
//
// TODO The `this` argument probably shouldn't be the first argument to the
// callback, anyway, since it's redundant. However, that will require a major
// version bump due to backwards compatibility, so I'm not changing it right
// away.
//
d3_selectionPrototype.call = function(callback) {
  callback.apply(this, (arguments[0] = this, arguments));
  return this;
};
d3_selectionPrototype.empty = function() {
  return !this.node();
};
d3_selectionPrototype.node = function(callback) {
  for (var j = 0, m = this.length; j < m; j++) {
    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
};
d3_selectionPrototype.transition = function() {
  var subgroups = [],
      subgroup,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      subgroup.push((node = group[i]) ? {node: node, delay: d3_transitionDelay, duration: d3_transitionDuration} : null);
    }
  }

  return d3_transition(subgroups, d3_transitionId || ++d3_transitionNextId, Date.now());
};
var d3_selectionRoot = d3_selection([[document]]);

d3_selectionRoot[0].parentNode = d3_selectRoot;

// TODO fast singleton implementation!
// TODO select(function)
d3.select = function(selector) {
  return typeof selector === "string"
      ? d3_selectionRoot.select(selector)
      : d3_selection([[selector]]); // assume node
};

// TODO selectAll(function)
d3.selectAll = function(selector) {
  return typeof selector === "string"
      ? d3_selectionRoot.selectAll(selector)
      : d3_selection([d3_array(selector)]); // assume node[]
};
function d3_selection_enter(selection) {
  d3_arraySubclass(selection, d3_selection_enterPrototype);
  return selection;
}

var d3_selection_enterPrototype = [];

d3.selection.enter = d3_selection_enter;
d3.selection.enter.prototype = d3_selection_enterPrototype;

d3_selection_enterPrototype.append = d3_selectionPrototype.append;
d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;
d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
d3_selection_enterPrototype.node = d3_selectionPrototype.node;
d3_selection_enterPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      upgroup,
      group,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    upgroup = (group = this[j]).update;
    subgroups.push(subgroup = []);
    subgroup.parentNode = group.parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));
        subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};
function d3_transition(groups, id, time) {
  d3_arraySubclass(groups, d3_transitionPrototype);

  var tweens = new d3_Map,
      event = d3.dispatch("start", "end"),
      ease = d3_transitionEase;

  groups.id = id;

  groups.time = time;

  groups.tween = function(name, tween) {
    if (arguments.length < 2) return tweens.get(name);
    if (tween == null) tweens.remove(name);
    else tweens.set(name, tween);
    return groups;
  };

  groups.ease = function(value) {
    if (!arguments.length) return ease;
    ease = typeof value === "function" ? value : d3.ease.apply(d3, arguments);
    return groups;
  };

  groups.each = function(type, listener) {
    if (arguments.length < 2) return d3_transition_each.call(groups, type);
    event.on(type, listener);
    return groups;
  };

  d3.timer(function(elapsed) {
    return d3_selection_each(groups, function(node, i, j) {
      var tweened = [],
          delay = node.delay,
          duration = node.duration,
          lock = (node = node.node).__transition__ || (node.__transition__ = {active: 0, count: 0}),
          d = node.__data__;

      ++lock.count;

      delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time);

      function start(elapsed) {
        if (lock.active > id) return stop();
        lock.active = id;

        tweens.forEach(function(key, value) {
          if (value = value.call(node, d, i)) {
            tweened.push(value);
          }
        });

        event.start.call(node, d, i);
        if (!tick(elapsed)) d3.timer(tick, 0, time);
        return 1;
      }

      function tick(elapsed) {
        if (lock.active !== id) return stop();

        var t = (elapsed - delay) / duration,
            e = ease(t),
            n = tweened.length;

        while (n > 0) {
          tweened[--n].call(node, e);
        }

        if (t >= 1) {
          stop();
          d3_transitionId = id;
          event.end.call(node, d, i);
          d3_transitionId = 0;
          return 1;
        }
      }

      function stop() {
        if (!--lock.count) delete node.__transition__;
        return 1;
      }
    });
  }, 0, time);

  return groups;
}

var d3_transitionRemove = {};

function d3_transitionNull(d, i, a) {
  return a != "" && d3_transitionRemove;
}

function d3_transitionTween(name, b) {
  var interpolate = d3_interpolateByName(name);

  function transitionFunction(d, i, a) {
    var v = b.call(this, d, i);
    return v == null
        ? a != "" && d3_transitionRemove
        : a != v && interpolate(a, v);
  }

  function transitionString(d, i, a) {
    return a != b && interpolate(a, b);
  }

  return typeof b === "function" ? transitionFunction
      : b == null ? d3_transitionNull
      : (b += "", transitionString);
}

var d3_transitionPrototype = [],
    d3_transitionNextId = 0,
    d3_transitionId = 0,
    d3_transitionDefaultDelay = 0,
    d3_transitionDefaultDuration = 250,
    d3_transitionDefaultEase = d3.ease("cubic-in-out"),
    d3_transitionDelay = d3_transitionDefaultDelay,
    d3_transitionDuration = d3_transitionDefaultDuration,
    d3_transitionEase = d3_transitionDefaultEase;

d3_transitionPrototype.call = d3_selectionPrototype.call;

d3.transition = function(selection) {
  return arguments.length
      ? (d3_transitionId ? selection.transition() : selection)
      : d3_selectionRoot.transition();
};

d3.transition.prototype = d3_transitionPrototype;
d3_transitionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      node;

  if (typeof selector !== "function") selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if ((node = group[i]) && (subnode = selector.call(node.node, node.node.__data__, i))) {
        if ("__data__" in node.node) subnode.__data__ = node.node.__data__;
        subgroup.push({node: subnode, delay: node.delay, duration: node.duration});
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      subnodes,
      node;

  if (typeof selector !== "function") selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subnodes = selector.call(node.node, node.node.__data__, i);
        subgroups.push(subgroup = []);
        for (var k = -1, o = subnodes.length; ++k < o;) {
          subgroup.push({node: subnodes[k], delay: node.delay, duration: node.duration});
        }
      }
    }
  }

  return d3_transition(subgroups, this.id, this.time).ease(this.ease());
};
d3_transitionPrototype.attr = function(name, value) {
  return this.attrTween(name, d3_transitionTween(name, value));
};

d3_transitionPrototype.attrTween = function(nameNS, tween) {
  var name = d3.ns.qualify(nameNS);

  function attrTween(d, i) {
    var f = tween.call(this, d, i, this.getAttribute(name));
    return f === d3_transitionRemove
        ? (this.removeAttribute(name), null)
        : f && function(t) { this.setAttribute(name, f(t)); };
  }

  function attrTweenNS(d, i) {
    var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
    return f === d3_transitionRemove
        ? (this.removeAttributeNS(name.space, name.local), null)
        : f && function(t) { this.setAttributeNS(name.space, name.local, f(t)); };
  }

  return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
};
d3_transitionPrototype.style = function(name, value, priority) {
  if (arguments.length < 3) priority = "";
  return this.styleTween(name, d3_transitionTween(name, value), priority);
};

d3_transitionPrototype.styleTween = function(name, tween, priority) {
  if (arguments.length < 3) priority = "";
  return this.tween("style." + name, function(d, i) {
    var f = tween.call(this, d, i, window.getComputedStyle(this, null).getPropertyValue(name));
    return f === d3_transitionRemove
        ? (this.style.removeProperty(name), null)
        : f && function(t) { this.style.setProperty(name, f(t), priority); };
  });
};
d3_transitionPrototype.text = function(value) {
  return this.tween("text", function(d, i) {
    this.textContent = typeof value === "function"
        ? value.call(this, d, i)
        : value;
  });
};
d3_transitionPrototype.remove = function() {
  return this.each("end.transition", function() {
    var p;
    if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);
  });
};
d3_transitionPrototype.delay = function(value) {
  return d3_selection_each(this, typeof value === "function"
      ? function(node, i, j) { node.delay = value.call(node = node.node, node.__data__, i, j) | 0; }
      : (value = value | 0, function(node) { node.delay = value; }));
};
d3_transitionPrototype.duration = function(value) {
  return d3_selection_each(this, typeof value === "function"
      ? function(node, i, j) { node.duration = Math.max(1, value.call(node = node.node, node.__data__, i, j) | 0); }
      : (value = Math.max(1, value | 0), function(node) { node.duration = value; }));
};
function d3_transition_each(callback) {
  var id = d3_transitionId,
      ease = d3_transitionEase,
      delay = d3_transitionDelay,
      duration = d3_transitionDuration;

  d3_transitionId = this.id;
  d3_transitionEase = this.ease();
  d3_selection_each(this, function(node, i, j) {
    d3_transitionDelay = node.delay;
    d3_transitionDuration = node.duration;
    callback.call(node = node.node, node.__data__, i, j);
  });

  d3_transitionId = id;
  d3_transitionEase = ease;
  d3_transitionDelay = delay;
  d3_transitionDuration = duration;
  return this;
}
d3_transitionPrototype.transition = function() {
  return this.select(d3_this);
};
var d3_timer_queue = null,
    d3_timer_interval, // is an interval (or frame) active?
    d3_timer_timeout; // is a timeout active?

// The timer will continue to fire until callback returns true.
d3.timer = function(callback, delay, then) {
  var found = false,
      t0,
      t1 = d3_timer_queue;

  if (arguments.length < 3) {
    if (arguments.length < 2) delay = 0;
    else if (!isFinite(delay)) return;
    then = Date.now();
  }

  // See if the callback's already in the queue.
  while (t1) {
    if (t1.callback === callback) {
      t1.then = then;
      t1.delay = delay;
      found = true;
      break;
    }
    t0 = t1;
    t1 = t1.next;
  }

  // Otherwise, add the callback to the queue.
  if (!found) d3_timer_queue = {
    callback: callback,
    then: then,
    delay: delay,
    next: d3_timer_queue
  };

  // Start animatin'!
  if (!d3_timer_interval) {
    d3_timer_timeout = clearTimeout(d3_timer_timeout);
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

function d3_timer_step() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  var delay = d3_timer_flush() - now;
  if (delay > 24) {
    if (isFinite(delay)) {
      clearTimeout(d3_timer_timeout);
      d3_timer_timeout = setTimeout(d3_timer_step, delay);
    }
    d3_timer_interval = 0;
  } else {
    d3_timer_interval = 1;
    d3_timer_frame(d3_timer_step);
  }
}

d3.timer.flush = function() {
  var elapsed,
      now = Date.now(),
      t1 = d3_timer_queue;

  while (t1) {
    elapsed = now - t1.then;
    if (!t1.delay) t1.flush = t1.callback(elapsed);
    t1 = t1.next;
  }

  d3_timer_flush();
};

// Flush after callbacks, to avoid concurrent queue modification.
function d3_timer_flush() {
  var t0 = null,
      t1 = d3_timer_queue,
      then = Infinity;
  while (t1) {
    if (t1.flush) {
      t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;
    } else {
      then = Math.min(then, t1.then + t1.delay);
      t1 = (t0 = t1).next;
    }
  }
  return then;
}

var d3_timer_frame = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.oRequestAnimationFrame
    || window.msRequestAnimationFrame
    || function(callback) { setTimeout(callback, 17); };
d3.transform = function(string) {
  var g = document.createElementNS(d3.ns.prefix.svg, "g"),
      identity = {a: 1, b: 0, c: 0, d: 1, e: 0, f: 0};
  return (d3.transform = function(string) {
    g.setAttribute("transform", string);
    var t = g.transform.baseVal.consolidate();
    return new d3_transform(t ? t.matrix : identity);
  })(string);
};

// Compute x-scale and normalize the first row.
// Compute shear and make second row orthogonal to first.
// Compute y-scale and normalize the second row.
// Finally, compute the rotation.
function d3_transform(m) {
  var r0 = [m.a, m.b],
      r1 = [m.c, m.d],
      kx = d3_transformNormalize(r0),
      kz = d3_transformDot(r0, r1),
      ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
  if (r0[0] * r1[1] < r1[0] * r0[1]) {
    r0[0] *= -1;
    r0[1] *= -1;
    kx *= -1;
    kz *= -1;
  }
  this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_transformDegrees;
  this.translate = [m.e, m.f];
  this.scale = [kx, ky];
  this.skew = ky ? Math.atan2(kz, ky) * d3_transformDegrees : 0;
};

d3_transform.prototype.toString = function() {
  return "translate(" + this.translate
      + ")rotate(" + this.rotate
      + ")skewX(" + this.skew
      + ")scale(" + this.scale
      + ")";
};

function d3_transformDot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

function d3_transformNormalize(a) {
  var k = Math.sqrt(d3_transformDot(a, a));
  if (k) {
    a[0] /= k;
    a[1] /= k;
  }
  return k;
}

function d3_transformCombine(a, b, k) {
  a[0] += k * b[0];
  a[1] += k * b[1];
  return a;
}

var d3_transformDegrees = 180 / Math.PI;
d3.mouse = function(container) {
  return d3_mousePoint(container, d3_eventSource());
};

// https://bugs.webkit.org/show_bug.cgi?id=44083
var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;

function d3_mousePoint(container, e) {
  var svg = container.ownerSVGElement || container;
  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    if ((d3_mouse_bug44083 < 0) && (window.scrollX || window.scrollY)) {
      svg = d3.select(document.body)
        .append("svg")
          .style("position", "absolute")
          .style("top", 0)
          .style("left", 0);
      var ctm = svg[0][0].getScreenCTM();
      d3_mouse_bug44083 = !(ctm.f || ctm.e);
      svg.remove();
    }
    if (d3_mouse_bug44083) {
      point.x = e.pageX;
      point.y = e.pageY;
    } else {
      point.x = e.clientX;
      point.y = e.clientY;
    }
    point = point.matrixTransform(container.getScreenCTM().inverse());
    return [point.x, point.y];
  }
  var rect = container.getBoundingClientRect();
  return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
};
d3.touches = function(container, touches) {
  if (arguments.length < 2) touches = d3_eventSource().touches;
  return touches ? d3_array(touches).map(function(touch) {
    var point = d3_mousePoint(container, touch);
    point.identifier = touch.identifier;
    return point;
  }) : [];
};
function d3_noop() {}
d3.scale = {};

function d3_scaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}

function d3_scaleRange(scale) {
  return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
}
function d3_scale_nice(domain, nice) {
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      dx;

  if (x1 < x0) {
    dx = i0; i0 = i1; i1 = dx;
    dx = x0; x0 = x1; x1 = dx;
  }

  if (dx = x1 - x0) {
    nice = nice(dx);
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
  }

  return domain;
}

function d3_scale_niceDefault() {
  return Math;
}
d3.scale.linear = function() {
  return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);
};

function d3_scale_linear(domain, range, interpolate, clamp) {
  var output,
      input;

  function rescale() {
    var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
        uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
    output = linear(domain, range, uninterpolate, interpolate);
    input = linear(range, domain, uninterpolate, d3.interpolate);
    return scale;
  }

  function scale(x) {
    return output(x);
  }

  // Note: requires range is coercible to number!
  scale.invert = function(y) {
    return input(y);
  };

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.map(Number);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.rangeRound = function(x) {
    return scale.range(x).interpolate(d3.interpolateRound);
  };

  scale.clamp = function(x) {
    if (!arguments.length) return clamp;
    clamp = x;
    return rescale();
  };

  scale.interpolate = function(x) {
    if (!arguments.length) return interpolate;
    interpolate = x;
    return rescale();
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(domain, m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(domain, m);
  };

  scale.nice = function() {
    d3_scale_nice(domain, d3_scale_linearNice);
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_linear(domain, range, interpolate, clamp);
  };

  return rescale();
}

function d3_scale_linearRebind(scale, linear) {
  return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
}

function d3_scale_linearNice(dx) {
  dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);
  return {
    floor: function(x) { return Math.floor(x / dx) * dx; },
    ceil: function(x) { return Math.ceil(x / dx) * dx; }
  };
}

function d3_scale_linearTickRange(domain, m) {
  var extent = d3_scaleExtent(domain),
      span = extent[1] - extent[0],
      step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
      err = m / span * step;

  // Filter ticks to get closer to the desired count.
  if (err <= .15) step *= 10;
  else if (err <= .35) step *= 5;
  else if (err <= .75) step *= 2;

  // Round start and stop values to step interval.
  extent[0] = Math.ceil(extent[0] / step) * step;
  extent[1] = Math.floor(extent[1] / step) * step + step * .5; // inclusive
  extent[2] = step;
  return extent;
}

function d3_scale_linearTicks(domain, m) {
  return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
}

function d3_scale_linearTickFormat(domain, m) {
  return d3.format(",." + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + "f");
}
function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
  var u = uninterpolate(domain[0], domain[1]),
      i = interpolate(range[0], range[1]);
  return function(x) {
    return i(u(x));
  };
}
function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
  var u = [],
      i = [],
      j = 0,
      k = Math.min(domain.length, range.length) - 1;

  // Handle descending domains.
  if (domain[k] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++j <= k) {
    u.push(uninterpolate(domain[j - 1], domain[j]));
    i.push(interpolate(range[j - 1], range[j]));
  }

  return function(x) {
    var j = d3.bisect(domain, x, 1, k) - 1;
    return i[j](u[j](x));
  };
}
d3.scale.log = function() {
  return d3_scale_log(d3.scale.linear(), d3_scale_logp);
};

function d3_scale_log(linear, log) {
  var pow = log.pow;

  function scale(x) {
    return linear(log(x));
  }

  scale.invert = function(x) {
    return pow(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(pow);
    log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;
    pow = log.pow;
    linear.domain(x.map(log));
    return scale;
  };

  scale.nice = function() {
    linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));
    return scale;
  };

  scale.ticks = function() {
    var extent = d3_scaleExtent(linear.domain()),
        ticks = [];
    if (extent.every(isFinite)) {
      var i = Math.floor(extent[0]),
          j = Math.ceil(extent[1]),
          u = pow(extent[0]),
          v = pow(extent[1]);
      if (log === d3_scale_logn) {
        ticks.push(pow(i));
        for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);
      } else {
        for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);
        ticks.push(pow(i));
      }
      for (i = 0; ticks[i] < u; i++) {} // strip small values
      for (j = ticks.length; ticks[j - 1] > v; j--) {} // strip big values
      ticks = ticks.slice(i, j);
    }
    return ticks;
  };

  scale.tickFormat = function(n, format) {
    if (arguments.length < 2) format = d3_scale_logFormat;
    if (arguments.length < 1) return format;
    var k = Math.max(.1, n / scale.ticks().length),
        f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil),
        e;
    return function(d) {
      return d / pow(f(log(d) + e)) <= k ? format(d) : "";
    };
  };

  scale.copy = function() {
    return d3_scale_log(linear.copy(), log);
  };

  return d3_scale_linearRebind(scale, linear);
}

var d3_scale_logFormat = d3.format(".0e");

function d3_scale_logp(x) {
  return Math.log(x < 0 ? 0 : x) / Math.LN10;
}

function d3_scale_logn(x) {
  return -Math.log(x > 0 ? 0 : -x) / Math.LN10;
}

d3_scale_logp.pow = function(x) {
  return Math.pow(10, x);
};

d3_scale_logn.pow = function(x) {
  return -Math.pow(10, -x);
};
d3.scale.pow = function() {
  return d3_scale_pow(d3.scale.linear(), 1);
};

function d3_scale_pow(linear, exponent) {
  var powp = d3_scale_powPow(exponent),
      powb = d3_scale_powPow(1 / exponent);

  function scale(x) {
    return linear(powp(x));
  }

  scale.invert = function(x) {
    return powb(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(powb);
    linear.domain(x.map(powp));
    return scale;
  };

  scale.ticks = function(m) {
    return d3_scale_linearTicks(scale.domain(), m);
  };

  scale.tickFormat = function(m) {
    return d3_scale_linearTickFormat(scale.domain(), m);
  };

  scale.nice = function() {
    return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));
  };

  scale.exponent = function(x) {
    if (!arguments.length) return exponent;
    var domain = scale.domain();
    powp = d3_scale_powPow(exponent = x);
    powb = d3_scale_powPow(1 / exponent);
    return scale.domain(domain);
  };

  scale.copy = function() {
    return d3_scale_pow(linear.copy(), exponent);
  };

  return d3_scale_linearRebind(scale, linear);
}

function d3_scale_powPow(e) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
  };
}
d3.scale.sqrt = function() {
  return d3.scale.pow().exponent(.5);
};
d3.scale.ordinal = function() {
  return d3_scale_ordinal([], {t: "range", x: []});
};

function d3_scale_ordinal(domain, ranger) {
  var index,
      range,
      rangeBand;

  function scale(x) {
    return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];
  }

  function steps(start, step) {
    return d3.range(domain.length).map(function(i) { return start + step * i; });
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = [];
    index = new d3_Map;
    var i = -1, n = x.length, xi;
    while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
    return scale[ranger.t](ranger.x, ranger.p);
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    rangeBand = 0;
    ranger = {t: "range", x: x};
    return scale;
  };

  scale.rangePoints = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var start = x[0],
        stop = x[1],
        step = (stop - start) / (domain.length - 1 + padding);
    range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);
    rangeBand = 0;
    ranger = {t: "rangePoints", x: x, p: padding};
    return scale;
  };

  scale.rangeBands = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var reverse = x[1] < x[0],
        start = x[reverse - 0],
        stop = x[1 - reverse],
        step = (stop - start) / (domain.length + padding);
    range = steps(start + step * padding, step);
    if (reverse) range.reverse();
    rangeBand = step * (1 - padding);
    ranger = {t: "rangeBands", x: x, p: padding};
    return scale;
  };

  scale.rangeRoundBands = function(x, padding) {
    if (arguments.length < 2) padding = 0;
    var reverse = x[1] < x[0],
        start = x[reverse - 0],
        stop = x[1 - reverse],
        step = Math.floor((stop - start) / (domain.length + padding)),
        error = stop - start - (domain.length - padding) * step;
    range = steps(start + Math.round(error / 2), step);
    if (reverse) range.reverse();
    rangeBand = Math.round(step * (1 - padding));
    ranger = {t: "rangeRoundBands", x: x, p: padding};
    return scale;
  };

  scale.rangeBand = function() {
    return rangeBand;
  };

  scale.rangeExtent = function() {
    return d3_scaleExtent(ranger.x);
  };

  scale.copy = function() {
    return d3_scale_ordinal(domain, ranger);
  };

  return scale.domain(domain);
}
/*
 * This product includes color specifications and designs developed by Cynthia
 * Brewer (http://colorbrewer.org/). See lib/colorbrewer for more information.
 */

d3.scale.category10 = function() {
  return d3.scale.ordinal().range(d3_category10);
};

d3.scale.category20 = function() {
  return d3.scale.ordinal().range(d3_category20);
};

d3.scale.category20b = function() {
  return d3.scale.ordinal().range(d3_category20b);
};

d3.scale.category20c = function() {
  return d3.scale.ordinal().range(d3_category20c);
};

var d3_category10 = [
  "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
  "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"
];

var d3_category20 = [
  "#1f77b4", "#aec7e8",
  "#ff7f0e", "#ffbb78",
  "#2ca02c", "#98df8a",
  "#d62728", "#ff9896",
  "#9467bd", "#c5b0d5",
  "#8c564b", "#c49c94",
  "#e377c2", "#f7b6d2",
  "#7f7f7f", "#c7c7c7",
  "#bcbd22", "#dbdb8d",
  "#17becf", "#9edae5"
];

var d3_category20b = [
  "#393b79", "#5254a3", "#6b6ecf", "#9c9ede",
  "#637939", "#8ca252", "#b5cf6b", "#cedb9c",
  "#8c6d31", "#bd9e39", "#e7ba52", "#e7cb94",
  "#843c39", "#ad494a", "#d6616b", "#e7969c",
  "#7b4173", "#a55194", "#ce6dbd", "#de9ed6"
];

var d3_category20c = [
  "#3182bd", "#6baed6", "#9ecae1", "#c6dbef",
  "#e6550d", "#fd8d3c", "#fdae6b", "#fdd0a2",
  "#31a354", "#74c476", "#a1d99b", "#c7e9c0",
  "#756bb1", "#9e9ac8", "#bcbddc", "#dadaeb",
  "#636363", "#969696", "#bdbdbd", "#d9d9d9"
];
d3.scale.quantile = function() {
  return d3_scale_quantile([], []);
};

function d3_scale_quantile(domain, range) {
  var thresholds;

  function rescale() {
    var k = 0,
        n = domain.length,
        q = range.length;
    thresholds = [];
    while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
    return scale;
  }

  function scale(x) {
    if (isNaN(x = +x)) return NaN;
    return range[d3.bisect(thresholds, x)];
  }

  scale.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x.filter(function(d) { return !isNaN(d); }).sort(d3.ascending);
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.quantiles = function() {
    return thresholds;
  };

  scale.copy = function() {
    return d3_scale_quantile(domain, range); // copy on write!
  };

  return rescale();
}
d3.scale.quantize = function() {
  return d3_scale_quantize(0, 1, [0, 1]);
};

function d3_scale_quantize(x0, x1, range) {
  var kx, i;

  function scale(x) {
    return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
  }

  function rescale() {
    kx = range.length / (x1 - x0);
    i = range.length - 1;
    return scale;
  }

  scale.domain = function(x) {
    if (!arguments.length) return [x0, x1];
    x0 = +x[0];
    x1 = +x[x.length - 1];
    return rescale();
  };

  scale.range = function(x) {
    if (!arguments.length) return range;
    range = x;
    return rescale();
  };

  scale.copy = function() {
    return d3_scale_quantize(x0, x1, range); // copy on write
  };

  return rescale();
}
d3.scale.identity = function() {
  return d3_scale_identity([0, 1]);
};

function d3_scale_identity(domain) {

  function identity(x) { return +x; }

  identity.invert = identity;

  identity.domain = identity.range = function(x) {
    if (!arguments.length) return domain;
    domain = x.map(identity);
    return identity;
  };

  identity.ticks = function(m) {
    return d3_scale_linearTicks(domain, m);
  };

  identity.tickFormat = function(m) {
    return d3_scale_linearTickFormat(domain, m);
  };

  identity.copy = function() {
    return d3_scale_identity(domain);
  };

  return identity;
}
d3.svg = {};
d3.svg.arc = function() {
  var innerRadius = d3_svg_arcInnerRadius,
      outerRadius = d3_svg_arcOuterRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  function arc() {
    var r0 = innerRadius.apply(this, arguments),
        r1 = outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,
        a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,
        da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),
        df = da < Math.PI ? "0" : "1",
        c0 = Math.cos(a0),
        s0 = Math.sin(a0),
        c1 = Math.cos(a1),
        s1 = Math.sin(a1);
    return da >= d3_svg_arcMax
      ? (r0
      ? "M0," + r1
      + "A" + r1 + "," + r1 + " 0 1,1 0," + (-r1)
      + "A" + r1 + "," + r1 + " 0 1,1 0," + r1
      + "M0," + r0
      + "A" + r0 + "," + r0 + " 0 1,0 0," + (-r0)
      + "A" + r0 + "," + r0 + " 0 1,0 0," + r0
      + "Z"
      : "M0," + r1
      + "A" + r1 + "," + r1 + " 0 1,1 0," + (-r1)
      + "A" + r1 + "," + r1 + " 0 1,1 0," + r1
      + "Z")
      : (r0
      ? "M" + r1 * c0 + "," + r1 * s0
      + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1
      + "L" + r0 * c1 + "," + r0 * s1
      + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0
      + "Z"
      : "M" + r1 * c0 + "," + r1 * s0
      + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1
      + "L0,0"
      + "Z");
  }

  arc.innerRadius = function(v) {
    if (!arguments.length) return innerRadius;
    innerRadius = d3_functor(v);
    return arc;
  };

  arc.outerRadius = function(v) {
    if (!arguments.length) return outerRadius;
    outerRadius = d3_functor(v);
    return arc;
  };

  arc.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3_functor(v);
    return arc;
  };

  arc.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3_functor(v);
    return arc;
  };

  arc.centroid = function() {
    var r = (innerRadius.apply(this, arguments)
        + outerRadius.apply(this, arguments)) / 2,
        a = (startAngle.apply(this, arguments)
        + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  return arc;
};

var d3_svg_arcOffset = -Math.PI / 2,
    d3_svg_arcMax = 2 * Math.PI - 1e-6;

function d3_svg_arcInnerRadius(d) {
  return d.innerRadius;
}

function d3_svg_arcOuterRadius(d) {
  return d.outerRadius;
}

function d3_svg_arcStartAngle(d) {
  return d.startAngle;
}

function d3_svg_arcEndAngle(d) {
  return d.endAngle;
}
function d3_svg_line(projection) {
  var x = d3_svg_lineX,
      y = d3_svg_lineY,
      defined = d3_true,
      interpolate = d3_svg_lineInterpolatorDefault,
      interpolator = d3_svg_lineLinear,
      tension = .7;

  function line(data) {
    var segments = [],
        points = [],
        i = -1,
        n = data.length,
        d,
        fx = d3_functor(x),
        fy = d3_functor(y);

    function segment() {
      segments.push("M", interpolator(projection(points), tension));
    }

    while (++i < n) {
      if (defined.call(this, d = data[i], i)) {
        points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
      } else if (points.length) {
        segment();
        points = [];
      }
    }

    if (points.length) segment();

    return segments.length ? segments.join("") : null;
  }

  line.x = function(_) {
    if (!arguments.length) return x;
    x = _;
    return line;
  };

  line.y = function(_) {
    if (!arguments.length) return y;
    y = _;
    return line;
  };

  line.defined  = function(_) {
    if (!arguments.length) return defined;
    defined = _;
    return line;
  };

  line.interpolate = function(_) {
    if (!arguments.length) return interpolate;
    if (!d3_svg_lineInterpolators.has(_ += "")) _ = d3_svg_lineInterpolatorDefault;
    interpolator = d3_svg_lineInterpolators.get(interpolate = _);
    return line;
  };

  line.tension = function(_) {
    if (!arguments.length) return tension;
    tension = _;
    return line;
  };

  return line;
}

d3.svg.line = function() {
  return d3_svg_line(d3_identity);
};

// The default `x` property, which references d[0].
function d3_svg_lineX(d) {
  return d[0];
}

// The default `y` property, which references d[1].
function d3_svg_lineY(d) {
  return d[1];
}

var d3_svg_lineInterpolatorDefault = "linear";

// The various interpolators supported by the `line` class.
var d3_svg_lineInterpolators = d3.map({
  "linear": d3_svg_lineLinear,
  "step-before": d3_svg_lineStepBefore,
  "step-after": d3_svg_lineStepAfter,
  "basis": d3_svg_lineBasis,
  "basis-open": d3_svg_lineBasisOpen,
  "basis-closed": d3_svg_lineBasisClosed,
  "bundle": d3_svg_lineBundle,
  "cardinal": d3_svg_lineCardinal,
  "cardinal-open": d3_svg_lineCardinalOpen,
  "cardinal-closed": d3_svg_lineCardinalClosed,
  "monotone": d3_svg_lineMonotone
});

// Linear interpolation; generates "L" commands.
function d3_svg_lineLinear(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("L", (p = points[i])[0], ",", p[1]);
  return path.join("");
}

// Step interpolation; generates "H" and "V" commands.
function d3_svg_lineStepBefore(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
  return path.join("");
}

// Step interpolation; generates "H" and "V" commands.
function d3_svg_lineStepAfter(points) {
  var i = 0,
      n = points.length,
      p = points[0],
      path = [p[0], ",", p[1]];
  while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
  return path.join("");
}

// Open cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinalOpen(points, tension) {
  return points.length < 4
      ? d3_svg_lineLinear(points)
      : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1),
        d3_svg_lineCardinalTangents(points, tension));
}

// Closed cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinalClosed(points, tension) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite((points.push(points[0]), points),
        d3_svg_lineCardinalTangents([points[points.length - 2]]
        .concat(points, [points[1]]), tension));
}

// Cardinal spline interpolation; generates "C" commands.
function d3_svg_lineCardinal(points, tension, closed) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite(points,
        d3_svg_lineCardinalTangents(points, tension));
}

// Hermite spline construction; generates "C" commands.
function d3_svg_lineHermite(points, tangents) {
  if (tangents.length < 1
      || (points.length != tangents.length
      && points.length != tangents.length + 2)) {
    return d3_svg_lineLinear(points);
  }

  var quad = points.length != tangents.length,
      path = "",
      p0 = points[0],
      p = points[1],
      t0 = tangents[0],
      t = t0,
      pi = 1;

  if (quad) {
    path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3)
        + "," + p[0] + "," + p[1];
    p0 = points[1];
    pi = 2;
  }

  if (tangents.length > 1) {
    t = tangents[1];
    p = points[pi];
    pi++;
    path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1])
        + "," + (p[0] - t[0]) + "," + (p[1] - t[1])
        + "," + p[0] + "," + p[1];
    for (var i = 2; i < tangents.length; i++, pi++) {
      p = points[pi];
      t = tangents[i];
      path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1])
          + "," + p[0] + "," + p[1];
    }
  }

  if (quad) {
    var lp = points[pi];
    path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3)
        + "," + lp[0] + "," + lp[1];
  }

  return path;
}

// Generates tangents for a cardinal spline.
function d3_svg_lineCardinalTangents(points, tension) {
  var tangents = [],
      a = (1 - tension) / 2,
      p0,
      p1 = points[0],
      p2 = points[1],
      i = 1,
      n = points.length;
  while (++i < n) {
    p0 = p1;
    p1 = p2;
    p2 = points[i];
    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
  }
  return tangents;
}

// B-spline interpolation; generates "C" commands.
function d3_svg_lineBasis(points) {
  if (points.length < 3) return d3_svg_lineLinear(points);
  var i = 1,
      n = points.length,
      pi = points[0],
      x0 = pi[0],
      y0 = pi[1],
      px = [x0, x0, x0, (pi = points[1])[0]],
      py = [y0, y0, y0, pi[1]],
      path = [x0, ",", y0];
  d3_svg_lineBasisBezier(path, px, py);
  while (++i < n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  i = -1;
  while (++i < 2) {
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

// Open B-spline interpolation; generates "C" commands.
function d3_svg_lineBasisOpen(points) {
  if (points.length < 4) return d3_svg_lineLinear(points);
  var path = [],
      i = -1,
      n = points.length,
      pi,
      px = [0],
      py = [0];
  while (++i < 3) {
    pi = points[i];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px)
    + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
  --i; while (++i < n) {
    pi = points[i];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

// Closed B-spline interpolation; generates "C" commands.
function d3_svg_lineBasisClosed(points) {
  var path,
      i = -1,
      n = points.length,
      m = n + 4,
      pi,
      px = [],
      py = [];
  while (++i < 4) {
    pi = points[i % n];
    px.push(pi[0]);
    py.push(pi[1]);
  }
  path = [
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",",
    d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
  ];
  --i; while (++i < m) {
    pi = points[i % n];
    px.shift(); px.push(pi[0]);
    py.shift(); py.push(pi[1]);
    d3_svg_lineBasisBezier(path, px, py);
  }
  return path.join("");
}

function d3_svg_lineBundle(points, tension) {
  var n = points.length - 1;
  if (n) {
    var x0 = points[0][0],
        y0 = points[0][1],
        dx = points[n][0] - x0,
        dy = points[n][1] - y0,
        i = -1,
        p,
        t;
    while (++i <= n) {
      p = points[i];
      t = i / n;
      p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
      p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
    }
  }
  return d3_svg_lineBasis(points);
}

// Returns the dot product of the given four-element vectors.
function d3_svg_lineDot4(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

// Matrix to transform basis (b-spline) control points to bezier
// control points. Derived from FvD 11.2.8.
var d3_svg_lineBasisBezier1 = [0, 2/3, 1/3, 0],
    d3_svg_lineBasisBezier2 = [0, 1/3, 2/3, 0],
    d3_svg_lineBasisBezier3 = [0, 1/6, 2/3, 1/6];

// Pushes a "C" Bézier curve onto the specified path array, given the
// two specified four-element arrays which define the control points.
function d3_svg_lineBasisBezier(path, x, y) {
  path.push(
      "C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x),
      ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
}

// Computes the slope from points p0 to p1.
function d3_svg_lineSlope(p0, p1) {
  return (p1[1] - p0[1]) / (p1[0] - p0[0]);
}

// Compute three-point differences for the given points.
// http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference
function d3_svg_lineFiniteDifferences(points) {
  var i = 0,
      j = points.length - 1,
      m = [],
      p0 = points[0],
      p1 = points[1],
      d = m[0] = d3_svg_lineSlope(p0, p1);
  while (++i < j) {
    m[i] = d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]));
  }
  m[i] = d;
  return m;
}

// Interpolates the given points using Fritsch-Carlson Monotone cubic Hermite
// interpolation. Returns an array of tangent vectors. For details, see
// http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
function d3_svg_lineMonotoneTangents(points) {
  var tangents = [],
      d,
      a,
      b,
      s,
      m = d3_svg_lineFiniteDifferences(points),
      i = -1,
      j = points.length - 1;

  // The first two steps are done by computing finite-differences:
  // 1. Compute the slopes of the secant lines between successive points.
  // 2. Initialize the tangents at every point as the average of the secants.

  // Then, for each segment…
  while (++i < j) {
    d = d3_svg_lineSlope(points[i], points[i + 1]);

    // 3. If two successive yk = y{k + 1} are equal (i.e., d is zero), then set
    // mk = m{k + 1} = 0 as the spline connecting these points must be flat to
    // preserve monotonicity. Ignore step 4 and 5 for those k.

    if (Math.abs(d) < 1e-6) {
      m[i] = m[i + 1] = 0;
    } else {
      // 4. Let ak = mk / dk and bk = m{k + 1} / dk.
      a = m[i] / d;
      b = m[i + 1] / d;

      // 5. Prevent overshoot and ensure monotonicity by restricting the
      // magnitude of vector <ak, bk> to a circle of radius 3.
      s = a * a + b * b;
      if (s > 9) {
        s = d * 3 / Math.sqrt(s);
        m[i] = s * a;
        m[i + 1] = s * b;
      }
    }
  }

  // Compute the normalized tangent vector from the slopes. Note that if x is
  // not monotonic, it's possible that the slope will be infinite, so we protect
  // against NaN by setting the coordinate to zero.
  i = -1; while (++i <= j) {
    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
    tangents.push([s || 0, m[i] * s || 0]);
  }

  return tangents;
}

function d3_svg_lineMonotone(points) {
  return points.length < 3
      ? d3_svg_lineLinear(points)
      : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
}
d3.svg.line.radial = function() {
  var line = d3_svg_line(d3_svg_lineRadial);
  line.radius = line.x, delete line.x;
  line.angle = line.y, delete line.y;
  return line;
};

function d3_svg_lineRadial(points) {
  var point,
      i = -1,
      n = points.length,
      r,
      a;
  while (++i < n) {
    point = points[i];
    r = point[0];
    a = point[1] + d3_svg_arcOffset;
    point[0] = r * Math.cos(a);
    point[1] = r * Math.sin(a);
  }
  return points;
}
function d3_svg_area(projection) {
  var x0 = d3_svg_lineX,
      x1 = d3_svg_lineX,
      y0 = 0,
      y1 = d3_svg_lineY,
      defined = d3_true,
      interpolate = d3_svg_lineInterpolatorDefault,
      i0 = d3_svg_lineLinear,
      i1 = d3_svg_lineLinear,
      L = "L",
      tension = .7;

  function area(data) {
    var segments = [],
        points0 = [],
        points1 = [],
        i = -1,
        n = data.length,
        d,
        fx0 = d3_functor(x0),
        fy0 = d3_functor(y0),
        fx1 = x0 === x1 ? function() { return x; } : d3_functor(x1),
        fy1 = y0 === y1 ? function() { return y; } : d3_functor(y1),
        x,
        y;

    function segment() {
      segments.push("M", i0(projection(points1), tension),
          L, i1(projection(points0.reverse()), tension),
          "Z");
    }

    while (++i < n) {
      if (defined.call(this, d = data[i], i)) {
        points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
        points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
      } else if (points0.length) {
        segment();
        points0 = [];
        points1 = [];
      }
    }

    if (points0.length) segment();

    return segments.length ? segments.join("") : null;
  }

  area.x = function(_) {
    if (!arguments.length) return x1;
    x0 = x1 = _;
    return area;
  };

  area.x0 = function(_) {
    if (!arguments.length) return x0;
    x0 = _;
    return area;
  };

  area.x1 = function(_) {
    if (!arguments.length) return x1;
    x1 = _;
    return area;
  };

  area.y = function(_) {
    if (!arguments.length) return y1;
    y0 = y1 = _;
    return area;
  };

  area.y0 = function(_) {
    if (!arguments.length) return y0;
    y0 = _;
    return area;
  };

  area.y1 = function(_) {
    if (!arguments.length) return y1;
    y1 = _;
    return area;
  };

  area.defined  = function(_) {
    if (!arguments.length) return defined;
    defined = _;
    return area;
  };

  area.interpolate = function(_) {
    if (!arguments.length) return interpolate;
    if (!d3_svg_lineInterpolators.has(_ += "")) _ = d3_svg_lineInterpolatorDefault;
    i0 = d3_svg_lineInterpolators.get(interpolate = _);
    i1 = i0.reverse || i0;
    L = /-closed$/.test(_) ? "M" : "L";
    return area;
  };

  area.tension = function(_) {
    if (!arguments.length) return tension;
    tension = _;
    return area;
  };

  return area;
}

d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;

d3.svg.area = function() {
  return d3_svg_area(Object);
};
d3.svg.area.radial = function() {
  var area = d3_svg_area(d3_svg_lineRadial);
  area.radius = area.x, delete area.x;
  area.innerRadius = area.x0, delete area.x0;
  area.outerRadius = area.x1, delete area.x1;
  area.angle = area.y, delete area.y;
  area.startAngle = area.y0, delete area.y0;
  area.endAngle = area.y1, delete area.y1;
  return area;
};
d3.svg.chord = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      radius = d3_svg_chordRadius,
      startAngle = d3_svg_arcStartAngle,
      endAngle = d3_svg_arcEndAngle;

  // TODO Allow control point to be customized.

  function chord(d, i) {
    var s = subgroup(this, source, d, i),
        t = subgroup(this, target, d, i);
    return "M" + s.p0
      + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t)
      ? curve(s.r, s.p1, s.r, s.p0)
      : curve(s.r, s.p1, t.r, t.p0)
      + arc(t.r, t.p1, t.a1 - t.a0)
      + curve(t.r, t.p1, s.r, s.p0))
      + "Z";
  }

  function subgroup(self, f, d, i) {
    var subgroup = f.call(self, d, i),
        r = radius.call(self, subgroup, i),
        a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,
        a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;
    return {
      r: r,
      a0: a0,
      a1: a1,
      p0: [r * Math.cos(a0), r * Math.sin(a0)],
      p1: [r * Math.cos(a1), r * Math.sin(a1)]
    };
  }

  function equals(a, b) {
    return a.a0 == b.a0 && a.a1 == b.a1;
  }

  function arc(r, p, a) {
    return "A" + r + "," + r + " 0 " + +(a > Math.PI) + ",1 " + p;
  }

  function curve(r0, p0, r1, p1) {
    return "Q 0,0 " + p1;
  }

  chord.radius = function(v) {
    if (!arguments.length) return radius;
    radius = d3_functor(v);
    return chord;
  };

  chord.source = function(v) {
    if (!arguments.length) return source;
    source = d3_functor(v);
    return chord;
  };

  chord.target = function(v) {
    if (!arguments.length) return target;
    target = d3_functor(v);
    return chord;
  };

  chord.startAngle = function(v) {
    if (!arguments.length) return startAngle;
    startAngle = d3_functor(v);
    return chord;
  };

  chord.endAngle = function(v) {
    if (!arguments.length) return endAngle;
    endAngle = d3_functor(v);
    return chord;
  };

  return chord;
};

function d3_svg_chordSource(d) {
  return d.source;
}

function d3_svg_chordTarget(d) {
  return d.target;
}

function d3_svg_chordRadius(d) {
  return d.radius;
}

function d3_svg_chordStartAngle(d) {
  return d.startAngle;
}

function d3_svg_chordEndAngle(d) {
  return d.endAngle;
}
d3.svg.diagonal = function() {
  var source = d3_svg_chordSource,
      target = d3_svg_chordTarget,
      projection = d3_svg_diagonalProjection;

  function diagonal(d, i) {
    var p0 = source.call(this, d, i),
        p3 = target.call(this, d, i),
        m = (p0.y + p3.y) / 2,
        p = [p0, {x: p0.x, y: m}, {x: p3.x, y: m}, p3];
    p = p.map(projection);
    return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
  }

  diagonal.source = function(x) {
    if (!arguments.length) return source;
    source = d3_functor(x);
    return diagonal;
  };

  diagonal.target = function(x) {
    if (!arguments.length) return target;
    target = d3_functor(x);
    return diagonal;
  };

  diagonal.projection = function(x) {
    if (!arguments.length) return projection;
    projection = x;
    return diagonal;
  };

  return diagonal;
};

function d3_svg_diagonalProjection(d) {
  return [d.x, d.y];
}
d3.svg.diagonal.radial = function() {
  var diagonal = d3.svg.diagonal(),
      projection = d3_svg_diagonalProjection,
      projection_ = diagonal.projection;

  diagonal.projection = function(x) {
    return arguments.length
        ? projection_(d3_svg_diagonalRadialProjection(projection = x))
        : projection;
  };

  return diagonal;
};

function d3_svg_diagonalRadialProjection(projection) {
  return function() {
    var d = projection.apply(this, arguments),
        r = d[0],
        a = d[1] + d3_svg_arcOffset;
    return [r * Math.cos(a), r * Math.sin(a)];
  };
}
d3.svg.mouse = d3.mouse;
d3.svg.touches = d3.touches;
d3.svg.symbol = function() {
  var type = d3_svg_symbolType,
      size = d3_svg_symbolSize;

  function symbol(d, i) {
    return (d3_svg_symbols.get(type.call(this, d, i))
        || d3_svg_symbolCircle)
        (size.call(this, d, i));
  }

  symbol.type = function(x) {
    if (!arguments.length) return type;
    type = d3_functor(x);
    return symbol;
  };

  // size of symbol in square pixels
  symbol.size = function(x) {
    if (!arguments.length) return size;
    size = d3_functor(x);
    return symbol;
  };

  return symbol;
};

function d3_svg_symbolSize() {
  return 64;
}

function d3_svg_symbolType() {
  return "circle";
}

function d3_svg_symbolCircle(size) {
  var r = Math.sqrt(size / Math.PI);
  return "M0," + r
      + "A" + r + "," + r + " 0 1,1 0," + (-r)
      + "A" + r + "," + r + " 0 1,1 0," + r
      + "Z";
}

// TODO cross-diagonal?
var d3_svg_symbols = d3.map({
  "circle": d3_svg_symbolCircle,
  "cross": function(size) {
    var r = Math.sqrt(size / 5) / 2;
    return "M" + -3 * r + "," + -r
        + "H" + -r
        + "V" + -3 * r
        + "H" + r
        + "V" + -r
        + "H" + 3 * r
        + "V" + r
        + "H" + r
        + "V" + 3 * r
        + "H" + -r
        + "V" + r
        + "H" + -3 * r
        + "Z";
  },
  "diamond": function(size) {
    var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
        rx = ry * d3_svg_symbolTan30;
    return "M0," + -ry
        + "L" + rx + ",0"
        + " 0," + ry
        + " " + -rx + ",0"
        + "Z";
  },
  "square": function(size) {
    var r = Math.sqrt(size) / 2;
    return "M" + -r + "," + -r
        + "L" + r + "," + -r
        + " " + r + "," + r
        + " " + -r + "," + r
        + "Z";
  },
  "triangle-down": function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return "M0," + ry
        + "L" + rx +"," + -ry
        + " " + -rx + "," + -ry
        + "Z";
  },
  "triangle-up": function(size) {
    var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
        ry = rx * d3_svg_symbolSqrt3 / 2;
    return "M0," + -ry
        + "L" + rx +"," + ry
        + " " + -rx + "," + ry
        + "Z";
  }
});

d3.svg.symbolTypes = d3_svg_symbols.keys();

var d3_svg_symbolSqrt3 = Math.sqrt(3),
    d3_svg_symbolTan30 = Math.tan(30 * Math.PI / 180);
d3.svg.axis = function() {
  var scale = d3.scale.linear(),
      orient = "bottom",
      tickMajorSize = 6,
      tickMinorSize = 6,
      tickEndSize = 6,
      tickPadding = 3,
      tickArguments_ = [10],
      tickValues = null,
      tickFormat_,
      tickSubdivide = 0;

  function axis(g) {
    g.each(function() {
      var g = d3.select(this);

      // Ticks, or domain values for ordinal scales.
      var ticks = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain()) : tickValues,
          tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_;

      // Minor ticks.
      var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),
          subtick = g.selectAll(".minor").data(subticks, String),
          subtickEnter = subtick.enter().insert("line", "g").attr("class", "tick minor").style("opacity", 1e-6),
          subtickExit = d3.transition(subtick.exit()).style("opacity", 1e-6).remove(),
          subtickUpdate = d3.transition(subtick).style("opacity", 1);

      // Major ticks.
      var tick = g.selectAll("g").data(ticks, String),
          tickEnter = tick.enter().insert("g", "path").style("opacity", 1e-6),
          tickExit = d3.transition(tick.exit()).style("opacity", 1e-6).remove(),
          tickUpdate = d3.transition(tick).style("opacity", 1),
          tickTransform;

      // Domain.
      var range = d3_scaleRange(scale),
          path = g.selectAll(".domain").data([0]),
          pathEnter = path.enter().append("path").attr("class", "domain"),
          pathUpdate = d3.transition(path);

      // Stash a snapshot of the new scale, and retrieve the old snapshot.
      var scale1 = scale.copy(),
          scale0 = this.__chart__ || scale1;
      this.__chart__ = scale1;

      tickEnter.append("line").attr("class", "tick");
      tickEnter.append("text");

      var lineEnter = tickEnter.select("line"),
          lineUpdate = tickUpdate.select("line"),
          text = tick.select("text").text(tickFormat),
          textEnter = tickEnter.select("text"),
          textUpdate = tickUpdate.select("text");

      switch (orient) {
        case "bottom": {
          tickTransform = d3_svg_axisX;
          subtickEnter.attr("y2", tickMinorSize);
          subtickUpdate.attr("x2", 0).attr("y2", tickMinorSize);
          lineEnter.attr("y2", tickMajorSize);
          textEnter.attr("y", Math.max(tickMajorSize, 0) + tickPadding);
          lineUpdate.attr("x2", 0).attr("y2", tickMajorSize);
          textUpdate.attr("x", 0).attr("y", Math.max(tickMajorSize, 0) + tickPadding);
          text.attr("dy", ".71em").attr("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + tickEndSize + "V0H" + range[1] + "V" + tickEndSize);
          break;
        }
        case "top": {
          tickTransform = d3_svg_axisX;
          subtickEnter.attr("y2", -tickMinorSize);
          subtickUpdate.attr("x2", 0).attr("y2", -tickMinorSize);
          lineEnter.attr("y2", -tickMajorSize);
          textEnter.attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
          lineUpdate.attr("x2", 0).attr("y2", -tickMajorSize);
          textUpdate.attr("x", 0).attr("y", -(Math.max(tickMajorSize, 0) + tickPadding));
          text.attr("dy", "0em").attr("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + -tickEndSize + "V0H" + range[1] + "V" + -tickEndSize);
          break;
        }
        case "left": {
          tickTransform = d3_svg_axisY;
          subtickEnter.attr("x2", -tickMinorSize);
          subtickUpdate.attr("x2", -tickMinorSize).attr("y2", 0);
          lineEnter.attr("x2", -tickMajorSize);
          textEnter.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding));
          lineUpdate.attr("x2", -tickMajorSize).attr("y2", 0);
          textUpdate.attr("x", -(Math.max(tickMajorSize, 0) + tickPadding)).attr("y", 0);
          text.attr("dy", ".32em").attr("text-anchor", "end");
          pathUpdate.attr("d", "M" + -tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + -tickEndSize);
          break;
        }
        case "right": {
          tickTransform = d3_svg_axisY;
          subtickEnter.attr("x2", tickMinorSize);
          subtickUpdate.attr("x2", tickMinorSize).attr("y2", 0);
          lineEnter.attr("x2", tickMajorSize);
          textEnter.attr("x", Math.max(tickMajorSize, 0) + tickPadding);
          lineUpdate.attr("x2", tickMajorSize).attr("y2", 0);
          textUpdate.attr("x", Math.max(tickMajorSize, 0) + tickPadding).attr("y", 0);
          text.attr("dy", ".32em").attr("text-anchor", "start");
          pathUpdate.attr("d", "M" + tickEndSize + "," + range[0] + "H0V" + range[1] + "H" + tickEndSize);
          break;
        }
      }

      // For quantitative scales:
      // - enter new ticks from the old scale
      // - exit old ticks to the new scale
      if (scale.ticks) {
        tickEnter.call(tickTransform, scale0);
        tickUpdate.call(tickTransform, scale1);
        tickExit.call(tickTransform, scale1);
        subtickEnter.call(tickTransform, scale0);
        subtickUpdate.call(tickTransform, scale1);
        subtickExit.call(tickTransform, scale1);
      }

      // For ordinal scales:
      // - any entering ticks are undefined in the old scale
      // - any exiting ticks are undefined in the new scale
      // Therefore, we only need to transition updating ticks.
      else {
        var dx = scale1.rangeBand() / 2, x = function(d) { return scale1(d) + dx; };
        tickEnter.call(tickTransform, x);
        tickUpdate.call(tickTransform, x);
      }
    });
  }

  axis.scale = function(x) {
    if (!arguments.length) return scale;
    scale = x;
    return axis;
  };

  axis.orient = function(x) {
    if (!arguments.length) return orient;
    orient = x;
    return axis;
  };

  axis.ticks = function() {
    if (!arguments.length) return tickArguments_;
    tickArguments_ = arguments;
    return axis;
  };

  axis.tickValues = function(x) {
    if (!arguments.length) return tickValues;
    tickValues = x;
    return axis;
  };

  axis.tickFormat = function(x) {
    if (!arguments.length) return tickFormat_;
    tickFormat_ = x;
    return axis;
  };

  axis.tickSize = function(x, y, z) {
    if (!arguments.length) return tickMajorSize;
    var n = arguments.length - 1;
    tickMajorSize = +x;
    tickMinorSize = n > 1 ? +y : tickMajorSize;
    tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;
    return axis;
  };

  axis.tickPadding = function(x) {
    if (!arguments.length) return tickPadding;
    tickPadding = +x;
    return axis;
  };

  axis.tickSubdivide = function(x) {
    if (!arguments.length) return tickSubdivide;
    tickSubdivide = +x;
    return axis;
  };

  return axis;
};

function d3_svg_axisX(selection, x) {
  selection.attr("transform", function(d) { return "translate(" + x(d) + ",0)"; });
}

function d3_svg_axisY(selection, y) {
  selection.attr("transform", function(d) { return "translate(0," + y(d) + ")"; });
}

function d3_svg_axisSubdivide(scale, ticks, m) {
  subticks = [];
  if (m && ticks.length > 1) {
    var extent = d3_scaleExtent(scale.domain()),
        subticks,
        i = -1,
        n = ticks.length,
        d = (ticks[1] - ticks[0]) / ++m,
        j,
        v;
    while (++i < n) {
      for (j = m; --j > 0;) {
        if ((v = +ticks[i] - j * d) >= extent[0]) {
          subticks.push(v);
        }
      }
    }
    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
      subticks.push(v);
    }
  }
  return subticks;
}
d3.svg.brush = function() {
  var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
      x = null, // x-scale, optional
      y = null, // y-scale, optional
      resizes = d3_svg_brushResizes[0],
      extent = [[0, 0], [0, 0]], // [x0, y0], [x1, y1], in pixels (integers)
      extentDomain; // the extent in data space, lazily created

  function brush(g) {
    g.each(function() {
      var g = d3.select(this),
          bg = g.selectAll(".background").data([0]),
          fg = g.selectAll(".extent").data([0]),
          tz = g.selectAll(".resize").data(resizes, String),
          e;

      // Prepare the brush container for events.
      g
          .style("pointer-events", "all")
          .on("mousedown.brush", brushstart)
          .on("touchstart.brush", brushstart);

      // An invisible, mouseable area for starting a new brush.
      bg.enter().append("rect")
          .attr("class", "background")
          .style("visibility", "hidden")
          .style("cursor", "crosshair");

      // The visible brush extent; style this as you like!
      fg.enter().append("rect")
          .attr("class", "extent")
          .style("cursor", "move");

      // More invisible rects for resizing the extent.
      tz.enter().append("g")
          .attr("class", function(d) { return "resize " + d; })
          .style("cursor", function(d) { return d3_svg_brushCursor[d]; })
        .append("rect")
          .attr("x", function(d) { return /[ew]$/.test(d) ? -3 : null; })
          .attr("y", function(d) { return /^[ns]/.test(d) ? -3 : null; })
          .attr("width", 6)
          .attr("height", 6)
          .style("visibility", "hidden");

      // Show or hide the resizers.
      tz.style("display", brush.empty() ? "none" : null);

      // Remove any superfluous resizers.
      tz.exit().remove();

      // Initialize the background to fill the defined range.
      // If the range isn't defined, you can post-process.
      if (x) {
        e = d3_scaleRange(x);
        bg.attr("x", e[0]).attr("width", e[1] - e[0]);
        redrawX(g);
      }
      if (y) {
        e = d3_scaleRange(y);
        bg.attr("y", e[0]).attr("height", e[1] - e[0]);
        redrawY(g);
      }
      redraw(g);
    });
  }

  function redraw(g) {
    g.selectAll(".resize").attr("transform", function(d) {
      return "translate(" + extent[+/e$/.test(d)][0] + "," + extent[+/^s/.test(d)][1] + ")";
    });
  }

  function redrawX(g) {
    g.select(".extent").attr("x", extent[0][0]);
    g.selectAll(".extent,.n>rect,.s>rect").attr("width", extent[1][0] - extent[0][0]);
  }

  function redrawY(g) {
    g.select(".extent").attr("y", extent[0][1]);
    g.selectAll(".extent,.e>rect,.w>rect").attr("height", extent[1][1] - extent[0][1]);
  }

  function brushstart() {
    var target = this,
        eventTarget = d3.select(d3.event.target),
        event_ = event.of(target, arguments),
        g = d3.select(target),
        resizing = eventTarget.datum(),
        resizingX = !/^(n|s)$/.test(resizing) && x,
        resizingY = !/^(e|w)$/.test(resizing) && y,
        dragging = eventTarget.classed("extent"),
        center,
        origin = mouse(),
        offset;

    var w = d3.select(window)
        .on("mousemove.brush", brushmove)
        .on("mouseup.brush", brushend)
        .on("touchmove.brush", brushmove)
        .on("touchend.brush", brushend)
        .on("keydown.brush", keydown)
        .on("keyup.brush", keyup);

    // If the extent was clicked on, drag rather than brush;
    // store the point between the mouse and extent origin instead.
    if (dragging) {
      origin[0] = extent[0][0] - origin[0];
      origin[1] = extent[0][1] - origin[1];
    }

    // If a resizer was clicked on, record which side is to be resized.
    // Also, set the origin to the opposite side.
    else if (resizing) {
      var ex = +/w$/.test(resizing),
          ey = +/^n/.test(resizing);
      offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]];
      origin[0] = extent[ex][0];
      origin[1] = extent[ey][1];
    }

    // If the ALT key is down when starting a brush, the center is at the mouse.
    else if (d3.event.altKey) center = origin.slice();

    // Propagate the active cursor to the body for the drag duration.
    g.style("pointer-events", "none").selectAll(".resize").style("display", null);
    d3.select("body").style("cursor", eventTarget.style("cursor"));

    // Notify listeners.
    event_({type: "brushstart"});
    brushmove();
    d3_eventCancel();

    function mouse() {
      var touches = d3.event.changedTouches;
      return touches ? d3.touches(target, touches)[0] : d3.mouse(target);
    }

    function keydown() {
      if (d3.event.keyCode == 32) {
        if (!dragging) {
          center = null;
          origin[0] -= extent[1][0];
          origin[1] -= extent[1][1];
          dragging = 2;
        }
        d3_eventCancel();
      }
    }

    function keyup() {
      if (d3.event.keyCode == 32 && dragging == 2) {
        origin[0] += extent[1][0];
        origin[1] += extent[1][1];
        dragging = 0;
        d3_eventCancel();
      }
    }

    function brushmove() {
      var point = mouse(),
          moved = false;

      // Preserve the offset for thick resizers.
      if (offset) {
        point[0] += offset[0];
        point[1] += offset[1];
      }

      if (!dragging) {

        // If needed, determine the center from the current extent.
        if (d3.event.altKey) {
          if (!center) center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2];

          // Update the origin, for when the ALT key is released.
          origin[0] = extent[+(point[0] < center[0])][0];
          origin[1] = extent[+(point[1] < center[1])][1];
        }

        // When the ALT key is released, we clear the center.
        else center = null;
      }

      // Update the brush extent for each dimension.
      if (resizingX && move1(point, x, 0)) {
        redrawX(g);
        moved = true;
      }
      if (resizingY && move1(point, y, 1)) {
        redrawY(g);
        moved = true;
      }

      // Final redraw and notify listeners.
      if (moved) {
        redraw(g);
        event_({type: "brush", mode: dragging ? "move" : "resize"});
      }
    }

    function move1(point, scale, i) {
      var range = d3_scaleRange(scale),
          r0 = range[0],
          r1 = range[1],
          position = origin[i],
          size = extent[1][i] - extent[0][i],
          min,
          max;

      // When dragging, reduce the range by the extent size and position.
      if (dragging) {
        r0 -= position;
        r1 -= size + position;
      }

      // Clamp the point so that the extent fits within the range extent.
      min = Math.max(r0, Math.min(r1, point[i]));

      // Compute the new extent bounds.
      if (dragging) {
        max = (min += position) + size;
      } else {

        // If the ALT key is pressed, then preserve the center of the extent.
        if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));

        // Compute the min and max of the position and point.
        if (position < min) {
          max = min;
          min = position;
        } else {
          max = position;
        }
      }

      // Update the stored bounds.
      if (extent[0][i] !== min || extent[1][i] !== max) {
        extentDomain = null;
        extent[0][i] = min;
        extent[1][i] = max;
        return true;
      }
    }

    function brushend() {
      brushmove();

      // reset the cursor styles
      g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
      d3.select("body").style("cursor", null);

      w .on("mousemove.brush", null)
        .on("mouseup.brush", null)
        .on("touchmove.brush", null)
        .on("touchend.brush", null)
        .on("keydown.brush", null)
        .on("keyup.brush", null);

      event_({type: "brushend"});
      d3_eventCancel();
    }
  }

  brush.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!
    return brush;
  };

  brush.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    resizes = d3_svg_brushResizes[!x << 1 | !y]; // fore!
    return brush;
  };

  brush.extent = function(z) {
    var x0, x1, y0, y1, t;

    // Invert the pixel extent to data-space.
    if (!arguments.length) {
      z = extentDomain || extent;
      if (x) {
        x0 = z[0][0], x1 = z[1][0];
        if (!extentDomain) {
          x0 = extent[0][0], x1 = extent[1][0];
          if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
          if (x1 < x0) t = x0, x0 = x1, x1 = t;
        }
      }
      if (y) {
        y0 = z[0][1], y1 = z[1][1];
        if (!extentDomain) {
          y0 = extent[0][1], y1 = extent[1][1];
          if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
          if (y1 < y0) t = y0, y0 = y1, y1 = t;
        }
      }
      return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
    }

    // Scale the data-space extent to pixels.
    extentDomain = [[0, 0], [0, 0]];
    if (x) {
      x0 = z[0], x1 = z[1];
      if (y) x0 = x0[0], x1 = x1[0];
      extentDomain[0][0] = x0, extentDomain[1][0] = x1;
      if (x.invert) x0 = x(x0), x1 = x(x1);
      if (x1 < x0) t = x0, x0 = x1, x1 = t;
      extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;
    }
    if (y) {
      y0 = z[0], y1 = z[1];
      if (x) y0 = y0[1], y1 = y1[1];
      extentDomain[0][1] = y0, extentDomain[1][1] = y1;
      if (y.invert) y0 = y(y0), y1 = y(y1);
      if (y1 < y0) t = y0, y0 = y1, y1 = t;
      extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;
    }

    return brush;
  };

  brush.clear = function() {
    extentDomain = null;
    extent[0][0] =
    extent[0][1] =
    extent[1][0] =
    extent[1][1] = 0;
    return brush;
  };

  brush.empty = function() {
    return (x && extent[0][0] === extent[1][0])
        || (y && extent[0][1] === extent[1][1]);
  };

  return d3.rebind(brush, event, "on");
};

var d3_svg_brushCursor = {
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var d3_svg_brushResizes = [
  ["n", "e", "s", "w", "nw", "ne", "se", "sw"],
  ["e", "w"],
  ["n", "s"],
  []
];
d3.behavior = {};
// TODO Track touch points by identifier.

d3.behavior.drag = function() {
  var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
      origin = null;

  function drag() {
    this.on("mousedown.drag", mousedown)
        .on("touchstart.drag", mousedown);
  }

  function mousedown() {
    var target = this,
        event_ = event.of(target, arguments),
        eventTarget = d3.event.target,
        offset,
        origin_ = point(),
        moved = 0;

    var w = d3.select(window)
        .on("mousemove.drag", dragmove)
        .on("touchmove.drag", dragmove)
        .on("mouseup.drag", dragend, true)
        .on("touchend.drag", dragend, true);

    if (origin) {
      offset = origin.apply(target, arguments);
      offset = [offset.x - origin_[0], offset.y - origin_[1]];
    } else {
      offset = [0, 0];
    }

    d3_eventCancel();
    event_({type: "dragstart"});

    function point() {
      var p = target.parentNode,
          t = d3.event.changedTouches;
      return t ? d3.touches(p, t)[0] : d3.mouse(p);
    }

    function dragmove() {
      if (!target.parentNode) return dragend(); // target removed from DOM

      var p = point(),
          dx = p[0] - origin_[0],
          dy = p[1] - origin_[1];

      moved |= dx | dy;
      origin_ = p;
      d3_eventCancel();

      event_({type: "drag", x: p[0] + offset[0], y: p[1] + offset[1], dx: dx, dy: dy});
    }

    function dragend() {
      event_({type: "dragend"});

      // if moved, prevent the mouseup (and possibly click) from propagating
      if (moved) {
        d3_eventCancel();
        if (d3.event.target === eventTarget) w.on("click.drag", click, true);
      }

      w .on("mousemove.drag", null)
        .on("touchmove.drag", null)
        .on("mouseup.drag", null)
        .on("touchend.drag", null);
    }

    // prevent the subsequent click from propagating (e.g., for anchors)
    function click() {
      d3_eventCancel();
      w.on("click.drag", null);
    }
  }

  drag.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    return drag;
  };

  return d3.rebind(drag, event, "on");
};
d3.behavior.zoom = function() {
  var translate = [0, 0],
      translate0, // translate when we started zooming (to avoid drift)
      scale = 1,
      scale0, // scale when we started touching
      scaleExtent = d3_behavior_zoomInfinity,
      event = d3_eventDispatch(zoom, "zoom"),
      x0,
      x1,
      y0,
      y1,
      touchtime; // time of last touchstart (to detect double-tap)

  function zoom() {
    this
        .on("mousedown.zoom", mousedown)
        .on("mousewheel.zoom", mousewheel)
        .on("mousemove.zoom", mousemove)
        .on("DOMMouseScroll.zoom", mousewheel)
        .on("dblclick.zoom", dblclick)
        .on("touchstart.zoom", touchstart)
        .on("touchmove.zoom", touchmove)
        .on("touchend.zoom", touchstart);
  }

  zoom.translate = function(x) {
    if (!arguments.length) return translate;
    translate = x.map(Number);
    return zoom;
  };

  zoom.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return zoom;
  };

  zoom.scaleExtent = function(x) {
    if (!arguments.length) return scaleExtent;
    scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);
    return zoom;
  };

  zoom.x = function(z) {
    if (!arguments.length) return x1;
    x1 = z;
    x0 = z.copy();
    return zoom;
  };

  zoom.y = function(z) {
    if (!arguments.length) return y1;
    y1 = z;
    y0 = z.copy();
    return zoom;
  };

  function location(p) {
    return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];
  }

  function point(l) {
    return [l[0] * scale + translate[0], l[1] * scale + translate[1]];
  }

  function scaleTo(s) {
    scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
  }

  function translateTo(p, l) {
    l = point(l);
    translate[0] += p[0] - l[0];
    translate[1] += p[1] - l[1];
  }

  function dispatch(event) {
    if (x1) x1.domain(x0.range().map(function(x) { return (x - translate[0]) / scale; }).map(x0.invert));
    if (y1) y1.domain(y0.range().map(function(y) { return (y - translate[1]) / scale; }).map(y0.invert));
    d3.event.preventDefault();
    event({type: "zoom", scale: scale, translate: translate});
  }

  function mousedown() {
    var target = this,
        event_ = event.of(target, arguments),
        eventTarget = d3.event.target,
        moved = 0,
        w = d3.select(window).on("mousemove.zoom", mousemove).on("mouseup.zoom", mouseup),
        l = location(d3.mouse(target));

    window.focus();
    d3_eventCancel();

    function mousemove() {
      moved = 1;
      translateTo(d3.mouse(target), l);
      dispatch(event_);
    }

    function mouseup() {
      if (moved) d3_eventCancel();
      w.on("mousemove.zoom", null).on("mouseup.zoom", null);
      if (moved && d3.event.target === eventTarget) w.on("click.zoom", click, true);
    }

    function click() {
      d3_eventCancel();
      w.on("click.zoom", null);
    }
  }

  function mousewheel() {
    if (!translate0) translate0 = location(d3.mouse(this));
    scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);
    translateTo(d3.mouse(this), translate0);
    dispatch(event.of(this, arguments));
  }

  function mousemove() {
    translate0 = null;
  }

  function dblclick() {
    var p = d3.mouse(this), l = location(p);
    scaleTo(d3.event.shiftKey ? scale / 2 : scale * 2);
    translateTo(p, l);
    dispatch(event.of(this, arguments));
  }

  function touchstart() {
    var touches = d3.touches(this),
        now = Date.now();

    scale0 = scale;
    translate0 = {};
    touches.forEach(function(t) { translate0[t.identifier] = location(t); });
    d3_eventCancel();

    if ((touches.length === 1) && (now - touchtime < 500)) { // dbltap
      var p = touches[0], l = location(touches[0]);
      scaleTo(scale * 2);
      translateTo(p, l);
      dispatch(event.of(this, arguments));
    }
    touchtime = now;
  }

  function touchmove() {
    var touches = d3.touches(this),
        p0 = touches[0],
        l0 = translate0[p0.identifier];
    if (p1 = touches[1]) {
      var p1, l1 = translate0[p1.identifier];
      p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      scaleTo(d3.event.scale * scale0);
    }
    translateTo(p0, l0);
    dispatch(event.of(this, arguments));
  }

  return d3.rebind(zoom, event, "on");
};

var d3_behavior_zoomDiv, // for interpreting mousewheel events
    d3_behavior_zoomInfinity = [0, Infinity]; // default scale extent

function d3_behavior_zoomDelta() {

  // mousewheel events are totally broken!
  // https://bugs.webkit.org/show_bug.cgi?id=40441
  // not only that, but Chrome and Safari differ in re. to acceleration!
  if (!d3_behavior_zoomDiv) {
    d3_behavior_zoomDiv = d3.select("body").append("div")
        .style("visibility", "hidden")
        .style("top", 0)
        .style("height", 0)
        .style("width", 0)
        .style("overflow-y", "scroll")
      .append("div")
        .style("height", "2000px")
      .node().parentNode;
  }

  var e = d3.event, delta;
  try {
    d3_behavior_zoomDiv.scrollTop = 1000;
    d3_behavior_zoomDiv.dispatchEvent(e);
    delta = 1000 - d3_behavior_zoomDiv.scrollTop;
  } catch (error) {
    delta = e.wheelDelta || (-e.detail * 5);
  }

  return delta;
}
d3.layout = {};
// Implements hierarchical edge bundling using Holten's algorithm. For each
// input link, a path is computed that travels through the tree, up the parent
// hierarchy to the least common ancestor, and then back down to the destination
// node. Each path is simply an array of nodes.
d3.layout.bundle = function() {
  return function(links) {
    var paths = [],
        i = -1,
        n = links.length;
    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
    return paths;
  };
};

function d3_layout_bundlePath(link) {
  var start = link.source,
      end = link.target,
      lca = d3_layout_bundleLeastCommonAncestor(start, end),
      points = [start];
  while (start !== lca) {
    start = start.parent;
    points.push(start);
  }
  var k = points.length;
  while (end !== lca) {
    points.splice(k, 0, end);
    end = end.parent;
  }
  return points;
}

function d3_layout_bundleAncestors(node) {
  var ancestors = [],
      parent = node.parent;
  while (parent != null) {
    ancestors.push(node);
    node = parent;
    parent = parent.parent;
  }
  ancestors.push(node);
  return ancestors;
}

function d3_layout_bundleLeastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = d3_layout_bundleAncestors(a),
      bNodes = d3_layout_bundleAncestors(b),
      aNode = aNodes.pop(),
      bNode = bNodes.pop(),
      sharedNode = null;
  while (aNode === bNode) {
    sharedNode = aNode;
    aNode = aNodes.pop();
    bNode = bNodes.pop();
  }
  return sharedNode;
}
d3.layout.chord = function() {
  var chord = {},
      chords,
      groups,
      matrix,
      n,
      padding = 0,
      sortGroups,
      sortSubgroups,
      sortChords;

  function relayout() {
    var subgroups = {},
        groupSums = [],
        groupIndex = d3.range(n),
        subgroupIndex = [],
        k,
        x,
        x0,
        i,
        j;

    chords = [];
    groups = [];

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3.range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) {
      groupIndex.sort(function(a, b) {
        return sortGroups(groupSums[a], groupSums[b]);
      });
    }

    // Sort subgroups…
    if (sortSubgroups) {
      subgroupIndex.forEach(function(d, i) {
        d.sort(function(a, b) {
          return sortSubgroups(matrix[i][a], matrix[i][b]);
        });
      });
    }

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified.
    // TODO Allow padding to be specified as percentage?
    k = (2 * Math.PI - padding * n) / k;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[di + "-" + dj] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: (x - x0) / k
      };
      x += padding;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[i + "-" + j],
            target = subgroups[j + "-" + i];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    if (sortChords) resort();
  }

  function resort() {
    chords.sort(function(a, b) {
      return sortChords(
          (a.source.value + a.target.value) / 2,
          (b.source.value + b.target.value) / 2);
    });
  }

  chord.matrix = function(x) {
    if (!arguments.length) return matrix;
    n = (matrix = x) && matrix.length;
    chords = groups = null;
    return chord;
  };

  chord.padding = function(x) {
    if (!arguments.length) return padding;
    padding = x;
    chords = groups = null;
    return chord;
  };

  chord.sortGroups = function(x) {
    if (!arguments.length) return sortGroups;
    sortGroups = x;
    chords = groups = null;
    return chord;
  };

  chord.sortSubgroups = function(x) {
    if (!arguments.length) return sortSubgroups;
    sortSubgroups = x;
    chords = null;
    return chord;
  };

  chord.sortChords = function(x) {
    if (!arguments.length) return sortChords;
    sortChords = x;
    if (chords) resort();
    return chord;
  };

  chord.chords = function() {
    if (!chords) relayout();
    return chords;
  };

  chord.groups = function() {
    if (!groups) relayout();
    return groups;
  };

  return chord;
};
// A rudimentary force layout using Gauss-Seidel.
d3.layout.force = function() {
  var force = {},
      event = d3.dispatch("start", "tick", "end"),
      size = [1, 1],
      drag,
      alpha,
      friction = .9,
      linkDistance = d3_layout_forceLinkDistance,
      linkStrength = d3_layout_forceLinkStrength,
      charge = -30,
      gravity = .1,
      theta = .8,
      interval,
      nodes = [],
      links = [],
      distances,
      strengths,
      charges;

  function repulse(node) {
    return function(quad, x1, y1, x2, y2) {
      if (quad.point !== node) {
        var dx = quad.cx - node.x,
            dy = quad.cy - node.y,
            dn = 1 / Math.sqrt(dx * dx + dy * dy);

        /* Barnes-Hut criterion. */
        if ((x2 - x1) * dn < theta) {
          var k = quad.charge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
          return true;
        }

        if (quad.point && isFinite(dn)) {
          var k = quad.pointCharge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
        }
      }
      return !quad.charge;
    };
  }

  force.tick = function() {
    // simulated annealing, basically
    if ((alpha *= .99) < .005) {
      event.end({type: "end", alpha: alpha = 0});
      return true;
    }

    var n = nodes.length,
        m = links.length,
        q,
        i, // current index
        o, // current object
        s, // current source
        t, // current target
        l, // current distance
        k, // current force
        x, // x-distance
        y; // y-distance

    // gauss-seidel relaxation for links
    for (i = 0; i < m; ++i) {
      o = links[i];
      s = o.source;
      t = o.target;
      x = t.x - s.x;
      y = t.y - s.y;
      if (l = (x * x + y * y)) {
        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
        x *= l;
        y *= l;
        t.x -= x * (k = s.weight / (t.weight + s.weight));
        t.y -= y * k;
        s.x += x * (k = 1 - k);
        s.y += y * k;
      }
    }

    // apply gravity forces
    if (k = alpha * gravity) {
      x = size[0] / 2;
      y = size[1] / 2;
      i = -1; if (k) while (++i < n) {
        o = nodes[i];
        o.x += (x - o.x) * k;
        o.y += (y - o.y) * k;
      }
    }

    // compute quadtree center of mass and apply charge forces
    if (charge) {
      d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
      i = -1; while (++i < n) {
        if (!(o = nodes[i]).fixed) {
          q.visit(repulse(o));
        }
      }
    }

    // position verlet integration
    i = -1; while (++i < n) {
      o = nodes[i];
      if (o.fixed) {
        o.x = o.px;
        o.y = o.py;
      } else {
        o.x -= (o.px - (o.px = o.x)) * friction;
        o.y -= (o.py - (o.py = o.y)) * friction;
      }
    }

    event.tick({type: "tick", alpha: alpha});
  };

  force.nodes = function(x) {
    if (!arguments.length) return nodes;
    nodes = x;
    return force;
  };

  force.links = function(x) {
    if (!arguments.length) return links;
    links = x;
    return force;
  };

  force.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return force;
  };

  force.linkDistance = function(x) {
    if (!arguments.length) return linkDistance;
    linkDistance = d3_functor(x);
    return force;
  };

  // For backwards-compatibility.
  force.distance = force.linkDistance;

  force.linkStrength = function(x) {
    if (!arguments.length) return linkStrength;
    linkStrength = d3_functor(x);
    return force;
  };

  force.friction = function(x) {
    if (!arguments.length) return friction;
    friction = x;
    return force;
  };

  force.charge = function(x) {
    if (!arguments.length) return charge;
    charge = typeof x === "function" ? x : +x;
    return force;
  };

  force.gravity = function(x) {
    if (!arguments.length) return gravity;
    gravity = x;
    return force;
  };

  force.theta = function(x) {
    if (!arguments.length) return theta;
    theta = x;
    return force;
  };

  force.alpha = function(x) {
    if (!arguments.length) return alpha;

    if (alpha) { // if we're already running
      if (x > 0) alpha = x; // we might keep it hot
      else alpha = 0; // or, next tick will dispatch "end"
    } else if (x > 0) { // otherwise, fire it up!
      event.start({type: "start", alpha: alpha = x});
      d3.timer(force.tick);
    }

    return force;
  };

  force.start = function() {
    var i,
        j,
        n = nodes.length,
        m = links.length,
        w = size[0],
        h = size[1],
        neighbors,
        o;

    for (i = 0; i < n; ++i) {
      (o = nodes[i]).index = i;
      o.weight = 0;
    }

    distances = [];
    strengths = [];
    for (i = 0; i < m; ++i) {
      o = links[i];
      if (typeof o.source == "number") o.source = nodes[o.source];
      if (typeof o.target == "number") o.target = nodes[o.target];
      distances[i] = linkDistance.call(this, o, i);
      strengths[i] = linkStrength.call(this, o, i);
      ++o.source.weight;
      ++o.target.weight;
    }

    for (i = 0; i < n; ++i) {
      o = nodes[i];
      if (isNaN(o.x)) o.x = position("x", w);
      if (isNaN(o.y)) o.y = position("y", h);
      if (isNaN(o.px)) o.px = o.x;
      if (isNaN(o.py)) o.py = o.y;
    }

    charges = [];
    if (typeof charge === "function") {
      for (i = 0; i < n; ++i) {
        charges[i] = +charge.call(this, nodes[i], i);
      }
    } else {
      for (i = 0; i < n; ++i) {
        charges[i] = charge;
      }
    }

    // initialize node position based on first neighbor
    function position(dimension, size) {
      var neighbors = neighbor(i),
          j = -1,
          m = neighbors.length,
          x;
      while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
      return Math.random() * size;
    }

    // initialize neighbors lazily
    function neighbor() {
      if (!neighbors) {
        neighbors = [];
        for (j = 0; j < n; ++j) {
          neighbors[j] = [];
        }
        for (j = 0; j < m; ++j) {
          var o = links[j];
          neighbors[o.source.index].push(o.target);
          neighbors[o.target.index].push(o.source);
        }
      }
      return neighbors[i];
    }

    return force.resume();
  };

  force.resume = function() {
    return force.alpha(.1);
  };

  force.stop = function() {
    return force.alpha(0);
  };

  // use `node.call(force.drag)` to make nodes draggable
  force.drag = function() {
    if (!drag) drag = d3.behavior.drag()
        .origin(d3_identity)
        .on("dragstart", dragstart)
        .on("drag", d3_layout_forceDrag)
        .on("dragend", d3_layout_forceDragEnd);

    this.on("mouseover.force", d3_layout_forceDragOver)
        .on("mouseout.force", d3_layout_forceDragOut)
        .call(drag);
  };

  function dragstart(d) {
    d3_layout_forceDragOver(d3_layout_forceDragNode = d);
    d3_layout_forceDragForce = force;
  }

  return d3.rebind(force, event, "on");
};

var d3_layout_forceDragForce,
    d3_layout_forceDragNode;

function d3_layout_forceDragOver(d) {
  d.fixed |= 2;
}

function d3_layout_forceDragOut(d) {
  if (d !== d3_layout_forceDragNode) d.fixed &= 1;
}

function d3_layout_forceDragEnd() {
  d3_layout_forceDragNode.fixed &= 1;
  d3_layout_forceDragForce = d3_layout_forceDragNode = null;
}

function d3_layout_forceDrag() {
  d3_layout_forceDragNode.px = d3.event.x;
  d3_layout_forceDragNode.py = d3.event.y;
  d3_layout_forceDragForce.resume(); // restart annealing
}

function d3_layout_forceAccumulate(quad, alpha, charges) {
  var cx = 0,
      cy = 0;
  quad.charge = 0;
  if (!quad.leaf) {
    var nodes = quad.nodes,
        n = nodes.length,
        i = -1,
        c;
    while (++i < n) {
      c = nodes[i];
      if (c == null) continue;
      d3_layout_forceAccumulate(c, alpha, charges);
      quad.charge += c.charge;
      cx += c.charge * c.cx;
      cy += c.charge * c.cy;
    }
  }
  if (quad.point) {
    // jitter internal nodes that are coincident
    if (!quad.leaf) {
      quad.point.x += Math.random() - .5;
      quad.point.y += Math.random() - .5;
    }
    var k = alpha * charges[quad.point.index];
    quad.charge += quad.pointCharge = k;
    cx += k * quad.point.x;
    cy += k * quad.point.y;
  }
  quad.cx = cx / quad.charge;
  quad.cy = cy / quad.charge;
}

function d3_layout_forceLinkDistance(link) {
  return 20;
}

function d3_layout_forceLinkStrength(link) {
  return 1;
}
d3.layout.partition = function() {
  var hierarchy = d3.layout.hierarchy(),
      size = [1, 1]; // width, height

  function position(node, x, dx, dy) {
    var children = node.children;
    node.x = x;
    node.y = node.depth * dy;
    node.dx = dx;
    node.dy = dy;
    if (children && (n = children.length)) {
      var i = -1,
          n,
          c,
          d;
      dx = node.value ? dx / node.value : 0;
      while (++i < n) {
        position(c = children[i], x, d = c.value * dx, dy);
        x += d;
      }
    }
  }

  function depth(node) {
    var children = node.children,
        d = 0;
    if (children && (n = children.length)) {
      var i = -1,
          n;
      while (++i < n) d = Math.max(d, depth(children[i]));
    }
    return 1 + d;
  }

  function partition(d, i) {
    var nodes = hierarchy.call(this, d, i);
    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
    return nodes;
  }

  partition.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return partition;
  };

  return d3_layout_hierarchyRebind(partition, hierarchy);
};
d3.layout.pie = function() {
  var value = Number,
      sort = d3_layout_pieSortByValue,
      startAngle = 0,
      endAngle = 2 * Math.PI;

  function pie(data, i) {

    // Compute the numeric values for each data element.
    var values = data.map(function(d, i) { return +value.call(pie, d, i); });

    // Compute the start angle.
    var a = +(typeof startAngle === "function"
        ? startAngle.apply(this, arguments)
        : startAngle);

    // Compute the angular scale factor: from value to radians.
    var k = ((typeof endAngle === "function"
        ? endAngle.apply(this, arguments)
        : endAngle) - startAngle)
        / d3.sum(values);

    // Optionally sort the data.
    var index = d3.range(data.length);
    if (sort != null) index.sort(sort === d3_layout_pieSortByValue
        ? function(i, j) { return values[j] - values[i]; }
        : function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs!
    // They are stored in the original data's order.
    var arcs = [];
    index.forEach(function(i) {
      var d;
      arcs[i] = {
        data: data[i],
        value: d = values[i],
        startAngle: a,
        endAngle: a += d * k
      };
    });
    return arcs;
  }

  /**
   * Specifies the value function *x*, which returns a nonnegative numeric value
   * for each datum. The default value function is `Number`. The value function
   * is passed two arguments: the current datum and the current index.
   */
  pie.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return pie;
  };

  /**
   * Specifies a sort comparison operator *x*. The comparator is passed two data
   * elements from the data array, a and b; it returns a negative value if a is
   * less than b, a positive value if a is greater than b, and zero if a equals
   * b.
   */
  pie.sort = function(x) {
    if (!arguments.length) return sort;
    sort = x;
    return pie;
  };

  /**
   * Specifies the overall start angle of the pie chart. Defaults to 0. The
   * start angle can be specified either as a constant or as a function; in the
   * case of a function, it is evaluated once per array (as opposed to per
   * element).
   */
  pie.startAngle = function(x) {
    if (!arguments.length) return startAngle;
    startAngle = x;
    return pie;
  };

  /**
   * Specifies the overall end angle of the pie chart. Defaults to 2π. The
   * end angle can be specified either as a constant or as a function; in the
   * case of a function, it is evaluated once per array (as opposed to per
   * element).
   */
  pie.endAngle = function(x) {
    if (!arguments.length) return endAngle;
    endAngle = x;
    return pie;
  };

  return pie;
};

var d3_layout_pieSortByValue = {};
// data is two-dimensional array of x,y; we populate y0
d3.layout.stack = function() {
  var values = d3_identity,
      order = d3_layout_stackOrderDefault,
      offset = d3_layout_stackOffsetZero,
      out = d3_layout_stackOut,
      x = d3_layout_stackX,
      y = d3_layout_stackY;

  function stack(data, index) {

    // Convert series to canonical two-dimensional representation.
    var series = data.map(function(d, i) {
      return values.call(stack, d, i);
    });

    // Convert each series to canonical [[x,y]] representation.
    var points = series.map(function(d, i) {
      return d.map(function(v, i) {
        return [x.call(stack, v, i), y.call(stack, v, i)];
      });
    });

    // Compute the order of series, and permute them.
    var orders = order.call(stack, points, index);
    series = d3.permute(series, orders);
    points = d3.permute(points, orders);

    // Compute the baseline…
    var offsets = offset.call(stack, points, index);

    // And propagate it to other series.
    var n = series.length,
        m = series[0].length,
        i,
        j,
        o;
    for (j = 0; j < m; ++j) {
      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
      for (i = 1; i < n; ++i) {
        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
      }
    }

    return data;
  }

  stack.values = function(x) {
    if (!arguments.length) return values;
    values = x;
    return stack;
  };

  stack.order = function(x) {
    if (!arguments.length) return order;
    order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
    return stack;
  };

  stack.offset = function(x) {
    if (!arguments.length) return offset;
    offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
    return stack;
  };

  stack.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    return stack;
  };

  stack.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    return stack;
  };

  stack.out = function(z) {
    if (!arguments.length) return out;
    out = z;
    return stack;
  };

  return stack;
}

function d3_layout_stackX(d) {
  return d.x;
}

function d3_layout_stackY(d) {
  return d.y;
}

function d3_layout_stackOut(d, y0, y) {
  d.y0 = y0;
  d.y = y;
}

var d3_layout_stackOrders = d3.map({

  "inside-out": function(data) {
    var n = data.length,
        i,
        j,
        max = data.map(d3_layout_stackMaxIndex),
        sums = data.map(d3_layout_stackReduceSum),
        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),
        top = 0,
        bottom = 0,
        tops = [],
        bottoms = [];
    for (i = 0; i < n; ++i) {
      j = index[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  },

  "reverse": function(data) {
    return d3.range(data.length).reverse();
  },

  "default": d3_layout_stackOrderDefault

});

var d3_layout_stackOffsets = d3.map({

  "silhouette": function(data) {
    var n = data.length,
        m = data[0].length,
        sums = [],
        max = 0,
        i,
        j,
        o,
        y0 = [];
    for (j = 0; j < m; ++j) {
      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
      if (o > max) max = o;
      sums.push(o);
    }
    for (j = 0; j < m; ++j) {
      y0[j] = (max - sums[j]) / 2;
    }
    return y0;
  },

  "wiggle": function(data) {
    var n = data.length,
        x = data[0],
        m = x.length,
        max = 0,
        i,
        j,
        k,
        s1,
        s2,
        s3,
        dx,
        o,
        o0,
        y0 = [];
    y0[0] = o = o0 = 0;
    for (j = 1; j < m; ++j) {
      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
        }
        s2 += s3 * data[i][j][1];
      }
      y0[j] = o -= s1 ? s2 / s1 * dx : 0;
      if (o < o0) o0 = o;
    }
    for (j = 0; j < m; ++j) y0[j] -= o0;
    return y0;
  },

  "expand": function(data) {
    var n = data.length,
        m = data[0].length,
        k = 1 / n,
        i,
        j,
        o,
        y0 = [];
    for (j = 0; j < m; ++j) {
      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
      else for (i = 0; i < n; i++) data[i][j][1] = k;
    }
    for (j = 0; j < m; ++j) y0[j] = 0;
    return y0;
  },

  "zero": d3_layout_stackOffsetZero

});

function d3_layout_stackOrderDefault(data) {
  return d3.range(data.length);
}

function d3_layout_stackOffsetZero(data) {
  var j = -1,
      m = data[0].length,
      y0 = [];
  while (++j < m) y0[j] = 0;
  return y0;
}

function d3_layout_stackMaxIndex(array) {
  var i = 1,
      j = 0,
      v = array[0][1],
      k,
      n = array.length;
  for (; i < n; ++i) {
    if ((k = array[i][1]) > v) {
      j = i;
      v = k;
    }
  }
  return j;
}

function d3_layout_stackReduceSum(d) {
  return d.reduce(d3_layout_stackSum, 0);
}

function d3_layout_stackSum(p, d) {
  return p + d[1];
}
d3.layout.histogram = function() {
  var frequency = true,
      valuer = Number,
      ranger = d3_layout_histogramRange,
      binner = d3_layout_histogramBinSturges;

  function histogram(data, i) {
    var bins = [],
        values = data.map(valuer, this),
        range = ranger.call(this, values, i),
        thresholds = binner.call(this, range, values, i),
        bin,
        i = -1,
        n = values.length,
        m = thresholds.length - 1,
        k = frequency ? 1 : 1 / n,
        x;

    // Initialize the bins.
    while (++i < m) {
      bin = bins[i] = [];
      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
      bin.y = 0;
    }

    // Fill the bins, ignoring values outside the range.
    if (m > 0) {
      i = -1; while(++i < n) {
        x = values[i];
        if ((x >= range[0]) && (x <= range[1])) {
          bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
          bin.y += k;
          bin.push(data[i]);
        }
      }
    }

    return bins;
  }

  // Specifies how to extract a value from the associated data. The default
  // value function is `Number`, which is equivalent to the identity function.
  histogram.value = function(x) {
    if (!arguments.length) return valuer;
    valuer = x;
    return histogram;
  };

  // Specifies the range of the histogram. Values outside the specified range
  // will be ignored. The argument `x` may be specified either as a two-element
  // array representing the minimum and maximum value of the range, or as a
  // function that returns the range given the array of values and the current
  // index `i`. The default range is the extent (minimum and maximum) of the
  // values.
  histogram.range = function(x) {
    if (!arguments.length) return ranger;
    ranger = d3_functor(x);
    return histogram;
  };

  // Specifies how to bin values in the histogram. The argument `x` may be
  // specified as a number, in which case the range of values will be split
  // uniformly into the given number of bins. Or, `x` may be an array of
  // threshold values, defining the bins; the specified array must contain the
  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`
  // may be a function which is evaluated, being passed the range, the array of
  // values, and the current index `i`, returning an array of thresholds. The
  // default bin function will divide the values into uniform bins using
  // Sturges' formula.
  histogram.bins = function(x) {
    if (!arguments.length) return binner;
    binner = typeof x === "number"
        ? function(range) { return d3_layout_histogramBinFixed(range, x); }
        : d3_functor(x);
    return histogram;
  };

  // Specifies whether the histogram's `y` value is a count (frequency) or a
  // probability (density). The default value is true.
  histogram.frequency = function(x) {
    if (!arguments.length) return frequency;
    frequency = !!x;
    return histogram;
  };

  return histogram;
};

function d3_layout_histogramBinSturges(range, values) {
  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
}

function d3_layout_histogramBinFixed(range, n) {
  var x = -1,
      b = +range[0],
      m = (range[1] - b) / n,
      f = [];
  while (++x <= n) f[x] = m * x + b;
  return f;
}

function d3_layout_histogramRange(values) {
  return [d3.min(values), d3.max(values)];
}
d3.layout.hierarchy = function() {
  var sort = d3_layout_hierarchySort,
      children = d3_layout_hierarchyChildren,
      value = d3_layout_hierarchyValue;

  // Recursively compute the node depth and value.
  // Also converts the data representation into a standard hierarchy structure.
  function recurse(data, depth, nodes) {
    var childs = children.call(hierarchy, data, depth),
        node = d3_layout_hierarchyInline ? data : {data: data};
    node.depth = depth;
    nodes.push(node);
    if (childs && (n = childs.length)) {
      var i = -1,
          n,
          c = node.children = [],
          v = 0,
          j = depth + 1,
          d;
      while (++i < n) {
        d = recurse(childs[i], j, nodes);
        d.parent = node;
        c.push(d);
        v += d.value;
      }
      if (sort) c.sort(sort);
      if (value) node.value = v;
    } else if (value) {
      node.value = +value.call(hierarchy, data, depth) || 0;
    }
    return node;
  }

  // Recursively re-evaluates the node value.
  function revalue(node, depth) {
    var children = node.children,
        v = 0;
    if (children && (n = children.length)) {
      var i = -1,
          n,
          j = depth + 1;
      while (++i < n) v += revalue(children[i], j);
    } else if (value) {
      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;
    }
    if (value) node.value = v;
    return v;
  }

  function hierarchy(d) {
    var nodes = [];
    recurse(d, 0, nodes);
    return nodes;
  }

  hierarchy.sort = function(x) {
    if (!arguments.length) return sort;
    sort = x;
    return hierarchy;
  };

  hierarchy.children = function(x) {
    if (!arguments.length) return children;
    children = x;
    return hierarchy;
  };

  hierarchy.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return hierarchy;
  };

  // Re-evaluates the `value` property for the specified hierarchy.
  hierarchy.revalue = function(root) {
    revalue(root, 0);
    return root;
  };

  return hierarchy;
};

// A method assignment helper for hierarchy subclasses.
function d3_layout_hierarchyRebind(object, hierarchy) {
  d3.rebind(object, hierarchy, "sort", "children", "value");

  // Add an alias for links, for convenience.
  object.links = d3_layout_hierarchyLinks;

  // If the new API is used, enabling inlining.
  object.nodes = function(d) {
    d3_layout_hierarchyInline = true;
    return (object.nodes = object)(d);
  };

  return object;
}

function d3_layout_hierarchyChildren(d) {
  return d.children;
}

function d3_layout_hierarchyValue(d) {
  return d.value;
}

function d3_layout_hierarchySort(a, b) {
  return b.value - a.value;
}

// Returns an array source+target objects for the specified nodes.
function d3_layout_hierarchyLinks(nodes) {
  return d3.merge(nodes.map(function(parent) {
    return (parent.children || []).map(function(child) {
      return {source: parent, target: child};
    });
  }));
}

// For backwards-compatibility, don't enable inlining by default.
var d3_layout_hierarchyInline = false;
d3.layout.pack = function() {
  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
      size = [1, 1];

  function pack(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0];

    // Recursively compute the layout.
    root.x = 0;
    root.y = 0;
    d3_layout_packTree(root);

    // Scale the layout to fit the requested size.
    var w = size[0],
        h = size[1],
        k = 1 / Math.max(2 * root.r / w, 2 * root.r / h);
    d3_layout_packTransform(root, w / 2, h / 2, k);

    return nodes;
  }

  pack.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return pack;
  };

  return d3_layout_hierarchyRebind(pack, hierarchy);
};

function d3_layout_packSort(a, b) {
  return a.value - b.value;
}

function d3_layout_packInsert(a, b) {
  var c = a._pack_next;
  a._pack_next = b;
  b._pack_prev = a;
  b._pack_next = c;
  c._pack_prev = b;
}

function d3_layout_packSplice(a, b) {
  a._pack_next = b;
  b._pack_prev = a;
}

function d3_layout_packIntersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - dx * dx - dy * dy > .001; // within epsilon
}

function d3_layout_packCircle(nodes) {
  var xMin = Infinity,
      xMax = -Infinity,
      yMin = Infinity,
      yMax = -Infinity,
      n = nodes.length,
      a, b, c, j, k;

  function bound(node) {
    xMin = Math.min(node.x - node.r, xMin);
    xMax = Math.max(node.x + node.r, xMax);
    yMin = Math.min(node.y - node.r, yMin);
    yMax = Math.max(node.y + node.r, yMax);
  }

  // Create node links.
  nodes.forEach(d3_layout_packLink);

  // Create first node.
  a = nodes[0];
  a.x = -a.r;
  a.y = 0;
  bound(a);

  // Create second node.
  if (n > 1) {
    b = nodes[1];
    b.x = b.r;
    b.y = 0;
    bound(b);

    // Create third node and build chain.
    if (n > 2) {
      c = nodes[2];
      d3_layout_packPlace(a, b, c);
      bound(c);
      d3_layout_packInsert(a, c);
      a._pack_prev = c;
      d3_layout_packInsert(c, b);
      b = a._pack_next;

      // Now iterate through the rest.
      for (var i = 3; i < n; i++) {
        d3_layout_packPlace(a, b, c = nodes[i]);

        // Search for the closest intersection.
        var isect = 0, s1 = 1, s2 = 1;
        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
          if (d3_layout_packIntersects(j, c)) {
            isect = 1;
            break;
          }
        }
        if (isect == 1) {
          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
            if (d3_layout_packIntersects(k, c)) {
              break;
            }
          }
        }

        // Update node chain.
        if (isect) {
          if (s1 < s2 || (s1 == s2 && b.r < a.r)) d3_layout_packSplice(a, b = j);
          else d3_layout_packSplice(a = k, b);
          i--;
        } else {
          d3_layout_packInsert(a, c);
          b = c;
          bound(c);
        }
      }
    }
  }

  // Re-center the circles and return the encompassing radius.
  var cx = (xMin + xMax) / 2,
      cy = (yMin + yMax) / 2,
      cr = 0;
  for (var i = 0; i < n; i++) {
    var node = nodes[i];
    node.x -= cx;
    node.y -= cy;
    cr = Math.max(cr, node.r + Math.sqrt(node.x * node.x + node.y * node.y));
  }

  // Remove node links.
  nodes.forEach(d3_layout_packUnlink);

  return cr;
}

function d3_layout_packLink(node) {
  node._pack_next = node._pack_prev = node;
}

function d3_layout_packUnlink(node) {
  delete node._pack_next;
  delete node._pack_prev;
}

function d3_layout_packTree(node) {
  var children = node.children;
  if (children && children.length) {
    children.forEach(d3_layout_packTree);
    node.r = d3_layout_packCircle(children);
  } else {
    node.r = Math.sqrt(node.value);
  }
}

function d3_layout_packTransform(node, x, y, k) {
  var children = node.children;
  node.x = (x += k * node.x);
  node.y = (y += k * node.y);
  node.r *= k;
  if (children) {
    var i = -1, n = children.length;
    while (++i < n) d3_layout_packTransform(children[i], x, y, k);
  }
}

function d3_layout_packPlace(a, b, c) {
  var db = a.r + c.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  if (db && (dx || dy)) {
    var da = b.r + c.r,
        dc = Math.sqrt(dx * dx + dy * dy),
        cos = Math.max(-1, Math.min(1, (db * db + dc * dc - da * da) / (2 * db * dc))),
        theta = Math.acos(cos),
        x = cos * (db /= dc),
        y = Math.sin(theta) * db;
    c.x = a.x + x * dx + y * dy;
    c.y = a.y + x * dy - y * dx;
  } else {
    c.x = a.x + db;
    c.y = a.y;
  }
}
// Implements a hierarchical layout using the cluster (or dendrogram)
// algorithm.
d3.layout.cluster = function() {
  var hierarchy = d3.layout.hierarchy().sort(null).value(null),
      separation = d3_layout_treeSeparation,
      size = [1, 1]; // width, height

  function cluster(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0],
        previousNode,
        x = 0,
        kx,
        ky;

    // First walk, computing the initial x & y values.
    d3_layout_treeVisitAfter(root, function(node) {
      var children = node.children;
      if (children && children.length) {
        node.x = d3_layout_clusterX(children);
        node.y = d3_layout_clusterY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    // Compute the left-most, right-most, and depth-most nodes for extents.
    var left = d3_layout_clusterLeft(root),
        right = d3_layout_clusterRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    d3_layout_treeVisitAfter(root, function(node) {
      node.x = (node.x - x0) / (x1 - x0) * size[0];
      node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
    });

    return nodes;
  }

  cluster.separation = function(x) {
    if (!arguments.length) return separation;
    separation = x;
    return cluster;
  };

  cluster.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return cluster;
  };

  return d3_layout_hierarchyRebind(cluster, hierarchy);
};

function d3_layout_clusterY(children) {
  return 1 + d3.max(children, function(child) {
    return child.y;
  });
}

function d3_layout_clusterX(children) {
  return children.reduce(function(x, child) {
    return x + child.x;
  }, 0) / children.length;
}

function d3_layout_clusterLeft(node) {
  var children = node.children;
  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
}

function d3_layout_clusterRight(node) {
  var children = node.children, n;
  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
}
// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
d3.layout.tree = function() {
  var hierarchy = d3.layout.hierarchy().sort(null).value(null),
      separation = d3_layout_treeSeparation,
      size = [1, 1]; // width, height

  function tree(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0];

    function firstWalk(node, previousSibling) {
      var children = node.children,
          layout = node._tree;
      if (children && (n = children.length)) {
        var n,
            firstChild = children[0],
            previousChild,
            ancestor = firstChild,
            child,
            i = -1;
        while (++i < n) {
          child = children[i];
          firstWalk(child, previousChild);
          ancestor = apportion(child, previousChild, ancestor);
          previousChild = child;
        }
        d3_layout_treeShift(node);
        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
        if (previousSibling) {
          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          layout.mod = layout.prelim - midpoint;
        } else {
          layout.prelim = midpoint;
        }
      } else {
        if (previousSibling) {
          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
        }
      }
    }

    function secondWalk(node, x) {
      node.x = node._tree.prelim + x;
      var children = node.children;
      if (children && (n = children.length)) {
        var i = -1,
            n;
        x += node._tree.mod;
        while (++i < n) {
          secondWalk(children[i], x);
        }
      }
    }

    function apportion(node, previousSibling, ancestor) {
      if (previousSibling) {
        var vip = node,
            vop = node,
            vim = previousSibling,
            vom = node.parent.children[0],
            sip = vip._tree.mod,
            sop = vop._tree.mod,
            sim = vim._tree.mod,
            som = vom._tree.mod,
            shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop._tree.ancestor = node;
          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim._tree.mod;
          sip += vip._tree.mod;
          som += vom._tree.mod;
          sop += vop._tree.mod;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop._tree.thread = vim;
          vop._tree.mod += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom._tree.thread = vip;
          vom._tree.mod += sip - som;
          ancestor = node;
        }
      }
      return ancestor;
    }

    // Initialize temporary layout variables.
    d3_layout_treeVisitAfter(root, function(node, previousSibling) {
      node._tree = {
        ancestor: node,
        prelim: 0,
        mod: 0,
        change: 0,
        shift: 0,
        number: previousSibling ? previousSibling._tree.number + 1 : 0
      };
    });

    // Compute the layout using Buchheim et al.'s algorithm.
    firstWalk(root);
    secondWalk(root, -root._tree.prelim);

    // Compute the left-most, right-most, and depth-most nodes for extents.
    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),
        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),
        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2,
        y1 = deep.depth || 1;

    // Clear temporary layout variables; transform x and y.
    d3_layout_treeVisitAfter(root, function(node) {
      node.x = (node.x - x0) / (x1 - x0) * size[0];
      node.y = node.depth / y1 * size[1];
      delete node._tree;
    });

    return nodes;
  }

  tree.separation = function(x) {
    if (!arguments.length) return separation;
    separation = x;
    return tree;
  };

  tree.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return tree;
  };

  return d3_layout_hierarchyRebind(tree, hierarchy);
};

function d3_layout_treeSeparation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}

// function d3_layout_treeSeparationRadial(a, b) {
//   return (a.parent == b.parent ? 1 : 2) / a.depth;
// }

function d3_layout_treeLeft(node) {
  var children = node.children;
  return children && children.length ? children[0] : node._tree.thread;
}

function d3_layout_treeRight(node) {
  var children = node.children,
      n;
  return children && (n = children.length) ? children[n - 1] : node._tree.thread;
}

function d3_layout_treeSearch(node, compare) {
  var children = node.children;
  if (children && (n = children.length)) {
    var child,
        n,
        i = -1;
    while (++i < n) {
      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
        node = child;
      }
    }
  }
  return node;
}

function d3_layout_treeRightmost(a, b) {
  return a.x - b.x;
}

function d3_layout_treeLeftmost(a, b) {
  return b.x - a.x;
}

function d3_layout_treeDeepest(a, b) {
  return a.depth - b.depth;
}

function d3_layout_treeVisitAfter(node, callback) {
  function visit(node, previousSibling) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child,
          previousChild = null,
          i = -1,
          n;
      while (++i < n) {
        child = children[i];
        visit(child, previousChild);
        previousChild = child;
      }
    }
    callback(node, previousSibling);
  }
  visit(node, null);
}

function d3_layout_treeShift(node) {
  var shift = 0,
      change = 0,
      children = node.children,
      i = children.length,
      child;
  while (--i >= 0) {
    child = children[i]._tree;
    child.prelim += shift;
    child.mod += shift;
    shift += child.shift + (change += child.change);
  }
}

function d3_layout_treeMove(ancestor, node, shift) {
  ancestor = ancestor._tree;
  node = node._tree;
  var change = shift / (node.number - ancestor.number);
  ancestor.change += change;
  node.change -= change;
  node.shift += shift;
  node.prelim += shift;
  node.mod += shift;
}

function d3_layout_treeAncestor(vim, node, ancestor) {
  return vim._tree.ancestor.parent == node.parent
      ? vim._tree.ancestor
      : ancestor;
}
// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
// Modified to support a target aspect ratio by Jeff Heer
d3.layout.treemap = function() {
  var hierarchy = d3.layout.hierarchy(),
      round = Math.round,
      size = [1, 1], // width, height
      padding = null,
      pad = d3_layout_treemapPadNull,
      sticky = false,
      stickies,
      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio

  // Compute the area for each child based on value & scale.
  function scale(children, k) {
    var i = -1,
        n = children.length,
        child,
        area;
    while (++i < n) {
      area = (child = children[i]).value * (k < 0 ? 0 : k);
      child.area = isNaN(area) || area <= 0 ? 0 : area;
    }
  }

  // Recursively arranges the specified node's children into squarified rows.
  function squarify(node) {
    var children = node.children;
    if (children && children.length) {
      var rect = pad(node),
          row = [],
          remaining = children.slice(), // copy-on-write
          child,
          best = Infinity, // the best row score so far
          score, // the current row score
          u = Math.min(rect.dx, rect.dy), // initial orientation
          n;
      scale(remaining, rect.dx * rect.dy / node.value);
      row.area = 0;
      while ((n = remaining.length) > 0) {
        row.push(child = remaining[n - 1]);
        row.area += child.area;
        if ((score = worst(row, u)) <= best) { // continue with this orientation
          remaining.pop();
          best = score;
        } else { // abort, and try a different orientation
          row.area -= row.pop().area;
          position(row, u, rect, false);
          u = Math.min(rect.dx, rect.dy);
          row.length = row.area = 0;
          best = Infinity;
        }
      }
      if (row.length) {
        position(row, u, rect, true);
        row.length = row.area = 0;
      }
      children.forEach(squarify);
    }
  }

  // Recursively resizes the specified node's children into existing rows.
  // Preserves the existing layout!
  function stickify(node) {
    var children = node.children;
    if (children && children.length) {
      var rect = pad(node),
          remaining = children.slice(), // copy-on-write
          child,
          row = [];
      scale(remaining, rect.dx * rect.dy / node.value);
      row.area = 0;
      while (child = remaining.pop()) {
        row.push(child);
        row.area += child.area;
        if (child.z != null) {
          position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
          row.length = row.area = 0;
        }
      }
      children.forEach(stickify);
    }
  }

  // Computes the score for the specified row, as the worst aspect ratio.
  function worst(row, u) {
    var s = row.area,
        r,
        rmax = 0,
        rmin = Infinity,
        i = -1,
        n = row.length;
    while (++i < n) {
      if (!(r = row[i].area)) continue;
      if (r < rmin) rmin = r;
      if (r > rmax) rmax = r;
    }
    s *= s;
    u *= u;
    return s
        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))
        : Infinity;
  }

  // Positions the specified row of nodes. Modifies `rect`.
  function position(row, u, rect, flush) {
    var i = -1,
        n = row.length,
        x = rect.x,
        y = rect.y,
        v = u ? round(row.area / u) : 0,
        o;
    if (u == rect.dx) { // horizontal subdivision
      if (flush || v > rect.dy) v = rect.dy; // over+underflow
      while (++i < n) {
        o = row[i];
        o.x = x;
        o.y = y;
        o.dy = v;
        x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
      }
      o.z = true;
      o.dx += rect.x + rect.dx - x; // rounding error
      rect.y += v;
      rect.dy -= v;
    } else { // vertical subdivision
      if (flush || v > rect.dx) v = rect.dx; // over+underflow
      while (++i < n) {
        o = row[i];
        o.x = x;
        o.y = y;
        o.dx = v;
        y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
      }
      o.z = false;
      o.dy += rect.y + rect.dy - y; // rounding error
      rect.x += v;
      rect.dx -= v;
    }
  }

  function treemap(d) {
    var nodes = stickies || hierarchy(d),
        root = nodes[0];
    root.x = 0;
    root.y = 0;
    root.dx = size[0];
    root.dy = size[1];
    if (stickies) hierarchy.revalue(root);
    scale([root], root.dx * root.dy / root.value);
    (stickies ? stickify : squarify)(root);
    if (sticky) stickies = nodes;
    return nodes;
  }

  treemap.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return treemap;
  };

  treemap.padding = function(x) {
    if (!arguments.length) return padding;

    function padFunction(node) {
      var p = x.call(treemap, node, node.depth);
      return p == null
          ? d3_layout_treemapPadNull(node)
          : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
    }

    function padConstant(node) {
      return d3_layout_treemapPad(node, x);
    }

    var type;
    pad = (padding = x) == null ? d3_layout_treemapPadNull
        : (type = typeof x) === "function" ? padFunction
        : type === "number" ? (x = [x, x, x, x], padConstant)
        : padConstant;
    return treemap;
  };

  treemap.round = function(x) {
    if (!arguments.length) return round != Number;
    round = x ? Math.round : Number;
    return treemap;
  };

  treemap.sticky = function(x) {
    if (!arguments.length) return sticky;
    sticky = x;
    stickies = null;
    return treemap;
  };

  treemap.ratio = function(x) {
    if (!arguments.length) return ratio;
    ratio = x;
    return treemap;
  };

  return d3_layout_hierarchyRebind(treemap, hierarchy);
};

function d3_layout_treemapPadNull(node) {
  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};
}

function d3_layout_treemapPad(node, padding) {
  var x = node.x + padding[3],
      y = node.y + padding[0],
      dx = node.dx - padding[1] - padding[3],
      dy = node.dy - padding[0] - padding[2];
  if (dx < 0) { x += dx / 2; dx = 0; }
  if (dy < 0) { y += dy / 2; dy = 0; }
  return {x: x, y: y, dx: dx, dy: dy};
}
d3.csv = function(url, callback) {
  d3.text(url, "text/csv", function(text) {
    callback(text && d3.csv.parse(text));
  });
};
d3.csv.parse = function(text) {
  var header;
  return d3.csv.parseRows(text, function(row, i) {
    if (i) {
      var o = {}, j = -1, m = header.length;
      while (++j < m) o[header[j]] = row[j];
      return o;
    } else {
      header = row;
      return null;
    }
  });
};

d3.csv.parseRows = function(text, f) {
  var EOL = {}, // sentinel value for end-of-line
      EOF = {}, // sentinel value for end-of-file
      rows = [], // output rows
      re = /\r\n|[,\r\n]/g, // field separator regex
      n = 0, // the current line number
      t, // the current token
      eol; // is the current token followed by EOL?

  re.lastIndex = 0; // work-around bug in FF 3.6

  /** @private Returns the next token. */
  function token() {
    if (re.lastIndex >= text.length) return EOF; // special case: end of file
    if (eol) { eol = false; return EOL; } // special case: end of line

    // special case: quotes
    var j = re.lastIndex;
    if (text.charCodeAt(j) === 34) {
      var i = j;
      while (i++ < text.length) {
        if (text.charCodeAt(i) === 34) {
          if (text.charCodeAt(i + 1) !== 34) break;
          i++;
        }
      }
      re.lastIndex = i + 2;
      var c = text.charCodeAt(i + 1);
      if (c === 13) {
        eol = true;
        if (text.charCodeAt(i + 2) === 10) re.lastIndex++;
      } else if (c === 10) {
        eol = true;
      }
      return text.substring(j + 1, i).replace(/""/g, "\"");
    }

    // common case
    var m = re.exec(text);
    if (m) {
      eol = m[0].charCodeAt(0) !== 44;
      return text.substring(j, m.index);
    }
    re.lastIndex = text.length;
    return text.substring(j);
  }

  while ((t = token()) !== EOF) {
    var a = [];
    while ((t !== EOL) && (t !== EOF)) {
      a.push(t);
      t = token();
    }
    if (f && !(a = f(a, n++))) continue;
    rows.push(a);
  }

  return rows;
};
d3.csv.format = function(rows) {
  return rows.map(d3_csv_formatRow).join("\n");
};

function d3_csv_formatRow(row) {
  return row.map(d3_csv_formatValue).join(",");
}

function d3_csv_formatValue(text) {
  return /[",\n]/.test(text)
      ? "\"" + text.replace(/\"/g, "\"\"") + "\""
      : text;
}
d3.geo = {};

var d3_geo_radians = Math.PI / 180;
// TODO clip input coordinates on opposite hemisphere
d3.geo.azimuthal = function() {
  var mode = "orthographic", // or stereographic, gnomonic, equidistant or equalarea
      origin,
      scale = 200,
      translate = [480, 250],
      x0,
      y0,
      cy0,
      sy0;

  function azimuthal(coordinates) {
    var x1 = coordinates[0] * d3_geo_radians - x0,
        y1 = coordinates[1] * d3_geo_radians,
        cx1 = Math.cos(x1),
        sx1 = Math.sin(x1),
        cy1 = Math.cos(y1),
        sy1 = Math.sin(y1),
        cc = mode !== "orthographic" ? sy0 * sy1 + cy0 * cy1 * cx1 : null,
        c,
        k = mode === "stereographic" ? 1 / (1 + cc)
          : mode === "gnomonic" ? 1 / cc
          : mode === "equidistant" ? (c = Math.acos(cc), c ? c / Math.sin(c) : 0)
          : mode === "equalarea" ? Math.sqrt(2 / (1 + cc))
          : 1,
        x = k * cy1 * sx1,
        y = k * (sy0 * cy1 * cx1 - cy0 * sy1);
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  azimuthal.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale,
        p = Math.sqrt(x * x + y * y),
        c = mode === "stereographic" ? 2 * Math.atan(p)
          : mode === "gnomonic" ? Math.atan(p)
          : mode === "equidistant" ? p
          : mode === "equalarea" ? 2 * Math.asin(.5 * p)
          : Math.asin(p),
        sc = Math.sin(c),
        cc = Math.cos(c);
    return [
      (x0 + Math.atan2(x * sc, p * cy0 * cc + y * sy0 * sc)) / d3_geo_radians,
      Math.asin(cc * sy0 - (p ? (y * sc * cy0) / p : 0)) / d3_geo_radians
    ];
  };

  azimuthal.mode = function(x) {
    if (!arguments.length) return mode;
    mode = x + "";
    return azimuthal;
  };

  azimuthal.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    x0 = origin[0] * d3_geo_radians;
    y0 = origin[1] * d3_geo_radians;
    cy0 = Math.cos(y0);
    sy0 = Math.sin(y0);
    return azimuthal;
  };

  azimuthal.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return azimuthal;
  };

  azimuthal.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return azimuthal;
  };

  return azimuthal.origin([0, 0]);
};
// Derived from Tom Carden's Albers implementation for Protovis.
// http://gist.github.com/476238
// http://mathworld.wolfram.com/AlbersEqual-AreaConicProjection.html

d3.geo.albers = function() {
  var origin = [-98, 38],
      parallels = [29.5, 45.5],
      scale = 1000,
      translate = [480, 250],
      lng0, // d3_geo_radians * origin[0]
      n,
      C,
      p0;

  function albers(coordinates) {
    var t = n * (d3_geo_radians * coordinates[0] - lng0),
        p = Math.sqrt(C - 2 * n * Math.sin(d3_geo_radians * coordinates[1])) / n;
    return [
      scale * p * Math.sin(t) + translate[0],
      scale * (p * Math.cos(t) - p0) + translate[1]
    ];
  }

  albers.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale,
        p0y = p0 + y,
        t = Math.atan2(x, p0y),
        p = Math.sqrt(x * x + p0y * p0y);
    return [
      (lng0 + t / n) / d3_geo_radians,
      Math.asin((C - p * p * n * n) / (2 * n)) / d3_geo_radians
    ];
  };

  function reload() {
    var phi1 = d3_geo_radians * parallels[0],
        phi2 = d3_geo_radians * parallels[1],
        lat0 = d3_geo_radians * origin[1],
        s = Math.sin(phi1),
        c = Math.cos(phi1);
    lng0 = d3_geo_radians * origin[0];
    n = .5 * (s + Math.sin(phi2));
    C = c * c + 2 * n * s;
    p0 = Math.sqrt(C - 2 * n * Math.sin(lat0)) / n;
    return albers;
  }

  albers.origin = function(x) {
    if (!arguments.length) return origin;
    origin = [+x[0], +x[1]];
    return reload();
  };

  albers.parallels = function(x) {
    if (!arguments.length) return parallels;
    parallels = [+x[0], +x[1]];
    return reload();
  };

  albers.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return albers;
  };

  albers.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return albers;
  };

  return reload();
};

// A composite projection for the United States, 960x500. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
// TODO allow the composite projection to be rescaled?
d3.geo.albersUsa = function() {
  var lower48 = d3.geo.albers();

  var alaska = d3.geo.albers()
      .origin([-160, 60])
      .parallels([55, 65]);

  var hawaii = d3.geo.albers()
      .origin([-160, 20])
      .parallels([8, 18]);

  var puertoRico = d3.geo.albers()
      .origin([-60, 10])
      .parallels([8, 18]);

  function albersUsa(coordinates) {
    var lon = coordinates[0],
        lat = coordinates[1];
    return (lat > 50 ? alaska
        : lon < -140 ? hawaii
        : lat < 21 ? puertoRico
        : lower48)(coordinates);
  }

  albersUsa.scale = function(x) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(x);
    alaska.scale(x * .6);
    hawaii.scale(x);
    puertoRico.scale(x * 1.5);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(x) {
    if (!arguments.length) return lower48.translate();
    var dz = lower48.scale() / 1000,
        dx = x[0],
        dy = x[1];
    lower48.translate(x);
    alaska.translate([dx - 400 * dz, dy + 170 * dz]);
    hawaii.translate([dx - 190 * dz, dy + 200 * dz]);
    puertoRico.translate([dx + 580 * dz, dy + 430 * dz]);
    return albersUsa;
  };

  return albersUsa.scale(lower48.scale());
};
d3.geo.bonne = function() {
  var scale = 200,
      translate = [480, 250],
      x0, // origin longitude in radians
      y0, // origin latitude in radians
      y1, // parallel latitude in radians
      c1; // cot(y1)

  function bonne(coordinates) {
    var x = coordinates[0] * d3_geo_radians - x0,
        y = coordinates[1] * d3_geo_radians - y0;
    if (y1) {
      var p = c1 + y1 - y, E = x * Math.cos(y) / p;
      x = p * Math.sin(E);
      y = p * Math.cos(E) - c1;
    } else {
      x *= Math.cos(y);
      y *= -1;
    }
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  bonne.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    if (y1) {
      var c = c1 + y, p = Math.sqrt(x * x + c * c);
      y = c1 + y1 - p;
      x = x0 + p * Math.atan2(x, c) / Math.cos(y);
    } else {
      y *= -1;
      x /= Math.cos(y);
    }
    return [
      x / d3_geo_radians,
      y / d3_geo_radians
    ];
  };

  // 90° for Werner, 0° for Sinusoidal
  bonne.parallel = function(x) {
    if (!arguments.length) return y1 / d3_geo_radians;
    c1 = 1 / Math.tan(y1 = x * d3_geo_radians);
    return bonne;
  };

  bonne.origin = function(x) {
    if (!arguments.length) return [x0 / d3_geo_radians, y0 / d3_geo_radians];
    x0 = x[0] * d3_geo_radians;
    y0 = x[1] * d3_geo_radians;
    return bonne;
  };

  bonne.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return bonne;
  };

  bonne.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return bonne;
  };

  return bonne.origin([0, 0]).parallel(45);
};
d3.geo.equirectangular = function() {
  var scale = 500,
      translate = [480, 250];

  function equirectangular(coordinates) {
    var x = coordinates[0] / 360,
        y = -coordinates[1] / 360;
    return [
      scale * x + translate[0],
      scale * y + translate[1]
    ];
  }

  equirectangular.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    return [
      360 * x,
      -360 * y
    ];
  };

  equirectangular.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return equirectangular;
  };

  equirectangular.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return equirectangular;
  };

  return equirectangular;
};
d3.geo.mercator = function() {
  var scale = 500,
      translate = [480, 250];

  function mercator(coordinates) {
    var x = coordinates[0] / 360,
        y = -(Math.log(Math.tan(Math.PI / 4 + coordinates[1] * d3_geo_radians / 2)) / d3_geo_radians) / 360;
    return [
      scale * x + translate[0],
      scale * Math.max(-.5, Math.min(.5, y)) + translate[1]
    ];
  }

  mercator.invert = function(coordinates) {
    var x = (coordinates[0] - translate[0]) / scale,
        y = (coordinates[1] - translate[1]) / scale;
    return [
      360 * x,
      2 * Math.atan(Math.exp(-360 * y * d3_geo_radians)) / d3_geo_radians - 90
    ];
  };

  mercator.scale = function(x) {
    if (!arguments.length) return scale;
    scale = +x;
    return mercator;
  };

  mercator.translate = function(x) {
    if (!arguments.length) return translate;
    translate = [+x[0], +x[1]];
    return mercator;
  };

  return mercator;
};
function d3_geo_type(types, defaultValue) {
  return function(object) {
    return object && types.hasOwnProperty(object.type) ? types[object.type](object) : defaultValue;
  };
}
/**
 * Returns a function that, given a GeoJSON object (e.g., a feature), returns
 * the corresponding SVG path. The function can be customized by overriding the
 * projection. Point features are mapped to circles with a default radius of
 * 4.5px; the radius can be specified either as a constant or a function that
 * is evaluated per object.
 */
d3.geo.path = function() {
  var pointRadius = 4.5,
      pointCircle = d3_path_circle(pointRadius),
      projection = d3.geo.albersUsa(),
      buffer = [];

  function path(d, i) {
    if (typeof pointRadius === "function") pointCircle = d3_path_circle(pointRadius.apply(this, arguments));
    pathType(d);
    var result = buffer.length ? buffer.join("") : null;
    buffer = [];
    return result;
  }

  function project(coordinates) {
    return projection(coordinates).join(",");
  }

  var pathType = d3_geo_type({

    FeatureCollection: function(o) {
      var features = o.features,
          i = -1, // features.index
          n = features.length;
      while (++i < n) buffer.push(pathType(features[i].geometry));
    },

    Feature: function(o) {
      pathType(o.geometry);
    },

    Point: function(o) {
      buffer.push("M", project(o.coordinates), pointCircle);
    },

    MultiPoint: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length;
      while (++i < n) buffer.push("M", project(coordinates[i]), pointCircle);
    },

    LineString: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length;
      buffer.push("M");
      while (++i < n) buffer.push(project(coordinates[i]), "L");
      buffer.pop();
    },

    MultiLineString: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates.index
          m; // subcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        m = subcoordinates.length;
        buffer.push("M");
        while (++j < m) buffer.push(project(subcoordinates[j]), "L");
        buffer.pop();
      }
    },

    Polygon: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates.index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates.index
          m; // subcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        if ((m = subcoordinates.length - 1) > 0) {
          buffer.push("M");
          while (++j < m) buffer.push(project(subcoordinates[j]), "L");
          buffer[buffer.length - 1] = "Z";
        }
      }
    },

    MultiPolygon: function(o) {
      var coordinates = o.coordinates,
          i = -1, // coordinates index
          n = coordinates.length,
          subcoordinates, // coordinates[i]
          j, // subcoordinates index
          m, // subcoordinates.length
          subsubcoordinates, // subcoordinates[j]
          k, // subsubcoordinates index
          p; // subsubcoordinates.length
      while (++i < n) {
        subcoordinates = coordinates[i];
        j = -1;
        m = subcoordinates.length;
        while (++j < m) {
          subsubcoordinates = subcoordinates[j];
          k = -1;
          if ((p = subsubcoordinates.length - 1) > 0) {
            buffer.push("M");
            while (++k < p) buffer.push(project(subsubcoordinates[k]), "L");
            buffer[buffer.length - 1] = "Z";
          }
        }
      }
    },

    GeometryCollection: function(o) {
      var geometries = o.geometries,
          i = -1, // geometries index
          n = geometries.length;
      while (++i < n) buffer.push(pathType(geometries[i]));
    }

  });

  var areaType = path.area = d3_geo_type({

    FeatureCollection: function(o) {
      var area = 0,
          features = o.features,
          i = -1, // features.index
          n = features.length;
      while (++i < n) area += areaType(features[i]);
      return area;
    },

    Feature: function(o) {
      return areaType(o.geometry);
    },

    Polygon: function(o) {
      return polygonArea(o.coordinates);
    },

    MultiPolygon: function(o) {
      var sum = 0,
          coordinates = o.coordinates,
          i = -1, // coordinates index
          n = coordinates.length;
      while (++i < n) sum += polygonArea(coordinates[i]);
      return sum;
    },

    GeometryCollection: function(o) {
      var sum = 0,
          geometries = o.geometries,
          i = -1, // geometries index
          n = geometries.length;
      while (++i < n) sum += areaType(geometries[i]);
      return sum;
    }

  }, 0);

  function polygonArea(coordinates) {
    var sum = area(coordinates[0]), // exterior ring
        i = 0, // coordinates.index
        n = coordinates.length;
    while (++i < n) sum -= area(coordinates[i]); // holes
    return sum;
  }

  function polygonCentroid(coordinates) {
    var polygon = d3.geom.polygon(coordinates[0].map(projection)), // exterior ring
        area = polygon.area(),
        centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1),
        x = centroid[0],
        y = centroid[1],
        z = area,
        i = 0, // coordinates index
        n = coordinates.length;
    while (++i < n) {
      polygon = d3.geom.polygon(coordinates[i].map(projection)); // holes
      area = polygon.area();
      centroid = polygon.centroid(area < 0 ? (area *= -1, 1) : -1);
      x -= centroid[0];
      y -= centroid[1];
      z -= area;
    }
    return [x, y, 6 * z]; // weighted centroid
  }

  var centroidType = path.centroid = d3_geo_type({

    // TODO FeatureCollection
    // TODO Point
    // TODO MultiPoint
    // TODO LineString
    // TODO MultiLineString
    // TODO GeometryCollection

    Feature: function(o) {
      return centroidType(o.geometry);
    },

    Polygon: function(o) {
      var centroid = polygonCentroid(o.coordinates);
      return [centroid[0] / centroid[2], centroid[1] / centroid[2]];
    },

    MultiPolygon: function(o) {
      var area = 0,
          coordinates = o.coordinates,
          centroid,
          x = 0,
          y = 0,
          z = 0,
          i = -1, // coordinates index
          n = coordinates.length;
      while (++i < n) {
        centroid = polygonCentroid(coordinates[i]);
        x += centroid[0];
        y += centroid[1];
        z += centroid[2];
      }
      return [x / z, y / z];
    }

  });

  function area(coordinates) {
    return Math.abs(d3.geom.polygon(coordinates.map(projection)).area());
  }

  path.projection = function(x) {
    projection = x;
    return path;
  };

  path.pointRadius = function(x) {
    if (typeof x === "function") pointRadius = x;
    else {
      pointRadius = +x;
      pointCircle = d3_path_circle(pointRadius);
    }
    return path;
  };

  return path;
};

function d3_path_circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + (-2 * radius)
      + "a" + radius + "," + radius + " 0 1,1 0," + (+2 * radius)
      + "z";
}
/**
 * Given a GeoJSON object, returns the corresponding bounding box. The bounding
 * box is represented by a two-dimensional array: [[left, bottom], [right,
 * top]], where left is the minimum longitude, bottom is the minimum latitude,
 * right is maximum longitude, and top is the maximum latitude.
 */
d3.geo.bounds = function(feature) {
  var left = Infinity,
      bottom = Infinity,
      right = -Infinity,
      top = -Infinity;
  d3_geo_bounds(feature, function(x, y) {
    if (x < left) left = x;
    if (x > right) right = x;
    if (y < bottom) bottom = y;
    if (y > top) top = y;
  });
  return [[left, bottom], [right, top]];
};

function d3_geo_bounds(o, f) {
  if (d3_geo_boundsTypes.hasOwnProperty(o.type)) d3_geo_boundsTypes[o.type](o, f);
}

var d3_geo_boundsTypes = {
  Feature: d3_geo_boundsFeature,
  FeatureCollection: d3_geo_boundsFeatureCollection,
  GeometryCollection: d3_geo_boundsGeometryCollection,
  LineString: d3_geo_boundsLineString,
  MultiLineString: d3_geo_boundsMultiLineString,
  MultiPoint: d3_geo_boundsLineString,
  MultiPolygon: d3_geo_boundsMultiPolygon,
  Point: d3_geo_boundsPoint,
  Polygon: d3_geo_boundsPolygon
};

function d3_geo_boundsFeature(o, f) {
  d3_geo_bounds(o.geometry, f);
}

function d3_geo_boundsFeatureCollection(o, f) {
  for (var a = o.features, i = 0, n = a.length; i < n; i++) {
    d3_geo_bounds(a[i].geometry, f);
  }
}

function d3_geo_boundsGeometryCollection(o, f) {
  for (var a = o.geometries, i = 0, n = a.length; i < n; i++) {
    d3_geo_bounds(a[i], f);
  }
}

function d3_geo_boundsLineString(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    f.apply(null, a[i]);
  }
}

function d3_geo_boundsMultiLineString(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    for (var b = a[i], j = 0, m = b.length; j < m; j++) {
      f.apply(null, b[j]);
    }
  }
}

function d3_geo_boundsMultiPolygon(o, f) {
  for (var a = o.coordinates, i = 0, n = a.length; i < n; i++) {
    for (var b = a[i][0], j = 0, m = b.length; j < m; j++) {
      f.apply(null, b[j]);
    }
  }
}

function d3_geo_boundsPoint(o, f) {
  f.apply(null, o.coordinates);
}

function d3_geo_boundsPolygon(o, f) {
  for (var a = o.coordinates[0], i = 0, n = a.length; i < n; i++) {
    f.apply(null, a[i]);
  }
}
// TODO breakAtDateLine?

d3.geo.circle = function() {
  var origin = [0, 0],
      degrees = 90 - 1e-2,
      radians = degrees * d3_geo_radians,
      arc = d3.geo.greatArc().source(origin).target(d3_identity);

  function circle() {
    // TODO render a circle as a Polygon
  }

  function visible(point) {
    return arc.distance(point) < radians;
  }

  circle.clip = function(d) {
    if (typeof origin === "function") arc.source(origin.apply(this, arguments));
    return clipType(d) || null;
  };

  var clipType = d3_geo_type({

    FeatureCollection: function(o) {
      var features = o.features.map(clipType).filter(d3_identity);
      return features && (o = Object.create(o), o.features = features, o);
    },

    Feature: function(o) {
      var geometry = clipType(o.geometry);
      return geometry && (o = Object.create(o), o.geometry = geometry, o);
    },

    Point: function(o) {
      return visible(o.coordinates) && o;
    },

    MultiPoint: function(o) {
      var coordinates = o.coordinates.filter(visible);
      return coordinates.length && {
        type: o.type,
        coordinates: coordinates
      };
    },

    LineString: function(o) {
      var coordinates = clip(o.coordinates);
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    MultiLineString: function(o) {
      var coordinates = o.coordinates.map(clip).filter(function(d) { return d.length; });
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    Polygon: function(o) {
      var coordinates = o.coordinates.map(clip);
      return coordinates[0].length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    MultiPolygon: function(o) {
      var coordinates = o.coordinates.map(function(d) { return d.map(clip); }).filter(function(d) { return d[0].length; });
      return coordinates.length && (o = Object.create(o), o.coordinates = coordinates, o);
    },

    GeometryCollection: function(o) {
      var geometries = o.geometries.map(clipType).filter(d3_identity);
      return geometries.length && (o = Object.create(o), o.geometries = geometries, o);
    }

  });

  function clip(coordinates) {
    var i = -1,
        n = coordinates.length,
        clipped = [],
        p0,
        p1,
        p2,
        d0,
        d1;

    while (++i < n) {
      d1 = arc.distance(p2 = coordinates[i]);
      if (d1 < radians) {
        if (p1) clipped.push(d3_geo_greatArcInterpolate(p1, p2)((d0 - radians) / (d0 - d1)));
        clipped.push(p2);
        p0 = p1 = null;
      } else {
        p1 = p2;
        if (!p0 && clipped.length) {
          clipped.push(d3_geo_greatArcInterpolate(clipped[clipped.length - 1], p1)((radians - d0) / (d1 - d0)));
          p0 = p1;
        }
      }
      d0 = d1;
    }

    // Close the clipped polygon if necessary.
    p0 = coordinates[0];
    p1 = clipped[0];
    if (p1 && p2[0] === p0[0] && p2[1] === p0[1] && !(p2[0] === p1[0] && p2[1] === p1[1])) {
      clipped.push(p1);
    }

    return resample(clipped);
  }

  // Resample coordinates, creating great arcs between each.
  function resample(coordinates) {
    var i = 0,
        n = coordinates.length,
        j,
        m,
        resampled = n ? [coordinates[0]] : coordinates,
        resamples,
        origin = arc.source();

    while (++i < n) {
      resamples = arc.source(coordinates[i - 1])(coordinates[i]).coordinates;
      for (j = 0, m = resamples.length; ++j < m;) resampled.push(resamples[j]);
    }

    arc.source(origin);
    return resampled;
  }

  circle.origin = function(x) {
    if (!arguments.length) return origin;
    origin = x;
    if (typeof origin !== "function") arc.source(origin);
    return circle;
  };

  circle.angle = function(x) {
    if (!arguments.length) return degrees;
    radians = (degrees = +x) * d3_geo_radians;
    return circle;
  };

  return d3.rebind(circle, arc, "precision");
}
d3.geo.greatArc = function() {
  var source = d3_geo_greatArcSource, p0,
      target = d3_geo_greatArcTarget, p1,
      precision = 6 * d3_geo_radians,
      interpolate = d3_geo_greatArcInterpolator();

  function greatArc() {
    var d = greatArc.distance.apply(this, arguments), // initializes the interpolator, too
        t = 0,
        dt = precision / d,
        coordinates = [p0];
    while ((t += dt) < 1) coordinates.push(interpolate(t));
    coordinates.push(p1);
    return {type: "LineString", coordinates: coordinates};
  }

  // Length returned in radians; multiply by radius for distance.
  greatArc.distance = function() {
    if (typeof source === "function") interpolate.source(p0 = source.apply(this, arguments));
    if (typeof target === "function") interpolate.target(p1 = target.apply(this, arguments));
    return interpolate.distance();
  };

  greatArc.source = function(_) {
    if (!arguments.length) return source;
    source = _;
    if (typeof source !== "function") interpolate.source(p0 = source);
    return greatArc;
  };

  greatArc.target = function(_) {
    if (!arguments.length) return target;
    target = _;
    if (typeof target !== "function") interpolate.target(p1 = target);
    return greatArc;
  };

  // Precision is specified in degrees.
  greatArc.precision = function(_) {
    if (!arguments.length) return precision / d3_geo_radians;
    precision = _ * d3_geo_radians;
    return greatArc;
  };

  return greatArc;
};

function d3_geo_greatArcSource(d) {
  return d.source;
}

function d3_geo_greatArcTarget(d) {
  return d.target;
}

function d3_geo_greatArcInterpolator() {
  var x0, y0, cy0, sy0, kx0, ky0,
      x1, y1, cy1, sy1, kx1, ky1,
      d,
      k;

  function interpolate(t) {
    var B = Math.sin(t *= d) * k,
        A = Math.sin(d - t) * k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      Math.atan2(y, x) / d3_geo_radians,
      Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_geo_radians
    ];
  }

  interpolate.distance = function() {
    if (d == null) k = 1 / Math.sin(d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))));
    return d;
  };

  interpolate.source = function(_) {
    var cx0 = Math.cos(x0 = _[0] * d3_geo_radians),
        sx0 = Math.sin(x0);
    cy0 = Math.cos(y0 = _[1] * d3_geo_radians);
    sy0 = Math.sin(y0);
    kx0 = cy0 * cx0;
    ky0 = cy0 * sx0;
    d = null;
    return interpolate;
  };

  interpolate.target = function(_) {
    var cx1 = Math.cos(x1 = _[0] * d3_geo_radians),
        sx1 = Math.sin(x1);
    cy1 = Math.cos(y1 = _[1] * d3_geo_radians);
    sy1 = Math.sin(y1);
    kx1 = cy1 * cx1;
    ky1 = cy1 * sx1;
    d = null;
    return interpolate;
  };

  return interpolate;
}

function d3_geo_greatArcInterpolate(a, b) {
  var i = d3_geo_greatArcInterpolator().source(a).target(b);
  i.distance();
  return i;
}
d3.geo.greatCircle = d3.geo.circle;
d3.geom = {};
/**
 * Computes a contour for a given input grid function using the <a
 * href="http://en.wikipedia.org/wiki/Marching_squares">marching
 * squares</a> algorithm. Returns the contour polygon as an array of points.
 *
 * @param grid a two-input function(x, y) that returns true for values
 * inside the contour and false for values outside the contour.
 * @param start an optional starting point [x, y] on the grid.
 * @returns polygon [[x1, y1], [x2, y2], …]
 */
d3.geom.contour = function(grid, start) {
  var s = start || d3_geom_contourStart(grid), // starting point
      c = [],    // contour polygon
      x = s[0],  // current x position
      y = s[1],  // current y position
      dx = 0,    // next x direction
      dy = 0,    // next y direction
      pdx = NaN, // previous x direction
      pdy = NaN, // previous y direction
      i = 0;

  do {
    // determine marching squares index
    i = 0;
    if (grid(x-1, y-1)) i += 1;
    if (grid(x,   y-1)) i += 2;
    if (grid(x-1, y  )) i += 4;
    if (grid(x,   y  )) i += 8;

    // determine next direction
    if (i === 6) {
      dx = pdy === -1 ? -1 : 1;
      dy = 0;
    } else if (i === 9) {
      dx = 0;
      dy = pdx === 1 ? -1 : 1;
    } else {
      dx = d3_geom_contourDx[i];
      dy = d3_geom_contourDy[i];
    }

    // update contour polygon
    if (dx != pdx && dy != pdy) {
      c.push([x, y]);
      pdx = dx;
      pdy = dy;
    }

    x += dx;
    y += dy;
  } while (s[0] != x || s[1] != y);

  return c;
};

// lookup tables for marching directions
var d3_geom_contourDx = [1, 0, 1, 1,-1, 0,-1, 1,0, 0,0,0,-1, 0,-1,NaN],
    d3_geom_contourDy = [0,-1, 0, 0, 0,-1, 0, 0,1,-1,1,1, 0,-1, 0,NaN];

function d3_geom_contourStart(grid) {
  var x = 0,
      y = 0;

  // search for a starting point; begin at origin
  // and proceed along outward-expanding diagonals
  while (true) {
    if (grid(x,y)) {
      return [x,y];
    }
    if (x === 0) {
      x = y + 1;
      y = 0;
    } else {
      x = x - 1;
      y = y + 1;
    }
  }
}
/**
 * Computes the 2D convex hull of a set of points using Graham's scanning
 * algorithm. The algorithm has been implemented as described in Cormen,
 * Leiserson, and Rivest's Introduction to Algorithms. The running time of
 * this algorithm is O(n log n), where n is the number of input points.
 *
 * @param vertices [[x1, y1], [x2, y2], …]
 * @returns polygon [[x1, y1], [x2, y2], …]
 */
d3.geom.hull = function(vertices) {
  if (vertices.length < 3) return [];

  var len = vertices.length,
      plen = len - 1,
      points = [],
      stack = [],
      i, j, h = 0, x1, y1, x2, y2, u, v, a, sp;

  // find the starting ref point: leftmost point with the minimum y coord
  for (i=1; i<len; ++i) {
    if (vertices[i][1] < vertices[h][1]) {
      h = i;
    } else if (vertices[i][1] == vertices[h][1]) {
      h = (vertices[i][0] < vertices[h][0] ? i : h);
    }
  }

  // calculate polar angles from ref point and sort
  for (i=0; i<len; ++i) {
    if (i === h) continue;
    y1 = vertices[i][1] - vertices[h][1];
    x1 = vertices[i][0] - vertices[h][0];
    points.push({angle: Math.atan2(y1, x1), index: i});
  }
  points.sort(function(a, b) { return a.angle - b.angle; });

  // toss out duplicate angles
  a = points[0].angle;
  v = points[0].index;
  u = 0;
  for (i=1; i<plen; ++i) {
    j = points[i].index;
    if (a == points[i].angle) {
      // keep angle for point most distant from the reference
      x1 = vertices[v][0] - vertices[h][0];
      y1 = vertices[v][1] - vertices[h][1];
      x2 = vertices[j][0] - vertices[h][0];
      y2 = vertices[j][1] - vertices[h][1];
      if ((x1*x1 + y1*y1) >= (x2*x2 + y2*y2)) {
        points[i].index = -1;
      } else {
        points[u].index = -1;
        a = points[i].angle;
        u = i;
        v = j;
      }
    } else {
      a = points[i].angle;
      u = i;
      v = j;
    }
  }

  // initialize the stack
  stack.push(h);
  for (i=0, j=0; i<2; ++j) {
    if (points[j].index !== -1) {
      stack.push(points[j].index);
      i++;
    }
  }
  sp = stack.length;

  // do graham's scan
  for (; j<plen; ++j) {
    if (points[j].index === -1) continue; // skip tossed out points
    while (!d3_geom_hullCCW(stack[sp-2], stack[sp-1], points[j].index, vertices)) {
      --sp;
    }
    stack[sp++] = points[j].index;
  }

  // construct the hull
  var poly = [];
  for (i=0; i<sp; ++i) {
    poly.push(vertices[stack[i]]);
  }
  return poly;
}

// are three points in counter-clockwise order?
function d3_geom_hullCCW(i1, i2, i3, v) {
  var t, a, b, c, d, e, f;
  t = v[i1]; a = t[0]; b = t[1];
  t = v[i2]; c = t[0]; d = t[1];
  t = v[i3]; e = t[0]; f = t[1];
  return ((f-b)*(c-a) - (d-b)*(e-a)) > 0;
}
// Note: requires coordinates to be counterclockwise and convex!
d3.geom.polygon = function(coordinates) {

  coordinates.area = function() {
    var i = 0,
        n = coordinates.length,
        a = coordinates[n - 1][0] * coordinates[0][1],
        b = coordinates[n - 1][1] * coordinates[0][0];
    while (++i < n) {
      a += coordinates[i - 1][0] * coordinates[i][1];
      b += coordinates[i - 1][1] * coordinates[i][0];
    }
    return (b - a) * .5;
  };

  coordinates.centroid = function(k) {
    var i = -1,
        n = coordinates.length,
        x = 0,
        y = 0,
        a,
        b = coordinates[n - 1],
        c;
    if (!arguments.length) k = -1 / (6 * coordinates.area());
    while (++i < n) {
      a = b;
      b = coordinates[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [x * k, y * k];
  };

  // The Sutherland-Hodgman clipping algorithm.
  coordinates.clip = function(subject) {
    var input,
        i = -1,
        n = coordinates.length,
        j,
        m,
        a = coordinates[n - 1],
        b,
        c,
        d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = coordinates[i];
      c = input[(m = input.length) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      a = b;
    }
    return subject;
  };

  return coordinates;
};

function d3_geom_polygonInside(p, a, b) {
  return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
}

// Intersect two infinite lines cd and ab.
function d3_geom_polygonIntersect(c, d, a, b) {
  var x1 = c[0], x2 = d[0], x3 = a[0], x4 = b[0],
      y1 = c[1], y2 = d[1], y3 = a[1], y4 = b[1],
      x13 = x1 - x3,
      x21 = x2 - x1,
      x43 = x4 - x3,
      y13 = y1 - y3,
      y21 = y2 - y1,
      y43 = y4 - y3,
      ua = (x43 * y13 - y43 * x13) / (y43 * x21 - x43 * y21);
  return [x1 + ua * x21, y1 + ua * y21];
}
// Adapted from Nicolas Garcia Belmonte's JIT implementation:
// http://blog.thejit.org/2010/02/12/voronoi-tessellation/
// http://blog.thejit.org/assets/voronoijs/voronoi.js
// See lib/jit/LICENSE for details.

// Notes:
//
// This implementation does not clip the returned polygons, so if you want to
// clip them to a particular shape you will need to do that either in SVG or by
// post-processing with d3.geom.polygon's clip method.
//
// If any vertices are coincident or have NaN positions, the behavior of this
// method is undefined. Most likely invalid polygons will be returned. You
// should filter invalid points, and consolidate coincident points, before
// computing the tessellation.

/**
 * @param vertices [[x1, y1], [x2, y2], …]
 * @returns polygons [[[x1, y1], [x2, y2], …], …]
 */
d3.geom.voronoi = function(vertices) {
  var polygons = vertices.map(function() { return []; });

  d3_voronoi_tessellate(vertices, function(e) {
    var s1,
        s2,
        x1,
        x2,
        y1,
        y2;
    if (e.a === 1 && e.b >= 0) {
      s1 = e.ep.r;
      s2 = e.ep.l;
    } else {
      s1 = e.ep.l;
      s2 = e.ep.r;
    }
    if (e.a === 1) {
      y1 = s1 ? s1.y : -1e6;
      x1 = e.c - e.b * y1;
      y2 = s2 ? s2.y : 1e6;
      x2 = e.c - e.b * y2;
    } else {
      x1 = s1 ? s1.x : -1e6;
      y1 = e.c - e.a * x1;
      x2 = s2 ? s2.x : 1e6;
      y2 = e.c - e.a * x2;
    }
    var v1 = [x1, y1],
        v2 = [x2, y2];
    polygons[e.region.l.index].push(v1, v2);
    polygons[e.region.r.index].push(v1, v2);
  });

  // Reconnect the polygon segments into counterclockwise loops.
  return polygons.map(function(polygon, i) {
    var cx = vertices[i][0],
        cy = vertices[i][1];
    polygon.forEach(function(v) {
      v.angle = Math.atan2(v[0] - cx, v[1] - cy);
    });
    return polygon.sort(function(a, b) {
      return a.angle - b.angle;
    }).filter(function(d, i) {
      return !i || (d.angle - polygon[i - 1].angle > 1e-10);
    });
  });
};

var d3_voronoi_opposite = {"l": "r", "r": "l"};

function d3_voronoi_tessellate(vertices, callback) {

  var Sites = {
    list: vertices
      .map(function(v, i) {
        return {
          index: i,
          x: v[0],
          y: v[1]
        };
      })
      .sort(function(a, b) {
        return a.y < b.y ? -1
          : a.y > b.y ? 1
          : a.x < b.x ? -1
          : a.x > b.x ? 1
          : 0;
      }),
    bottomSite: null
  };

  var EdgeList = {
    list: [],
    leftEnd: null,
    rightEnd: null,

    init: function() {
      EdgeList.leftEnd = EdgeList.createHalfEdge(null, "l");
      EdgeList.rightEnd = EdgeList.createHalfEdge(null, "l");
      EdgeList.leftEnd.r = EdgeList.rightEnd;
      EdgeList.rightEnd.l = EdgeList.leftEnd;
      EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);
    },

    createHalfEdge: function(edge, side) {
      return {
        edge: edge,
        side: side,
        vertex: null,
        "l": null,
        "r": null
      };
    },

    insert: function(lb, he) {
      he.l = lb;
      he.r = lb.r;
      lb.r.l = he;
      lb.r = he;
    },

    leftBound: function(p) {
      var he = EdgeList.leftEnd;
      do {
        he = he.r;
      } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));
      he = he.l;
      return he;
    },

    del: function(he) {
      he.l.r = he.r;
      he.r.l = he.l;
      he.edge = null;
    },

    right: function(he) {
      return he.r;
    },

    left: function(he) {
      return he.l;
    },

    leftRegion: function(he) {
      return he.edge == null
          ? Sites.bottomSite
          : he.edge.region[he.side];
    },

    rightRegion: function(he) {
      return he.edge == null
          ? Sites.bottomSite
          : he.edge.region[d3_voronoi_opposite[he.side]];
    }
  };

  var Geom = {

    bisect: function(s1, s2) {
      var newEdge = {
        region: {"l": s1, "r": s2},
        ep: {"l": null, "r": null}
      };

      var dx = s2.x - s1.x,
          dy = s2.y - s1.y,
          adx = dx > 0 ? dx : -dx,
          ady = dy > 0 ? dy : -dy;

      newEdge.c = s1.x * dx + s1.y * dy
          + (dx * dx + dy * dy) * .5;

      if (adx > ady) {
        newEdge.a = 1;
        newEdge.b = dy / dx;
        newEdge.c /= dx;
      } else {
        newEdge.b = 1;
        newEdge.a = dx / dy;
        newEdge.c /= dy;
      }

      return newEdge;
    },

    intersect: function(el1, el2) {
      var e1 = el1.edge,
          e2 = el2.edge;
      if (!e1 || !e2 || (e1.region.r == e2.region.r)) {
        return null;
      }
      var d = (e1.a * e2.b) - (e1.b * e2.a);
      if (Math.abs(d) < 1e-10) {
        return null;
      }
      var xint = (e1.c * e2.b - e2.c * e1.b) / d,
          yint = (e2.c * e1.a - e1.c * e2.a) / d,
          e1r = e1.region.r,
          e2r = e2.region.r,
          el,
          e;
      if ((e1r.y < e2r.y) ||
         (e1r.y == e2r.y && e1r.x < e2r.x)) {
        el = el1;
        e = e1;
      } else {
        el = el2;
        e = e2;
      }
      var rightOfSite = (xint >= e.region.r.x);
      if ((rightOfSite && (el.side === "l")) ||
        (!rightOfSite && (el.side === "r"))) {
        return null;
      }
      return {
        x: xint,
        y: yint
      };
    },

    rightOf: function(he, p) {
      var e = he.edge,
          topsite = e.region.r,
          rightOfSite = (p.x > topsite.x);

      if (rightOfSite && (he.side === "l")) {
        return 1;
      }
      if (!rightOfSite && (he.side === "r")) {
        return 0;
      }
      if (e.a === 1) {
        var dyp = p.y - topsite.y,
            dxp = p.x - topsite.x,
            fast = 0,
            above = 0;

        if ((!rightOfSite && (e.b < 0)) ||
          (rightOfSite && (e.b >= 0))) {
          above = fast = (dyp >= e.b * dxp);
        } else {
          above = ((p.x + p.y * e.b) > e.c);
          if (e.b < 0) {
            above = !above;
          }
          if (!above) {
            fast = 1;
          }
        }
        if (!fast) {
          var dxs = topsite.x - e.region.l.x;
          above = (e.b * (dxp * dxp - dyp * dyp)) <
            (dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b));

          if (e.b < 0) {
            above = !above;
          }
        }
      } else /* e.b == 1 */ {
        var yl = e.c - e.a * p.x,
            t1 = p.y - yl,
            t2 = p.x - topsite.x,
            t3 = yl - topsite.y;

        above = (t1 * t1) > (t2 * t2 + t3 * t3);
      }
      return he.side === "l" ? above : !above;
    },

    endPoint: function(edge, side, site) {
      edge.ep[side] = site;
      if (!edge.ep[d3_voronoi_opposite[side]]) return;
      callback(edge);
    },

    distance: function(s, t) {
      var dx = s.x - t.x,
          dy = s.y - t.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  };

  var EventQueue = {
    list: [],

    insert: function(he, site, offset) {
      he.vertex = site;
      he.ystar = site.y + offset;
      for (var i=0, list=EventQueue.list, l=list.length; i<l; i++) {
        var next = list[i];
        if (he.ystar > next.ystar ||
          (he.ystar == next.ystar &&
          site.x > next.vertex.x)) {
          continue;
        } else {
          break;
        }
      }
      list.splice(i, 0, he);
    },

    del: function(he) {
      for (var i=0, ls=EventQueue.list, l=ls.length; i<l && (ls[i] != he); ++i) {}
      ls.splice(i, 1);
    },

    empty: function() { return EventQueue.list.length === 0; },

    nextEvent: function(he) {
      for (var i=0, ls=EventQueue.list, l=ls.length; i<l; ++i) {
        if (ls[i] == he) return ls[i+1];
      }
      return null;
    },

    min: function() {
      var elem = EventQueue.list[0];
      return {
        x: elem.vertex.x,
        y: elem.ystar
      };
    },

    extractMin: function() {
      return EventQueue.list.shift();
    }
  };

  EdgeList.init();
  Sites.bottomSite = Sites.list.shift();

  var newSite = Sites.list.shift(), newIntStar;
  var lbnd, rbnd, llbnd, rrbnd, bisector;
  var bot, top, temp, p, v;
  var e, pm;

  while (true) {
    if (!EventQueue.empty()) {
      newIntStar = EventQueue.min();
    }
    if (newSite && (EventQueue.empty()
      || newSite.y < newIntStar.y
      || (newSite.y == newIntStar.y
      && newSite.x < newIntStar.x))) { //new site is smallest
      lbnd = EdgeList.leftBound(newSite);
      rbnd = EdgeList.right(lbnd);
      bot = EdgeList.rightRegion(lbnd);
      e = Geom.bisect(bot, newSite);
      bisector = EdgeList.createHalfEdge(e, "l");
      EdgeList.insert(lbnd, bisector);
      p = Geom.intersect(lbnd, bisector);
      if (p) {
        EventQueue.del(lbnd);
        EventQueue.insert(lbnd, p, Geom.distance(p, newSite));
      }
      lbnd = bisector;
      bisector = EdgeList.createHalfEdge(e, "r");
      EdgeList.insert(lbnd, bisector);
      p = Geom.intersect(bisector, rbnd);
      if (p) {
        EventQueue.insert(bisector, p, Geom.distance(p, newSite));
      }
      newSite = Sites.list.shift();
    } else if (!EventQueue.empty()) { //intersection is smallest
      lbnd = EventQueue.extractMin();
      llbnd = EdgeList.left(lbnd);
      rbnd = EdgeList.right(lbnd);
      rrbnd = EdgeList.right(rbnd);
      bot = EdgeList.leftRegion(lbnd);
      top = EdgeList.rightRegion(rbnd);
      v = lbnd.vertex;
      Geom.endPoint(lbnd.edge, lbnd.side, v);
      Geom.endPoint(rbnd.edge, rbnd.side, v);
      EdgeList.del(lbnd);
      EventQueue.del(rbnd);
      EdgeList.del(rbnd);
      pm = "l";
      if (bot.y > top.y) {
        temp = bot;
        bot = top;
        top = temp;
        pm = "r";
      }
      e = Geom.bisect(bot, top);
      bisector = EdgeList.createHalfEdge(e, pm);
      EdgeList.insert(llbnd, bisector);
      Geom.endPoint(e, d3_voronoi_opposite[pm], v);
      p = Geom.intersect(llbnd, bisector);
      if (p) {
        EventQueue.del(llbnd);
        EventQueue.insert(llbnd, p, Geom.distance(p, bot));
      }
      p = Geom.intersect(bisector, rrbnd);
      if (p) {
        EventQueue.insert(bisector, p, Geom.distance(p, bot));
      }
    } else {
      break;
    }
  }//end while

  for (lbnd = EdgeList.right(EdgeList.leftEnd);
      lbnd != EdgeList.rightEnd;
      lbnd = EdgeList.right(lbnd)) {
    callback(lbnd.edge);
  }
}
/**
* @param vertices [[x1, y1], [x2, y2], …]
* @returns triangles [[[x1, y1], [x2, y2], [x3, y3]], …]
 */
d3.geom.delaunay = function(vertices) {
  var edges = vertices.map(function() { return []; }),
      triangles = [];

  // Use the Voronoi tessellation to determine Delaunay edges.
  d3_voronoi_tessellate(vertices, function(e) {
    edges[e.region.l.index].push(vertices[e.region.r.index]);
  });

  // Reconnect the edges into counterclockwise triangles.
  edges.forEach(function(edge, i) {
    var v = vertices[i],
        cx = v[0],
        cy = v[1];
    edge.forEach(function(v) {
      v.angle = Math.atan2(v[0] - cx, v[1] - cy);
    });
    edge.sort(function(a, b) {
      return a.angle - b.angle;
    });
    for (var j = 0, m = edge.length - 1; j < m; j++) {
      triangles.push([v, edge[j], edge[j + 1]]);
    }
  });

  return triangles;
};
// Constructs a new quadtree for the specified array of points. A quadtree is a
// two-dimensional recursive spatial subdivision. This implementation uses
// square partitions, dividing each square into four equally-sized squares. Each
// point exists in a unique node; if multiple points are in the same position,
// some points may be stored on internal nodes rather than leaf nodes. Quadtrees
// can be used to accelerate various spatial operations, such as the Barnes-Hut
// approximation for computing n-body forces, or collision detection.
d3.geom.quadtree = function(points, x1, y1, x2, y2) {
  var p,
      i = -1,
      n = points.length;

  // Type conversion for deprecated API.
  if (n && isNaN(points[0].x)) points = points.map(d3_geom_quadtreePoint);

  // Allow bounds to be specified explicitly.
  if (arguments.length < 5) {
    if (arguments.length === 3) {
      y2 = x2 = y1;
      y1 = x1;
    } else {
      x1 = y1 = Infinity;
      x2 = y2 = -Infinity;

      // Compute bounds.
      while (++i < n) {
        p = points[i];
        if (p.x < x1) x1 = p.x;
        if (p.y < y1) y1 = p.y;
        if (p.x > x2) x2 = p.x;
        if (p.y > y2) y2 = p.y;
      }

      // Squarify the bounds.
      var dx = x2 - x1,
          dy = y2 - y1;
      if (dx > dy) y2 = y1 + dx;
      else x2 = x1 + dy;
    }
  }

  // Recursively inserts the specified point p at the node n or one of its
  // descendants. The bounds are defined by [x1, x2] and [y1, y2].
  function insert(n, p, x1, y1, x2, y2) {
    if (isNaN(p.x) || isNaN(p.y)) return; // ignore invalid points
    if (n.leaf) {
      var v = n.point;
      if (v) {
        // If the point at this leaf node is at the same position as the new
        // point we are adding, we leave the point associated with the
        // internal node while adding the new point to a child node. This
        // avoids infinite recursion.
        if ((Math.abs(v.x - p.x) + Math.abs(v.y - p.y)) < .01) {
          insertChild(n, p, x1, y1, x2, y2);
        } else {
          n.point = null;
          insertChild(n, v, x1, y1, x2, y2);
          insertChild(n, p, x1, y1, x2, y2);
        }
      } else {
        n.point = p;
      }
    } else {
      insertChild(n, p, x1, y1, x2, y2);
    }
  }

  // Recursively inserts the specified point p into a descendant of node n. The
  // bounds are defined by [x1, x2] and [y1, y2].
  function insertChild(n, p, x1, y1, x2, y2) {
    // Compute the split point, and the quadrant in which to insert p.
    var sx = (x1 + x2) * .5,
        sy = (y1 + y2) * .5,
        right = p.x >= sx,
        bottom = p.y >= sy,
        i = (bottom << 1) + right;

    // Recursively insert into the child node.
    n.leaf = false;
    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());

    // Update the bounds as we recurse.
    if (right) x1 = sx; else x2 = sx;
    if (bottom) y1 = sy; else y2 = sy;
    insert(n, p, x1, y1, x2, y2);
  }

  // Create the root node.
  var root = d3_geom_quadtreeNode();

  root.add = function(p) {
    insert(root, p, x1, y1, x2, y2);
  };

  root.visit = function(f) {
    d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);
  };

  // Insert all points.
  points.forEach(root.add);
  return root;
};

function d3_geom_quadtreeNode() {
  return {
    leaf: true,
    nodes: [],
    point: null
  };
}

function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
  if (!f(node, x1, y1, x2, y2)) {
    var sx = (x1 + x2) * .5,
        sy = (y1 + y2) * .5,
        children = node.nodes;
    if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
    if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
    if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
    if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
  }
}

function d3_geom_quadtreePoint(p) {
  return {
    x: p[0],
    y: p[1]
  };
}
d3.time = {};

var d3_time = Date;

function d3_time_utc() {
  this._ = new Date(arguments.length > 1
      ? Date.UTC.apply(this, arguments)
      : arguments[0]);
}

d3_time_utc.prototype = {
  getDate: function() { return this._.getUTCDate(); },
  getDay: function() { return this._.getUTCDay(); },
  getFullYear: function() { return this._.getUTCFullYear(); },
  getHours: function() { return this._.getUTCHours(); },
  getMilliseconds: function() { return this._.getUTCMilliseconds(); },
  getMinutes: function() { return this._.getUTCMinutes(); },
  getMonth: function() { return this._.getUTCMonth(); },
  getSeconds: function() { return this._.getUTCSeconds(); },
  getTime: function() { return this._.getTime(); },
  getTimezoneOffset: function() { return 0; },
  valueOf: function() { return this._.valueOf(); },
  setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); },
  setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); },
  setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); },
  setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); },
  setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); },
  setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); },
  setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); },
  setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); },
  setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); }
};

var d3_time_prototype = Date.prototype;
d3.time.format = function(template) {
  var n = template.length;

  function format(date) {
    var string = [],
        i = -1,
        j = 0,
        c,
        f;
    while (++i < n) {
      if (template.charCodeAt(i) == 37) {
        string.push(
            template.substring(j, i),
            (f = d3_time_formats[c = template.charAt(++i)])
            ? f(date) : c);
        j = i + 1;
      }
    }
    string.push(template.substring(j, i));
    return string.join("");
  }

  format.parse = function(string) {
    var d = {y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0},
        i = d3_time_parse(d, template, string, 0);
    if (i != string.length) return null;

    // The am-pm flag is 0 for AM, and 1 for PM.
    if ("p" in d) d.H = d.H % 12 + d.p * 12;

    var date = new d3_time();
    date.setFullYear(d.y, d.m, d.d);
    date.setHours(d.H, d.M, d.S, d.L);
    return date;
  };

  format.toString = function() {
    return template;
  };

  return format;
};

function d3_time_parse(date, template, string, j) {
  var c,
      p,
      i = 0,
      n = template.length,
      m = string.length;
  while (i < n) {
    if (j >= m) return -1;
    c = template.charCodeAt(i++);
    if (c == 37) {
      p = d3_time_parsers[template.charAt(i++)];
      if (!p || ((j = p(date, string, j)) < 0)) return -1;
    } else if (c != string.charCodeAt(j++)) {
      return -1;
    }
  }
  return j;
}

var d3_time_zfill2 = d3.format("02d"),
    d3_time_zfill3 = d3.format("03d"),
    d3_time_zfill4 = d3.format("04d"),
    d3_time_sfill2 = d3.format("2d");

var d3_time_formats = {
  a: function(d) { return d3_time_weekdays[d.getDay()].substring(0, 3); },
  A: function(d) { return d3_time_weekdays[d.getDay()]; },
  b: function(d) { return d3_time_months[d.getMonth()].substring(0, 3); },
  B: function(d) { return d3_time_months[d.getMonth()]; },
  c: d3.time.format("%a %b %e %H:%M:%S %Y"),
  d: function(d) { return d3_time_zfill2(d.getDate()); },
  e: function(d) { return d3_time_sfill2(d.getDate()); },
  H: function(d) { return d3_time_zfill2(d.getHours()); },
  I: function(d) { return d3_time_zfill2(d.getHours() % 12 || 12); },
  j: function(d) { return d3_time_zfill3(1 + d3.time.dayOfYear(d)); },
  L: function(d) { return d3_time_zfill3(d.getMilliseconds()); },
  m: function(d) { return d3_time_zfill2(d.getMonth() + 1); },
  M: function(d) { return d3_time_zfill2(d.getMinutes()); },
  p: function(d) { return d.getHours() >= 12 ? "PM" : "AM"; },
  S: function(d) { return d3_time_zfill2(d.getSeconds()); },
  U: function(d) { return d3_time_zfill2(d3.time.sundayOfYear(d)); },
  w: function(d) { return d.getDay(); },
  W: function(d) { return d3_time_zfill2(d3.time.mondayOfYear(d)); },
  x: d3.time.format("%m/%d/%y"),
  X: d3.time.format("%H:%M:%S"),
  y: function(d) { return d3_time_zfill2(d.getFullYear() % 100); },
  Y: function(d) { return d3_time_zfill4(d.getFullYear() % 10000); },
  Z: d3_time_zone,
  "%": function(d) { return "%"; }
};

var d3_time_parsers = {
  a: d3_time_parseWeekdayAbbrev,
  A: d3_time_parseWeekday,
  b: d3_time_parseMonthAbbrev,
  B: d3_time_parseMonth,
  c: d3_time_parseLocaleFull,
  d: d3_time_parseDay,
  e: d3_time_parseDay,
  H: d3_time_parseHour24,
  I: d3_time_parseHour24,
  // j: function(d, s, i) { /*TODO day of year [001,366] */ return i; },
  L: d3_time_parseMilliseconds,
  m: d3_time_parseMonthNumber,
  M: d3_time_parseMinutes,
  p: d3_time_parseAmPm,
  S: d3_time_parseSeconds,
  // U: function(d, s, i) { /*TODO week number (sunday) [00,53] */ return i; },
  // w: function(d, s, i) { /*TODO weekday [0,6] */ return i; },
  // W: function(d, s, i) { /*TODO week number (monday) [00,53] */ return i; },
  x: d3_time_parseLocaleDate,
  X: d3_time_parseLocaleTime,
  y: d3_time_parseYear,
  Y: d3_time_parseFullYear
  // ,
  // Z: function(d, s, i) { /*TODO time zone */ return i; },
  // "%": function(d, s, i) { /*TODO literal % */ return i; }
};

// Note: weekday is validated, but does not set the date.
function d3_time_parseWeekdayAbbrev(date, string, i) {
  return d3_time_weekdayAbbrevRe.test(string.substring(i, i += 3)) ? i : -1;
}

// Note: weekday is validated, but does not set the date.
function d3_time_parseWeekday(date, string, i) {
  d3_time_weekdayRe.lastIndex = 0;
  var n = d3_time_weekdayRe.exec(string.substring(i, i + 10));
  return n ? i += n[0].length : -1;
}

var d3_time_weekdayAbbrevRe = /^(?:sun|mon|tue|wed|thu|fri|sat)/i,
    d3_time_weekdayRe = /^(?:Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)/i,
    d3_time_weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

function d3_time_parseMonthAbbrev(date, string, i) {
  var n = d3_time_monthAbbrevLookup.get(string.substring(i, i += 3).toLowerCase());
  return n == null ? -1 : (date.m = n, i);
}

var d3_time_monthAbbrevLookup = d3.map({
  jan: 0,
  feb: 1,
  mar: 2,
  apr: 3,
  may: 4,
  jun: 5,
  jul: 6,
  aug: 7,
  sep: 8,
  oct: 9,
  nov: 10,
  dec: 11
});

function d3_time_parseMonth(date, string, i) {
  d3_time_monthRe.lastIndex = 0;
  var n = d3_time_monthRe.exec(string.substring(i, i + 12));
  return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;
}

var d3_time_monthRe = /^(?:January|February|March|April|May|June|July|August|September|October|November|December)/ig;

var d3_time_monthLookup = d3.map({
  january: 0,
  february: 1,
  march: 2,
  april: 3,
  may: 4,
  june: 5,
  july: 6,
  august: 7,
  september: 8,
  october: 9,
  november: 10,
  december: 11
});

var d3_time_months = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];

function d3_time_parseLocaleFull(date, string, i) {
  return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
}

function d3_time_parseLocaleDate(date, string, i) {
  return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
}

function d3_time_parseLocaleTime(date, string, i) {
  return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
}

function d3_time_parseFullYear(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 4));
  return n ? (date.y = +n[0], i += n[0].length) : -1;
}

function d3_time_parseYear(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.y = d3_time_century() + +n[0], i += n[0].length) : -1;
}

function d3_time_century() {
  return ~~(new Date().getFullYear() / 1000) * 1000;
}

function d3_time_parseMonthNumber(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.m = n[0] - 1, i += n[0].length) : -1;
}

function d3_time_parseDay(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.d = +n[0], i += n[0].length) : -1;
}

// Note: we don't validate that the hour is in the range [0,23] or [1,12].
function d3_time_parseHour24(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.H = +n[0], i += n[0].length) : -1;
}

function d3_time_parseMinutes(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.M = +n[0], i += n[0].length) : -1;
}

function d3_time_parseSeconds(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 2));
  return n ? (date.S = +n[0], i += n[0].length) : -1;
}

function d3_time_parseMilliseconds(date, string, i) {
  d3_time_numberRe.lastIndex = 0;
  var n = d3_time_numberRe.exec(string.substring(i, i + 3));
  return n ? (date.L = +n[0], i += n[0].length) : -1;
}

// Note: we don't look at the next directive.
var d3_time_numberRe = /\s*\d+/;

function d3_time_parseAmPm(date, string, i) {
  var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());
  return n == null ? -1 : (date.p = n, i);
}

var d3_time_amPmLookup = d3.map({
  am: 0,
  pm: 1
});

// TODO table of time zone offset names?
function d3_time_zone(d) {
  var z = d.getTimezoneOffset(),
      zs = z > 0 ? "-" : "+",
      zh = ~~(Math.abs(z) / 60),
      zm = Math.abs(z) % 60;
  return zs + d3_time_zfill2(zh) + d3_time_zfill2(zm);
}
d3.time.format.utc = function(template) {
  var local = d3.time.format(template);

  function format(date) {
    try {
      d3_time = d3_time_utc;
      var utc = new d3_time();
      utc._ = date;
      return local(utc);
    } finally {
      d3_time = Date;
    }
  }

  format.parse = function(string) {
    try {
      d3_time = d3_time_utc;
      var date = local.parse(string);
      return date && date._;
    } finally {
      d3_time = Date;
    }
  };

  format.toString = local.toString;

  return format;
};
var d3_time_formatIso = d3.time.format.utc("%Y-%m-%dT%H:%M:%S.%LZ");

d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;

function d3_time_formatIsoNative(date) {
  return date.toISOString();
}

d3_time_formatIsoNative.parse = function(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
};

d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
function d3_time_interval(local, step, number) {

  function round(date) {
    var d0 = local(date), d1 = offset(d0, 1);
    return date - d0 < d1 - date ? d0 : d1;
  }

  function ceil(date) {
    step(date = local(new d3_time(date - 1)), 1);
    return date;
  }

  function offset(date, k) {
    step(date = new d3_time(+date), k);
    return date;
  }

  function range(t0, t1, dt) {
    var time = ceil(t0), times = [];
    if (dt > 1) {
      while (time < t1) {
        if (!(number(time) % dt)) times.push(new Date(+time));
        step(time, 1);
      }
    } else {
      while (time < t1) times.push(new Date(+time)), step(time, 1);
    }
    return times;
  }

  function range_utc(t0, t1, dt) {
    try {
      d3_time = d3_time_utc;
      var utc = new d3_time_utc();
      utc._ = t0;
      return range(utc, t1, dt);
    } finally {
      d3_time = Date;
    }
  }

  local.floor = local;
  local.round = round;
  local.ceil = ceil;
  local.offset = offset;
  local.range = range;

  var utc = local.utc = d3_time_interval_utc(local);
  utc.floor = utc;
  utc.round = d3_time_interval_utc(round);
  utc.ceil = d3_time_interval_utc(ceil);
  utc.offset = d3_time_interval_utc(offset);
  utc.range = range_utc;

  return local;
}

function d3_time_interval_utc(method) {
  return function(date, k) {
    try {
      d3_time = d3_time_utc;
      var utc = new d3_time_utc();
      utc._ = date;
      return method(utc, k)._;
    } finally {
      d3_time = Date;
    }
  };
}
d3.time.second = d3_time_interval(function(date) {
  return new d3_time(Math.floor(date / 1e3) * 1e3);
}, function(date, offset) {
  date.setTime(date.getTime() + Math.floor(offset) * 1e3); // DST breaks setSeconds
}, function(date) {
  return date.getSeconds();
});

d3.time.seconds = d3.time.second.range;
d3.time.seconds.utc = d3.time.second.utc.range;
d3.time.minute = d3_time_interval(function(date) {
  return new d3_time(Math.floor(date / 6e4) * 6e4);
}, function(date, offset) {
  date.setTime(date.getTime() + Math.floor(offset) * 6e4); // DST breaks setMinutes
}, function(date) {
  return date.getMinutes();
});

d3.time.minutes = d3.time.minute.range;
d3.time.minutes.utc = d3.time.minute.utc.range;
d3.time.hour = d3_time_interval(function(date) {
  var timezone = date.getTimezoneOffset() / 60;
  return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
}, function(date, offset) {
  date.setTime(date.getTime() + Math.floor(offset) * 36e5); // DST breaks setHours
}, function(date) {
  return date.getHours();
});

d3.time.hours = d3.time.hour.range;
d3.time.hours.utc = d3.time.hour.utc.range;
d3.time.day = d3_time_interval(function(date) {
  return new d3_time(date.getFullYear(), date.getMonth(), date.getDate());
}, function(date, offset) {
  date.setDate(date.getDate() + offset);
}, function(date) {
  return date.getDate() - 1;
});

d3.time.days = d3.time.day.range;
d3.time.days.utc = d3.time.day.utc.range;

d3.time.dayOfYear = function(date) {
  var year = d3.time.year(date);
  return Math.floor((date - year) / 864e5 - (date.getTimezoneOffset() - year.getTimezoneOffset()) / 1440);
};
d3_time_weekdays.forEach(function(day, i) {
  day = day.toLowerCase();
  i = 7 - i;

  var interval = d3.time[day] = d3_time_interval(function(date) {
    (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
    return date;
  }, function(date, offset) {
    date.setDate(date.getDate() + Math.floor(offset) * 7);
  }, function(date) {
    var day = d3.time.year(date).getDay();
    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
  });

  d3.time[day + "s"] = interval.range;
  d3.time[day + "s"].utc = interval.utc.range;

  d3.time[day + "OfYear"] = function(date) {
    var day = d3.time.year(date).getDay();
    return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);
  };
});

d3.time.week = d3.time.sunday;
d3.time.weeks = d3.time.sunday.range;
d3.time.weeks.utc = d3.time.sunday.utc.range;
d3.time.weekOfYear = d3.time.sundayOfYear;
d3.time.month = d3_time_interval(function(date) {
  return new d3_time(date.getFullYear(), date.getMonth(), 1);
}, function(date, offset) {
  date.setMonth(date.getMonth() + offset);
}, function(date) {
  return date.getMonth();
});

d3.time.months = d3.time.month.range;
d3.time.months.utc = d3.time.month.utc.range;
d3.time.year = d3_time_interval(function(date) {
  return new d3_time(date.getFullYear(), 0, 1);
}, function(date, offset) {
  date.setFullYear(date.getFullYear() + offset);
}, function(date) {
  return date.getFullYear();
});

d3.time.years = d3.time.year.range;
d3.time.years.utc = d3.time.year.utc.range;
function d3_time_scale(linear, methods, format) {

  function scale(x) {
    return linear(x);
  }

  scale.invert = function(x) {
    return d3_time_scaleDate(linear.invert(x));
  };

  scale.domain = function(x) {
    if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
    linear.domain(x);
    return scale;
  };

  scale.nice = function(m) {
    var extent = d3_time_scaleExtent(scale.domain());
    return scale.domain([m.floor(extent[0]), m.ceil(extent[1])]);
  };

  scale.ticks = function(m, k) {
    var extent = d3_time_scaleExtent(scale.domain());
    if (typeof m !== "function") {
      var span = extent[1] - extent[0],
          target = span / m,
          i = d3.bisect(d3_time_scaleSteps, target);
      if (i == d3_time_scaleSteps.length) return methods.year(extent, m);
      if (!i) return linear.ticks(m).map(d3_time_scaleDate);
      if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;
      m = methods[i];
      k = m[1];
      m = m[0].range;
    }
    return m(extent[0], new Date(+extent[1] + 1), k); // inclusive upper bound
  };

  scale.tickFormat = function() {
    return format;
  };

  scale.copy = function() {
    return d3_time_scale(linear.copy(), methods, format);
  };

  // TOOD expose d3_scale_linear_rebind?
  return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
}

// TODO expose d3_scaleExtent?
function d3_time_scaleExtent(domain) {
  var start = domain[0], stop = domain[domain.length - 1];
  return start < stop ? [start, stop] : [stop, start];
}

function d3_time_scaleDate(t) {
  return new Date(t);
}

function d3_time_scaleFormat(formats) {
  return function(date) {
    var i = formats.length - 1, f = formats[i];
    while (!f[1](date)) f = formats[--i];
    return f[0](date);
  };
}

function d3_time_scaleSetYear(y) {
  var d = new Date(y, 0, 1);
  d.setFullYear(y); // Y2K fail
  return d;
}

function d3_time_scaleGetYear(d) {
  var y = d.getFullYear(),
      d0 = d3_time_scaleSetYear(y),
      d1 = d3_time_scaleSetYear(y + 1);
  return y + (d - d0) / (d1 - d0);
}

var d3_time_scaleSteps = [
  1e3,    // 1-second
  5e3,    // 5-second
  15e3,   // 15-second
  3e4,    // 30-second
  6e4,    // 1-minute
  3e5,    // 5-minute
  9e5,    // 15-minute
  18e5,   // 30-minute
  36e5,   // 1-hour
  108e5,  // 3-hour
  216e5,  // 6-hour
  432e5,  // 12-hour
  864e5,  // 1-day
  1728e5, // 2-day
  6048e5, // 1-week
  2592e6, // 1-month
  7776e6, // 3-month
  31536e6 // 1-year
];

var d3_time_scaleLocalMethods = [
  [d3.time.second, 1],
  [d3.time.second, 5],
  [d3.time.second, 15],
  [d3.time.second, 30],
  [d3.time.minute, 1],
  [d3.time.minute, 5],
  [d3.time.minute, 15],
  [d3.time.minute, 30],
  [d3.time.hour, 1],
  [d3.time.hour, 3],
  [d3.time.hour, 6],
  [d3.time.hour, 12],
  [d3.time.day, 1],
  [d3.time.day, 2],
  [d3.time.week, 1],
  [d3.time.month, 1],
  [d3.time.month, 3],
  [d3.time.year, 1]
];

var d3_time_scaleLocalFormats = [
  [d3.time.format("%Y"), function(d) { return true; }],
  [d3.time.format("%B"), function(d) { return d.getMonth(); }],
  [d3.time.format("%b %d"), function(d) { return d.getDate() != 1; }],
  [d3.time.format("%a %d"), function(d) { return d.getDay() && d.getDate() != 1; }],
  [d3.time.format("%I %p"), function(d) { return d.getHours(); }],
  [d3.time.format("%I:%M"), function(d) { return d.getMinutes(); }],
  [d3.time.format(":%S"), function(d) { return d.getSeconds(); }],
  [d3.time.format(".%L"), function(d) { return d.getMilliseconds(); }]
];

var d3_time_scaleLinear = d3.scale.linear(),
    d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);

d3_time_scaleLocalMethods.year = function(extent, m) {
  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);
};

d3.time.scale = function() {
  return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
};
var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function(m) {
  return [m[0].utc, m[1]];
});

var d3_time_scaleUTCFormats = [
  [d3.time.format.utc("%Y"), function(d) { return true; }],
  [d3.time.format.utc("%B"), function(d) { return d.getUTCMonth(); }],
  [d3.time.format.utc("%b %d"), function(d) { return d.getUTCDate() != 1; }],
  [d3.time.format.utc("%a %d"), function(d) { return d.getUTCDay() && d.getUTCDate() != 1; }],
  [d3.time.format.utc("%I %p"), function(d) { return d.getUTCHours(); }],
  [d3.time.format.utc("%I:%M"), function(d) { return d.getUTCMinutes(); }],
  [d3.time.format.utc(":%S"), function(d) { return d.getUTCSeconds(); }],
  [d3.time.format.utc(".%L"), function(d) { return d.getUTCMilliseconds(); }]
];

var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);

function d3_time_scaleUTCSetYear(y) {
  var d = new Date(Date.UTC(y, 0, 1));
  d.setUTCFullYear(y); // Y2K fail
  return d;
}

function d3_time_scaleUTCGetYear(d) {
  var y = d.getUTCFullYear(),
      d0 = d3_time_scaleUTCSetYear(y),
      d1 = d3_time_scaleUTCSetYear(y + 1);
  return y + (d - d0) / (d1 - d0);
}

d3_time_scaleUTCMethods.year = function(extent, m) {
  return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);
};

d3.time.scale.utc = function() {
  return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);
};
})();

(function(){d3.layout = {};
// Implements hierarchical edge bundling using Holten's algorithm. For each
// input link, a path is computed that travels through the tree, up the parent
// hierarchy to the least common ancestor, and then back down to the destination
// node. Each path is simply an array of nodes.
d3.layout.bundle = function() {
  return function(links) {
    var paths = [],
        i = -1,
        n = links.length;
    while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
    return paths;
  };
};

function d3_layout_bundlePath(link) {
  var start = link.source,
      end = link.target,
      lca = d3_layout_bundleLeastCommonAncestor(start, end),
      points = [start];
  while (start !== lca) {
    start = start.parent;
    points.push(start);
  }
  var k = points.length;
  while (end !== lca) {
    points.splice(k, 0, end);
    end = end.parent;
  }
  return points;
}

function d3_layout_bundleAncestors(node) {
  var ancestors = [],
      parent = node.parent;
  while (parent != null) {
    ancestors.push(node);
    node = parent;
    parent = parent.parent;
  }
  ancestors.push(node);
  return ancestors;
}

function d3_layout_bundleLeastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = d3_layout_bundleAncestors(a),
      bNodes = d3_layout_bundleAncestors(b),
      aNode = aNodes.pop(),
      bNode = bNodes.pop(),
      sharedNode = null;
  while (aNode === bNode) {
    sharedNode = aNode;
    aNode = aNodes.pop();
    bNode = bNodes.pop();
  }
  return sharedNode;
}
d3.layout.chord = function() {
  var chord = {},
      chords,
      groups,
      matrix,
      n,
      padding = 0,
      sortGroups,
      sortSubgroups,
      sortChords;

  function relayout() {
    var subgroups = {},
        groupSums = [],
        groupIndex = d3.range(n),
        subgroupIndex = [],
        k,
        x,
        x0,
        i,
        j;

    chords = [];
    groups = [];

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3.range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) {
      groupIndex.sort(function(a, b) {
        return sortGroups(groupSums[a], groupSums[b]);
      });
    }

    // Sort subgroups…
    if (sortSubgroups) {
      subgroupIndex.forEach(function(d, i) {
        d.sort(function(a, b) {
          return sortSubgroups(matrix[i][a], matrix[i][b]);
        });
      });
    }

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified.
    // TODO Allow padding to be specified as percentage?
    k = (2 * Math.PI - padding * n) / k;

    // Compute the start and end angle for each group and subgroup.
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[i][j],
            v = matrix[di][dj];
        subgroups[di + "-" + dj] = {
          index: di,
          subindex: dj,
          startAngle: x,
          endAngle: x += v * k,
          value: v
        };
      }
      groups.push({
        index: di,
        startAngle: x0,
        endAngle: x,
        value: (x - x0) / k
      });
      x += padding;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[i + "-" + j],
            target = subgroups[j + "-" + i];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    if (sortChords) resort();
  }

  function resort() {
    chords.sort(function(a, b) {
      return sortChords(a.target.value, b.target.value);
    });
  }

  chord.matrix = function(x) {
    if (!arguments.length) return matrix;
    n = (matrix = x) && matrix.length;
    chords = groups = null;
    return chord;
  };

  chord.padding = function(x) {
    if (!arguments.length) return padding;
    padding = x;
    chords = groups = null;
    return chord;
  };

  chord.sortGroups = function(x) {
    if (!arguments.length) return sortGroups;
    sortGroups = x;
    chords = groups = null;
    return chord;
  };

  chord.sortSubgroups = function(x) {
    if (!arguments.length) return sortSubgroups;
    sortSubgroups = x;
    chords = null;
    return chord;
  };

  chord.sortChords = function(x) {
    if (!arguments.length) return sortChords;
    sortChords = x;
    if (chords) resort();
    return chord;
  };

  chord.chords = function() {
    if (!chords) relayout();
    return chords;
  };

  chord.groups = function() {
    if (!groups) relayout();
    return groups;
  };

  return chord;
};
// A rudimentary force layout using Gauss-Seidel.
d3.layout.force = function() {
  var force = {},
      event = d3.dispatch("tick"),
      size = [1, 1],
      drag,
      alpha,
      friction = .9,
      linkDistance = d3_layout_forceLinkDistance,
      linkStrength = d3_layout_forceLinkStrength,
      charge = -30,
      gravity = .1,
      theta = .8,
      interval,
      nodes = [],
      links = [],
      distances,
      strengths,
      charges;

  function repulse(node) {
    return function(quad, x1, y1, x2, y2) {
      if (quad.point !== node) {
        var dx = quad.cx - node.x,
            dy = quad.cy - node.y,
            dn = 1 / Math.sqrt(dx * dx + dy * dy);

        /* Barnes-Hut criterion. */
        if ((x2 - x1) * dn < theta) {
          var k = quad.charge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
          return true;
        }

        if (quad.point && isFinite(dn)) {
          var k = quad.pointCharge * dn * dn;
          node.px -= dx * k;
          node.py -= dy * k;
        }
      }
      return !quad.charge;
    };
  }

  function tick() {
    var n = nodes.length,
        m = links.length,
        q,
        i, // current index
        o, // current object
        s, // current source
        t, // current target
        l, // current distance
        k, // current force
        x, // x-distance
        y; // y-distance

    // gauss-seidel relaxation for links
    for (i = 0; i < m; ++i) {
      o = links[i];
      s = o.source;
      t = o.target;
      x = t.x - s.x;
      y = t.y - s.y;
      if (l = (x * x + y * y)) {
        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
        x *= l;
        y *= l;
        t.x -= x * (k = s.weight / (t.weight + s.weight));
        t.y -= y * k;
        s.x += x * (k = 1 - k);
        s.y += y * k;
      }
    }

    // apply gravity forces
    if (k = alpha * gravity) {
      x = size[0] / 2;
      y = size[1] / 2;
      i = -1; if (k) while (++i < n) {
        o = nodes[i];
        o.x += (x - o.x) * k;
        o.y += (y - o.y) * k;
      }
    }

    // compute quadtree center of mass and apply charge forces
    if (charge) {
      d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
      i = -1; while (++i < n) {
        if (!(o = nodes[i]).fixed) {
          q.visit(repulse(o));
        }
      }
    }

    // position verlet integration
    i = -1; while (++i < n) {
      o = nodes[i];
      if (o.fixed) {
        o.x = o.px;
        o.y = o.py;
      } else {
        o.x -= (o.px - (o.px = o.x)) * friction;
        o.y -= (o.py - (o.py = o.y)) * friction;
      }
    }

    event.tick.dispatch({type: "tick", alpha: alpha});

    // simulated annealing, basically
    return (alpha *= .99) < .005;
  }

  force.on = function(type, listener) {
    event[type].add(listener);
    return force;
  };

  force.nodes = function(x) {
    if (!arguments.length) return nodes;
    nodes = x;
    return force;
  };

  force.links = function(x) {
    if (!arguments.length) return links;
    links = x;
    return force;
  };

  force.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return force;
  };

  force.linkDistance = function(x) {
    if (!arguments.length) return linkDistance;
    linkDistance = d3.functor(x);
    return force;
  };

  // For backwards-compatibility.
  force.distance = force.linkDistance;

  force.linkStrength = function(x) {
    if (!arguments.length) return linkStrength;
    linkStrength = d3.functor(x);
    return force;
  };

  force.friction = function(x) {
    if (!arguments.length) return friction;
    friction = x;
    return force;
  };

  force.charge = function(x) {
    if (!arguments.length) return charge;
    charge = typeof x === "function" ? x : +x;
    return force;
  };

  force.gravity = function(x) {
    if (!arguments.length) return gravity;
    gravity = x;
    return force;
  };

  force.theta = function(x) {
    if (!arguments.length) return theta;
    theta = x;
    return force;
  };

  force.start = function() {
    var i,
        j,
        n = nodes.length,
        m = links.length,
        w = size[0],
        h = size[1],
        neighbors,
        o;

    for (i = 0; i < n; ++i) {
      (o = nodes[i]).index = i;
      o.weight = 0;
    }

    distances = [];
    strengths = [];
    for (i = 0; i < m; ++i) {
      o = links[i];
      if (typeof o.source == "number") o.source = nodes[o.source];
      if (typeof o.target == "number") o.target = nodes[o.target];
      distances[i] = linkDistance.call(this, o, i);
      strengths[i] = linkStrength.call(this, o, i);
      ++o.source.weight;
      ++o.target.weight;
    }

    for (i = 0; i < n; ++i) {
      o = nodes[i];
      if (isNaN(o.x)) o.x = position("x", w);
      if (isNaN(o.y)) o.y = position("y", h);
      if (isNaN(o.px)) o.px = o.x;
      if (isNaN(o.py)) o.py = o.y;
    }

    charges = [];
    if (typeof charge === "function") {
      for (i = 0; i < n; ++i) {
        charges[i] = +charge.call(this, nodes[i], i);
      }
    } else {
      for (i = 0; i < n; ++i) {
        charges[i] = charge;
      }
    }

    // initialize node position based on first neighbor
    function position(dimension, size) {
      var neighbors = neighbor(i),
          j = -1,
          m = neighbors.length,
          x;
      while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;
      return Math.random() * size;
    }

    // initialize neighbors lazily
    function neighbor() {
      if (!neighbors) {
        neighbors = [];
        for (j = 0; j < n; ++j) {
          neighbors[j] = [];
        }
        for (j = 0; j < m; ++j) {
          var o = links[j];
          neighbors[o.source.index].push(o.target);
          neighbors[o.target.index].push(o.source);
        }
      }
      return neighbors[i];
    }

    return force.resume();
  };

  force.resume = function() {
    alpha = .1;
    d3.timer(tick);
    return force;
  };

  force.stop = function() {
    alpha = 0;
    return force;
  };

  // use `node.call(force.drag)` to make nodes draggable
  force.drag = function() {
    if (!drag) drag = d3.behavior.drag()
        .on("dragstart", dragstart)
        .on("drag", d3_layout_forceDrag)
        .on("dragend", d3_layout_forceDragEnd);

    this.on("mouseover.force", d3_layout_forceDragOver)
        .on("mouseout.force", d3_layout_forceDragOut)
        .call(drag);
  };

  function dragstart(d) {
    d3_layout_forceDragOver(d3_layout_forceDragNode = d);
    d3_layout_forceDragForce = force;
  }

  return force;
};

var d3_layout_forceDragForce,
    d3_layout_forceDragNode;

function d3_layout_forceDragOver(d) {
  d.fixed |= 2;
}

function d3_layout_forceDragOut(d) {
  if (d !== d3_layout_forceDragNode) d.fixed &= 1;
}

function d3_layout_forceDragEnd() {
  d3_layout_forceDrag();
  d3_layout_forceDragNode.fixed &= 1;
  d3_layout_forceDragForce = d3_layout_forceDragNode = null;
}

function d3_layout_forceDrag() {
  d3_layout_forceDragNode.px += d3.event.dx;
  d3_layout_forceDragNode.py += d3.event.dy;
  d3_layout_forceDragForce.resume(); // restart annealing
}

function d3_layout_forceAccumulate(quad, alpha, charges) {
  var cx = 0,
      cy = 0;
  quad.charge = 0;
  if (!quad.leaf) {
    var nodes = quad.nodes,
        n = nodes.length,
        i = -1,
        c;
    while (++i < n) {
      c = nodes[i];
      if (c == null) continue;
      d3_layout_forceAccumulate(c, alpha, charges);
      quad.charge += c.charge;
      cx += c.charge * c.cx;
      cy += c.charge * c.cy;
    }
  }
  if (quad.point) {
    // jitter internal nodes that are coincident
    if (!quad.leaf) {
      quad.point.x += Math.random() - .5;
      quad.point.y += Math.random() - .5;
    }
    var k = alpha * charges[quad.point.index];
    quad.charge += quad.pointCharge = k;
    cx += k * quad.point.x;
    cy += k * quad.point.y;
  }
  quad.cx = cx / quad.charge;
  quad.cy = cy / quad.charge;
}

function d3_layout_forceLinkDistance(link) {
  return 20;
}

function d3_layout_forceLinkStrength(link) {
  return 1;
}
d3.layout.partition = function() {
  var hierarchy = d3.layout.hierarchy(),
      size = [1, 1]; // width, height

  function position(node, x, dx, dy) {
    var children = node.children;
    node.x = x;
    node.y = node.depth * dy;
    node.dx = dx;
    node.dy = dy;
    if (children && (n = children.length)) {
      var i = -1,
          n,
          c,
          d;
      dx = node.value ? dx / node.value : 0;
      while (++i < n) {
        position(c = children[i], x, d = c.value * dx, dy);
        x += d;
      }
    }
  }

  function depth(node) {
    var children = node.children,
        d = 0;
    if (children && (n = children.length)) {
      var i = -1,
          n;
      while (++i < n) d = Math.max(d, depth(children[i]));
    }
    return 1 + d;
  }

  function partition(d, i) {
    var nodes = hierarchy.call(this, d, i);
    position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
    return nodes;
  }

  partition.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return partition;
  };

  return d3_layout_hierarchyRebind(partition, hierarchy);
};
d3.layout.pie = function() {
  var value = Number,
      sort = null,
      startAngle = 0,
      endAngle = 2 * Math.PI;

  function pie(data, i) {

    // Compute the start angle.
    var a = +(typeof startAngle === "function"
        ? startAngle.apply(this, arguments)
        : startAngle);

    // Compute the angular range (end - start).
    var k = (typeof endAngle === "function"
        ? endAngle.apply(this, arguments)
        : endAngle) - startAngle;

    // Optionally sort the data.
    var index = d3.range(data.length);
    if (sort != null) index.sort(function(i, j) {
      return sort(data[i], data[j]);
    });

    // Compute the numeric values for each data element.
    var values = data.map(value);

    // Convert k into a scale factor from value to angle, using the sum.
    k /= values.reduce(function(p, d) { return p + d; }, 0);

    // Compute the arcs!
    var arcs = index.map(function(i) {
      return {
        data: data[i],
        value: d = values[i],
        startAngle: a,
        endAngle: a += d * k
      };
    });

    // Return the arcs in the original data's order.
    return data.map(function(d, i) {
      return arcs[index[i]];
    });
  }

  /**
   * Specifies the value function *x*, which returns a nonnegative numeric value
   * for each datum. The default value function is `Number`. The value function
   * is passed two arguments: the current datum and the current index.
   */
  pie.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return pie;
  };

  /**
   * Specifies a sort comparison operator *x*. The comparator is passed two data
   * elements from the data array, a and b; it returns a negative value if a is
   * less than b, a positive value if a is greater than b, and zero if a equals
   * b.
   */
  pie.sort = function(x) {
    if (!arguments.length) return sort;
    sort = x;
    return pie;
  };

  /**
   * Specifies the overall start angle of the pie chart. Defaults to 0. The
   * start angle can be specified either as a constant or as a function; in the
   * case of a function, it is evaluated once per array (as opposed to per
   * element).
   */
  pie.startAngle = function(x) {
    if (!arguments.length) return startAngle;
    startAngle = x;
    return pie;
  };

  /**
   * Specifies the overall end angle of the pie chart. Defaults to 2π. The
   * end angle can be specified either as a constant or as a function; in the
   * case of a function, it is evaluated once per array (as opposed to per
   * element).
   */
  pie.endAngle = function(x) {
    if (!arguments.length) return endAngle;
    endAngle = x;
    return pie;
  };

  return pie;
};
// data is two-dimensional array of x,y; we populate y0
d3.layout.stack = function() {
  var values = Object,
      order = d3_layout_stackOrders["default"],
      offset = d3_layout_stackOffsets["zero"],
      out = d3_layout_stackOut,
      x = d3_layout_stackX,
      y = d3_layout_stackY;

  function stack(data, index) {

    // Convert series to canonical two-dimensional representation.
    var series = data.map(function(d, i) {
      return values.call(stack, d, i);
    });

    // Convert each series to canonical [[x,y]] representation.
    var points = series.map(function(d, i) {
      return d.map(function(v, i) {
        return [x.call(stack, v, i), y.call(stack, v, i)];
      });
    });

    // Compute the order of series, and permute them.
    var orders = order.call(stack, points, index);
    series = d3.permute(series, orders);
    points = d3.permute(points, orders);

    // Compute the baseline…
    var offsets = offset.call(stack, points, index);

    // And propagate it to other series.
    var n = series.length,
        m = series[0].length,
        i,
        j,
        o;
    for (j = 0; j < m; ++j) {
      out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
      for (i = 1; i < n; ++i) {
        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
      }
    }

    return data;
  }

  stack.values = function(x) {
    if (!arguments.length) return values;
    values = x;
    return stack;
  };

  stack.order = function(x) {
    if (!arguments.length) return order;
    order = typeof x === "function" ? x : d3_layout_stackOrders[x];
    return stack;
  };

  stack.offset = function(x) {
    if (!arguments.length) return offset;
    offset = typeof x === "function" ? x : d3_layout_stackOffsets[x];
    return stack;
  };

  stack.x = function(z) {
    if (!arguments.length) return x;
    x = z;
    return stack;
  };

  stack.y = function(z) {
    if (!arguments.length) return y;
    y = z;
    return stack;
  };

  stack.out = function(z) {
    if (!arguments.length) return out;
    out = z;
    return stack;
  };

  return stack;
}

function d3_layout_stackX(d) {
  return d.x;
}

function d3_layout_stackY(d) {
  return d.y;
}

function d3_layout_stackOut(d, y0, y) {
  d.y0 = y0;
  d.y = y;
}

var d3_layout_stackOrders = {

  "inside-out": function(data) {
    var n = data.length,
        i,
        j,
        max = data.map(d3_layout_stackMaxIndex),
        sums = data.map(d3_layout_stackReduceSum),
        index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }),
        top = 0,
        bottom = 0,
        tops = [],
        bottoms = [];
    for (i = 0; i < n; ++i) {
      j = index[i];
      if (top < bottom) {
        top += sums[j];
        tops.push(j);
      } else {
        bottom += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  },

  "reverse": function(data) {
    return d3.range(data.length).reverse();
  },

  "default": function(data) {
    return d3.range(data.length);
  }

};

var d3_layout_stackOffsets = {

  "silhouette": function(data) {
    var n = data.length,
        m = data[0].length,
        sums = [],
        max = 0,
        i,
        j,
        o,
        y0 = [];
    for (j = 0; j < m; ++j) {
      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
      if (o > max) max = o;
      sums.push(o);
    }
    for (j = 0; j < m; ++j) {
      y0[j] = (max - sums[j]) / 2;
    }
    return y0;
  },

  "wiggle": function(data) {
    var n = data.length,
        x = data[0],
        m = x.length,
        max = 0,
        i,
        j,
        k,
        s1,
        s2,
        s3,
        dx,
        o,
        o0,
        y0 = [];
    y0[0] = o = o0 = 0;
    for (j = 1; j < m; ++j) {
      for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
      for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
          s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
        }
        s2 += s3 * data[i][j][1];
      }
      y0[j] = o -= s1 ? s2 / s1 * dx : 0;
      if (o < o0) o0 = o;
    }
    for (j = 0; j < m; ++j) y0[j] -= o0;
    return y0;
  },

  "expand": function(data) {
    var n = data.length,
        m = data[0].length,
        k = 1 / n,
        i,
        j,
        o,
        y0 = [];
    for (j = 0; j < m; ++j) {
      for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
      if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
      else for (i = 0; i < n; i++) data[i][j][1] = k;
    }
    for (j = 0; j < m; ++j) y0[j] = 0;
    return y0;
  },

  "zero": function(data) {
    var j = -1,
        m = data[0].length,
        y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }

};

function d3_layout_stackMaxIndex(array) {
  var i = 1,
      j = 0,
      v = array[0][1],
      k,
      n = array.length;
  for (; i < n; ++i) {
    if ((k = array[i][1]) > v) {
      j = i;
      v = k;
    }
  }
  return j;
}

function d3_layout_stackReduceSum(d) {
  return d.reduce(d3_layout_stackSum, 0);
}

function d3_layout_stackSum(p, d) {
  return p + d[1];
}
d3.layout.histogram = function() {
  var frequency = true,
      valuer = Number,
      ranger = d3_layout_histogramRange,
      binner = d3_layout_histogramBinSturges;

  function histogram(data, i) {
    var bins = [],
        values = data.map(valuer, this),
        range = ranger.call(this, values, i),
        thresholds = binner.call(this, range, values, i),
        bin,
        i = -1,
        n = values.length,
        m = thresholds.length - 1,
        k = frequency ? 1 : 1 / n,
        x;

    // Initialize the bins.
    while (++i < m) {
      bin = bins[i] = [];
      bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
      bin.y = 0;
    }

    // Fill the bins, ignoring values outside the range.
    i = -1; while(++i < n) {
      x = values[i];
      if ((x >= range[0]) && (x <= range[1])) {
        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
        bin.y += k;
        bin.push(data[i]);
      }
    }

    return bins;
  }

  // Specifies how to extract a value from the associated data. The default
  // value function is `Number`, which is equivalent to the identity function.
  histogram.value = function(x) {
    if (!arguments.length) return valuer;
    valuer = x;
    return histogram;
  };

  // Specifies the range of the histogram. Values outside the specified range
  // will be ignored. The argument `x` may be specified either as a two-element
  // array representing the minimum and maximum value of the range, or as a
  // function that returns the range given the array of values and the current
  // index `i`. The default range is the extent (minimum and maximum) of the
  // values.
  histogram.range = function(x) {
    if (!arguments.length) return ranger;
    ranger = d3.functor(x);
    return histogram;
  };

  // Specifies how to bin values in the histogram. The argument `x` may be
  // specified as a number, in which case the range of values will be split
  // uniformly into the given number of bins. Or, `x` may be an array of
  // threshold values, defining the bins; the specified array must contain the
  // rightmost (upper) value, thus specifying n + 1 values for n bins. Or, `x`
  // may be a function which is evaluated, being passed the range, the array of
  // values, and the current index `i`, returning an array of thresholds. The
  // default bin function will divide the values into uniform bins using
  // Sturges' formula.
  histogram.bins = function(x) {
    if (!arguments.length) return binner;
    binner = typeof x === "number"
        ? function(range) { return d3_layout_histogramBinFixed(range, x); }
        : d3.functor(x);
    return histogram;
  };

  // Specifies whether the histogram's `y` value is a count (frequency) or a
  // probability (density). The default value is true.
  histogram.frequency = function(x) {
    if (!arguments.length) return frequency;
    frequency = !!x;
    return histogram;
  };

  return histogram;
};

function d3_layout_histogramBinSturges(range, values) {
  return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
}

function d3_layout_histogramBinFixed(range, n) {
  var x = -1,
      b = +range[0],
      m = (range[1] - b) / n,
      f = [];
  while (++x <= n) f[x] = m * x + b;
  return f;
}

function d3_layout_histogramRange(values) {
  return [d3.min(values), d3.max(values)];
}
d3.layout.hierarchy = function() {
  var sort = d3_layout_hierarchySort,
      children = d3_layout_hierarchyChildren,
      value = d3_layout_hierarchyValue;

  // Recursively compute the node depth and value.
  // Also converts the data representation into a standard hierarchy structure.
  function recurse(data, depth, nodes) {
    var childs = children.call(hierarchy, data, depth),
        node = d3_layout_hierarchyInline ? data : {data: data};
    node.depth = depth;
    nodes.push(node);
    if (childs && (n = childs.length)) {
      var i = -1,
          n,
          c = node.children = [],
          v = 0,
          j = depth + 1;
      while (++i < n) {
        d = recurse(childs[i], j, nodes);
        d.parent = node;
        c.push(d);
        v += d.value;
      }
      if (sort) c.sort(sort);
      if (value) node.value = v;
    } else if (value) {
      node.value = +value.call(hierarchy, data, depth) || 0;
    }
    return node;
  }

  // Recursively re-evaluates the node value.
  function revalue(node, depth) {
    var children = node.children,
        v = 0;
    if (children && (n = children.length)) {
      var i = -1,
          n,
          j = depth + 1;
      while (++i < n) v += revalue(children[i], j);
    } else if (value) {
      v = +value.call(hierarchy, d3_layout_hierarchyInline ? node : node.data, depth) || 0;
    }
    if (value) node.value = v;
    return v;
  }

  function hierarchy(d) {
    var nodes = [];
    recurse(d, 0, nodes);
    return nodes;
  }

  hierarchy.sort = function(x) {
    if (!arguments.length) return sort;
    sort = x;
    return hierarchy;
  };

  hierarchy.children = function(x) {
    if (!arguments.length) return children;
    children = x;
    return hierarchy;
  };

  hierarchy.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return hierarchy;
  };

  // Re-evaluates the `value` property for the specified hierarchy.
  hierarchy.revalue = function(root) {
    revalue(root, 0);
    return root;
  };

  return hierarchy;
};

// A method assignment helper for hierarchy subclasses.
function d3_layout_hierarchyRebind(object, hierarchy) {
  object.sort = d3.rebind(object, hierarchy.sort);
  object.children = d3.rebind(object, hierarchy.children);
  object.links = d3_layout_hierarchyLinks;
  object.value = d3.rebind(object, hierarchy.value);

  // If the new API is used, enabling inlining.
  object.nodes = function(d) {
    d3_layout_hierarchyInline = true;
    return (object.nodes = object)(d);
  };

  return object;
}

function d3_layout_hierarchyChildren(d) {
  return d.children;
}

function d3_layout_hierarchyValue(d) {
  return d.value;
}

function d3_layout_hierarchySort(a, b) {
  return b.value - a.value;
}

// Returns an array source+target objects for the specified nodes.
function d3_layout_hierarchyLinks(nodes) {
  return d3.merge(nodes.map(function(parent) {
    return (parent.children || []).map(function(child) {
      return {source: parent, target: child};
    });
  }));
}

// For backwards-compatibility, don't enable inlining by default.
var d3_layout_hierarchyInline = false;
d3.layout.pack = function() {
  var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
      size = [1, 1];

  function pack(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0];

    // Recursively compute the layout.
    root.x = 0;
    root.y = 0;
    d3_layout_packTree(root);

    // Scale the layout to fit the requested size.
    var w = size[0],
        h = size[1],
        k = 1 / Math.max(2 * root.r / w, 2 * root.r / h);
    d3_layout_packTransform(root, w / 2, h / 2, k);

    return nodes;
  }

  pack.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return pack;
  };

  return d3_layout_hierarchyRebind(pack, hierarchy);
};

function d3_layout_packSort(a, b) {
  return a.value - b.value;
}

function d3_layout_packInsert(a, b) {
  var c = a._pack_next;
  a._pack_next = b;
  b._pack_prev = a;
  b._pack_next = c;
  c._pack_prev = b;
}

function d3_layout_packSplice(a, b) {
  a._pack_next = b;
  b._pack_prev = a;
}

function d3_layout_packIntersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return (dr * dr - dx * dx - dy * dy) > .001; // within epsilon
}

function d3_layout_packCircle(nodes) {
  var xMin = Infinity,
      xMax = -Infinity,
      yMin = Infinity,
      yMax = -Infinity,
      n = nodes.length,
      a, b, c, j, k;

  function bound(node) {
    xMin = Math.min(node.x - node.r, xMin);
    xMax = Math.max(node.x + node.r, xMax);
    yMin = Math.min(node.y - node.r, yMin);
    yMax = Math.max(node.y + node.r, yMax);
  }

  // Create node links.
  nodes.forEach(d3_layout_packLink);

  // Create first node.
  a = nodes[0];
  a.x = -a.r;
  a.y = 0;
  bound(a);

  // Create second node.
  if (n > 1) {
    b = nodes[1];
    b.x = b.r;
    b.y = 0;
    bound(b);

    // Create third node and build chain.
    if (n > 2) {
      c = nodes[2];
      d3_layout_packPlace(a, b, c);
      bound(c);
      d3_layout_packInsert(a, c);
      a._pack_prev = c;
      d3_layout_packInsert(c, b);
      b = a._pack_next;

      // Now iterate through the rest.
      for (var i = 3; i < n; i++) {
        d3_layout_packPlace(a, b, c = nodes[i]);

        // Search for the closest intersection.
        var isect = 0, s1 = 1, s2 = 1;
        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
          if (d3_layout_packIntersects(j, c)) {
            isect = 1;
            break;
          }
        }
        if (isect == 1) {
          for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
            if (d3_layout_packIntersects(k, c)) {
              if (s2 < s1) {
                isect = -1;
                j = k;
              }
              break;
            }
          }
        }

        // Update node chain.
        if (isect == 0) {
          d3_layout_packInsert(a, c);
          b = c;
          bound(c);
        } else if (isect > 0) {
          d3_layout_packSplice(a, j);
          b = j;
          i--;
        } else { // isect < 0
          d3_layout_packSplice(j, b);
          a = j;
          i--;
        }
      }
    }
  }

  // Re-center the circles and return the encompassing radius.
  var cx = (xMin + xMax) / 2,
      cy = (yMin + yMax) / 2,
      cr = 0;
  for (var i = 0; i < n; i++) {
    var node = nodes[i];
    node.x -= cx;
    node.y -= cy;
    cr = Math.max(cr, node.r + Math.sqrt(node.x * node.x + node.y * node.y));
  }

  // Remove node links.
  nodes.forEach(d3_layout_packUnlink);

  return cr;
}

function d3_layout_packLink(node) {
  node._pack_next = node._pack_prev = node;
}

function d3_layout_packUnlink(node) {
  delete node._pack_next;
  delete node._pack_prev;
}

function d3_layout_packTree(node) {
  var children = node.children;
  if (children && children.length) {
    children.forEach(d3_layout_packTree);
    node.r = d3_layout_packCircle(children);
  } else {
    node.r = Math.sqrt(node.value);
  }
}

function d3_layout_packTransform(node, x, y, k) {
  var children = node.children;
  node.x = (x += k * node.x);
  node.y = (y += k * node.y);
  node.r *= k;
  if (children) {
    var i = -1, n = children.length;
    while (++i < n) d3_layout_packTransform(children[i], x, y, k);
  }
}

function d3_layout_packPlace(a, b, c) {
  var db = a.r + c.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  if (db && (dx || dy)) {
    var da = b.r + c.r,
        dc = Math.sqrt(dx * dx + dy * dy),
        cos = Math.max(-1, Math.min(1, (db * db + dc * dc - da * da) / (2 * db * dc))),
        theta = Math.acos(cos),
        x = cos * (db /= dc),
        y = Math.sin(theta) * db;
    c.x = a.x + x * dx + y * dy;
    c.y = a.y + x * dy - y * dx;
  } else {
    c.x = a.x + db;
    c.y = a.y;
  }
}
// Implements a hierarchical layout using the cluster (or dendogram) algorithm.
d3.layout.cluster = function() {
  var hierarchy = d3.layout.hierarchy().sort(null).value(null),
      separation = d3_layout_treeSeparation,
      size = [1, 1]; // width, height

  function cluster(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0],
        previousNode,
        x = 0,
        kx,
        ky;

    // First walk, computing the initial x & y values.
    d3_layout_treeVisitAfter(root, function(node) {
      var children = node.children;
      if (children && children.length) {
        node.x = d3_layout_clusterX(children);
        node.y = d3_layout_clusterY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    // Compute the left-most, right-most, and depth-most nodes for extents.
    var left = d3_layout_clusterLeft(root),
        right = d3_layout_clusterRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    d3_layout_treeVisitAfter(root, function(node) {
      node.x = (node.x - x0) / (x1 - x0) * size[0];
      node.y = (1 - node.y / root.y) * size[1];
    });

    return nodes;
  }

  cluster.separation = function(x) {
    if (!arguments.length) return separation;
    separation = x;
    return cluster;
  };

  cluster.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return cluster;
  };

  return d3_layout_hierarchyRebind(cluster, hierarchy);
};

function d3_layout_clusterY(children) {
  return 1 + d3.max(children, function(child) {
    return child.y;
  });
}

function d3_layout_clusterX(children) {
  return children.reduce(function(x, child) {
    return x + child.x;
  }, 0) / children.length;
}

function d3_layout_clusterLeft(node) {
  var children = node.children;
  return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
}

function d3_layout_clusterRight(node) {
  var children = node.children, n;
  return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
}
// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
d3.layout.tree = function() {
  var hierarchy = d3.layout.hierarchy().sort(null).value(null),
      separation = d3_layout_treeSeparation,
      size = [1, 1]; // width, height

  function tree(d, i) {
    var nodes = hierarchy.call(this, d, i),
        root = nodes[0];

    function firstWalk(node, previousSibling) {
      var children = node.children,
          layout = node._tree;
      if (children && (n = children.length)) {
        var n,
            firstChild = children[0],
            previousChild,
            ancestor = firstChild,
            child,
            i = -1;
        while (++i < n) {
          child = children[i];
          firstWalk(child, previousChild);
          ancestor = apportion(child, previousChild, ancestor);
          previousChild = child;
        }
        d3_layout_treeShift(node);
        var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);
        if (previousSibling) {
          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
          layout.mod = layout.prelim - midpoint;
        } else {
          layout.prelim = midpoint;
        }
      } else {
        if (previousSibling) {
          layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);
        }
      }
    }

    function secondWalk(node, x) {
      node.x = node._tree.prelim + x;
      var children = node.children;
      if (children && (n = children.length)) {
        var i = -1,
            n;
        x += node._tree.mod;
        while (++i < n) {
          secondWalk(children[i], x);
        }
      }
    }

    function apportion(node, previousSibling, ancestor) {
      if (previousSibling) {
        var vip = node,
            vop = node,
            vim = previousSibling,
            vom = node.parent.children[0],
            sip = vip._tree.mod,
            sop = vop._tree.mod,
            sim = vim._tree.mod,
            som = vom._tree.mod,
            shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop._tree.ancestor = node;
          shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim._tree.mod;
          sip += vip._tree.mod;
          som += vom._tree.mod;
          sop += vop._tree.mod;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop._tree.thread = vim;
          vop._tree.mod += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom._tree.thread = vip;
          vom._tree.mod += sip - som;
          ancestor = node;
        }
      }
      return ancestor;
    }

    // Initialize temporary layout variables.
    d3_layout_treeVisitAfter(root, function(node, previousSibling) {
      node._tree = {
        ancestor: node,
        prelim: 0,
        mod: 0,
        change: 0,
        shift: 0,
        number: previousSibling ? previousSibling._tree.number + 1 : 0
      };
    });

    // Compute the layout using Buchheim et al.'s algorithm.
    firstWalk(root);
    secondWalk(root, -root._tree.prelim);

    // Compute the left-most, right-most, and depth-most nodes for extents.
    var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),
        right = d3_layout_treeSearch(root, d3_layout_treeRightmost),
        deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2,
        y1 = deep.depth || 1;

    // Clear temporary layout variables; transform x and y.
    d3_layout_treeVisitAfter(root, function(node) {
      node.x = (node.x - x0) / (x1 - x0) * size[0];
      node.y = node.depth / y1 * size[1];
      delete node._tree;
    });

    return nodes;
  }

  tree.separation = function(x) {
    if (!arguments.length) return separation;
    separation = x;
    return tree;
  };

  tree.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return tree;
  };

  return d3_layout_hierarchyRebind(tree, hierarchy);
};

function d3_layout_treeSeparation(a, b) {
  return a.parent == b.parent ? 1 : 2;
}

// function d3_layout_treeSeparationRadial(a, b) {
//   return (a.parent == b.parent ? 1 : 2) / a.depth;
// }

function d3_layout_treeLeft(node) {
  var children = node.children;
  return children && children.length ? children[0] : node._tree.thread;
}

function d3_layout_treeRight(node) {
  var children = node.children,
      n;
  return children && (n = children.length) ? children[n - 1] : node._tree.thread;
}

function d3_layout_treeSearch(node, compare) {
  var children = node.children;
  if (children && (n = children.length)) {
    var child,
        n,
        i = -1;
    while (++i < n) {
      if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {
        node = child;
      }
    }
  }
  return node;
}

function d3_layout_treeRightmost(a, b) {
  return a.x - b.x;
}

function d3_layout_treeLeftmost(a, b) {
  return b.x - a.x;
}

function d3_layout_treeDeepest(a, b) {
  return a.depth - b.depth;
}

function d3_layout_treeVisitAfter(node, callback) {
  function visit(node, previousSibling) {
    var children = node.children;
    if (children && (n = children.length)) {
      var child,
          previousChild = null,
          i = -1,
          n;
      while (++i < n) {
        child = children[i];
        visit(child, previousChild);
        previousChild = child;
      }
    }
    callback(node, previousSibling);
  }
  visit(node, null);
}

function d3_layout_treeShift(node) {
  var shift = 0,
      change = 0,
      children = node.children,
      i = children.length,
      child;
  while (--i >= 0) {
    child = children[i]._tree;
    child.prelim += shift;
    child.mod += shift;
    shift += child.shift + (change += child.change);
  }
}

function d3_layout_treeMove(ancestor, node, shift) {
  ancestor = ancestor._tree;
  node = node._tree;
  var change = shift / (node.number - ancestor.number);
  ancestor.change += change;
  node.change -= change;
  node.shift += shift;
  node.prelim += shift;
  node.mod += shift;
}

function d3_layout_treeAncestor(vim, node, ancestor) {
  return vim._tree.ancestor.parent == node.parent
      ? vim._tree.ancestor
      : ancestor;
}
// Squarified Treemaps by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
// Modified to support a target aspect ratio by Jeff Heer
d3.layout.treemap = function() {
  var hierarchy = d3.layout.hierarchy(),
      round = Math.round,
      size = [1, 1], // width, height
      padding = null,
      pad = d3_layout_treemapPadNull,
      sticky = false,
      stickies,
      ratio = 0.5 * (1 + Math.sqrt(5)); // golden ratio

  // Compute the area for each child based on value & scale.
  function scale(children, k) {
    var i = -1,
        n = children.length,
        child,
        area;
    while (++i < n) {
      area = (child = children[i]).value * (k < 0 ? 0 : k);
      child.area = isNaN(area) || area <= 0 ? 0 : area;
    }
  }

  // Recursively arranges the specified node's children into squarified rows.
  function squarify(node) {
    var children = node.children;
    if (children && children.length) {
      var rect = pad(node),
          row = [],
          remaining = children.slice(), // copy-on-write
          child,
          best = Infinity, // the best row score so far
          score, // the current row score
          u = Math.min(rect.dx, rect.dy), // initial orientation
          n;
      scale(remaining, rect.dx * rect.dy / node.value);
      row.area = 0;
      while ((n = remaining.length) > 0) {
        row.push(child = remaining[n - 1]);
        row.area += child.area;
        if ((score = worst(row, u)) <= best) { // continue with this orientation
          remaining.pop();
          best = score;
        } else { // abort, and try a different orientation
          row.area -= row.pop().area;
          position(row, u, rect, false);
          u = Math.min(rect.dx, rect.dy);
          row.length = row.area = 0;
          best = Infinity;
        }
      }
      if (row.length) {
        position(row, u, rect, true);
        row.length = row.area = 0;
      }
      children.forEach(squarify);
    }
  }

  // Recursively resizes the specified node's children into existing rows.
  // Preserves the existing layout!
  function stickify(node) {
    var children = node.children;
    if (children && children.length) {
      var rect = pad(node),
          remaining = children.slice(), // copy-on-write
          child,
          row = [];
      scale(remaining, rect.dx * rect.dy / node.value);
      row.area = 0;
      while (child = remaining.pop()) {
        row.push(child);
        row.area += child.area;
        if (child.z != null) {
          position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
          row.length = row.area = 0;
        }
      }
      children.forEach(stickify);
    }
  }

  // Computes the score for the specified row, as the worst aspect ratio.
  function worst(row, u) {
    var s = row.area,
        r,
        rmax = 0,
        rmin = Infinity,
        i = -1,
        n = row.length;
    while (++i < n) {
      if (!(r = row[i].area)) continue;
      if (r < rmin) rmin = r;
      if (r > rmax) rmax = r;
    }
    s *= s;
    u *= u;
    return s
        ? Math.max((u * rmax * ratio) / s, s / (u * rmin * ratio))
        : Infinity;
  }

  // Positions the specified row of nodes. Modifies `rect`.
  function position(row, u, rect, flush) {
    var i = -1,
        n = row.length,
        x = rect.x,
        y = rect.y,
        v = u ? round(row.area / u) : 0,
        o;
    if (u == rect.dx) { // horizontal subdivision
      if (flush || v > rect.dy) v = v ? rect.dy : 0; // over+underflow
      while (++i < n) {
        o = row[i];
        o.x = x;
        o.y = y;
        o.dy = v;
        x += o.dx = v ? round(o.area / v) : 0;
      }
      o.z = true;
      o.dx += rect.x + rect.dx - x; // rounding error
      rect.y += v;
      rect.dy -= v;
    } else { // vertical subdivision
      if (flush || v > rect.dx) v = v ? rect.dx : 0; // over+underflow
      while (++i < n) {
        o = row[i];
        o.x = x;
        o.y = y;
        o.dx = v;
        y += o.dy = v ? round(o.area / v) : 0;
      }
      o.z = false;
      o.dy += rect.y + rect.dy - y; // rounding error
      rect.x += v;
      rect.dx -= v;
    }
  }

  function treemap(d) {
    var nodes = stickies || hierarchy(d),
        root = nodes[0];
    root.x = 0;
    root.y = 0;
    root.dx = size[0];
    root.dy = size[1];
    if (stickies) hierarchy.revalue(root);
    scale([root], root.dx * root.dy / root.value);
    (stickies ? stickify : squarify)(root);
    if (sticky) stickies = nodes;
    return nodes;
  }

  treemap.size = function(x) {
    if (!arguments.length) return size;
    size = x;
    return treemap;
  };

  treemap.padding = function(x) {
    if (!arguments.length) return padding;

    function padFunction(node) {
      var p = x.call(treemap, node, node.depth);
      return p == null
          ? d3_layout_treemapPadNull(node)
          : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
    }

    function padConstant(node) {
      return d3_layout_treemapPad(node, x);
    }

    var type;
    pad = (padding = x) == null ? d3_layout_treemapPadNull
        : (type = typeof x) === "function" ? padFunction
        : type === "number" ? (x = [x, x, x, x], padConstant)
        : padConstant;
    return treemap;
  };

  treemap.round = function(x) {
    if (!arguments.length) return round != Number;
    round = x ? Math.round : Number;
    return treemap;
  };

  treemap.sticky = function(x) {
    if (!arguments.length) return sticky;
    sticky = x;
    stickies = null;
    return treemap;
  };

  treemap.ratio = function(x) {
    if (!arguments.length) return ratio;
    ratio = x;
    return treemap;
  };

  return d3_layout_hierarchyRebind(treemap, hierarchy);
};

function d3_layout_treemapPadNull(node) {
  return {x: node.x, y: node.y, dx: node.dx, dy: node.dy};
}

function d3_layout_treemapPad(node, padding) {
  var x = node.x + padding[3],
      y = node.y + padding[0],
      dx = node.dx - padding[1] - padding[3],
      dy = node.dy - padding[0] - padding[2];
  if (dx < 0) { x += dx / 2; dx = 0; }
  if (dy < 0) { y += dy / 2; dy = 0; }
  return {x: x, y: y, dx: dx, dy: dy};
}
})();


/*
 * Wrapper around calls to Boxy to inject common functionality we want across all our popups
 */

function centerBoxy(boxy, x, y) {
    boxy.centerAtY(y);
    boxy.centerAtX(x);
}

function getOptions(ext_options) {
    ext_options = ext_options || {};

    // Default options go here
    var options = {
        x: $(window).width() * 0.5,
        y: $(window).height() * 0.35,
        modal: true,
        fixed: true,
    };

    $.extend(options, ext_options);


    var handleEnter = function(evt) {
      var key = evt.which || evt.keyCode;

      if (key === 13) {
        if ($('[value="OK"]').length) {
          $('[value="OK"]').click()
        } else if ($('.kt-boxy-confirm-action').length) {
          $('.kt-boxy-confirm-action').click();
        }
      }
    }

    // $.extend does something weird to "this", so this assignment is outside
    options.afterShow = function() {
      this.boxy.find('input').first().focus();
      centerBoxy(this, options.x, options.y);

      if (typeof(ext_options.afterShow) === "function") {
          ext_options.afterShow.call(this);
      }

      $(document).on('keypress', handleEnter);
    }

    options.beforeUnload = function() {
      $(document).off('keypress', handleEnter);
    }

    return options;
}

function BoxyLoad(url, options) {
    Boxy.load(url, getOptions(options));
}

function BoxyAlert(message, callback, options) {
    Boxy.alert(message, callback, getOptions(options));
}

function BoxyConfirm(message, callback, options) {
    Boxy.confirm(message, callback, getOptions(options));
}

function BoxyAsk(question, answers, callback, options) {
    Boxy.ask(question, answers, callback, getOptions(options));
}

/**
 * todo: explain term/context
 */

(function ($, autocomplete) {
    var proto = autocomplete.prototype;

    // Get the caret location in a textarea


    function getCaret(el) {
        if (el.selectionStart) { // Firefox / Chrome
            return el.selectionStart;
        } else if (document.selection) { // IE
            if (el !== document.activeElement) {
                return 0;
            }

            var r = document.selection.createRange(),
                re = el.createTextRange(),
                rc = re.duplicate();
            if (r === null) {
                return 0;
            }

            re.moveToBookmark(r.getBookmark());
            rc.setEndPoint('EndToStart', re);

            return rc.text.length;
        }
        return 0;
    }

    // Sets the position of the caret in a textarea


    function setCaret(el, pos) {
        if (typeof (el.selectionStart) !== "undefined") { // Firefox / Chrome
            el.selectionStart = el.selectionEnd = pos;
        } else if (document.selection) { // IE
            var range = el.createTextRange();
            range.collapse(true);
            range.moveStart('character', pos);
            range.moveEnd('character', pos);
            range.select();
        }
    }

    // Splits the text into 3 parts [ beforeTerm, termAtCursor, afterTerm ]


    function splitTerm(text, cursor) {
        // Search for the bounds of a term (defined by /\w+/).
        // Start bound is exclusive (right before the start of the term)
        // End bound is also exclusive
        var termStart = text.substring(0, cursor).search(/[^a-zA-Z_]\w*$/),
            termEnd = text.substring(cursor).search(/^[^a-zA-Z_]/) + cursor;

        if (termEnd < cursor) {
            termEnd = cursor;
        }

        return [text.substring(0, termStart + 1), text.substring(termStart + 1, termEnd), text.substring(termEnd)];
    }

    function extractTerm(val, cursor) {
        var terms = splitTerm(val, cursor);
        return terms[1];
    }

    /**
     * Gets the context of what should be autocompleted based on the cursor location.
     *
     * e.g. if  the cursor is marked by |
     *      the following should give the context 'none'
     *        inst|
     *        installs.offset(3) + ev|
     *        installs.offset(3) + |
     *
     *      the following should give the context 'property'
     *        installs.off| ...
     *        event_info_per_day_all.filt| ...
     *        event_info_per_day_all.filter|( ...
     *        event_info_per_day_all.| ...
     *
     *      the following should give the context 'filter'
     *        event_info_per_day_all.filter(| ...
     *        event_info_per_day_all.filter(|) ...
     *        event_info_per_day_all.filter(monitization, ...
     *        event_info_per_day_all.filter(virality, invitSent,|) ...
     */

    function getContext(val, cursor) {
        var terms = splitTerm(val, cursor),
            contextSrc = terms[0] + terms[1],
            propertyRegex = /(\w+)\s*(?:\.\s*\w+\s*\((?:\w|,|\s)*?\)\s*)*\.\s*\w*$/,
            filterRegex = /(\w+)\s*(?:\.\s*(?:offset|type)\s*\(.*?\)\s*)*\.\s*filter\s*\(([^)]*)$/,
            offsetRegex = /(\w+)\s*(?:\.\s*(?:filter|eventName|type)\s*\(.*?\)\s*)*\.\s*offset\s*\(\s*$/,
            eventNameRegex = /(\w+)\s*(?:\.\s*(?:offset|filter)\s*\([^)]*\)\s*)*\.\s*eventName\s*\(([^)]*)$/,
            typeRegex = /(\w+)\s*(?:\.\s*(?:offset)\s*\([^)]*\)\s*)*\.\s*type\s*\(([^)]*)$/,
            context = {
                type: 'none',
                dataSource: ''
            },
            match = propertyRegex.exec(contextSrc),
            rawAppliedProperties = null;
        if (match) {
            context.type = 'property';
            context.dataSource = match[1];
            context.appliedProperties = [];

            // Find any applied properties
            rawAppliedProperties = match[0].match(/\.\s*\w+\s*\(.*?\)\s*/g);
            if (rawAppliedProperties !== null) {
                // Filter the raw properties to find the property names
                // e.g. '.  filter (1, 2,3)' -> 'filter'
                for (var i = 0, len = rawAppliedProperties.length; i < len; i++) {
                    context.appliedProperties.push(rawAppliedProperties[i].match(/\.\s*(\w+)\s*\(.*/)[1]);
                }
            }
        }

        match = typeRegex.exec(contextSrc);
        if (match) {
            context.type = 'type';
            context.dataSource = match[1];
            //called to prevent .type(type, from returning the list of types. 
            context.subtypes = [];
            //Check to prevent '.type(type,' from returning anything beyond "no monetization types"
            if (getContextSubtypes(match).length > 0){
                context.subtypes.push("userTryingToSetAdditionalTypeInContext");
            }
        }

        match = offsetRegex.exec(contextSrc);
        if (match) {
            context.type = 'offset';
            context.dataSource = match[1];
        }

        match = filterRegex.exec(contextSrc);
        if (match) {
            context.type = 'filter';
            context.dataSource = match[1];
            context.subtypes = [];
            //For filtering via new type operator, we filter using the term from .type if it exists and we're looking at a revenue query.
            if (context.dataSource in this.query_map){
                if (this.query_map[context.dataSource].filters[0] === 'revenue'){
                    var subtypesMatch = match[0].match(/type\s*\(([^)]*)\)/);
                    if (subtypesMatch) {
                        var type = subtypesMatch[1].split(",");
                        context.subtypes.push($.trim(type[0]));
                    } else {
                        context.subtypes.push("noTypeSet");
                    }
                }
            }
            context.subtypes = context.subtypes.concat(getContextSubtypes(match))
        }

        match = eventNameRegex.exec(contextSrc);
        if (match) {
            context.type = 'eventName';
            context.dataSource = match[1];
            context.subtypes = [];

            var subtypesMatch = match[0].match(/filter\s*\(([^)]*)\)/);
            if (subtypesMatch) {
                var subtypes = subtypesMatch[1].split(",");
                for (var i = 0, len = subtypes.length; i < len; i++) {
                    context.subtypes.push($.trim(subtypes[i]));
                }
            }
            //Check to prevent '.eventName(event,' from returning anything beyond "no Events"
            if (getContextSubtypes(match).length > 0){
                context.subtypes.push("userTryingToSetAdditionalEventInContext");
            }
        }

        return context;
    }
    //Gets previous terms in the latest specifier, seperated by commas
    //i.e. '.filter(buy, facebookCredits,', this returns ['buy', 'facebookCredits]
    function getContextSubtypes (match) {
        var subtypes = match[2].split(","),
            trimmedSubtypes = [];
        //doesn't include last subtype, which is part of term, not context
        for (var i = 0, len = subtypes.length - 1; i < len; i++) {
            if (subtypes[i].length > 0) {
                trimmedSubtypes.push($.trim(subtypes[i]));
            };
        };
        return trimmedSubtypes;
    }

    $.widget('ui.customSourceAutocomplete', autocomplete, {
        options: {
            query_map: {}
        },

        _create: function() {
            var self = this;

            // Allow TAB completion so it doesn't escape the textarea
            this.element.bind('keydown', function(evt) {
                if (evt.keyCode === $.ui.keyCode.TAB && self.menu.active) {
                    evt.preventDefault();
                }
            });

            proto._create.call(this);
        },
        _search: function(value) {
            this.pending++;
            // always save the actual value, not the one passed as an argument
            this.term = this.element.addClass("ui-autocomplete-loading").val();

            var caretPos = getCaret(this.element[0]),
                term = extractTerm(value, caretPos),
                context = getContext(value, caretPos);
            if (term.length < 2 && context.type === 'none') {
                this._response()([]);
                return false;
            }

            this.source({
                term: value
            }, this._response());
        },
        _trigger: function(type, evt, data) {
            var ret = proto._trigger.apply(this, arguments);
            if (type === 'select' && ret !== false) {
                // Inject the selected term into the textarea
                var terms = splitTerm(this.element.val(), getCaret(this.element[0]));
                this.element.val(terms[0] + data.item.value + terms[2]);

                // Set the cursor
                var new_cursor_location = terms[0].length + data.item.value.length;
                setCaret(this.element[0], new_cursor_location);

                // Start a new search to with the inserted autocompleted term
                // on a timeout so we start after the autocomplete menu has
                // been closed
                var self = this;
                window.setTimeout(function() {
                    self.search();
                }, 10);

                // Prevent autocomplete from replacing the whole textarea
                // with the selected term
                ret = false;
            }

            // return false for focus events
            return (type === 'focus') ? false : ret;
        },
        _initSource: function() {
            this.query_map = this.options.query_map;
            this.query_list = this.options.query_list;
            this.source = this._source;
        },
        _source: function(request, response) {
            // Get the term and context at the currently placed cursor
            var val = this.element[0].value,
                caretPos = getCaret(this.element[0]),
                term = extractTerm(val, caretPos),
                context = getContext(val, caretPos),

            // From the term/context pair determine what are the valid autocompletions
                options_list = [];

            if (context.type === 'none') {
                options_list = this.query_list;
                response(autocomplete.filter(options_list, term));
            } else if (context.dataSource in this.query_map) { // Ensure a valid data source
                if (context.type === 'property') {
                    var has_type = ($.inArray('type', context.appliedProperties) !== -1),
                        has_filter = ($.inArray('filter', context.appliedProperties) !== -1),
                        has_eventName = ($.inArray('eventName', context.appliedProperties) !== -1),
                        has_offset = ($.inArray('offset', context.appliedProperties) !== -1),
                        filter_type = this.query_map[context.dataSource].filters[0];
                        options_list = [];
                    if (!has_offset) {
                        options_list.push('offset(');
                    }
                    if (!has_filter && !has_eventName && (filter_type !== 'revenue'|has_type)) {
                        options_list.push('filter(');
                    }
                    if (!has_eventName && filter_type === 'events') {
                        options_list.push('eventName(');
                    }
                    if (!has_type && !has_filter && filter_type === 'revenue'){
                        options_list.push('type(');
                    }
                    options_list = autocomplete.filter(options_list, term);
                } else if (context.type === 'offset') {
                    options_list = [{
                        label: 'Number of days',
                        value: ''
                    }];
                    options_list = autocomplete.filter(options_list, term);
                } else { // context.type === 'filter', context.type === 'eventName' or context.type === 'type', requires AJAX call.
                    if (context.dataSource in this.query_map){
                        var filter_type = this.query_map[context.dataSource].filters[0],
                            options_list = [];
                        if (context.type === 'eventName' && filter_type !== 'events'){
                            options_list = [{
                                label: 'Does not have events',
                                value: ''
                            }];

                        } else if (context.type === 'type' && filter_type !== 'revenue'){
                            options_list = [{
                                label: 'No Monetization Types',
                                value: ')'
                            }];

                        } else if (context.type === 'filter' && !filter_type){
                            options_list = [{
                                label: 'No Filters',
                                value: ')'
                            }];
                        } else{
                            $.ajax({
                                url: '/dashboard/custom_dashboard_get_subtypes/' + filter_type + '/',
                                type: 'POST',
                                data: {
                                    'subtypes': context.subtypes.join(',')
                                },
                                dataType: 'json',
                                success: function(data) {
                                    // Ensure the textarea hasn't changed since when we initiated the ajax call
                                    if (this.value !== this.el.value || this.caretPos !== getCaret(this.el)) {
                                        return;
                                    }

                                    // Remove an '' subtype if it is returned as the first element
                                    if (data.subtypes.length > 0 && data.subtypes[0] === '') {
                                        data.subtypes = data.subtypes.slice(1);
                                    }
                                    if (context.type === 'eventName'){
                                        data.names = ['All'].concat(data.names);
                                        options_list = autocomplete.filter(data.names, this.term);
                                    } else{
                                        options_list = autocomplete.filter(data.subtypes, this.term);
                                    };
                                    if (options_list.length === 0) {
                                        if (context.type === 'filter'){
                                        //Checking that a non-empty .type( has been set (it should be the first element in context.subtypes). Special case for revenue queries.
                                            if (filter_type === 'revenue' && $.inArray('noTypeSet', context.subtypes) === 0){
                                                options_list = [{
                                                label: 'Please specify a monetization event .type(',
                                                value: ')'
                                                }];
                                            } else{
                                                options_list = [{
                                                    label: 'No Filters',
                                                    value: ')'
                                                }];
                                            }
                                        } else if (context.type === 'type') {
                                            options_list = [{
                                                label: 'No Types',
                                                value: ')'
                                            }];
                                        };
                                    };
                                    response(options_list);
                                },
                                caretPos: caretPos,
                                value: val,
                                term: term,
                                el: this.element[0]
                            });

                        };
                    };
                };
	    response(options_list);
            };
        }
    });
    $.extend($.ui.customSourceAutocomplete, {
        getCaret: getCaret,
        setCaret: setCaret,
        getContext: getContext,
        splitTerm: splitTerm
    });
})(jQuery, jQuery.ui.autocomplete);

function NumFormatter() {
    this.decimal_regex = /(\d+)\.(\d+)/;

    this.comma_format = function(int_num) {
        var arg_type = (typeof int_num); //xxx
        if (arg_type === "string") {
            var num_str = int_num;
        } else if (arg_type === "number") {
            var num_str = int_num + "";
        }

        var len = num_str.length;
        var r = "";
        var j = 1;

        var decimal_point_index = num_str.indexOf(".");
        var starting_point_index = len - decimal_point_index - 1;

        for (var i = len - 1; i >= 0; i--) {
            var char_candidate = num_str.charAt(i);
            if (j % 3 === 0) {
                if (i !== 0 && num_str[i-1] !== '-') r = "," + char_candidate + r;
                else r = char_candidate + r;
            } else {
                r = char_candidate + r;
            } // else
            if (decimal_point_index === -1) {
                // doesn't have decimal
                j++;
            } else {
                // deal with decimal
                if ((len - 1 - i) > starting_point_index) {
                    j++;
                }
            }
        } // for
        return r;
    };

    this.format_decimal = function(float_num, decimal_places) {
        if (float_num === "Undefined") {
            return float_num;
        } else if (float_num === "N/A") {
            return "---";
        } else {
            var decimal_place_num = Math.pow(10, decimal_places);

            var r_str = String(Math.round(float_num * decimal_place_num) / decimal_place_num);
            var r_reg = this.decimal_regex.exec(r_str);
            var padded_zeros = decimal_places;
            // r_reg is null if float_num doesn't have a decimal point in it. like 1 instead of 1.0
            if (r_reg !== null) {
                padded_zeros -= r_reg[2].length;
            } else {
                r_str += ".";
            }

            for (var i = 0; i < padded_zeros; i++) {
                r_str += "0";
            }
            return r_str;
        }
    };
}

var timeoutDefault = 20000;
var retryDefault = 3;
var errorDefault = "Unable to fetch data.";
var errorWrapper = "<div id='error-top' style='width:500px;'><br><br><br><a class='show-error-button-red' href='#'><font size='-2'>Error Details <span class='num_errors'>(1)</span></font></a></div>" +
                   "<div id='error-details' style='display:none;height:200px;padding: 0px 10px; margin: 10px 0px;background-color:#E0E0E0'></div>";

var errorShown = false;
var errorDiv = null;
var errorNum = 0;
var leavingPage = false;
var pendingRequests = {};

function show_errors() {
    $(this).unbind('click');
    $(this).bind('click',hide_errors);
    errorDiv.filter("div#error-details").slideDown(350,function() { $(this).css("overflow-y","scroll"); });
    return false;
}

function hide_errors() {
    $(this).unbind('click');
    $(this).bind('click',show_errors);
    errorDiv.filter("div#error-details").slideUp(350);
    return false;
}

function ktAjaxWrapper(parameters) {
    var localParameters = {};
    var customError = parameters['error'];
    var customSuccess = parameters['success'];
    var customComplete = parameters['complete'];
    var errorMessage = errorDefault;
    var finished = false;
    var url = parameters['url'];
    var type = parameters['type'];
    var data = parameters['data'];
    var useFramework;
    if (parameters['useFramework'] !== undefined){
      useFramework = parameters['useFramework'];
    } else {
      useFramework = true; //default
    }
    var displayPageMessageError = parameters['displayPageMessageError'];

    var caller = parameters['caller'] || '';

    for (key in parameters) {
        localParameters[key] = parameters[key];
    }

    localParameters['dataType'] = parameters['dataType'] || 'json';
    localParameters['silent'] = parameters['silent'];

    if(useFramework) {
      if (type.toLowerCase() == 'get') {
          if (url.search(/\?/) == -1) {
              url += "?";
          } else {
              url += "&";
          }
          url += "framework=true";
          localParameters['url'] = url;
      } else {
          data['framework'] = true;
          localParameters['data'] = data;
      }
    }

    if (!localParameters['timeout']){
        localParameters['timeout'] = timeoutDefault;
    }
    if (localParameters['maxRetries'] === undefined){
        localParameters['maxRetries'] = retryDefault;
    }

    localParameters['tries'] = 0;

    localParameters['success'] = function(data,textStatus,xhr) {
      finished = true;

      if(useFramework) {
        if (!data){
          localParameters['error'](xhr,textStatus + " - No Data in success.");
          return;
        } else if (!('responseCode' in data)){
          localParameters['error'](xhr,textStatus + " - No responseCode in success.");
          return;
        }
        var responseCode = data.responseCode;
        if (responseCode != 1) {
          localParameters['error'](xhr,textStatus + " - No responseCode other than 1 returned.");
          return;
        }
      }

      if(customSuccess) {
        customSuccess(data,textStatus,xhr);
      }
    };

    localParameters['error'] = function(xhr, textStatus, errorThrown ) {
        if (textStatus == 'timeout') {
            if (this.tries < this.maxRetries) {
                localParameters['tries'] = this.tries+1;
                jQuery.ajax(localParameters);
                return;
            }
            localParameters['errorMessage'] = "Server timed out.  Please try again.";
        }
        finished = true;

        var errorText = errorDefault;
        if (localParameters['errorMessage']) {
            errorText = localParameters['errorMessage'];
        }
        var silent = false;

        var response = {};
        var timestamp = null;

        try {
            response = JSON.parse(xhr.responseText);
            if (response['errorMessage']) {
                errorText = response['errorMessage'];
            }
            if (response['timestamp']) {
                timestamp = response['timestamp'];
            }
            if (response['silent']) {
                silent = response['silent'];
            }
        } catch(err) {}

        silent = silent || localParameters['silent'];

        if (!errorShown && !leavingPage && !silent) {
          if(displayPageMessageError) {
            PageMessage.addMessageToPage({
              type: PageMessage.ERROR,
              content: response['errorDesc'] ? response['errorDesc'] + ' ' + errorText : errorText,
              hidable: true
            });
          } else {
            errorDiv = jQuery(errorWrapper);
            errorDiv.filter("#error-top").prepend(errorText);
            errorDiv.find(".show-error-button-red").bind('click',show_errors);
            errorShown = true;
            Boxy.alert(errorDiv,function() {
                errorShown = false;
                errorDiv = null;
                errorNum = 0;
            });
          }
        }

        if(!leavingPage) {
          var errorDetail = jQuery("<div style='padding:10px;'></div>");
          if (errorNum !== 0) {
              errorDetail.css("border-top","1px solid black");
          }

          errorNum += 1;
          if(errorDiv){ //LIH: I need to come back and understand this
            errorDiv.find("span.num_errors").empty();
            errorDiv.find("span.num_errors").append("("+errorNum+")");
          }

          errorDetail.append(errorText);
          if (timestamp){
              errorDetail.append("<br><font size='-2'>Error Reference: " + timestamp + "</font>");
          }

          if(errorDiv){ //LIH: I need to come back and understand this
            errorDiv.filter("div#error-details").append(errorDetail);
          }

          inform_server_of_error(localParameters,xhr,textStatus,errorThrown);
          if (customError) {
            customError(xhr,textStatus,errorThrown);
          }
        }
    };

    localParameters['complete'] = function(textStatus,xhr) {
        if (finished && customComplete) {
            customComplete(textStatus,xhr);
        }
    };

    if(caller) {

      // Ignore existing requests for this id
      if(pendingRequests[caller]) {

        // Aborted requests will call their success handler
        // unbind these before aborting so that we ignore these
        pendingRequests[caller].onreadystatechange = null;

        // Perform the actual abort, note most likely the server will
        // still process the request, we will simply ignore the response
        // on the client ssde
        pendingRequests[caller].abort();
      }

      pendingRequests[caller] = jQuery.ajax(localParameters);
    } else {
      jQuery.ajax(localParameters);
    }
}

function inform_server_of_error(parameters, xhr, textStatus, errorThrown){
    errorSummary = {};
    errorSummary['url'] = parameters['url'];
    errorSummary['data'] = parameters['data'];
    errorSummary['error'] = textStatus;
    try {
        errorSummary['status'] = xhr.status;
        response = JSON.parse(xhr.responseText);
        if (response['responseCode']) {
            errorSummary['errorCode'] = response['responseCode'];
        } else {
            errorSummary['errorCode'] = -1;
        }
        if (response['errorDesc']) {
            errorSummary['errorDesc'] = response['errorDesc'];
        } else {
            errorSummary['errorDesc'] = "No Description";
        }
        if (response['timestamp']) {
            errorSummary['timestamp'] = response['timestamp'];
        } else {
            errorSummary['timestamp'] = -1;
        }
    } catch(err) {
        errorSummary['status'] = -1;
        errorSummary['errorCode'] = -1;
        errorSummary['errorDesc'] = -1;
        errorSummary['timestamp'] = -1;
    }
    error_str = JSON.stringify(errorSummary);
    //May want a completely separate URL/server to log with.
    jQuery.post("/dashboard/error_log/",{'error_summary':error_str});
}

$(window).bind('beforeunload', function() {
  leavingPage = true;
  pendingRequests = {};
});

/**
 * Utility functions
 */
var DEBUG = false;

function KtDebug(debug_stuff) {
    if (DEBUG && window.console && window.console.firebug) console.log(debug_stuff);
}

/**
 * AJAX handler for JSON chart data
 * @constructor
 * @param {AbstractChartHandler} chart The parent chart object, usually "this" in the context of the chart.
 */

function ChartAjaxHandler(chart) {
  if (!chart._options) {
    return;
  } /* exit if _options is undefined */

  this.chart = chart;
  this.options = chart._options;
  this.last_fetched_data = null;
  this.csv_query_params = {};   /* CSV syntax    -- converts {'t': 1, 'b': [2, 3]} to t=1&b=2,3 */
  this.data_query_params = {};  /* jQuery syntax -- converts {'t': 1, 'b': [2, 3]} to t=1&b[]=2&b[]=3 */
  var url_components;

  this.location_id = [this.options['category'], this.options['tab'], this.options['page'], this.options['chart_index']].join('/');
  /*
   * KT_ENV_JS defines this key in custom_dashboard.py.
   * It is not available on standard pages.
   */
  if ('custom_dashboard_page_id' in KT_ENV_JS) {
    url_components = [
      this.options['root_url'], 'custom_dashboard_ajax', KT_ENV_JS['custom_dashboard_page_id']];

    this.csv_query_params['id'] = this.options['chart_index'];
    this.url = url_components.join('/') + '/';
  } else {
    url_components = [
      this.options['root_url'], 'np_ajax', this.options['category'], this.options['tab'], this.options['page'], this.options['chart_index']];
    this.url = url_components.join('/') + '/'; /* trailing slash */
    url_multi_components = [
      this.options['root_url'], 'np_ajax_multi', this.options['category'], this.options['tab'], this.options['page'], this.options['chart_index']];
    this.multi_url = url_multi_components.join('/') + '/';
  }

  this.csv_query_params['t'] = 'j';
  this.csv_query_params['json_chart'] = 'true';
}

/**
 *  KT-5505 karyon is removed
 *  Helper function that reconcile the differences between karyon and the original way of getting data.
 */
ChartAjaxHandler.prototype.get_data_url_wrapper = function(query_params) {
  var url = null;
  query_params = this.data_query_params;
  url = this.current_url() + window.location.hash;
  return url;
};

/**
 * AJAX request to this.current_url() for chart data
 */
ChartAjaxHandler.prototype.load_chart_data = function(success_callback, error_callback) {
  var ajax_obj = this;

  var params = {};
  var url = null;

  url = ajax_obj.get_data_url_wrapper(params);

  // for a URL like http://www.kontagent.com/# , window.location.hash returns:
  // IE: "#"
  // All other browsers: ""
  if (window.location.hash && window.location.hash !== '#') {
    params['filter_json_str'] = window.location.hash.substring(1);
  }

  ktAjaxWrapper({
    url: url,
    dataType: 'json',
    type: 'GET',
    data: params,
    cache: false,
    useFramework: false,
    caller: this.chart._id,
    success: function(data) {
      ajax_obj.last_fetched_data = data;
      success_callback(data);
    },
    error: error_callback
  });
};

ChartAjaxHandler.prototype.load_multi_chart_data = function(success_callback, error_callback) {
  var ajax_obj = this;
  var params = {};
  var url = null;

  params = ajax_obj.data_query_params;
  url = this.current_multi_url() + window.location.hash;

  ktAjaxWrapper({
    //url: this.current_multi_url(),
    url: url,
    dataType: 'json',
    type: 'GET',
    data: params,
    cache: false,
    useFramework: false,
    caller: this.chart._id,
    success: function(data) {
      ajax_obj.last_fetched_data = data;
      success_callback(data);
    },
    // this error_callback is not the typical callback. it has a customized message that can be found and changed in dashboard/static/js/kt/kt_highcharts.js line 380
    error: error_callback
  });
};

/**
 * Converts query params hash to array
 * @param {object} query_params {t: 'j', x: [1, 2, "three"]}
 * @return {Array} query params array ['t=j', x='1,2,three']
 */
ChartAjaxHandler.prototype.csv_query_params_to_array = function(csv_query_params) {
    var joined_query_params = [];
    for (var key in csv_query_params) {
        var values = csv_query_params[key];
        var joined = key + '=';
        joined += (values instanceof Array) ? values.join(',') : values;
        joined_query_params.push(joined);
    }
    return joined_query_params;
};

/**
 * Appends new query parameters to a URL
 * @param {string} url URL to append to
 * @param {Array} query_joined array of query parameters, i.e. ['t=3', 'hello=world']
 * @return {string} URL with parameters
 */
ChartAjaxHandler.prototype.append_query_params = function(url, query_params) {
    var new_url = url;

    if (query_params != null) {
        var prepend = (url.indexOf("?") > 0) ? "&" : "?";
        new_url += prepend + query_params.join("&");
    }

    return new_url;
};

/**
 * Generates current URL based on this.url and this.query_params
 * If an element is an array, it's joined into a comma separated list
 * @return {string} URL with parameters
 */
ChartAjaxHandler.prototype.current_url = function() {
    var joined_query_params = this.csv_query_params_to_array(this.csv_query_params);
    return this.append_query_params(this.url, joined_query_params);
};

ChartAjaxHandler.prototype.current_multi_url = function(){
  var joined_query_params = this.csv_query_params_to_array(this.csv_query_params);
  return this.append_query_params(this.multi_url, joined_query_params);
};


/**
 * Common abstract chart handler.
 */

function AbstractChartHandler(element, options) {
    this._element = element;
    this._options = options;
    this._ajax = new ChartAjaxHandler(this);

    this._so = null;
    this._applied_multi_filters = null;
    this._applied_multi_filter_names = null;
    this._tab = null;
    this._page = null;
    this._chart_index = null;

    // This should really be changed to accept arbitrary parameters from pages.py that are converted to xml
    this.prefix = '';
    this.suffix = '';
    if (options != undefined) {
        KtDebug(options);
        if (options['prefix'] != undefined) {
            this.prefix = options['prefix'];
        } else {
            this.prefix = '';
        }
        if (options['suffix'] != undefined) {
            this.suffix = options['suffix'];
        } else {
            this.suffix = '';
        }

      this.legend_enabled = options['legend_enabled'];
      this.x_axis_title = options['x_axis_title'];
      this.y_axis_title = options['y_axis_title'];
    }

    /* Charts are accessible via CSS id (i.e. $(chart_id).data('chart_obj') yields SomeChartHandler) */
    if(typeof this._element != "undefined") {
        this._element.data('chart_obj', this);
    }
}

AbstractChartHandler.prototype._load_trend_popup = function(id, resource_id_to_use) {
  var title = "Trends";

  var chart_id, query_string;

  var custom_id = this._element.attr('custom_chart_id');

  if(custom_id) {
    chart_id = custom_id;
    query_string = '?custom';
  } else {
    chart_id = resource_id_to_use || this._resource_id;
    query_string = '';
  }

  var load_url = "/trending/trend_line_popup/" + chart_id + "/" + id + "/" + query_string;

  var on_show = function() {
    populate_set_trends(id);
  }

  var on_close = function() {
    set_trend_form(id, true);
  }

  var popup_name = "trend_line_" + id;


  this._load_popup({
    id: this._id,
    title: title,
    load_url: load_url,
    popup_name: popup_name,
    on_show: on_show,
    on_close: on_close
  });
}

AbstractChartHandler.prototype._load_pin_popup = function() {
  var title = "Pin Chart"
  var load_url = KT_ENV_JS['root_url'] + "/pin_popup/" + this._id + "/";

  var popup_name = "pin_" + this._id;

  var chart = this;

  if(!chart.showing_pin) {
    chart.showing_pin = true;

    BoxyLoad(load_url, {
        title: title,
        unloadOnHide: true,
        afterShow: function() {
            Pinning.afterLoad({
                'boxy': this,
                'popup': this.boxy.find('.pin_popup'),
                'resource_id': chart._resource_id,
                'additional_data': chart.additional_pin_data()
            });
        },
        afterHide: function() {
            chart.showing_pin = false;
        }
    });
  }
}

/*
 * Overriden by any subclasses that need to provide extra information
 * beyond the current session filters to pin correctly
 */
AbstractChartHandler.prototype.additional_pin_data = function() {
  return {};
}

/* TODO: infer id from context. */
AbstractChartHandler.prototype._load_popup = function(args) {
  var id = args['id'];
  var title = args['title'];
  var load_url = args['load_url'];
  var popup_name = args['popup_name'];
  var on_show = args['on_show'];
  var on_close = args['on_close'];
  var on_apply = args['on_apply'];

  var chart_obj = this;

  var chart_box = chart_obj._element.find('div.k-box');

  if(chart_obj.showing_popup) {
    return;
  }

  //For tab chart, put popup on parent's k-box
  if (id.match("tab")) {
    chart_box = $('#' + id).parents('div.k-box');
  }

  chart_box.find('.options').addClass('disabled');

  var popup = Boxy.get($('.widget_popup[name=' + popup_name + ']'));

  if (popup) {
    popup.show();
  } else {
    Boxy.load(load_url, {
      title: title,
      unloadOnHide: false,
      modal: false,
      fixed: false,
      closeText: "",
      beforeUnload: function() {
        chart_box.find('.boxy-modal-blackout[name=blackout-' + id + ']').remove();
        chart_box.find('.options').removeClass('disabled');
        chart_obj.showing_popup = false;
      },
      afterHide: function() {
        chart_box.find('.boxy-modal-blackout[name=blackout-' + id + ']').hide();
        chart_box.find('.options').removeClass('disabled');
        chart_obj.showing_popup = false;
      },
      afterShow: function() {
        if(on_show) {
          on_show();
        }

        var popup = this;
        var chart_body = chart_box.find('.k-box-body');
        var height = chart_body.height();

        // Move the boxy into the chart if it isn't already
        if(!popup.boxy.parent('.k-box-body').length) {

          // Close handler
          var close = $("<div class='widget-popup-close'></div>");
          close.click(function() {
            popup.hide();

            if(on_close) {
              on_close();
            }
          });

          // Apply handler
          $('.widget-popup-apply-button').click(function() {
            popup.hide();

            if(on_apply) {
              on_apply();
            }
          });

          popup.boxy.find('.title-bar').append(close);

          if(!chart_body.find('.boxy-modal-blackout').length) {
            //Append blackout screen to chart
            var blackout = $("<div name=\"blackout-" + id + "\" class=\"boxy-modal-blackout\"></div>");
            blackout.addClass("widget-popup-blackout");
            blackout.css('height', (height) + 'px');
            blackout.css('top', '-' + (height) + 'px');

            chart_body.append(blackout);
          }

          //Position popup within chart
          popup.boxy.removeAttr('style');
          popup.boxy.addClass("widget-popup-boxy");
          popup.boxy.css("top", "-" + (height * 2) + "px");

          chart_body.append(popup.boxy);
        }

        chart_box.find('.boxy-modal-blackout[name=blackout-' + id + ']').show();
        chart_box.data('showing-popup', true);
        popup.boxy.parent('.k-box-body').css('height', (height) + 'px');
      },
      closeable: false,
      show: true,
      draggable: false,
      center: true
    });
  }
}


AbstractChartHandler.prototype.icon_classname_list = ['trends', 'advanced_link', 'export_link', 'print_link', 'pin_link'];

AbstractChartHandler.prototype._show_hide_chart_icons = function(chart_obj,show) {
  for (icon_classname in chart_obj.icon_classname_list) {
      var icon_element = $(chart_obj._element).find('.' + chart_obj.icon_classname_list[icon_classname]);
      if (icon_element) {
        var display = show ? '' : 'none';
        icon_element.css('display', display);
      }
  }
};

AbstractChartHandler.prototype.hide_chart_icons = function(chart_obj) {
  chart_obj._show_hide_chart_icons(chart_obj,false);
};

AbstractChartHandler.prototype.show_chart_icons = function(chart_obj) {
  chart_obj._show_hide_chart_icons(chart_obj,true);
};

AbstractChartHandler.prototype.get_root_url = function() {
    return this._root_url;
};

AbstractChartHandler.prototype._get_curr_url = function() {
    var curr_url = escape(window.location.href);
    return curr_url;
};

/**
 * To be used with ktTemplate
 */
AbstractChartHandler.prototype._get_simple_header = function() {
    if (this._show_frame()) {
        var template_str = '<div class="k-box">' + '<div class="k-box-head">' + '<div class="k-box-head-info">' + '<h1>[=title]</h1>' + '<a href="#" class="help" resource_id="[=resource_id]" title="[=bubble_text]">' + 'help' + '</a>';

        if(this._pinning_enabled) {
          template_str += '<a href="javascript:void(0)" class="k-box-icon pin_link" title="Pin Chart to Custom Page">&nbsp;</a>';
        }


        /* chart header icons */
        if(this._enable_print_link) {
            template_str += '<a href="#" class="k-box-icon print_link" title="Print Chart">&nbsp;</a>';
        }

        if (this._enable_data_export) {
            template_str += '<a href="#" class="k-box-icon export_link" title="Export to CSV" id="[=data_export_id]">&nbsp;</a>';

        }

        if(this._enable_advanced_link) {
            template_str += '<a href="#" class="k-box-icon advanced_link" title="Advanced Graph View">&nbsp;</a>';
        }

        if (this._show_trend_option()) {

            if ($('a.time_mode_button.active').data('time-mode') == 'daily')
                template_str += '<a href="javascript:void(0)" class="k-box-icon trends" id="' + this._trend_id + '" title="Trends">&nbsp;</a>';
            else
                template_str += '<a href="javascript:void(0)" class="k-box-icon trends disabled-trends" id="' + this._trend_id + '" title="Trendlines are currently only supported in daily time series">&nbsp;</a>';

        }


        template_str += '</div>' + '</div>' + '<div class="k-box-body" id="so_[=id]" style="height:[=height]"></div>' + '</div>';
    } else {
        var template_str = '<div id="so_[=id]" style="height:[=height]"></div>';
    }
    return template_str;
};

AbstractChartHandler.prototype._render_simple_header = function() {
    var template_str = this._get_simple_header();

    $(this._element).ktTemplate({
        template: template_str
    });

    var params = {
        title: this._options['title'],
        chart_index: this._options['chart_index'],
        bubble_text: this._options['bubble'],
        data_export_id: this._data_export_id,
        id: this._id,
        height: this._height
    };

    $(this._element).ktTemplate('render', params);
    $(this._element).find(".k-box-head-info").data("esc-title", escape(this._options['title']));
    if ('has_annotation' in this._options) {
        $(this._element).data("has_annotation", this._options['has_annotation']);
    } else {
        $(this._element).data("has_annotation", true);
    }
};

AbstractChartHandler.prototype.load_data = function() {
  var chart_obj = this;

  if (chart_obj._options['disable_data_load']) {
    return;
  }

  chart_obj.showLoading();

  var successHandler = function(data) {
    if (data.errorMessage) { // under np_ajax, some responses have HttpResponses without actual data but provide an error message
      chart_obj.hide_chart_icons(chart_obj);
      chart_obj.showLoading(data.errorMessage);
    } else {
      chart_obj.show_chart_icons(chart_obj);
      chart_obj.draw(data)
    }
  };

  var errorHandler = function(jqXHR, textStatus, errorThrown) {
    chart_obj.hide_chart_icons(chart_obj);
    var dataError = $.parseJSON(jqXHR.responseText);
    chart_obj.showLoading('This chart is experiencing technical difficulties.');
    if (dataError.responseCode){
      chart_obj.showLoading(dataError.errorMessage);
    }
  };

  this._ajax.load_chart_data(successHandler, errorHandler);
};

/**
 * Not to be used with ktTemplate (all templating is done inline)
 */
AbstractChartHandler.prototype._get_dropdown_header = function() {
    var media_url = this._options['media_url'];
    var data_export_anchor = "";
    if (this._enable_data_export) data_export_anchor = '<a href = "#" title="Export to CSV" id="' + this._data_export_id + '" class="k-box-icon export_link">&nbsp;</a>';

    var dropdown_chart_id = this._id + "_dropdown";
    var header_html_str = '<div class="k-box"><div class="k-box-head"><div class="k-box-head-info"><h1>' + this._options['title'] + '</h1><a href="#" class="help" resource_id="' + this._options['resource_id'] + '"title="' + this._options['bubble'] + '">help</a>' + data_export_anchor + '<ul class="icons"><li><a href="#"><img src="' + media_url + '/images/ico6.jpg" width="19" height="24" alt="" /></a></li><li><a href="#"><img src="' + media_url + '/images/ico3.jpg" width="19" height="24" alt="" /></a></li><li><a href="#"><img src="' + media_url + '/images/ico9.jpg" width="16" height="24" alt="" /></a></li></ul></div></div><div class="k-box-body">';
    header_html_str += '<ul>&nbsp;&nbsp;&nbsp;&nbsp;<select id="' + dropdown_chart_id + '">';


    var dropDownList = this._options['dropdown'];
    var dropDownListCount = this._options['dropdown'].length;
    for (var i = 0; i < dropDownListCount; i++) {
        var dropDownValue = i + 1;
        var dropDownString = dropDownList[i];
        header_html_str += '<option chart_id="' + this._id + '" value="' + dropDownValue + '" >' + dropDownString + '</option>';
    }

    header_html_str += '</select></ul>';
    header_html_str += '<div class="box-chart-info" id="so_' + this._id + '" style="height:' + this._height + '"></div>';
    header_html_str += '</div></div>';

    return header_html_str;
};

AbstractChartHandler.prototype._get_option = function(option, default_value) {
    var option_val = default_value;

    if (this._options[option] != undefined) {
        option_val = this._options[option];
    }

    return option_val;
};

AbstractChartHandler.prototype._get_parent_id = function() {
    var tmp_lst = this._id.split("_");
    var parent_id = null;
    if (tmp_lst[tmp_lst.length - 1] == 'tab') parent_id = tmp_lst[0];
    return parent_id;
};

AbstractChartHandler.prototype._get_dropdownId = function() {
    return this._id + "_dropdown";
};

AbstractChartHandler.prototype._get_dropdownSelVal = function() {
    var sel_id = this._get_dropdownId();
    var sel_val = $("#" + sel_id + " option:selected").val();
    return sel_val;
};

AbstractChartHandler.prototype._get_export_url = function(original_url) {
    var data_export_url = null;
    if (original_url.search('np_ajax_multi') > -1) {
        data_export_url = original_url.replace('np_ajax_multi', 'np_data_export');
    } else if (original_url.search('np_ajax') > -1) {
        data_export_url = original_url.replace('np_ajax', 'np_data_export');
    } else if (original_url.search('custom_dashboard_ajax') > -1) {
        data_export_url = original_url.replace('custom_dashboard_ajax', 'custom_dashboard_export');
    }

    if (data_export_url == null) {
        // God dammit. data_export_url is still empty.
        var tmp_list = original_url.split("?");
        if (tmp_list.length == 1) {
            // no query string
            data_export_url = original_url + "?export=1";
        } else {
            data_export_url = original_url + "&export=1";
        }
    }

    return data_export_url;
};

AbstractChartHandler.prototype._bind_export = function(chart_obj) {
    if (this._enable_data_export) {
        // bind data export link
        $("#" + this._data_export_id).click(function() {
            var original_url = chart_obj._last_ajax_get_data_url || chart_obj._ajax.current_url(); /* old style ajax || new style ajax */
            var data_export_url = append_api_key_to_url(chart_obj._get_export_url(original_url));
            document.location = data_export_url;
            return false;
        });
    }
};

AbstractChartHandler.prototype._show_option_menu = function() {
    return this._get_option('show_option_menu', false);
};

AbstractChartHandler.prototype._show_trend_option = function() {
    return this._get_option('show_trend_option', false);
};

AbstractChartHandler.prototype._show_frame = function() {
    return this._get_option('show_frame', true);
};

AbstractChartHandler.prototype._common_assignments = function() {
    var chart_id = $(this._element).prop('id');
    this._id = chart_id;
    this._root_url = this._options['root_url'];
    this._tab = this._options['tab'];
    this._page = this._options['page'];
    this._chart_index = this._options['chart_index'];
    this._resource_id = this._options['resource_id'];
    this._enable_data_export = !this._options['disable_data_export'];
    this._enable_advanced_link = this._options['enable_advanced_link'];
    this._enable_print_link = this._options['enable_print_link'];
    this._pinning_enabled = this._options['pinning_enabled'];
    this._editable = this._options['editable'];
    this._height = this._options['height'];
    this._trend_id = "trend_" + this._id;
    this._option_drop_id = "options_drop_" + this._id;
    this._data_export_id = "data_export_" + this._id;
    this._precision = this._options['precision'];
    this._summable = this._options['summable'];
    this._num_series = this._options['num_series'];
};

AbstractChartHandler.prototype._bind_common_events = function() {
  var chart_obj = this;

  $(this._element).find('.pin_link').click(function() {
    chart_obj._load_pin_popup();
  });
};

AbstractChartHandler.prototype._selected_chart_id = function() {
  // Lih(develop) : need to deal with the new charts later. It doesn't have chart_uuid atm.
  var selected_chart_id = null;
  if ($('#' + this._id).closest('div[custom_chart_id]').length > 0) {
    selected_chart_id = $('#' + this._id).closest('div[custom_chart_id]').attr('custom_chart_id');
  } else {
    selected_chart_id = $('#' + this._id).closest('div[chart_uuid]').attr('chart_uuid');
  }
  if (selected_chart_id) {
    selected_chart_id = selected_chart_id.replace('\\','');
  }
  return selected_chart_id;
};

/**
 * Build advanced_link
 */
AbstractChartHandler.prototype.advanced_link = function() {
    var url_components = [
      'dashboard',
      this._options['category'],
      this._options['tab'],
      this._options['page'],
      this._selected_chart_id()
    ];

    url_components = _.map(url_components, function(url) { if (url) return url.replace("/", ""); });
    return '/' + url_components.join('/') + '/';
};

function amProcessCompleted(chart_id, process) {
    var tmp_lst = chart_id.split("_");
    var flashobj_id = "";
    for (var i = 0; i < tmp_lst.length; i++) {
        if (tmp_lst[i] != "chart") {
            flashobj_id += tmp_lst[i];
            flashobj_id += "_";
        }
    }
    flashobj_id += "flashobj";
    var div_id = $("#" + chart_id.replace("_chart", ""));

    if (process != "showAll") {
        if (process != "appendData") $(div_id).data('annotation_binded', 'false');
        document.getElementById(flashobj_id).showAll();
    }
    if (process == "showAll" && $(div_id).data('annotation_binded') == 'false' && !$('#createnew').length > 0) {
        $(div_id).data('annotation_binded', 'true');
        if ($(div_id).prop('id') == $('div[chart_uuid]:data("has_annotation"):visible:last').prop('id')) {
            bind_annotation();
        }
    }
}

function amClickedOnBullet(chart_id, graph_index, value, series, a_lst) {
    var new_chart_id = chart_id.replace(/_chart/, "").replace(/_\d_tab/, "");
    handle_select_annotation(new_chart_id, a_lst);
}

// firefox 3.5.x under Windoz doesn't feel instantiating
// flash objects to its entirety unless it's visible to
// the user. This posts problems to us, since we need the
// call amchart related function.
// Sol'n : Store the arguments to _setSwfSettings and
// _reload_singular_chart_url.
// When the charts become visible, let them complete their
// instantiaton. Then, via amChartInited we force another
// data and setting reload.
var swf_setting_assoc_array = {};

function amChartInited(chart_id) {
    var plugin_id = chart_id.split("_chart")[0];
    var flashobj_id = plugin_id + "_flashobj";
    var setting_str = swf_setting_assoc_array[plugin_id];

    if (setting_str != undefined) {
        document.getElementById(flashobj_id).setSettings(setting_str);
        delete swf_setting_assoc_array[plugin_id];
    }

    $(document).trigger('resend_realtime_data');
}

var point_data_lst = []; // array storing all annotation on a date.
var point_data = {}; // object storing specific annotation.
var editable = false; // submit vs edit variable.


(function($) {

    /////////////////////// AbstractAmChartHandler ///////////////////////


    function AbstractAmChartHandler(element, options) {
        this.inheritedFrom = AbstractChartHandler;
        this.inheritedFrom(element, options);

        // Should generate the XML all dynamically
        this._color_hover = '#99FF00';
        this._line_width = 2;
        var balloon_text_xml_start = '<balloon_text><![CDATA[ {title}: ';
        var balloon_text_xml_middle = '{value}';
        var balloon_text_xml_end = ']]></balloon_text>';

        color_hover_xml = '<color_hover>' + this._color_hover + '</color_hover>';

        this._graph_format_xml_start = balloon_text_xml_start;
        this._graph_format_xml_middle = balloon_text_xml_middle;
        this._graph_format_xml_end = balloon_text_xml_end + color_hover_xml;

        // _last_ajax_get_data_url is obviously used to keep track of the last url that is used for fetching data.
        // Our export functionality depends on it.
        this._last_ajax_get_data_url = null;
    }
    AbstractAmChartHandler.prototype = new AbstractChartHandler();

    $.extend(AbstractAmChartHandler.prototype, {
        // This is a work around hack..
        // AMChart has a bug where if the unit text is a %, you have to escape it the first time, and have to not escape
        // it the second time.
        _get_graph_format_xml: function(prefix, suffix) {
            if (!prefix) {
                prefix = this.prefix;
            }
            if (!suffix) {
                suffix = this.suffix;
            }
            return this._graph_format_xml_start + prefix + this._graph_format_xml_middle + suffix + this._graph_format_xml_end;
        },

        _save_applied_multi_filters: function(filter_idx_lst, filter_name_lst) {
            this._applied_multi_filters = filter_idx_lst;
            this._applied_multi_filter_names = filter_name_lst;
            KtDebug("------->setting _applied_multi_filter_names: " + filter_name_lst); //xxx
            KtDebug(this); //xxx
        },

        _clear_applied_multi_filter: function() {
            this._applied_multi_filters = null;
            this._applied_multi_filter_names = null;
        },

        _set_chart_param: function(name, value) {
            var flashobj_id = this._id + "_flashobj";
            document.getElementById(flashobj_id).setParam(name, value);
        },

        _reload_url_cache_helper: function(new_url) {
            if (this._disable_data_load) {
                return;
            }

            var flashobj_id = this._id + "_flashobj";
            KtDebug("last:" + this._last_ajax_get_data_url); //xxx
            KtDebug("new :" + new_url); //xxx
            //if(this._last_ajax_get_data_url != new_url)
            try {
                var var_dict = this._so.getVariables();
                var_dict['data_file'] = escape(new_url);
                var var_lst = [];
                $.each(var_dict, function(k, v) {
                    var_lst.push(k + "=" + v);
                });

                document.getElementById(flashobj_id).setAttribute("flashvars", var_lst.join("&"));
                document.getElementById(flashobj_id).reloadData(escape(new_url));
            } catch (err) {}
            this._last_ajax_get_data_url = new_url;
        },

        _get_additional_simple_chart_settings_str: function() {
            alert("_get_additional_simple_chart_settings_str not defined");
        },

        _setSwfSettings: function(setting_xml_str) {
            try {
                var flashobj_id = this._id + "_flashobj";
                document.getElementById(flashobj_id).setSettings(setting_xml_str);
                //this._so.addVariable("additional_chart_settings", setting_xml_str);
            } catch (err) {
                swf_setting_assoc_array[this._id] = setting_xml_str;
            }
        },

      bind_events: function() {
        var so = this._so;
        var chart_obj = this;
        var flashobj_id = this._id + "_flashobj";

        $(this._element).bind('restart_swf', function(event) {
          var chart_type = chart_obj._options['type'];
          if (chart_type != 'tab_refactored') so.write('so_' + chart_obj._id);
        });

        $(this._element).bind('trend_button_clicked',

                              function(event) {
                                if ($('a.time_mode_button.active').data('time-mode') == 'daily'){ 
                                  chart_obj._load_trend_popup(chart_obj._id);
                                }
                              });

        $(this._element).bind('reload_chart', function(event, extra_query_params) {
          var chart_type = chart_obj._options['type'];
          var joined_query_params = chart_obj._ajax.query_params_to_array(extra_query_params);

          if (chart_obj._applied_multi_filters == null) {
            if (chart_type == 'simple') {
              chart_obj._reload_singular_chart_url(joined_query_params);
            } else if (chart_type == 'dropdown') {
              var sel_val = chart_obj._get_dropdownSelVal();
              chart_obj._reload_dropdown_chart_url(sel_val, joined_query_params);
            }
          } else {
            if (chart_type == 'simple') {
              chart_obj._reload_multi_chart_url(chart_obj._applied_multi_filters, joined_query_params);
            } else if (chart_type == 'dropdown') {
              var sel_val = chart_obj._get_dropdownSelVal();
              chart_obj._reload_multi_dropdown_chart_url(chart_obj._applied_multi_filters, sel_val, joined_query_params);
            }
          }
        });

        // When the chart is first loaded
        $(document).bind('initialize_amchart', function(event) {
          var func = chart_obj._options['filter_type_func'];

          var filter_type_dict = func();
          var chart_type = chart_obj._options['type'];
          // SINGLE FILTER (NON SAVED FILTER)
          if (filter_type_dict['type'] == 'singular_filter') {
            KtDebug('singular_filter'); //xxx
            chart_obj._clear_applied_multi_filter();
            so.addVariable("additional_chart_settings", encodeURIComponent(chart_obj._get_additional_simple_chart_settings_str()));
            if (chart_type == 'simple') {
              KtDebug('simple'); //xxx
              so.addVariable("data_file", escape(chart_obj._get_singular_chart_url()));
            } else if (chart_type == 'dropdown') {
              var sel_val = chart_obj._get_dropdownSelVal();
              so.addVariable("additional_chart_settings", encodeURIComponent(chart_obj._get_additional_simple_chart_settings_str()));
              so.addVariable("data_file", escape(chart_obj._get_dropdown_chart_url(sel_val)));
            }
          }
          // SAVED FILTER(S)
          else if (filter_type_dict['type'] == 'multiple_filter') {
            chart_obj._save_applied_multi_filters(filter_type_dict['saved_filters'], filter_type_dict['saved_filter_names']);
            so.addVariable("additional_chart_settings", encodeURIComponent(chart_obj._get_additional_simple_chart_settings_str()));
            if (chart_type == 'simple') {
              so.addVariable("data_file", escape(chart_obj._get_multi_chart_url(filter_type_dict['saved_filters'])));
            } else if (chart_type == 'dropdown') {
              var sel_val = chart_obj._get_dropdownSelVal();
              so.addVariable("data_file", escape(chart_obj._get_multi_dropdown_chart_url(filter_type_dict['saved_filters'], sel_val)));
            }
          }
          KtDebug(chart_obj._id); //xxx
          if (chart_type != 'tab_refactored') so.write('so_' + chart_obj._id);
        });

        $(document).bind('clear_all_chart', function(event, msg) {
          var flashobj_id = chart_obj._id + "_flashobj";
          try {
            try {
              // Reload Line Charts
              document.getElementById(flashobj_id).setToBlank();
            } catch (err) {
              // Reload Pie Charts
              document.getElementById(flashobj_id).setData([]);
            }
          } catch (err) {}
        });

        // When a simple filter is applied
        $(document).bind('load_all_chart', function(event, msg) {
          chart_obj._clear_applied_multi_filter();
          var chart_type = chart_obj._options['type'];
          if (chart_type == 'simple') {
            KtDebug("\t chart_type is simple"); //xxx
            chart_obj._reload_singular_chart_url();
          } else if (chart_type == 'dropdown') {
            KtDebug(">>dropdown"); //xxx
            var sel_val = chart_obj._get_dropdownSelVal();
            chart_obj._reload_dropdown_chart_url(sel_val);
          }
        });

        $(document).bind('load_all_charts_multi', function(event, msg) {
          KtDebug('load_all_charts_multi'); //xxx
          var len = event.saved_filters.length - 1;
          var func = chart_obj._options['filter_type_func'];
          var chart_type = chart_obj._options['type'];
          var filter_type_dict = func();
          KtDebug("calling save_applied_multi_filters from here."); //xxx
          KtDebug(filter_type_dict);
          KtDebug(event);
          chart_obj._save_applied_multi_filters(event.saved_filters, event.saved_filter_names);
          if (chart_type == 'dropdown') {
            var sel_val = chart_obj._get_dropdownSelVal();
            chart_obj._reload_multi_dropdown_chart_url(event.saved_filters, sel_val);
          } else {
            chart_obj._reload_multi_chart_url(event.saved_filters);
          }
        } //function(event,msg)
                        );

        $(document).bind('annotation_saved', function(event, msg) {
          KtDebug(event);
          var flashobj_id = chart_obj._id + "_flashobj";
          var selected_chart_id = chart_obj._selected_chart_id();

          point_data['title'] = event.title;
          point_data['text'] = event.text;
          point_data['share_level'] = event.share_level;
          point_data['keyid'] = event.keyid;
          point_data['creator'] = event.creator;
          var xml_str = "";
          if (selected_chart_id == event.selected_chart_id) {
            if (event.submit_type == "edit") {
              $("tr[id='au_" + point_data.keyid + "']").find('.title span').text(point_data.title);
              $("tr[id='au_" + point_data.keyid + "']").find('.text span:last').text(point_data.text);
              $("tr[id='au_" + point_data.keyid + "']").find('.text span.acess_label').text(point_data.share_level.toLowerCase());
            } else if (event.submit_type == "delete") {
              $("tr[id='au_" + point_data.keyid + "']").remove();
            }

            point_data['xid'] = event.xid;
            if (point_data['gid'] == undefined) {
              point_data['gid'] = "0";
            }
            xml_str += chart_obj._get_additional_simple_chart_data_str(
              point_data['xid'], point_data['keyid'], point_data['title'], point_data['text'], point_data['share_level'], point_data['creator'], event.submit_type);
            if (point_data.share_level == "GLOBAL") {
              var selector = $('object').length > 0 ? "object" : "embed";
              $('div:data("has_annotation"):visible ' + selector).each(function() {
                flashobj_id = $(this).prop('id');
                document.getElementById(flashobj_id).appendData(xml_str);
              });
            } else {
              document.getElementById(flashobj_id).appendData(xml_str);
            }
          }
        });

        $(document).bind('line_chart_dropdown_selected', function(event, msg) {
          KtDebug('handling line_chart_dropdown_selected'); //xxx
          KtDebug(msg); //xxxx
          KtDebug(chart_obj._id); //xxx
          if (msg == chart_obj._id) {
            KtDebug(chart_obj._applied_multi_filter_names); //xxx
            if (chart_obj._applied_multi_filters == null) {
              chart_obj._reload_dropdown_chart_url(event.dropdown_v);
            } else {
              chart_obj._reload_multi_dropdown_chart_url(chart_obj._applied_multi_filters, event.dropdown_v);
            }
          }
        });
        this._bind_export(this);
      },

        instantiate_am_chart: function() {
            alert("instantiate_am_chart not defined");
        },

        init_impl: function() { /* Settings in abstract_chart_handler.js run first */
            this._common_assignments();
            var chart_obj = this;
            var chart_type = this._options['type'];
            KtDebug("chart_type: " + chart_type); //xxx
            var $this = $(this);
            var data_export_anchor = "";
            if (this._enable_data_export) data_export_anchor = '<a href = "#" title="Export to CSV" id="' + this._data_export_id + '" class="k-box-icon export_link">&nbsp;</a>';

            this._disable_data_load = ('disable_data_load' in this._options && this._options['disable_data_load']);
            if (chart_type == 'simple') {
                ////// simple chart //////
                var template_str = this._get_simple_header();
                $(this._element).ktTemplate({
                    template: template_str
                });

                var params = {
                    title: this._options['title'],
                    chart_index: this._options['chart_index'],
                    bubble_text: this._options['bubble'],
                    data_export_id: this._data_export_id,
                    id: this._id,
                    height: this._height
                };

                $(this._element).ktTemplate('render', params);
                $(this._element).find(".k-box-head-info").data("esc-title", escape(this._options['title']));
                if ('has_annotation' in this._options) {
                    $(this._element).data("has_annotation", this._options['has_annotation']);
                } else {
                    $(this._element).data("has_annotation", true);
                }

            } else if (chart_type == 'dropdown') {
                var dropdown_chart_id = this._id + "_dropdown";
                var header_html_str = this._get_dropdown_header();

                KtDebug(header_html_str); //xxx
                $(this._element).append(header_html_str);
                $(this._element).find(".k-box-head-info").data("esc-title", escape(this._options['title']));

                //TODO: bind the event handler
                $("#" + dropdown_chart_id).change(function() {
                    var sel_id = $(this).prop('id');
                    var sel_v = $("#" + sel_id + " option:selected").val();
                    $(document).trigger({
                        type: 'line_chart_dropdown_selected',
                        dropdown_v: sel_v
                    }, [chart_obj._id]);
                });
            } else if (chart_type == 'tab_refactored') {
                var media_url = this._options['media_url'];
                var tab_list = this._options['chart_widget_lst'];
                var header_html_str = '<div class="k-box"><div class="k-box-head"><div class="k-box-head-info"><h1>' + this._options['title'] + '</h1><a href="#" class="help" resource_id="' + this._options['resource_id'] + '" title="' + this._options['bubble'] + '">help</a><ul class="icons"><li><a href="#"><img src="' + media_url + '/images/ico6.jpg" width="19" height="24" alt="" /></a></li><li><a href="#"><img src="' + media_url + '/images/ico3.jpg" width="19" height="24" alt="" /></a></li><li><a href="#"><img src="' + media_url + '/images/ico9.jpg" width="16" height="24" alt="" /></a></li></ul>';

                /* chart header icons */
                this.selected_chart = this.get_selected_chart_obj()
                if(this._enable_print_link) {
                    header_html_str += '<a href="#" class="k-box-icon print_link" title="Print Chart">&nbsp;</a>';
                }

                if (this._enable_data_export) {
                    header_html_str += '<a href="#" class="k-box-icon export_link" title="Export to CSV">&nbsp;</a>';
                }

                if(this._enable_advanced_link) {
                    header_html_str += '<a href="#" class="k-box-icon advanced_link" title="Advanced Graph View">&nbsp;</a>';
                }

                if (this._show_trend_option()) {
                    if ($('a.time_mode_button.active').data('time-mode') == 'daily')
                        header_html_str += '<a href="javascript:void(0)" class="k-box-icon trends" id="' + this._trend_id + '" title="Trends">&nbsp;</a>';
                    else 
                        header_html_str += '<a href="javascript:void(0)" class="k-box-icon trends disabled-trends" id="' + this._trend_id + '" title="Trendlines are currently only supported in daily time series">&nbsp;</a>';

                }

                header_html_str += '</div></div><div class="k-box-body"><ul>';

                for (var i = 0; i < tab_list.length; i++) {
                    var tabObj = tab_list[i];
                    var tabStr = tabObj['tab_str'];
                    var tabStrID = tabObj['tab_id'];
                    //var tabStrID = this._id + "_" + i + "_tab";
                    if (i == 0) {
                        header_html_str += '<li class="first"><a href="#" class="active" id="' + tabStrID + '"';
                    } else {
                        header_html_str += '<li><a href="#" id="' + tabStrID + '"';
                    }
                    header_html_str += ' sub_tab="true" chart_id="' + this._id + '" index="' + i + '"><span>' + tabStr + '</span></a>';

                    if(i != tab_list.length - 1) {
                        header_html_str += '|'; // separator
                    }

                    header_html_str += '</li>';
                }
                header_html_str += '</ul></div> </div>';
                $(this._element).append(header_html_str);

                //TODO: setup event
            }

            $(this._element).data("show_trend_option", this._show_trend_option());

            if (this._show_trend_option()) {
                var chart_obj = this;

                $("#" + this._trend_id).click(function() {
                    $("#" + chart_obj._id).trigger("trend_button_clicked");
                });
            }

            if (chart_type != 'tab_refactored') {
                this.instantiate_am_chart();
            }

            this.bind_events();
        }
    });

    AbstractAmChartHandler.prototype._send_parent_last_ajax_url_ifHasOne = function() {
        var parent_id = this._get_parent_id();
        if (parent_id != null) {
            $(document).trigger({
                type: 'push_child_last_url_info',
                last_ajax_url: this._last_ajax_get_data_url,
                tab_id: this._id
            }, [parent_id]);
        }
    };

    // possible urls:
    // singular
    // multi
    // singular tab
    // multi tab
    //doesn't cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_singular_chart_url_impl = function() {
        KtDebug("calling _get_singular_chart_url"); //xxx
        var key = 'get_singular_chart_url';
        var r = null;
        if (this._options[key] == undefined) {
            r = this._default_get_singular_chart_url();
        } else {
            r = this._options[key](this);
        }
        return r;
    };

    //does cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_singular_chart_url = function() {
        var r = this._get_singular_chart_url_impl();
        if (this._last_ajax_get_data_url == null) {
            this._last_ajax_get_data_url = r;
        }
        KtDebug(r);

        this._send_parent_last_ajax_url_ifHasOne();
        return r;
    };

    // doesn't cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_dropdown_chart_url_impl = function(dropdown_v) {
        var key = 'get_dropdown_chart_url';
        var r = null;
        if (this._options[key] == undefined) {
            r = this._default_get_dropdown_chart_url(dropdown_v);
        } else {
            r = this._options[key](this, dropdown_v);
        }
        return r;
    };

    // does cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_dropdown_chart_url = function(dropdown_v) {
        var r = this._get_dropdown_chart_url_impl(dropdown_v);

        if (this._last_ajax_get_data_url == null) {
            this._last_ajax_get_data_url = r;
        }
        return r;
    };

    // doesn't cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_multi_dropdown_chart_url_impl = function(saved_filters, dropdown_v) {
        var key = 'get_multi_dropdown_chart_url';
        var r = null;
        if (this._options[key] == undefined) {
            r = this._default_get_multi_dropdown_chart_url(saved_filters, dropdown_v);
        } else {
            r = this._options[key](this, saved_filters, dropdown_v);
        }
        return r;
    };

    // does cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_multi_dropdown_chart_url = function(saved_filters, dropdown_v) {
        var r = this._get_multi_dropdown_chart_url_impl(saved_filters, dropdown_v);
        if (this._last_ajax_get_data_url == null) {
            this._last_ajax_get_data_url = r;
        }
        return r;
    };

    // doesn't cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_multi_chart_url_impl = function(saved_filters) {
        KtDebug("calling _get_multi_chart_url"); //xxxx
        var key = 'get_multi_chart_url';
        var r = null;
        if (this._options[key] == undefined) {
            r = this._default_get_multi_chart_url(saved_filters);
        } else {
            r = this._options[key](this, saved_filters);
        }
        return r;
    };

    // does cache _last_ajax_get_data_url
    AbstractAmChartHandler.prototype._get_multi_chart_url = function(saved_filters) {
        var r = this._get_multi_chart_url_impl(saved_filters);
        if (this._last_ajax_get_data_url == null) {
            this._last_ajax_get_data_url = r;
        }
        return r;
    };

    AbstractAmChartHandler.prototype._reload_singular_chart_url = function(query_params) {
        var new_url = this._get_singular_chart_url_impl();
        new_url = this._ajax.append_query_params(new_url, query_params);
        this._reload_url_cache_helper(new_url);
    };

    AbstractAmChartHandler.prototype._reload_dropdown_chart_url = function(dropdown_v, query_params) {
        var new_url = this._get_dropdown_chart_url_impl(dropdown_v);
        new_url = this._ajax.append_query_params(new_url, query_params);
        this._reload_url_cache_helper(new_url);
    };

    AbstractAmChartHandler.prototype._reload_multi_dropdown_chart_url = function(saved_filters, dropdown_v, query_params) {
        var new_url = this._get_multi_dropdown_chart_url_impl(saved_filters, dropdown_v, query_params);
        new_url = this._ajax.append_query_params(new_url, query_params);
        this._reload_url_cache_helper(new_url);
    };

    AbstractAmChartHandler.prototype._reload_multi_chart_url = function(saved_filters, query_params) {
        var new_url = this._get_multi_chart_url_impl(saved_filters);
        new_url = this._ajax.append_query_params(new_url, query_params);
        this._reload_url_cache_helper(new_url);
    };

    // default functions are for the old ui framework. see query_conf.py
    AbstractAmChartHandler.prototype._default_get_singular_chart_url = function() {
        var url_str = this._root_url + '/ajax_get_chart_data/?chart_id=' + this._id + '&curr_url=' + this._get_curr_url();
        return url_str;
    };

    AbstractAmChartHandler.prototype._default_get_dropdown_chart_url = function(dropdown_v) {
        var url_str = this._root_url + '/ajax_get_chart_data/?chart_id=' + this._id + '&dropdown_v=' + dropdown_v + '&curr_url=' + this._get_curr_url();
        return url_str;
    };

    AbstractAmChartHandler.prototype._default_get_multi_dropdown_chart_url = function(saved_filters, dropdown_v) {
        var f_ids = saved_filters.join(",");
        var url_str = this._root_url + '/ajax_get_chart_data_multi_filter/?chart_id=' + this._id + '&dropdown_v=' + dropdown_v + '&f_ids=' + f_ids + '&curr_url=' + this._get_curr_url();
        return url_str;
    };

    /////////////////////// ChartNotPermitted ////////////////////////

    function ChartNotPermittedHandler(element, options) {
        this._element = element;
        this._options = options;
        this._chart_index = null;
    }

    ChartNotPermittedHandler.prototype = {
        _show_frame: function() {
            var show_chart_frame = true;
            if (this._options['show_frame'] != undefined && this._options['show_frame'] == false) {
                show_chart_frame = false;
            }
            return show_chart_frame;
        },

        _get_simple_header: function() {
            var text_str = '<div style="font-weight: bold; color:#666666;text-align:center; padding-top:[=half_height]">\
                        <span style="font-weight: bold; font-size: 14px; color:#333333;">You are not permitted to view this chart.</span><br />\
                        <span>Contact an admin for this account to get access.</span>\
                    </div>';

            if (this._show_frame()) {
                var template_str = '<div class="k-box"> \
                    <div class="k-box-head"> \
                        <div class="k-box-head-info"> \
                            <h1>[=title]</h1> \
                        </div> \
                    </div> \
                    <div class="k-box-body" id="so_[=id]" style="height:[=height]; position:relative;">' + text_str + '</div>\
                </div>';
            } else {
                var template_str = '<div id="so_[=id]" style="height:[=height]; position:relative;">' + text_str + '</div>';
            }
            return template_str;
        },
        _attach_header: function(template_str, params) {
            $(this._element).ktTemplate({
                template: template_str
            });
            $(this._element).ktTemplate('render', params);
        },
        init_impl: function() {
            var chart_id = $(this._element).prop('id');
            this._id = chart_id;
            this._chart_index = this._options['chart_index'];

            this._height = this._options['height'];
            //This is a hack.  Tried using display:table and display:table-cell with
            //vertical-align:middle but this wouldn't work with the border and would
            //require a hack on the width which breaks on window resize and the height
            //hack only breaks when font is resized
            this._int_height = parseInt(this._height, 10) / 2.1 + "px";

            KtDebug("chart_type: ChartNotPermitted"); //xxx
            var $this = $(this);

            var template_str = this._get_simple_header();

            var params = {
                title: this._options['title'],
                chart_index: this._options['chart_index'],
                id: this._id,
                height: this._height,
                half_height: this._int_height
            };

            this._attach_header(template_str, params);
            $(this._element).attr("not_permitted", true);
        }
    };

    function ChartNotPermitted() {
        this.handler = null;
        this._init = function() {
            this.handler = new ChartNotPermittedHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }
    /////////////////////// ChartNotPermittedOldStyle ///////////////////////

    function ChartNotPermittedOldStyleHandler(element, options) {
        this.inheritedFrom = ChartNotPermittedHandler;
        this.inheritedFrom(element, options);
    }

    ChartNotPermittedOldStyleHandler.prototype = new ChartNotPermittedHandler();

    ChartNotPermittedOldStyleHandler.prototype._attach_header = function(template_str, params) {
        $(this._element).prop('class', 'k-box');
        $(this._element).ktTemplate({
            template: template_str
        });
        $(this._element).ktTemplate('renderPrepend', params);
    };

    ChartNotPermittedOldStyleHandler.prototype._get_simple_header = function() {
        var text_str = '<div style="font-weight: bold; color:#666666;text-align:center; padding-top:[=half_height]">\
                       <span style="font-weight: bold; font-size: 14px; color:#333333;">You are not permitted to view this chart.</span><br />\
                       <span>Contact an admin for this account to get access.</span>\
                  </div>';

        if (this._show_frame()) {
            var template_str = '<div class="k-box-head"> \
                <div class="k-box-head-info"> \
                    <h1>[=title]</h1> \
                </div> \
            </div> \
            <div class="k-box-body" id="so_[=id]" style="height:[=height]; position:relative;">' + text_str + '</div>';
        } else {
            var template_str = '<div id="so_[=id]" style="height:[=height]; position:relative;">' + text_str + '</div>';
        }
        return template_str;
    };

    function ChartNotPermittedOldStyle() {
        this.handler = null;
        this._init = function() {
            this.handler = new ChartNotPermittedOldStyleHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }

    /////////////////////// AmLineChartHandler ///////////////////////

    function AmLineChartHandler(element, options) {
        this.inheritedFrom = AbstractAmChartHandler;
        this.inheritedFrom(element, options);
    }

    AmLineChartHandler.prototype = new AbstractAmChartHandler();

    AmLineChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var so = new SWFObject(media_url + "/amchart/amline/amline.swf", this._id + "_flashobj", "100%", "100%", "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/amline/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amline/amline_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    AmLineChartHandler.prototype._get_additional_simple_chart_data_str = function(xid, keyid, title, text, share_level, creator, submit_type) {
        var xml_str = "<annotations><value xid=\"" + xid + "\" keyid=\"" + keyid + "\" title=\"" + encodeURIComponent(title) + "\" share=\"" + share_level + "\" creator=\"" + encodeURIComponent(creator) + "\"";

        if (submit_type == "delete") {
            xml_str += " deleteMe=\"true\"";
        }

        xml_str += ">" + text + "</value></annotations>";
        return xml_str;
    };

    AmLineChartHandler.prototype._get_additional_simple_chart_settings_str = function() {
        var xml_str = undefined;
        xml_str = "<settings>";

        var has_y_axi_setting = (this._options['y_max_value'] != undefined || (this._options['prefix'] != '' && this._options['prefix'] != undefined) || (this._options['suffix'] != '' && this._options['suffix'] != undefined));

        if (has_y_axi_setting) {
            xml_str += "<values><y_left>";

            if (this._options['y_max_value'] != undefined) xml_str += "<max>" + this._options['y_max_value'] + "</max>";
            if (this._options['prefix'] != '' && this._options['prefix'] != undefined) xml_str += "<unit><![CDATA[" + this._options['prefix'] + "]]></unit><unit_position>left</unit_position>";
            else if (this._options['suffix'] != '' && this._options['suffix'] != undefined) xml_str += "<unit><![CDATA[" + this._options['suffix'] + "]]></unit><unit_position>right</unit_position>";
            xml_str += "</y_left></values>";
        }
        xml_str += "</settings>";
        KtDebug(xml_str);
        return xml_str;
    };

    function AmLineChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmLineChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }

    /////////////////////// AmPieChartHandler ///////////////////////

    function AmPieChartHandler(element, options) {
        this.inheritedFrom = AbstractAmChartHandler;
        this.inheritedFrom(element, options);
    }

    AmPieChartHandler.prototype = new AbstractAmChartHandler();
    //   AmPieChartHandler.prototype = AbstractAmChartHandler.prototype;
    AmPieChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var has_annotation = this._options['has_annotation'];
        var so = new SWFObject(media_url + "/amchart/ampie/ampie.swf", this._id + "_flashobj", "100%", "100%", "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/ampie/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/ampie/ampie_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    AmPieChartHandler.prototype._get_additional_simple_chart_settings_str = function() {
        return '';
    };

    function AmPieChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmPieChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }


    /////////////////////// AmColumnChartHandler ///////////////////////

    function AmColumnChartHandler(element, options) {
        this.inheritedFrom = AmLineChartHandler;
        this.inheritedFrom(element, options);
    }

    AmColumnChartHandler.prototype = new AmLineChartHandler();

    AmColumnChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var so = new SWFObject(media_url + "/amchart/amcolumn/amcolumn.swf", this._id + "_flashobj", "100%", "100%", "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/amcolumn/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amcolumn/amcolumn_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    AmColumnChartHandler.prototype._get_additional_simple_chart_settings_str = function() {
        var xml_str = "<settings>";
        var has_y_axi_setting = ((this._options['prefix'] != '' && this._options['prefix'] != undefined) || (this._options['suffix'] != '' && this._options['suffix'] != undefined));
        if (has_y_axi_setting) {
            xml_str += "<values><value>";

            if (this._options['prefix'] != '' && this._options['prefix'] != undefined) xml_str += "<unit><![CDATA[" + this._options['prefix'] + "]]></unit><unit_position>left</unit_position>";
            if (this._options['suffix'] != '' && this._options['suffix'] != undefined) xml_str += "<unit><![CDATA[" + this._options['suffix'] + "]]></unit><unit_position>right</unit_position>";
            xml_str += "</values>";
        }
        xml_str += "</settings>";

        KtDebug(xml_str); //xxx
        return xml_str;
    };

    function AmColumnChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmColumnChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }


    /////////////////////// AmRealTimeChartHandler ///////////////////////

    function AmRealTimeChartHandler(element, options) {
        this.inheritedFrom = AbstractAmChartHandler;
        this.inheritedFrom(element, options);
    }

    AmRealTimeChartHandler.prototype = new AbstractAmChartHandler();

    AmRealTimeChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var chart_style = this._options['chart_style'];
        var height = this._options['height'];

        var so = new SWFObject(media_url + "/amchart/" + chart_style + "/" + chart_style + ".swf", this._id + "_flashobj", "100%", height, "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/" + chart_style + "/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amrealtime/amrealtime_" + chart_style + "_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    AmRealTimeChartHandler.prototype.bind_events = function() {
        AmColumnChartHandler.prototype.bind_events.call(this);

        var flashobj_id = this._id + "_flashobj";
        var index = this._options['realtime_data_index'];

        $(document).bind('set_realtime_data', function(event, data) {

            try {
                document.getElementById(flashobj_id).setData(data[index]);
            } catch (err) {
                //Javascript complains about setData not existing but the call goes through anyway
            }
        });
    };

    AmRealTimeChartHandler.prototype._get_additional_simple_chart_settings_str = function() {
        var xml_str = '<settings>';

        var mini_chart = this._options['mini_chart'];

        if (mini_chart == "true") {
            xml_str += '<labels> \
                      <label lid="0"> \
                      <x></x> \
                      <y></y> \
                      <rotate></rotate> \
                      <width></width> \
                      <align>center</align> \
                      <text><![CDATA[<b>' + this._options['title'] + '</b>]]></text> \
                      </label> \
                      </labels>';

            xml_str += '<labels> \
                      <label lid="1"> \
                      <x>-5</x> \
                      <y>60%</y> \
                      <rotate>90</rotate> \
                      <width></width> \
                      <align>left</align> \
                      <text><![CDATA[' + this._options['y_label'] + ']]></text> \
                      </label> \
                      </labels>';

            xml_str += '<plot_area> \
                      <margins> \
                      <left>45</left> \
                      <top>20</top> \
                      <right>0</right> \
                      <bottom>40</bottom> \
                      </margins> \
                      </plot_area>';
        } else {
            xml_str += '<graphs> \
                      <graph gid="0"> \
                      <color>#057D9F</color> \
                      <alpha>60</alpha> \
                      <axis>left</axis> \
                      <balloon_color>#057D9F</balloon_color> \
                      <bullet_color>#057D9F</bullet_color> \
                      <fill_alpha>20</fill_alpha> \
                      <fill_color>#057D9F</fill_color> \
                      <line_width>3</line_width> \
                      <bullet>round_outlined</bullet> \
                      <bullet_size>8</bullet_size> \
                      </graph> \
                      </graphs>';

            xml_str += '<labels> \
                      <label lid="1"> \
                      <x>15</x> \
                      <y>55%</y> \
                      <rotate>90</rotate> \
                      <width></width> \
                      <align>left</align> \
                      <text><![CDATA[' + this._options['y_label'] + ']]></text> \
                      </label> \
                      </labels>';
        }

        xml_str += '</settings>';
        return xml_str;
    };

    function AmRealTimeChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmRealTimeChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }


    /////////////////////// AmBarChartHandler ///////////////////////

    function AmBarChartHandler(element, options) {
        this.inheritedFrom = AmColumnChartHandler;
        this.inheritedFrom(element, options);
    }

    AmBarChartHandler.prototype = new AmColumnChartHandler();

    AmBarChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var so = new SWFObject(media_url + "/amchart/amcolumn/amcolumn.swf", this._id + "_flashobj", "100%", "100%", "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/amcolumn/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amcolumn/ambar_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    AmBarChartHandler.prototype._get_additional_simple_chart_settings_str = function() {
        var xml_str = "<settings><column><data_labels><![CDATA[{value}" + this.suffix + "]]></data_labels><balloon_text><![CDATA[{series}: {value}" + this.suffix + "]]></balloon_text></column><values><value><unit>" + this.suffix + "</unit></value></values></settings>";
        KtDebug(xml_str); //xxx
        return xml_str;
    };

    function AmBarChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmBarChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }


    /////////////////////// AmColumnStackedChartHandler ///////////////////////

    function AmColumnStackedChartHandler(element, options) {
        this.inheritedFrom = AmColumnChartHandler;
        this.inheritedFrom(element, options);
    }

    AmColumnStackedChartHandler.prototype = new AmColumnChartHandler();
    AmColumnStackedChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var so = new SWFObject(media_url + "/amchart/amcolumn/amcolumn.swf", this._id + "_flashobj", "100%", "100%", "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/amcolumn/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amcolumn/amcolumnstacked_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    function AmColumnStackedChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmColumnStackedChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }

    /////////////////////// AmColumn100StackedChartHandler ///////////////////////

    function AmColumn100StackedChartHandler(element, options) {
        this.inheritedFrom = AmColumnChartHandler;
        this.inheritedFrom(element, options);
        this._graph_format_xml_middle = '{percents}';
    }

    AmColumn100StackedChartHandler.prototype = new AmColumnChartHandler();
    // AmColumn100StackedChartHandler.prototype._get_additional_simple_chart_settings_str = function()
    // {
    //   var xml_str = "<settings>";
    //   xml_str +="</settings>";
    //   KtDebug(xml_str); //xxx
    //   return xml_str;
    // };
    AmColumn100StackedChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = this._options['media_url'];
        var so = new SWFObject(media_url + "/amchart/amcolumn/amcolumn.swf", this._id + "_flashobj", "100%", "100%", "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/amcolumn/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amcolumn/amcolumn100stacked_settings.xml?v=2.8.1"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    function AmColumn100StackedChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new AmColumn100StackedChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }

    /////////////////////// AmConversionChartHandler ///////////////////////

    function AmConversionChartHandler(element, options) {
        this.inheritedFrom = AmColumnChartHandler;
        this.inheritedFrom(element, options);
    }
  
  
    AmConversionChartHandler.prototype = new AmColumnChartHandler();
    AmConversionChartHandler.prototype.instantiate_am_chart = function() {
        var media_url = "/static"; //KT-3572
        var width = this._options['width'];
        var height = this._options['height'];

        var so = new SWFObject(media_url + "/amchart/amcolumn/amcolumn.swf", this._id + "_flashobj", width, height, "8", "#ffffff");
        so.addVariable("path", media_url + "/amchart/amcolumn/");
        so.addVariable("chart_id", this._id + "_chart");
        so.addVariable("settings_file", escape(media_url + "/amchart/amcolumn/amconversion_settings.xml?v=2.8.2"));
        so.addParam("wmode", "opaque");
        this._so = so;
    };

    AmConversionChartHandler.prototype._get_additional_simple_chart_settings_str = function() {
        xml_str = "<settings>";
        xml_str += "</settings>";
      
        return xml_str;
    };

    function AmConversionChart() {
        this.handler = null;
        this._init = function() {
          this.handler = new AmConversionChartHandler(this.element, this.options);
          this.handler.init_impl();
          $(this.handler._element).find('div.k-box-body').removeClass('k-box-body').addClass('k-box-body-horizontal-scrollbar');
        };
    }

    /////////////////////// TabChart ///////////////////////

    function TabChartHandler(element, options) {
        this.inheritedFrom = AbstractAmChartHandler;
        this.inheritedFrom(element, options);
        this._tab_last_ajax_url_dict = {};
        this._sel_index = null;

        element.addClass('kt-tab-chart');
    }
    TabChartHandler.prototype = new AbstractAmChartHandler();

    TabChartHandler.prototype.get_selected_chart_obj = function() {
        var selected_chart_location = $("#" + this._sel_index);
        return selected_chart_location.data('chart_obj');
    };

    TabChartHandler.prototype._highlight_selected_tab = function(tab_id) {
        var index = "c";
        if (tab_id == undefined) {
            //pick the first one
            var $tab = $($("#" + this._id + " a[sub_tab='true']")[0]);
            $tab.addClass('active');
            index += $tab.prop('id');
        } else {
            var active_chart_link = $($("#" + this._id + " a[id='" + tab_id + "']")[0]);
            active_chart_link.addClass('active');
            index += tab_id;
        }

        $("#cluetip").hide();
        var show_trend_option = $("#" + index).data("show_trend_option");

        if (show_trend_option != undefined) {
            var trend_option = $("#trend_" + this._id);

            if (show_trend_option) {
                trend_option.show();
            } else {
                trend_option.hide();
            }
        }

        this._sel_index = index;
        this._last_ajax_get_data_url = this._tab_last_ajax_url_dict[index];

        this.bind_events();
    };

    TabChartHandler.prototype._unhighlight_selected_tab = function(tab_id) {
        $($("#" + this._id + " a[id='" + tab_id + "']")[0]).removeClass('active');
    };

    TabChartHandler.prototype.init_impl = function() {
        AbstractAmChartHandler.prototype.init_impl.call(this); //call parents init_impl
        var chart_widget_list = this._options['chart_widget_lst'];
        var chart_widget_list_len = chart_widget_list.length;
        for (var i = 0; i < chart_widget_list_len; i++) {
            $("#c" + this._chart_index + " div[class='k-box-body']").append($("#c" + chart_widget_list[i]['tab_id']));
        }

        //bind button
        var _this_obj = this;
        $("#" + this._id + " a[sub_tab='true']").click(

        function() {
            for (var i = 0; i < chart_widget_list_len; i++) {
                var sub_tab_index = chart_widget_list[i]['tab_id'];
                var chart_box_id = "#c" + sub_tab_index;
                var chart_box = $(chart_box_id);

                if (sub_tab_index == $(this).prop('id')) {
                    _this_obj._highlight_selected_tab(sub_tab_index);

                    /* highcharts needs to redraw on tab change */
                    chart_box.show().trigger("redraw_chart");

                    if (chart_box.data("has_annotation") == false) {
                        chart_box.parents(".k-box").parent().siblings('.annotation').hide();
                    }
                } else {
                    _this_obj._unhighlight_selected_tab(sub_tab_index);
                    chart_box.hide();
                }
            }
            return false;
        });

        this._highlight_selected_tab();
    };

    TabChartHandler.prototype.bind_events = function() {
        var chart_obj = this;
        $(document).bind('push_child_last_url_info', function(event) {
            chart_obj._tab_last_ajax_url_dict[event.tab_id] = event.last_ajax_url;
            if (chart_obj._sel_index == event.tab_id) {
                chart_obj._last_ajax_get_data_url = event.last_ajax_url;
            }
        });

        $(this._element).unbind('trend_button_clicked');
        $(this._element).bind('trend_button_clicked', function(event) {
           if ($('a.time_mode_button.active').data('time-mode') == 'daily'){
             selected_tab = chart_obj.get_selected_chart_obj();
             chart_obj._load_trend_popup(chart_obj._sel_index, selected_tab._resource_id);
           }
        });


        if (this._enable_data_export) {
            var export_obj = $("#" + this._data_export_id);

            export_obj.unbind('click');
            export_obj.click(function() {
                var selected_chart = chart_obj.get_selected_chart_obj();
                var original_url = selected_chart._ajax.current_url();

                var data_export_url = append_api_key_to_url(chart_obj._get_export_url(original_url));
                document.location = data_export_url;
                return false;
            });
            
            this._bind_export();
        }

        this._element.find('.advanced_link').click(function() { document.location = chart_obj.get_selected_chart_obj().advanced_link(); });
        this._element.find('.print_link').click(function() {
            chart_obj.get_selected_chart_obj().chart.print();
            return false;
        });
    };

    function TabChart() {
        this.handler = null;
        this._init = function() {
            this.handler = new TabChartHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }
    
    TabChartHandler.prototype._bind_export = function() {
        if (this._enable_data_export) {
            // bind data export link
            var that = this;
            this._element.find('.export_link').click(function() {
                var chart_obj = that.get_selected_chart_obj();
                var original_url = chart_obj._last_ajax_get_data_url || chart_obj._ajax.current_url(); /* old style ajax || new style ajax */
                var data_export_url = append_api_key_to_url(chart_obj._get_export_url(original_url));
                document.location = data_export_url;
                return false;
            });
        }
    };

    /////////////////////// Widget Construction ///////////////////////
    var chartNotPermitted = new ChartNotPermitted();
    $.widget("ui.ChartNotPermitted", chartNotPermitted);
    $.ui.ChartNotPermitted.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        height: '300px'
    };

    var chartNotPermittedOldStyle = new ChartNotPermittedOldStyle();
    $.widget("ui.ChartNotPermittedOldStyle", chartNotPermittedOldStyle);
    $.ui.ChartNotPermittedOldStyle.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        height: '300px'
    };

    var amLineChart = new AmLineChart();
    $.widget("ui.AmLineChart", amLineChart);
    $.ui.AmLineChart.getter = ["get_root_url"];
    $.ui.AmLineChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var amPieChart = new AmPieChart();
    $.widget("ui.AmPieChart", amPieChart);
    $.ui.AmPieChart.getter = ["get_root_url"];
    $.ui.AmPieChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var amColumnChart = new AmColumnChart();
    $.widget("ui.AmColumnChart", amColumnChart);
    $.ui.AmColumnChart.getter = ["get_root_url"];
    $.ui.AmColumnChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var amRealTimeChart = new AmRealTimeChart();
    $.widget("ui.AmRealTimeChart", amRealTimeChart);
    $.ui.AmRealTimeChart.getter = ["get_root_url"];
    $.ui.AmRealTimeChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()'
    };

    var amBarChart = new AmBarChart();
    $.widget("ui.AmBarChart", amBarChart);
    $.ui.AmBarChart.getter = ["get_root_url"];
    $.ui.AmBarChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var amColumnStackedChart = new AmColumnStackedChart();
    $.widget("ui.AmColumnStackedChart", amColumnStackedChart);
    $.ui.AmColumnStackedChart.getter = ["get_root_url"];
    $.ui.AmColumnStackedChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var amColumn100StackedChart = new AmColumn100StackedChart();
    $.widget("ui.AmColumn100StackedChart", amColumn100StackedChart);
    $.ui.AmColumn100StackedChart.getter = ["get_root_url"];
    $.ui.AmColumn100StackedChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var amConversionChart = new AmConversionChart();
    $.widget("ui.AmConversionChart", amConversionChart);
    $.ui.AmConversionChart.getter = ["get_root_url"];
    $.ui.AmConversionChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

    var tabChart = new TabChart();
    $.widget("ui.TabChart", tabChart);
    $.ui.TabChart.getter = ["get_root_url"];
    $.ui.TabChart.defaults = {
        title: 'You need to specify the TITLE attribute to am_chart()',
        bubble: 'You need to specify the BUBBLE attribute to am_chart()',
        height: '300px'
    };

})(jQuery);

function convertToDays(n, unit) {
  if (unit === "week") {
    return 7 * n;
  } else if (unit === "month") {
    return 30 * n;
  } else {
    return n;
  }
}

var ServerTime = (function() {
  /*
   * Utility object for grabbing the server time
   *
   * Polls the server every minute to update
   * its internal value for the current time
   */

  var POLL_INTERVAL = 60 * 1000;

  var _time_str;
  var _format;
  var _fetching = false;

  var fetchTime = function() {
    var dataParams = {};

    if(_format) {
      dataParams.date_format = _format;
    }

    $.ajax({
      url: KT_ENV_JS['root_url'] + '/current_time/',
      type: 'GET',
      data: dataParams,
      success: function(data, textStatus, jqXHR) {
        _time_str = data;

        setTimeout(function() {
          fetchTime();
        }, POLL_INTERVAL);
      }
    });
  };

  var startPolling = function(format) {
    _format = format;

    if(!_fetching) {
      _fetching = true;
      fetchTime();
    }
  };

  var getTime = function() {
    return _time_str;
  }

  return {
    startPolling: startPolling,
    getTime: getTime
  }
})();

function subclass(child, parent) {
  child.prototype = Object.create(parent.prototype);
  child.prototype.constructor = child;
}

/*
 * Process the elements of the dict in the order given
 */
function processDictInOrder(sortedList, dict, operation, constructKey) {
  _.each(sortedList, function(sortedElement) {
    var key = constructKey ? constructKey(sortedElement) : sortedElement;
    var value = dict[key];

    if(value) {
      operation(value, sortedElement);
      delete dict[key];
    }
  });

  // Process any remaining values in the dict
  _.each(dict, function(value) {
    operation(value);
  });
}

String.prototype.strip = function(chr) {
  /*
   * Removes leading and trailling occurrences of chr from
   * the string
   */
  var re = new RegExp('(^\\' + chr + ')|(\\' + chr + '$)', "g");
  return this.replace(re, "");
};

RegExp.escape= function(s) {
    return s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')
};

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

String.prototype.escapeHTML = function () {
    return(
       this.replace(/&/g,'&amp;').
       replace(/>/g,'&gt;').                                           
       replace(/</g,'&lt;').
       replace(/"/g,'&quot;') 
    );
};

// This funtion takes a position from the top left corner (x,y) and an element. If the position is within the element in question, this function returns true, else returns false
function is_over(x,y,$element){
    var position = $element.position(),
        position_top = position.top,
        position_left = position.left,
        element_height = $element.height(),
        element_width = $element.width();

    if( x > position_left && x < position_left + element_width && y > position_top && y < position_top + element_height){
        return true;
    }
    return false;
}


function append_api_key_to_url(url, api_key) {
	// if no api_key provided, use the KT_ENV_JS.  if no KT_ENV_JS api key provided, set to false.
	api_key = api_key || KT_ENV_JS['api_key'] || false;
	if (api_key) {
		//check for existing GET params
		var url_parts = url.split('?');
		if (url_parts.length <= 2) { // ... don't know why it'd ever be more than 2, but just in case ...
			url_parts[1] = (url_parts[1] ? url_parts[1] + '&' : '') + 'api_key=' + api_key;
			url = url_parts.join('?');
		}
	}
	return url;
}

// Cookie functions from http://www.w3schools.com/js/js_cookies.asp
function getCookie(cookieName){
  var i,x,y,ARRcookies = document.cookie.split(";");
  var cookiesLength = ARRcookies.length;
  for (i = 0; i < cookiesLength; i++){
    x = ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
    y = ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
    x = x.replace(/^\s+|\s+$/g,"");
    if (x === cookieName){
      return unescape(y);
    }
  }
}

function setCookie(cookieName, value, expiryDays){
  var expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + expiryDays);
  var cookieValue = escape(value) + ((expiryDays === null) ? "" : "; expires="+expiryDate.toUTCString());
  document.cookie = cookieName + "=" + cookieValue + " ;path=/";
}

function updateCookie(cookieName, value, expiryDays){
  setCookie(cookieName, "", -1);
  setCookie(cookieName, value, expiryDays);
}

function hexColorToRgbArray(hexColor) {
  // assumes colors are either '#rgb' or '#rrggbb'
  hexColor = hexColor.substring(1); // remove #
  
  // convert to rgb so we can add alpha and make math easier
  var splitEvery = (hexColor.length === 3) ? 1 : 2;
  var hexRgbRegex = new RegExp('[0-9a-f]{' + splitEvery + '}', 'gi');
  return $(hexColor.match(hexRgbRegex)).map(function(index, hexString) { return parseInt(hexString, 16); });
}

function generateColorGradient(startColor, endColor, numColors) {
  // requires that start/end colors be a list of [red, green, blue(, alpha)] values - if not, use the hexColorToRgbArray function above
  
  var colorInterval = $(endColor).map(function(index, colorValue) {
    return (colorValue - startColor[index]) / numColors;
  });

  var colorGradient = [];
  for (var i = 0; i < numColors; i++) {
    colorGradient.push($(colorInterval).map(function(index, colorInterval) {
      return Math.round(startColor[index] + i*colorInterval);
    }).get());
  }

  return colorGradient;
}

// adapted from http://dracoblue.net/dev/linear-least-squares-in-javascript/159/
function findLineByLeastSquares(x_y_pairs) {
  var min_x = false;
  var max_x = false;
  
  var sum_x = 0;
  var sum_y = 0;
  
  var sum_xy = 0;
  var sum_xx = 0;
  
  var count = 0;
  
  var values_length = x_y_pairs.length;
  
  /*
  * Nothing to do.
  */
  if (values_length === 0) {
    return [ 0, 0 ];
  }
  
  /*
  * Calculate the sum for each of the parts necessary.
  */
  for (var v = 0; v < values_length; v++) {
    x = x_y_pairs[v][0];
    y = x_y_pairs[v][1];
    if (min_x === false || x < min_x) { min_x = x; }
    if (max_x === false || x > max_x) { max_x = x; }
    sum_x += x;
    sum_y += y;
    sum_xx += x*x;
    sum_xy += x*y;
  }
  
  /*
  * Calculate m and b for the formular:
  * y = x * m + b
  */
  var m = (values_length*sum_xy - sum_x*sum_y) / (values_length*sum_xx - sum_x*sum_x);
  var b = (sum_y/values_length) - (m*sum_x)/values_length;
  
  /*
  * We will make the x and y result line now
  */
  return {
    'slope': m,
    'intercept': b,
    'fn': function(x) { return m*x+b; },
    'min_x': min_x,
    'max_x': max_x,
  }
}


  //from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
function createGUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
    return v.toString(16);
  });
}

// The following code is apparently a fix that would make UI selectable work for IE, though it doesn't for us. Visit the following site for more information: http://forum.jquery.com/topic/jquery-ui-sortable-and-draggable-do-not-work-in-ie9 
/*(function($){var a=$.ui.mouse.prototype._mouseMove;$.ui.mouse.prototype._mouseMove=function(b){if($.browser.msie&&document.documentMode>=9){b.button=1};a.apply(this,[b]);}}(jQuery));*/

function getParameter(paramName) {
  var searchString = window.location.search.substring(1),
  i, val, params = searchString.split("&");

  for (i=0 ; i < params.length; i++) {
    val = params[i].split("=");
    if (val[0] === paramName) {
      return decodeURIComponent(val[1]);
    }
  }
  return null;
};

//$(function(){
//  $(".submenu-toplevel a[id]").click(function(e) {
//    $(".submenu-toplevel a[id]").removeClass("active");
//    $(".submenu-toplevel").removeClass("hover")
//    var li = $(this).addClass("active").addClass("hover").parent();
//    li.toggleClass("hover");
//    e.stopImmediatePropagation();
//    return false;
//  });
//});
window.Template = (function() {
/*
   * Provides a simple interface for rendering underscore templates
   *
   * Define templates by including them somewhere in the page HTML like so:
   * 
   *  <script data-template-name="foo_bar" type="text/template">
   *    <div><%= some_variable %></div>
   *  </script>
   *
   * Important things to note: the type _must_ be text/template, and the
   * data-template-name attribute is not optional.
   *
   * Inside the javascript, use the template like so:
   *
   *  $('body').append(Template.render('foo_bar', {
   *    'some_variable' : 'Hello World',
   *  });
   */
    var templates = {};
    $(document).ready(function() {
        $('script[type="text/template"]').each(function() {
            if (!$(this).is('[data-template-name]')) {
                var first_three_lines = $(this).html().split("\n").slice(0, 3).join("\n");
                var message = '[Template] Found template with no template name. Starts with: ' + first_three_lines;
                window.console && console.warn(message);
                return;
            }
            templates[$(this).data('template-name')] = _.template($(this).html());
        });
    });

    return {
        'render': function(template_name, context) {
            if (!templates[template_name]) {
                var err = new Error();
                err.message = '[Template] No template found for name "' + template_name + '"';
                throw err;
            }
            try {
                var result = templates[template_name](context);
            } catch (err) {
                err.message = '[Template: ' + template_name + '] ' + err.message;
                throw err;
            }
            return result;
        }
    };
})();

function Pagination(data, table_id, entry_per_page_count) {
    this.data = data;
    this.table_id = table_id;
    this.entry_per_page_count = entry_per_page_count;
    this.page = 0;
    this.max_page = Math.ceil(this.data.length / this.entry_per_page_count);

    this.getData = function(page) {
        var begin_index = page * entry_per_page_count;
        var end_index = begin_index + entry_per_page_count;
        var r_data = new Array();

        end_index = Math.min(end_index, this.data.length);

        var cnt = 0;
        for (var idx = begin_index; idx < end_index; idx++, cnt++) {
            r_data[cnt] = (this.data[idx]);
        }
        return r_data;
    };

    this.getPrevData = function() {
        if (this.page > 0) {
            this.page = this.page - 1;
            return this.getData(this.page);
        }
        return null;
    };

    this.getNextData = function() {
        if (this.page < this.max_page) {
            this.page = this.page + 1;
            return this.getData(this.page);
        }
        return null;
    };

}

/*
 *   Depends:
 *	ui.core.js
 */

(function($) {


    function text_exp(exp_str) {
        this.inheritFrom = exp;
        this.inheritFrom();
        this.eval = function(data, for_index) {
            return exp_str;
        };
    }

    function cycle_exp(exp_str) {
        this.inheritFrom = exp;
        this.inheritFrom();
        this.even_text = null;
        this.odd_text = null;
        this.my_cycle_reg = /\[\[\s*cycle\s+(.*?)\s+(.*?)\s*\]\]/;

        this.code_gen = function() {
            var regex_r = this.my_cycle_reg.exec(exp_str);
            this.even_text = regex_r[1];
            this.odd_text = regex_r[2];
        };

        this.eval = function(data, for_index) {

            if (for_index % 2 == 0) {
                // even
                var r = this.even_text;
            } else {
                // odd
                var r = this.odd_text;
            }
            return r;
        };
    }

    function var_exp(exp_str) {
        this.inheritFrom = exp;
        this.inheritFrom();
        this.key_reg = /\[\=(.*?)\]/;
        this.var_ref_reg = /(.*?)\.(.*)/,

        this.code = null;
        this.code_gen = function() {
            var key_str = exp_str.match(this.key_reg)[1];
            var key_list = key_str.split(".");

            this.code = 'data';

            for (var i = 0; i < key_list.length; i++) {
                this.code += '["' + key_list[i] + '"]';
            }
            //this.code = 'data["' + key[1] + '"]';
        };

        this.eval = function(data, for_index) {
            var r = eval(this.code);
            if (r == undefined) return "";
            return r;
        };
    }

    function for_exp(exp_str) {
        this.inheritFrom = exp;
        this.inheritFrom();
        this.content_reg = /^\[\[\s*for.*?\]\](.*?)\[\[\s*endfor\s*\]\]$/;
        this.for_item_reg = /\[\[\s*for\s+(.*?)\s+in\s+(.*?)\]\].*/;

        this.code = null;
        this.code_gen = function() {
            var for_regex_r = this.for_item_reg.exec(exp_str);
            var for_item_str = for_regex_r[1].split(" ").join("");
            var for_data_str = for_regex_r[2].split(" ").join("");
            var content_str = this.content_reg.exec(exp_str)[1];

            var ex = new exp(content_str);
            ex.code_gen();
            this._children.push(ex);

            //       var r = "";
            this.code = "var r = '';" +
            //"alert(data['"+ for_data_str +"']);"+
            "var d = data['" + for_data_str + "'];" + "for(var i = 0 ; i < d.length; i++)" + "{" + "var item = d[i];" + "var param = {" + for_item_str + ":item};" + "for(var key in data)" + "{" + "param[key] = data[key];" + "}" + "var children_str = '';" + "for(var j =0 ; j < this._children.length; j++)" + "{" + "children_str += this._children[j].eval(param, i);" + "}" + "r += children_str;" + "}" + "r;";

        };

        this.eval = function(data, for_index) {
            var r = eval(this.code);
            return r;
        };
    }

    function exp(exp_str) {
        //     this.token_reg = /\[\[\s*for\s+.*?\[\[endfor\]\]|\[\=.*?\]/g,
        //     this.token_reg = /\[\[\s*for\s+.*?\]\]|\[\[\s*endfor\s*\]\]|\[\=.*?\]/g,
        //     this.for_reg = /\[\[\s*for\s+.*?\[\[endfor\]\]/,
        this.token_reg = /\[\=.*?\]|\[\[\s*for\s+.*?\]\]|\[\[\s*endfor\s*\]\]|\[\[\s*cycle\s+.*?\]\]|[^\[\]]+/g, this.for_reg = /\[\[\s*for\s+.*?\]\]/, this.end_for_reg = /\[\[\s*endfor\s*\]\]/, this.var_reg = /\[\=.*?\]/, this.cycle_reg = /\[\[\s*cycle\s+.*?\s*\]\]/,
        //     this.token_reg = new RegExp("\[\[\s*for\s+.*?\[\[endfor\]\]|\[\=.*?\]", "g");
        //     this.for_reg = new RegExp("\[\[\s*for\s+.*?\[\[endfor\]\]", "g");
        //     this.var_reg = new RegExp("\[\=.*?\]", "g");
        this._exp_str = exp_str; //for debugging
        this._children = [];

        this.code_gen = function() {

            var token_list = exp_str.match(this.token_reg);
            var begin_idx, end_idx = 0;
            for (var i = 0; i < token_list.length; i++) {
                if (this.for_reg.test(token_list[i])) {
                    //need to find endfor.
                    var counter = 1;
                    var for_block_str = token_list[i];
                    for (i += 1; i < token_list.length; i++) {
                        var end_for_candidate_token = token_list[i];
                        if (this.for_reg.test(end_for_candidate_token)) {
                            counter++;
                        } else if (this.end_for_reg.test(end_for_candidate_token)) {
                            counter--;
                        }
                        for_block_str += end_for_candidate_token;

                        if (counter == 0) {
                            var f_exp = new for_exp(for_block_str);
                            f_exp.code_gen();
                            this._children.push(f_exp);
                            break;
                        }
                    } // for
                } else if (this.var_reg.test(token_list[i])) {
                    var v_exp = new var_exp(token_list[i]);
                    v_exp.code_gen();
                    this._children.push(v_exp);
                } else if (this.cycle_reg.test(token_list[i])) {
                    var c_exp = new cycle_exp(token_list[i]);
                    c_exp.code_gen();
                    this._children.push(c_exp);
                } else {
                    //plain text
                    var t_exp = new text_exp(token_list[i]);
                    this._children.push(t_exp);
                }

            } // for
        };

        this.eval = function(data, for_index) {
            var r = "";
            for (var i = 0; i < this._children.length; i++) {
                r += this._children[i].eval(data, for_index);
            }
            return r;
        };
    };

    var KtTemplate = {

        root_exp: null,

        _init: function() {
            var e = new exp(this.options['template']);
            e.code_gen();
            this.root_exp = e;
        },

        render: function(params) {
            var r = this.root_exp.eval(params);
            $(this.element).append(r);
            $(this.element).trigger('render_complete', params);
        },

        renderPrepend: function(params) {
            var r = this.root_exp.eval(params);
            $(this.element).prepend(r);
        },

        clear: function(params) {
            $(this.element).empty();
        }

    };



    $.widget("kt.ktTemplate", KtTemplate);

})(jQuery);

/*
 *   Depends:
 *	ui.core.js
 */

(function($) {
  window.KtTableHandler = function(element, options) {
    this.element = element;
    this.options = options;
    this.category = undefined;
    this.tab = undefined;
    this.page = undefined;
    this.table_id = undefined;
    this.root_url = undefined;
    this.data = undefined;
    this.sort_dict = {}; // true means ascending; false means descending.
    this.type_dict = {}; // int, float, or string
    this.prefix_dict = {};
    this.suffix_dict = {};
    this.sparkline_dict = {};
    this.DATA_LENGTH_LIMIT = 3000;
  };

  KtTableHandler.prototype = {
    _trigger_load_table_data: function() {
      var is_a_member_of_a_subtab_chart = this._is_a_member_of_a_subtab_chart();
      if (is_a_member_of_a_subtab_chart) {
        var table_id = '#t' + this.table_id.split("_")[0];
        var table_widget_ids = $(table_id).ktSubTabTableRefactored("option", "table_widget_ids");
        var target_table_ids = [];
        for (var i = 0; i < table_widget_ids.length; i++) {
          $(document).trigger('load_all_table_data', [table_widget_ids[i]['index']]);
        }
      } else {
        $(document).trigger('load_all_table_data', [this.table_id]);
      }
    },

    _delete_row_handler: function(dom) {
      var arg = this._delete_row_handler_get_ajax_args(dom);
      var _this_obj = this;
      ktAjaxWrapper({
        type: "GET",
        url: "/dashboard/filter/ajax_create_filter/",
        data: arg,
        success: function(data) {
          if (data.exists) {
            var str = "A filter for this row already exists. Enable it?";
            Boxy.confirm(str, function() {
              ktAjaxWrapper({
                type: "GET",
                url: "/dashboard/filter/ajax_toggle_filter_without_id/",
                data: arg,
                success: function(msg) {
                  // If this chart is embedded in a subtype table, we will need to
                  // figure out the other tab charts and update those as well.
                  // Otherwise, update this chart only.
                  _this_obj._trigger_load_table_data();
                }
              });
            });
          } else {
            // If this chart is embedded in a subtype table, we will need to
            // figure out the other tab charts and update those as well.
            // Otherwise, update this chart only.
            _this_obj._trigger_load_table_data();
          }
        }
      }); // $.ajax
    },

    _delete_row_handler_get_ajax_args: function(dom) {
      var this_row = $(dom).parent().parent();
      var channel_type = $(dom).attr('channel_type');
      var arg = {
        channel_type: channel_type
      };
      arg['st1'] = $("td[coln_id=subtype1]", this_row).text(); // category
      arg['st2'] = $("td[coln_id=subtype2]", this_row).text(); // campaign
      arg['st3'] = $("td[coln_id=subtype3]", this_row).text(); // content
      return arg;
    },

    _bind_table_events: function() {
      var $remove_btns = $("#" + this.table_id + "_table a.remove_btn");
      var this_obj = this;
      if ($remove_btns.length > 0) {
        $remove_btns.click(function(event) {
          this_obj._delete_row_handler(event.target);
        });
      }
    },

    _is_a_member_of_a_subtab_chart: function() {
      var tmp_lst = this.table_id.split("_");
      var size = tmp_lst.length;
      if (tmp_lst[size - 1] == 'tab') {
        return true;
      }
      return false;
    },

    _get_table_j: function() {
      var my_id = $(this.element).prop('id');
      return $("#" + my_id + "_table");
    },

    _get_table_header: function(show_frame) {
      if (show_frame == true) {
        var template_str = "<div id='[=table_id]_secondary_data' class='k-box-secondary'></div>\
          <div class='k-box'> \
          <div class='k-box-head'> \
          <div class='k-box-head-info'>\
          <h1>[=title]</h1> \
          <a href='#' index='[=index]' class='help' title='[=bubble_text]'>help</a> \
          <a href='#' title='Export to CSV' class='k-box-icon export_link' id='[=data_export_id]'>&nbsp;</a>\
        </div> \
        </div>\
          <div class='k-box-body'> \
          <table class='k-table viral' id='[=table_id]_table' \
        cellpadding=\"0\" cellspacing=\"0\" border=\"0\"  id=\"data\" style=\"width: 100%\"> \
          <tr class=\"head-tr left-border\"> \
          <td decimal='[=first_coln.coln_decimal]' class='lit first-coln [=first_coln.coln_type] [=first_coln.coln_class]' coln_id='[=first_coln.coln_id]'><small>[=first_coln.coln_name]</small></td>\
        [[for coln in coln_list]] \
          <td decimal='[=coln.coln_decimal]' class='table-right lit [=coln.coln_type] [=coln.coln_class]' coln_id='[=coln.coln_id]'><small>[=coln.coln_name]</small></td>\
        [[endfor]]\
        </tr>\
        </table>\
        </div>\
        </div>";
      } else {
        var template_str = "<div id='[=table_id]_secondary_data' class='tab_secondary_info' style='display:none;'></div>\
          <div> \
          <table class='k-table' id='[=table_id]_table' \
        cellpadding=\"0\" cellspacing=\"0\" border=\"0\"  id=\"data\" style=\"width: 100%\"> \
          <tr class=\"head-tr left-border\"> \
          <td decimal='[=first_coln.coln_decimal]' class='lit first-coln [=first_coln.coln_type] [=first_coln.coln_class]' coln_id='[=first_coln.coln_id]'><small>[=first_coln.coln_name]</small></td>\
        [[for coln in coln_list]] \
          <td decimal='[=coln.coln_decimal]' class='table-right lit [=coln.coln_type] [=coln.coln_class]' coln_id='[=coln.coln_id]'><small>[=coln.coln_name]</small></td>\
        [[endfor]]\
        </tr>\
        </table>\
        </div>";
      }
      return template_str;
    },

    _construct_coln_header: function(show_frame) {
      var my_id = $(this.element).prop('id');
      var template_str = null;
      var data_export_id = "data_export_" + this.table_id;

      var coln_count = this.options['coln'].length;
      var first_coln = undefined;
      var remainder_coln_array = [];
      var colns_from_option = this.options['coln'];
      var idx = 0;
      for (var i = 0; i < coln_count; i++) {
        if (i == 0) first_coln = colns_from_option[i];
        else {
          remainder_coln_array[idx] = colns_from_option[i];
          idx++;
        }
      }

      var params = {
        title: this.options['title'],
        my_id: my_id,
        first_coln: first_coln,
        coln_list: remainder_coln_array,
        table_id: this.table_id,
        bubble_text: this.options['bubble_text'],
        index: this.options['index'],
        data_export_id: data_export_id
      };

      if (this.options['subtab'] != undefined) {
        params['subtab'] = this.options['subtab'];
      }


      template_str = this._get_table_header(show_frame);

      if (show_frame) params['data_export_id'] = data_export_id;

      $(this.element).ktTemplate({
        template: template_str
      });

      $(this.element).ktTemplate('render', params);
      $(this.element).find(".k-box-head-info").data("esc-title", escape(this.options['title']));
      
      this._build_load_table_notification();
      //setup sort_dict
      var coln_list = this.options['coln'];
      var len = coln_list.length;
      for (var i = 0; i < len; i++) {
        var coln = coln_list[i];
        this.sort_dict[coln.coln_id] = true;
        this.type_dict[coln.coln_id] = coln.coln_type;
        this.prefix_dict[coln.coln_id] = coln.coln_prefix;
        this.suffix_dict[coln.coln_id] = coln.coln_suffix;
        this.sparkline_dict[coln.coln_id] = coln.coln_sparkline;
      }
    },

    _setup_rows_template: function(rows) {
      $("#" + this.table_id + "_table").ktTemplate({
        template: '[[for item in list]]' + rows + '[[endfor]]'
      });
    },

    _setup_sorting: function() {
      // make title headers clickable
      var _this_obj = this;
      $(this._gen_table_id() + " td.lit").click(

        function() {
          var id = $(this).attr('coln_id');
          _this_obj._sort(id, _this_obj.data);
          _this_obj._bind_table_events();
        });
    },

    _gen_table_id: function() {
      return "#" + this.table_id + "_table";
    },

    _clear_content: function() {
      var rows = $(this._gen_table_id()).children().children();
      var len = rows.length;

      // purposedly skip the title row
      for (var i = 1; i < len; i++) {
        $(rows[i]).remove();
      }

    },

    _dollarize: function(value) {
      if (value != "N/A" && value != "--") {
        return KT_ENV_JS.currency + value;
      }
      return value;
    },

    _seconds_to_hms: function(secs) {
      if (secs != "N/A" && secs != "--") {
        var remaining_secs = Math.floor(secs);
        if (remaining_secs == 0) return "00:00:00";
        var hr = Math.floor(remaining_secs / 3600);
        remaining_secs -= hr * 3600;
        hr += "";
        if (hr.length == 1) hr = "0" + hr;

        var min = Math.floor(remaining_secs / 60);
        remaining_secs -= min * 60;
        min += "";
        if (min.length == 1) min = "0" + min;

        var sec = remaining_secs;
        sec += "";
        if (sec.length == 1) sec = "0" + sec;

        var r = hr + ":" + min + ":" + sec;
        return r;
      } else {
        return secs;
      }
    },

    _sort_comp_ascending_float: function(a, b, coln_id) {
      var a_v = parseFloat(a[coln_id]);
      var b_v = parseFloat(b[coln_id]);
      if (isNaN(a_v) && isNaN(b_v)) return 0;
      if (isNaN(a_v)) return -1 - b_v;
      if (isNaN(b_v)) return a_v - -1;
      return a_v - b_v;
    },

    _sort_comp_descending_float: function(a, b, coln_id) {
      var a_v = parseFloat(a[coln_id]);
      var b_v = parseFloat(b[coln_id]);
      if (isNaN(b_v) && isNaN(a_v)) return 0;
      if (isNaN(b_v)) return -1 - a_v;
      if (isNaN(a_v)) return b_v - (-1);
      return b_v - a_v;
    },

    _format_data: function(data) {
      var self = this;
      var row_script_handler = {};
      return $.map($.extend(true, [],data), function(row, i) {
        $.each(row, function(key, val) {
          if(!row_script_handler[key]) {
            var type = self.type_dict[key];
            if(!type) {
              row_script_handler[key] = "void(0)";
              return;
            }
            var prefix = self.prefix_dict[key];
            var suffix = self.suffix_dict[key];
            var script_str = [];
            if (typeof(row[key]) === "number") {
              script_str.push("val = parseFloat(val);");
              type == "cent" && script_str.push("val = val/100.0;");
              type == "percentage" && script_str.push("val = val*100.0;");
              // // format the decimal places first
              var decimal_places_str = $(self._gen_table_id() + " td[coln_id='" + key + "']").attr('decimal');
              decimal_places_str && script_str.push("val = val.toFixed(" + parseInt(decimal_places_str) + ");");
              // don't add commas to seconds; otherwise, _seconds_to_hms will break
              type != 'time' && script_str.push("val = self.num_formatter.comma_format(val);");
            } else {
              script_str.push("val;");
            }
            
            switch(type) {
            case "percentage":
              script_str.push("val+='%';");
              break;
            case "dollar":
            case "cent":
              script_str.push("val = self._dollarize(val);");
              break;
            case "time":
              script_str.push("val = self._seconds_to_hms(val);");
              break;
            }
            
            prefix && script_str.push("val='" + prefix + "' + val;");
            suffix && script_str.push("val+='" + suffix + "';");
            row_script_handler[key] = script_str.join("");
          }
          row_script_handler[key] != "void(0)" && (row[key] = eval(row_script_handler[key]));
        });
        return $.isArray(row) ? [row] : row;
      });
    },

    _sort_impl: function(coln_id, data, rollup_key) {
      var this_td = $(this._gen_table_id() + " td[coln_id=" + coln_id + "]");
      var this_obj = this;
      var ascending = this.sort_dict[coln_id];
      var type = this.type_dict[coln_id];
      var og_height = this_td.height();
      if (ascending == true) {
        this_td.children("small").removeClass('sort_ascending').addClass('sort_ascending');
        // clear all the other columns
        this_td.siblings().children("small").removeClass('sort_descending').removeClass('sort_ascending');
      } else {
        this_td.children("small").removeClass('sort_ascending').addClass('sort_descending');
        // clear all the other columns
        this_td.siblings().children("small").removeClass('sort_descending').removeClass('sort_ascending');
      }
      this_td.height(og_height);

      if ($.isFunction(data.sort)) {
        if (type == "int") {
          if (ascending == true) {
            data.sort(function(a, b) {
              var a_v = parseInt(a[coln_id]);
              var b_v = parseInt(b[coln_id]);
              if (isNaN(a_v)) return -1;
              if (isNaN(b_v)) return a_v;
              return a_v - b_v;
            });
          } else {
            data.sort(function(a, b) {
              var a_v = parseInt(a[coln_id]);
              var b_v = parseInt(b[coln_id]);
              if (isNaN(b_v)) return -1;
              if (isNaN(a_v)) return b_v;
              return b_v - a_v;
            });
          }
        } else if (type == "float" || type == "percentage" || type == "dollar" || type == "cent") {
          if (ascending == true) {

            data.sort(function(a, b) {

              return this_obj._sort_comp_ascending_float(a, b, coln_id);
            });
          } else {

            data.sort(function(a, b) {

              return this_obj._sort_comp_descending_float(a, b, coln_id);
            });
          }
        } else if (type == "time") {
          if (ascending == true) {
            data.sort(function(a, b) {
              return this_obj._sort_comp_ascending_float(a, b, coln_id);
            });
          } else {
            data.sort(function(a, b) {
              return this_obj._sort_comp_descending_float(a, b, coln_id);
            });
          }
        } else if (type == "string" || type == "rollup") {
          if (rollup_key) {
            coln_id = rollup_key;
          }

          if (ascending == true) {
            data.sort(function(a, b) {
              if (a[coln_id] > b[coln_id]) return 1;
              else return -1;
            });
          } else {
            data.sort(function(a, b) {
              if (b[coln_id] > a[coln_id]) return 1;
              else return -1;
            });
          }
        }
      }
    },

    _sort: function(coln_id, data, repopulate) {
      //do some bookkeeping first
      this.sort_dict[coln_id] = !this.sort_dict[coln_id];
      this._sort_impl(coln_id, data);
      if (data.length == 0) {
        // If there is no data don't need to clear data
        return;
      }

      // repopulate data
      if (repopulate == null || repopulate) {
        this._clear_content();
        var formated_data = this._format_data(data);

        $(this._gen_table_id()).ktTemplate('render', {
          list: formated_data
        });
      }
    },

    _mark_sorted_cells: function() {

      var all_cells = $(this._gen_table_id() + " td");

      //Clear all other cells
      all_cells.removeClass("sorted");

      //Find sorted column
      var sorted_header = $(this._gen_table_id() + " .sort_descending, .sort_ascending");

      if (sorted_header.length > 0) {
        var sorted_cell = sorted_header.parent();
        var idx = sorted_cell.index();

        //Mark each cell in the column as sorted
        all_cells.filter(":nth-child(" + (idx + 1) + ")").addClass("sorted");
      }
    },
    // INTERNET EXPLORER (IE) DOES NOT LIKE IT WHEN COLSPAN IS SET TO ZERO
    // IF CONDITION TO CHECK IF ZERO IS REQURED
    // WRONG --> cell.attr("colspan", 0) <-- WRONG
    _build_empty_table_notification: function() {
      this._build_table_notification($('<td>There is no data to display</td>'), '');
    },

    _build_load_table_notification: function() {
      var img = $("<img src=\"" + kt_media_url + "/images/indicator.gif\"/>");
      img.css("padding", "5px");
      var cell = $("<td>Loading Data </td>").append(img);

      this._build_table_notification(cell, 'loading-row');      
    },

    _build_large_data_notification: function() {
      this._build_table_notification($('<td>We have detected a large volume of data and are unable to render it at this time. Please <a href="http://support.kontagent.com/requests/new/">Contact Support</a> for assistance with this issue.</td>'), '');
    },
    
    _build_table_notification: function(cell, row_class) {
      cell.css("text-align", "center").css("padding", "8px");

      var c_length = this.options['coln'].length;

      if (c_length == 0) {
       cell.attr("colspan", "1");
      } else {
       cell.attr("colspan", c_length);
      }

      var row = $('<tr></tr>')
        .addClass(row_class)
        .append(cell);

      $("#" + this.table_id + "_table").find("tbody").append(row);
     },

    /*
     * This function is resposible for rendering the st1 level data.
     */
    _ajax_load_all_table_data_handler: function(data) {
      this._clear_content();

      if (data.length == 0) {
        this._build_empty_table_notification();
        return;
      }

      if (data.length > this.DATA_LENGTH_LIMIT) {
        this._build_large_data_notification();
        return;
      }

      this.data = data;

      var to_be_rendered_data = [];
      for (var i in this.data) {
        var d = this.data[i];
        if (d['deleted'] == undefined || d['deleted'] == false) {
          d['row_id'] = i;
          to_be_rendered_data.push(d);
        }
      }
      
      this._perform_initial_sorting(this);
      
      $("#" + this.table_id + "_table").ktTemplate('render', {
        //list: this._format_data(data)
        list: this._format_data(to_be_rendered_data)
      });

      this._bind_table_events();
    },

    _export_handler: function() {
      var data_export_url = np_get_table_export_url(this, this.category, this.tab, this.page, this.table_id);
      document.location = data_export_url;
      return false;
    },

    _load_all_table_data_handler: function() {
      var _this_obj = this;
      _this_obj._clear_content(); //clear out the old content.
      this._build_load_table_notification();
      ktAjaxWrapper({
        type: 'GET',
        traditional: true,
        url: np_get_table_url(_this_obj, _this_obj.category, _this_obj.tab, _this_obj.page, _this_obj.table_id),
        dataType: 'json',
        success: function(data, textStatus) {
          if (data.data != undefined) {
            data = data.data;
          } else {
            if (data == undefined) {
              data = [];
            }
          }
          
          if (data['__primary_data__'] != undefined) {
            _this_obj._ajax_load_all_table_data_handler(data['__primary_data__']);

            if (data['__secondary_data__'] != undefined) {
              $("#" + _this_obj.table_id + "_secondary_data").text(data['__secondary_data__']);
              $("#" + _this_obj.table_id + "_secondary_data").css("display", "block");
            } else {
              $("#" + _this_obj.table_id + "_secondary_data").css("display", "none");
            }
            $(document).trigger("onload_all_table_data", [_this_obj.table_id]);
          } else {
            $("#" + _this_obj.table_id + "_secondary_data").css("display", "none");
            _this_obj._ajax_load_all_table_data_handler(data);
            np_run_post_table_load(_this_obj, _this_obj.table_id);
          }

        },
        //sucess
        error: function(xhr) {
          var response;
          try {
            response = JSON.parse(xhr.responseText);
          } catch(e) {
            console && console.error("An error occurred while parsing error response.", e);
            response = {};
          }
          $('#' + _this_obj.table_id + "_table .loading-row td").html(response.errorMessage ? response.errorMessage : "No data available");                  
        }
      });
    },

    _perform_initial_sorting: function(table) {

      //Perform an initial sorting once the data has been loaded
      var initial_sorting = table.initial_sorting;
      if (initial_sorting && table.data) {
        table.sort_dict[initial_sorting] = false;
        table._sort(initial_sorting, table.data, false);
      }

    },

    add_sparklines: function(selector) {
      var max = 1;
      var pos = 0;
      var len = $(selector + " .sparkline_cell").length;

      function iteration() {
        var j = Math.min(len - pos, max);
        for (var i = 0; i < j; i++) {
          $($(selector + " .sparkline_cell")[pos]).show();
          if ($($(selector + " .sparkline_cell")[pos]).children("canvas").length == 0) {
            var js_str = "[" + $($(selector + " .sparkline_cell")[pos]).attr("data") + "]";
            var data_lst = eval(js_str);

            $($(selector + " .sparkline_cell")[pos]).sparkline(data_lst, {
              lineColor: '#057D9F',
              width: '50px',
              lineWidth: '2',
              spotColor: false,
              spotRadius: '0',
              fillColor: false
            });
          }
          pos++;
        }

        if (pos < len) {
          setTimeout(iteration, 60);
        } else {
        }
      }
      iteration();

    },

    init_impl: function() {
      this.category = this.options['category'];
      this.tab = this.options['tab'];
      this.page = this.options['page'];
      this.table_id = this.options['index'];
      this.root_url = this.options['root_url'];
      this.num_formatter = new NumFormatter();

      if (this.options['no_table_frame']) if (this.options['no_table_frame'] == true) this._construct_coln_header(false);
      else this._construct_coln_header(true);
      else this._construct_coln_header(true);

      this._setup_rows_template(this.options['rows']);


      var category = this.category;
      var tab = this.tab;
      var page = this.page;
      var table_id = this.table_id;
      var root_url = this.root_url;

      var _this_obj = this;

      // make title headers clickable
      this._setup_sorting();

      //Things we want to handle have data has been rendered
      $(this.element).bind('render_complete', function(event, params) {
        //Load sparklines
        var row_selector = "";
        if ('subtype2' in params) {
          row_selector = " tr.st3_row";
        } else if ('subtype1' in params) {
          row_selector = " tr.st2_row";
        }

        _this_obj.add_sparklines(_this_obj._gen_table_id() + row_selector);
        _this_obj._mark_sorted_cells();
      });

      $(document).bind('load_all_table_data', function(event, msg) {
        if (msg == undefined || msg == _this_obj.table_id) {
          _this_obj._load_all_table_data_handler();
        } // if(msg == ...
      });

      // bind data export link
      var data_export_id = "data_export_" + this.table_id;
      $("#" + data_export_id).click(

        function() {
          _this_obj._export_handler();
          return false;
        });

      // jQuery(this.element).data('kt_table_handler', this);
    }


  };


  function KtTable() {
    this.handler = null;
  }

  KtTable.prototype = {
    _init: function() {
      this.handler = new KtTableHandler(this.element, this.options);
      this.handler.init_impl();
    },
    get_handler: function() {
      return this.handler;
    }
  };

  ///////////////////// KtNotPermittedTable ////////////////////////

  function KtNotPermittedTableHandler(element, options) {
    this.inheritedFrom = KtTableHandler;
    this.inheritedFrom(element, options);
  };

  KtNotPermittedTableHandler.prototype = new KtTableHandler();

  KtNotPermittedTableHandler.prototype._construct_coln_header = function(show_frame) {
    var my_id = $(this.element).prop('id');
    var template_str = null;

    var coln_count = this.options['coln'].length;
    var first_coln = undefined;
    var remainder_coln_array = [];
    var colns_from_option = this.options['coln'];
    var idx = 0;
    for (var i = 0; i < coln_count; i++) {
      if (i == 0) first_coln = colns_from_option[i];
      else {
        remainder_coln_array[idx] = colns_from_option[i];
        idx++;
      }
    }

    var params = {
      title: this.options['title'],
      my_id: my_id,
      first_coln: first_coln,
      coln_list: remainder_coln_array,
      table_id: this.table_id,
      index: this.options['index']
    };


    if (this.options['subtab'] != undefined) {
      params['subtab'] = this.options['subtab'];
    }

    template_str = this._get_table_header(show_frame);
    $(this.element).ktTemplate({
      template: template_str
    });

    $(this.element).ktTemplate('render', params);

  };

  KtNotPermittedTableHandler.prototype._export_handler = function() {
    return false;
  };

  KtNotPermittedTableHandler.prototype._load_all_table_data_handler = function() {
    $("#" + this.table_id + "_table").append(this.row_str);
  };

  KtNotPermittedTableHandler.prototype.init_impl = function() {
    this.category = this.options['category'];
    this.tab = this.options['tab'];
    this.page = this.options['page'];
    this.table_id = this.options['index'];
    this.row_str = this.options['rows'];

    if (this.options['no_table_frame']) if (this.options['no_table_frame'] == true) this._construct_coln_header(false);
    else this._construct_coln_header(true);
    else this._construct_coln_header(true);

    var category = this.category;
    var tab = this.tab;
    var page = this.page;
    var table_id = this.table_id;
    var root_url = this.root_url;

    var _this_obj = this;

    $(document).bind('load_all_table_data', function(event, msg) {
      if (msg == undefined || msg == _this_obj.table_id) {
        _this_obj._load_all_table_data_handler();
      }
    });
    $(this.element).attr("not_permitted", true);
  };


  function KtNotPermittedTable() {
    this.inheritedFrom = KtTable;
  }

  KtNotPermittedTable.prototype = new KtTable();
  KtNotPermittedTable.prototype._init = function() {
    this.handler = new KtNotPermittedTableHandler(this.element, this.options);
    this.handler.init_impl();
  };

  //////////////////////// KtSt1St2Table ///////////////////////////

  function KtSt1St2TableHandler(element, options) {
    this.inheritedFrom = KtTableHandler;
    this.inheritedFrom(element, options);
    this.row_click_state = {}; //true: expanded false: folded
    this.rows_expanded = {
      'st2': 0,
      'st3': 0
    }; //Keep track of how many rows expanded at each level
    this.initial_sorting = 'subtype1';
    this.st2_data = {};
    this.st3_data = {};
    this.total_st2_st3_ajax_reload_calls = 0;
    this.st2_st3_ajax_reload_calls_returned_so_far = 0;
  };

  KtSt1St2TableHandler.prototype = new KtTableHandler();
  KtSt1St2TableHandler.prototype.init_impl = function() {
    // call parent's method
    KtTableHandler.prototype.init_impl.call(this);
    var _this_obj = this;
    $(document).bind('toggle_st2st3', function(event, table_id, st1, st2, st3) {
      _this_obj._toggle_or_removefilter_st2st3_handler(event, table_id, st1, st2, st3, false);
    });
    $(document).bind('delete_st2st3', function(event, table_id, st1, st2, st3) {
      _this_obj._toggle_or_removefilter_st2st3_handler(event, table_id, st1, st2, st3, true);
    });

    $(document).bind("repopulate_st2_st3_entries", function(event, table_id, render_data) {
      if (table_id == _this_obj.table_id) {
        KtTableHandler.prototype._ajax_load_all_table_data_handler.call(_this_obj, render_data);
        _this_obj._repopulate_after_bind_table_events(render_data);
      }
    });
  };

  // if force_delete is false, toggles.
  // if force_delete is true, remove it for good.
  KtSt1St2TableHandler.prototype._toggle_or_removefilter_st2st3_handler = function(event, table_id, st1, st2, st3, force_delete) {
    if (this.table_id == table_id) {
      if (st2 != "*" && st3 == "*" && this.st2_data[st1] != undefined) {
        var st2_data_lst = this.st2_data[st1];
        var len = st2_data_lst.length;
        for (var i = 0; i < len; i++) {
          if (st2_data_lst[i]['subtype2'] == st2) {
            if (force_delete) st2_data_lst[i]['deleted'] = false;
            else st2_data_lst[i]['deleted'] = !st2_data_lst[i]['deleted'];
            this._populate_cached_st2_row(st1);
            break;
          }
        } // for
      } else if (st2 != "*" && st3 != "*" && this.st3_data[st1] != undefined && this.st3_data[st1][st2] != undefined) {
        // if st3 data under st2 have been duplicated.
        var st3_data_lst = this.st3_data[st1][st2];
        var len = st3_data_lst.length;
        for (var i = 0; i < len; i++) {
          if (st3_data_lst[i]['subtype3'] == st3) {
            if (force_delete) st3_data_lst[i]['deleted'] = false;
            else st3_data_lst[i]['deleted'] = !st3_data_lst[i]['deleted'];
            this._populate_cached_st3_row(st1, st2);
          }
          break;
        } // for
      }
    }
  };

  KtSt1St2TableHandler.prototype._sort = function(coln_id, data, repopulate) {
    // sort st1 level data
    KtTableHandler.prototype._sort.call(this, coln_id, data, repopulate);

    // sort st2 level data
    var st1_key = null;
    for (st1_key in this.st2_data) {
      this._sort_impl(coln_id, this.st2_data[st1_key], "subtype2");
    }
    // sort st3 level data
    for (st1_key in this.st3_data) {
      for (var st2_key in this.st3_data[st1_key]) {
        this._sort_impl(coln_id, this.st3_data[st1_key][st2_key], "subtype3");
      }
    }
    //this._bind_table_events();
    this._repopulate_after_bind_table_events(data);
  };

  KtSt1St2TableHandler.prototype._repopulate_after_bind_table_events = function(data) {
    this._populate_all_cached_st2_rows();
    this._populate_all_cached_st3_rows();
    this._show_or_hide_all();
    this._get_rid_of_st1_arrows(data);
    for (st1_key in this.st2_data) {
      this._get_rid_of_st2_arrows(this.st2_data[st1_key], st1_key);
    }
  };

  KtSt1St2TableHandler.prototype._get_rid_of_arrows_helper = function(img_lst, data) {
    var len = data.length;
    // purge deleted data
    var d = [];
    for (var i = 0; i < len; i++) {
      if (data[i]['deleted'] == undefined || data[i]['deleted'] == false) {
        d.push(data[i]);
      }
    } // for
    len = d.length;
    for (i = 0; i < len; i++) {
      if (d[i]['expandable'] == false) {
        $(img_lst[i]).css('visibility', 'hidden');
        $(img_lst[i]).parent().parent().css('cursor', 'default');
      }
    }
  };

  KtSt1St2TableHandler.prototype._get_rid_of_st1_arrows = function(data) {
    var img_lst = $(this._gen_table_id() + " tr.st1_row img.plus");
    this._get_rid_of_arrows_helper(img_lst, data);
  };

  KtSt1St2TableHandler.prototype._get_rid_of_st2_arrows = function(data, st1_key) {
    var img_lst = $(this._gen_table_id() + " tr.st2_row[subtype1=" + st1_key + "] img.plus");
    this._get_rid_of_arrows_helper(img_lst, data);
  };

  KtSt1St2TableHandler.prototype._ajax_load_all_table_data_handler = function(data) {
    var this_obj = this;

    var num_of_ajax_calls = 0;
    $.each(this.st2_data, function(k, v) {
      num_of_ajax_calls++;
    });
    $.each(this.st3_data, function(subtype1, item) {
      $.each(item, function(subtype2, v3) {
        num_of_ajax_calls++;
      });
    });

    this_obj.total_st2_st3_ajax_reload_calls = num_of_ajax_calls;
    this_obj.st2_st3_ajax_reload_calls_returned_so_far = 0;
    if (num_of_ajax_calls == 0) {
      KtTableHandler.prototype._ajax_load_all_table_data_handler.call(this, data);
    } else {
      $.each(this.st2_data, function(k, v) {
        this_obj._ajax_fetch_st2_data(k, null, false, data);
      });

      $.each(this.st3_data, function(subtype1, item) {
        $.each(item, function(subtype2, v3) {
          this_obj._ajax_fetch_st3_data(subtype1, subtype2, null, false, data);
        });
      });
    }
  };

  KtSt1St2TableHandler.prototype._save_st3_data = function(subtype1, subtype2, data) {
    if (this.st3_data[subtype1] == undefined) {
      this.st3_data[subtype1] = {};
    }
    this.st3_data[subtype1][subtype2] = data;
  };

  KtSt1St2TableHandler.prototype._get_undeleted_st2_data = function(st1) {
    var r = [];
    var st2_data = this.st2_data[st1];
    var len = st2_data.length;
    for (var i = 0; i < st2_data.length; i++) {
      if (st2_data[i]['deleted'] == undefined || st2_data[i]['deleted'] == false) {
        r.push(st2_data[i]);
      }
    }
    return r;
  };
  KtSt1St2TableHandler.prototype._get_undeleted_st3_data = function(st1, st2) {
    var r = [];
    var st3_data = this.st3_data[st1][st2];
    var len = st3_data.length;
    for (var i = 0; i < st3_data.length; i++) {
      if (st3_data[i]['deleted'] == undefined || st3_data[i]['deleted'] == false) {
        r.push(st3_data[i]);
      }
    }
    return r;
  };

  KtSt1St2TableHandler.prototype._populate_cached_st2_row = function(subtype1) {
    var st2_data = this._get_undeleted_st2_data(subtype1);

    var $row = $('tr[table_id=' + this.table_id + '][subtype1=' + subtype1 + ']');

    if ($row.length == 1) {


      $row.after("<div></div>"); // add a temporary div
      $($row.next()).ktTemplate({
        template: '[[ for item in list ]]' + this.options['st2_rows'] + '[[ endfor ]]'
      });
      var formatted_st2_data = this._format_data(st2_data);
      $($row.next()).ktTemplate('render', {
        'list': formatted_st2_data,
        'subtype1': subtype1
      });

      var subtype2_rows = $row.next().children();
      $row.next().remove();
      $row.after(subtype2_rows);

      //iterate thru all the st2 rows and bind a click event handler
      var $curr_dom = $row.next();
      while ($curr_dom.length != 0 && $($curr_dom).attr('class') != 'st1_row') {
        var this_obj = this;
        $curr_dom.click(function(event) {
          var $og_target = $(event.target);
          if ($og_target.hasClass('remove_btn')) {
            this_obj._delete_row_handler(event.target);
          } else {
            var $row = $(this);
            if ($row.attr('expandable')) {
              var subtype2 = $($row.children()[1]).text();

              var need_to_fetch_data = false;
              if (this_obj.row_click_state[subtype1][1][subtype2] == undefined) {
                this_obj.row_click_state[subtype1][1][subtype2] = true;
                need_to_fetch_data = true;
              } else {
                //toggle;
                this_obj.row_click_state[subtype1][1][subtype2] = !this_obj.row_click_state[subtype1][1][subtype2];
              }

              if (need_to_fetch_data) {
                $row.find('img.plus').hide();
                $row.find('img.loading').show();
                this_obj._ajax_fetch_st3_data(subtype1, subtype2, $row, true);
              } else {
                this_obj._show_or_hide_st3_row(subtype1, subtype2);
              }
            }
          }
        });
        $curr_dom = $curr_dom.next();
      }
    }
  };
  KtSt1St2TableHandler.prototype._populate_cached_st3_row = function(subtype1, subtype2) {
    if (this.row_click_state[subtype1] == undefined || this.row_click_state[subtype1][1][subtype2] == undefined || this.row_click_state[subtype1][1][subtype2] == false) {
      return;
    }

    var st3_data = this._get_undeleted_st3_data(subtype1, subtype2);
    var $row = $('tr[table_id=' + this.table_id + '][subtype1=' + subtype1 + '][subtype2=' + subtype2 + '][class="st2_row"]');

    if ($row.length == 1) {
      $row.after("<div></div>"); // add a temporary div
      $($row.next()).ktTemplate({
        template: '[[ for item in list ]]' + this.options['st3_rows'] + '[[ endfor ]]'
      });
      $($row.next()).ktTemplate('render', {
        'list': this._format_data(st3_data),
        'subtype1': subtype1,
        'subtype2': subtype2
      });
      var subtype3_rows = $row.next().children();

      $row.next().remove();
      $row.after(subtype3_rows);

      var $curr_dom = $row.next();
      var this_obj = this;
      while ($curr_dom.length != 0 && $($curr_dom).attr('class') != 'st1_row' && $($curr_dom).attr('class') != 'st2_row') {
        $curr_dom.click(function(event) {
          var $og_target = $(event.target);
          if ($og_target.hasClass('remove_btn')) {
            this_obj._delete_row_handler(event.target);
          }
        });
        $curr_dom = $curr_dom.next();
      }
    }
  };
  KtSt1St2TableHandler.prototype._show_or_hide_st2_row = function(subtype1) {
    // show or hide the rows accordingly
    var $row = $('tr[table_id=' + this.table_id + '][subtype1=' + subtype1 + '][class="st1_row"]');
    if ($row.length == 0) return;

    var this_obj = this;
    var $curr_dom_lst = $('tr[table_id=' + this.table_id + '][subtype1=' + subtype1 + '][class="st2_row"]');
    if (this.row_click_state[subtype1] != undefined && this.row_click_state[subtype1][0] == true)
      //Show
    {
      $row.contents().find("img.plus").hide();
      $row.contents().find("img.minus").show();
      $.each($curr_dom_lst, function(i, dom) {
        $(dom).show();
        var subtype2 = '';
        if ($(dom).attr('subtype2') != undefined) subtype2 = $(dom).attr('subtype2');
        this_obj._show_or_hide_st3_row(subtype1, subtype2);
      });

      this.rows_expanded['st2']++;
    } else
      //Hide
    {
      $row.contents().find("img.plus").show();
      $row.contents().find("img.minus").hide();
      $.each($curr_dom_lst, function(i, dom) {
        $(dom).hide();
        var subtype2 = '';
        if ($(dom).attr('subtype2') != undefined) subtype2 = $(dom).attr('subtype2');
        this_obj._show_or_hide_st3_row(subtype1, subtype2, true /*force_hide*/ );
      });
      this.rows_expanded['st2']--;
    }

    this._show_or_hide_header('st2');
    $.sparkline_display_visible();
  };

  KtSt1St2TableHandler.prototype._show_or_hide_header = function(subtype) {
    var ele = $(this._gen_table_id() + " ." + subtype + "_header");
    if (this.rows_expanded[subtype] > 0) {
      ele.show();
    } else {
      ele.hide();
    }
  };

  KtSt1St2TableHandler.prototype._show_or_hide_st3_row = function(subtype1, subtype2, force_hide) {
    var $row = $('tr[table_id=' + this.table_id + '][subtype1=' + subtype1 + '][subtype2=' + subtype2 + '][class="st2_row"]');
    if ($row.length == 0) return;

    var $curr_dom = $row.next();
    if (this.row_click_state[subtype1] != undefined && this.row_click_state[subtype1][1][subtype2] != undefined && this.row_click_state[subtype1][1][subtype2] == true && force_hide == undefined)
      //Show
    {
      $row.contents().find("img.plus").hide();
      $row.contents().find("img.minus").show();
      while ($curr_dom.attr('class') == 'st3_row') {
        //Only count showing if currently hidden or unloaded
        if (!$curr_dom.is(':visible') || $row.contents().find("img.loading").is(":visible")) {
          this.rows_expanded['st3']++;
        }

        $curr_dom.show();
        $curr_dom = $curr_dom.next();
      }
    } else
      //Hide
    {
      $row.contents().find("img.plus").show();
      $row.contents().find("img.minus").hide();

      while ($curr_dom.attr('class') == 'st3_row') {
        //Only count hidding if currently showing
        if ($curr_dom.is(':visible')) {
          this.rows_expanded['st3']--;
        }

        $curr_dom.hide();
        $curr_dom = $curr_dom.next();
      }
    }

    this._show_or_hide_header('st3');
    $.sparkline_display_visible();

  };
  KtSt1St2TableHandler.prototype._show_or_hide_all = function() {
    for (var st1_key in this.st2_data) {
      this._show_or_hide_st2_row(st1_key);
    }
  };
  KtSt1St2TableHandler.prototype._populate_all_cached_st2_rows = function() {
    for (var st1_key in this.st2_data) {
      this._populate_cached_st2_row(st1_key);

    }
  };
  KtSt1St2TableHandler.prototype._populate_all_cached_st3_rows = function() {
    for (var st1_key in this.st3_data) {
      var st3_data = this.st3_data[st1_key];
      for (var st2_key in st3_data) {
        this._populate_cached_st3_row(st1_key, st2_key);
      }
    }
  };


  KtSt1St2TableHandler.prototype._delete_st2_from_cache = function(st1, st2) {
    if (this.st2_data[st1] != undefined) {
      var st2_data_lst = this.st2_data[st1];
      var len = st2_data_lst.length;
      if (st2 != undefined && st2 != null) {
        for (var i = 0; i < len; i++) {
          if (st2_data_lst[i]['subtype2'] == st2) {
            st2_data_lst[i]['deleted'] = true;
            break;
          }
        } // for
      } else {
        for (var i = 0; i < len; i++) {
          st2_data_lst[i]['deleted'] = true;
        }
      }
    }
    this._delete_st3_from_cache(st1, st2);
  };

  KtSt1St2TableHandler.prototype._delete_st3_from_cache = function(st1, st2, st3) {
    if (this.st3_data[st1] != undefined && this.st3_data[st1][st2] != undefined) {
      var st3_data_lst = this.st3_data[st1][st2];
      var len = st3_data_lst.length;
      if (st3 != undefined && st3 != null) {
        for (var i = 0; i < len; i++) {
          if (st3_data_lst[i]['subtype3'] == st3) {
            st3_data_lst[i]['deleted'] = true;
          } // if(st3_data_lst[i]['subtype3'] == st3) ...
          break;
        } // for(var i ...
      } else {
        //st3 is not specified, so delete all st3 associated with st1 and st2
        for (var i = 0; i < len; i++) {
          st3_data_lst[i]['deleted'] = true;
        } // for
      } // else
    }
  };

  KtSt1St2TableHandler.prototype._delete_row_handler_get_ajax_args = function(dom) {
    var this_row = $(dom).parent().parent();
    var channel_type = $(dom).attr('channel_type');
    var row_type = $(this_row).attr('class');

    var arg = {
      channel_type: channel_type
    };
    // clean up the row_click_state while at it
    // also, clean up the st2 and st3 cache while at it.
    if (row_type == 'st1_row') {
      var st1 = $(this_row).attr('subtype1');
      arg['st1'] = st1;
      if (this.row_click_state[st1] != undefined) {
        delete this.row_click_state[st1];
      }
      this._delete_st2_from_cache(st1);
    } else if (row_type == 'st2_row') {
      var st1 = $(this_row).attr('subtype1');
      var st2 = $(this_row).attr('subtype2');
      arg['st1'] = st1;
      arg['st2'] = st2;
      if (this.row_click_state[st1][1][st2] != undefined) {
        delete this.row_click_state[st1][1][st2];
      }
      this._delete_st2_from_cache(st1, st2);
    } else if (row_type == 'st3_row') {
      var st1 = $(this_row).attr('subtype1');
      var st2 = $(this_row).attr('subtype2');
      var st3 = $(this_row).attr('subtype3');
      arg['st1'] = st1;
      arg['st2'] = st2;
      arg['st3'] = st3;
      this._delete_st3_from_cache(st1, st2, st3);
    }
    return arg;
  };

  KtSt1St2TableHandler.prototype._ajax_fetch_st2_data = function(subtype1, $row, wait_for_everyone_else, render_data) {
    var this_obj = this;
    var st_prefix = this.options['st123_prefix']; // st_pref =  fcsst in this case
    var url = np_get_table_url(this_obj, this_obj.options['category'], this_obj.options['tab'], this_obj.options['page'], this_obj.table_id) + '&' + st_prefix + '1=' + encodeURIComponent(subtype1) + '&groupby=' + encodeURIComponent(subtype1);
    ktAjaxWrapper({
      type: 'GET',
      url: url,
      async: true,
      traditional: true,
      dataType: 'json',
      success: function(data, textStatus) {
        if (data['__primary_data__'] != undefined) {
          data.data = data['__primary_data__'];
        }

        // cache the subtype2 data
        this_obj.st2_data[subtype1] = data.data;
        if ($row != null) {
          this_obj._populate_cached_st2_row(subtype1);
          this_obj._show_or_hide_st2_row(subtype1);
          $row.find('img.loading').hide();
          this_obj._get_rid_of_st2_arrows(data.data, subtype1);
          $(document).trigger("load_st2_table_data", [this_obj.table_id, render_data]);
        }
        if (wait_for_everyone_else == false) {
          this_obj.st2_st3_ajax_reload_calls_returned_so_far = this_obj.st2_st3_ajax_reload_calls_returned_so_far + 1;
          if (this_obj.st2_st3_ajax_reload_calls_returned_so_far == this_obj.total_st2_st3_ajax_reload_calls) {
            this_obj.total_st2_st3_ajax_reload_calls = 0;
            this_obj.st2_st3_ajax_reload_calls_returned_so_far = 0;
            $(document).trigger("repopulate_st2_st3_entries", [this_obj.table_id, render_data]);
          }
        }
      } // success
    });
  };

  KtSt1St2TableHandler.prototype._ajax_fetch_st3_data = function(subtype1, subtype2, $row, wait_for_everyone_else, render_data) {
    var this_obj = this;
    var st_prefix = this.options['st123_prefix']; // st_pref =  fcsst in this case
    var url = np_get_table_url(this_obj, this_obj.options['category'], this_obj.options['tab'], this_obj.options['page'], this_obj.table_id) + '&' + st_prefix + '1=' + encodeURIComponent(subtype1) + '&' + st_prefix + '2=' + encodeURIComponent(subtype2) + '&groupby=' + encodeURIComponent(subtype1);
    ktAjaxWrapper({
      type: 'GET',
      traditional: true,
      url: url,
      async: true,
      dataType: 'json',
      success: function(data, textStatus) {

        if (data['__primary_data__'] != undefined) {
          data.data = data['__primary_data__'];
        }

        this_obj._save_st3_data(subtype1, subtype2, data.data);
        if ($row != null) {
          this_obj._populate_cached_st3_row(subtype1, subtype2);
          this_obj._show_or_hide_st3_row(subtype1, subtype2);
          $row.find('img.loading').hide();
          $(document).trigger("load_st3_table_data", [this_obj.table_id, render_data]);
        }
        if (wait_for_everyone_else == false) {
          this_obj.st2_st3_ajax_reload_calls_returned_so_far = this_obj.st2_st3_ajax_reload_calls_returned_so_far + 1;
          if (this_obj.st2_st3_ajax_reload_calls_returned_so_far == this_obj.total_st2_st3_ajax_reload_calls) {
            this_obj.total_st2_st3_ajax_reload_calls = 0;
            this_obj.st2_st3_ajax_reload_calls_returned_so_far = 0;
            $(document).trigger("repopulate_st2_st3_entries", [this_obj.table_id, render_data]);
          }
        }

      } //success
    }); //ktAjaxWrapper
  };

  KtSt1St2TableHandler.prototype._bind_table_events = function() {
    var this_obj = this;

    this_obj._get_rid_of_st1_arrows(this_obj.data);
    $("#" + this_obj.table_id + "_table tr.st1_row").click(

      function(event) {
        var $og_target = $(event.target);
        if ($og_target.hasClass('remove_btn')) {
          // remove event
          this_obj._delete_row_handler(event.target);
        } else {
          // normal toggle event
          var $row = $(this);
          if ($row.attr('expandable') == 'true') {
            var subtype1 = ($($($(this).children()[1]).children()[0]).text());

            // update the click state first
            var need_to_fetch_data = false;
            if (this_obj.row_click_state[subtype1] == undefined) {
              this_obj.row_click_state[subtype1] = [true,
                                                    {}];
              need_to_fetch_data = true;
            } else {
              this_obj.row_click_state[subtype1][0] = !this_obj.row_click_state[subtype1][0];
            }

            if (need_to_fetch_data) {
              $row.find('img.plus').hide();
              $row.find('img.loading').show();
              this_obj._ajax_fetch_st2_data(subtype1, $row, true);
            } else {
              this_obj._show_or_hide_st2_row(subtype1);
            }
          }
        }
        return false;
      });
  };

  function KtSt1St2Table() {
    this.inheritedFrom = KtTable;
  };

  KtSt1St2Table.prototype = new KtTable();
  KtSt1St2Table.prototype._init = function() {
    this.handler = new KtSt1St2TableHandler(this.element, this.options);
    this.handler.init_impl();
  };

  //////////////////////// KtPaginatedTable ///////////////////////////


  function KtPaginatedTableHandler(element, options) {
    this.inheritedFrom = KtTableHandler;
    this.inheritedFrom(element, options);
    this.pagination = null;
  }

  KtPaginatedTableHandler.prototype = new KtTableHandler();
  KtPaginatedTableHandler.prototype.init_impl = function() {
    // call parent's method
    KtTableHandler.prototype.init_impl.call(this);
  };

  KtPaginatedTableHandler.prototype._ajax_load_all_table_data_handler = function(data) {
    $("#" + this.table_id + "_table").find(".loading-row").remove();
    $("#t" + this.table_id + " a[id='prev']").unbind('click');
    $("#t" + this.table_id + " a[id='next']").unbind('click');

    this.data = data;
    // TODO: make the number of paginated rows customizable.
    this.pagination = new Pagination(this.data, this.table_id, this.options['num_rows']);

    $("#" + this.table_id + "_table").ktTemplate('render', {
      list: this._format_data(this.pagination.getData(0))
    });
    this._bind_table_events();
  };

  function KtPaginatedHeader(show_frame) {
    if (show_frame == true) {
      var template_str = "<div class='k-box'> \
        <div class='k-box-head'> \
        <div class='k-box-head-info'>\
        <h1>[=title]</h1> \
        <a href='#' index='[=index]' class='help' title='[=bubble_text]'>help</a> \
        <a href='#' title='Export to CSV' class='k-box-icon export_link' id='[=data_export_id]'>&nbsp;</a>\
      </div> \
      </div>\
        <div class='k-box-body'> \
        <table class='k-table' id='[=table_id]_table' cellpadding=\"0\" cellspacing=\"0\" border=\"0\"  id=\"data\" style=\"width: 100%\"> \
        <tr class=\"head-tr left-border\"> \
        <td class='lit first-coln [=first_coln.coln_type] [=first_coln.coln_class]' decimal='[=first_coln.coln_decimal]' coln_id='[=first_coln.coln_id]'><small>[=first_coln.coln_name]</small></td>\
      [[for coln in coln_list]] \
        <td class='lit [=coln.coln_type] [=coln.coln_class]' decimal='[=coln.coln_decimal]' coln_id='[=coln.coln_id]'><small>[=coln.coln_name]</small></td>\
      [[endfor]]\
      </tr>\
      </table>\
        <ul>\
        <li class=\"first\"><a id='prev' class=\"blank\" href='#' title=\"Previous\"><img class=\"prev_pagin_page\" src=\"" + KT_ENV_JS.media_url + "/images/arrowleft3.png\" style=\"display:none;\"></img></a></li>\
        <li class=\"first\"><img class=\"prev_pagin_page_inactive\" src=\"" + KT_ENV_JS.media_url + "/images/arrowleft3-disabled.png\"></img></li>\
        <li><span class='table_pagination'>Page&nbsp;</span><span class='table_pagination' id='curr_page'></span><span class='table_pagination'>&nbsp;of&nbsp;</span><span id='max_page'' class='table_pagination'></span></li>\
        <li><a id='next' class=\"blank\" href='#' title=\"Next\"><img class=\"next_pagin_page\" src=\"" + KT_ENV_JS.media_url + "/images/arrowright3.png\"></img></a></li>\
        <li><img class=\"next_pagin_page_inactive\" src=\"" + KT_ENV_JS.media_url + "/images/arrowright3-disabled.png\" style=\"display:none;\"></img></li>\
      </ul>\
      </div>\
      </div>";
    } else {
      var template_str = "<div class='k-box'> \
        <div class='k-box-body'> \
        <table class='k-table' id='[=table_id]_table' cellpadding=\"0\" cellspacing=\"0\" border=\"0\"  id=\"data\" style=\"width: 100%\"> \
        <tr class=\"head-tr left-border\"> \
        <td decimal='[=first_coln.coln_decimal]' class='lit first-coln [=first_coln.coln_type] [=first_coln.coln_class]' coln_id='[=first_coln.coln_id]'><small>[=first_coln.coln_name]</small></td>\
      [[for coln in coln_list]] \
        <td decimal='[=coln.coln_decimal]' class='lit [=coln.coln_type] [=coln.coln_class]' coln_id='[=coln.coln_id]'><small>[=coln.coln_name]</small></td>\
      [[endfor]]\
      </tr>\
      </table>\
        <ul>\
        <li class=\"first\"><a id='prev' class=\"blank\" href='#' title=\"Previous\"><img class=\"prev_pagin_page\" src=\"" + KT_ENV_JS.media_url + "/images/arrowleft3.png\" style=\"display:none;\"></img></a></li>\
        <li class=\"first\"><img class=\"prev_pagin_page_inactive\" src=\"" + KT_ENV_JS.media_url + "/images/arrowleft3-disabled.png\"></img></li>\
        <li><span class='table_pagination'>Page&nbsp;</span><span class='table_pagination' id='curr_page'></span><span class='table_pagination'>&nbsp;of&nbsp;</span><span id='max_page'' class='table_pagination'></span></li>\
        <li><a id='next' class=\"blank\" href='#' title=\"Next\"><img class=\"next_pagin_page\" src=\"" + KT_ENV_JS.media_url + "/images/arrowright3.png\"></img></a></li>\
        <li><img class=\"next_pagin_page_inactive\" src=\"" + KT_ENV_JS.media_url + "/images/arrowright3-disabled.png\" style=\"display:none;\"></img></li>\
      </ul>\
      </div>\
      </div>";
    }
    return template_str;
  };

  KtPaginatedTableHandler.prototype._get_table_header = function(show_frame) {
    return KtPaginatedHeader(show_frame);
  };

  KtPaginatedTableHandler.prototype._bind_table_events = function() {
    this.show_hide_prev_next_btn();
    this.bind_prev_click();
    this.bind_post_click();
    $("#t" + this.table_id + " span[id='curr_page']").text(this.pagination.page + 1);
    $("#t" + this.table_id + " span[id='max_page']").text(this.pagination.max_page);
  };

  KtPaginatedTableHandler.prototype.show_hide_prev_next_btn = function() {
    var element_id = this.element[0].id;
    if (this.pagination.page == 0) {
      //deactivate prev
      $('#' + element_id + " .prev_pagin_page_inactive").show();
      $("#" + element_id + " .prev_pagin_page").hide();
    } else {
      $("#" + element_id + " .prev_pagin_page_inactive").hide();
      $("#" + element_id + " .prev_pagin_page").show();
    }

    if (this.pagination.page == this.pagination.max_page - 1) {
      $("#" + element_id + " .next_pagin_page_inactive").show();
      $("#" + element_id + " .next_pagin_page").hide();
    } else {
      $("#" + element_id + " .next_pagin_page_inactive").hide();
      $("#" + element_id + " .next_pagin_page").show();
    }
  };

  KtPaginatedTableHandler.prototype.bind_prev_click = function() {
    var this_obj = this;
    var $header_td_obj = $($(this._gen_table_id() + " td")[0]);
    var og_height = $header_td_obj.height();
    $("#t" + this.table_id + " a[id='prev']").unbind('click');
    $("#t" + this.table_id + " a[id='prev']").click(

      function() {
        this_obj._clear_content();
        var data = this_obj.pagination.getPrevData();
        $(this_obj._gen_table_id()).ktTemplate('render', {
          list: this_obj._format_data(data)
        });
        this_obj.show_hide_prev_next_btn();
        $("#t" + this_obj.table_id + " span[id='curr_page']").text(this_obj.pagination.page + 1);

        return false;
      });
    $header_td_obj.height(og_height); //hack to work around the column shrinkage problem
  };

  KtPaginatedTableHandler.prototype.bind_post_click = function() {
    var this_obj = this;
    var $header_td_obj = $($(this._gen_table_id() + " td")[0]);
    var og_height = $header_td_obj.height();
    $("#t" + this_obj.table_id + " a[id='next']").unbind('click');
    $("#t" + this_obj.table_id + " a[id='next']").click(

      function() {
        this_obj._clear_content();
        var data = this_obj.pagination.getNextData();
        $(this_obj._gen_table_id()).ktTemplate('render', {
          list: this_obj._format_data(data)
        });
        this_obj.show_hide_prev_next_btn();
        $("#t" + this_obj.table_id + " span[id='curr_page']").text(this_obj.pagination.page + 1);
        return false;
      });
    $header_td_obj.height(og_height); //hack to work around the column shrinkage problem
  };

  KtPaginatedTableHandler.prototype._sort = function(coln_id, data) {
    //do some bookkeeping first
    this.sort_dict[coln_id] = !this.sort_dict[coln_id];

    this._sort_impl(coln_id, data);
    var curr_page = this.pagination.page;
    this.pagination = new Pagination(this.data, this.table_id, this.options['num_rows']); //TODO: customize how many is showing per paginated page.
    this.pagination.page = curr_page;
    // repopulate data
    this._clear_content();
    $(this._gen_table_id()).ktTemplate('render', {
      list: this._format_data(this.pagination.getData(curr_page))
    });
  };

  function KtPaginatedTable() {
    this.inheritedFrom = KtTable;
  }

  KtPaginatedTable.prototype = new KtTable();
  KtPaginatedTable.prototype._init = function() {
    this.handler = new KtPaginatedTableHandler(this.element, this.options);
    this.handler.init_impl();
  };

  ////////////////// KtPaginatedTableNotPermitted //////////////////////

  function KtPaginatedTableNotPermittedHandler(element, options) {
    this.inheritedFrom = KtNotPermittedTableHandler;
    this.inheritedFrom(element, options);
    this.pagination = null;
  }

  KtPaginatedTableNotPermittedHandler.prototype = new KtNotPermittedTableHandler();


  KtPaginatedTableNotPermittedHandler.prototype._get_table_header = function(show_frame) {
    return KtPaginatedHeader(show_frame);
  };

  function KtPaginatedTableNotPermitted() {
    this.inheritedFrom = KtNotPermittedTable;
  }

  KtPaginatedTableNotPermitted.prototype = new KtNotPermittedTable();
  KtPaginatedTableNotPermitted.prototype._init = function() {
    this.handler = new KtPaginatedTableNotPermittedHandler(this.element, this.options);
    this.handler.init_impl();
    $(this.element).attr("not_permitted", true);
  };

  //////////////////////// KtSubTabTable ///////////////////////////


  function KtSubTabTableHandler(element, options) {
    this.inheritedFrom = KtTableHandler;
    this.inheritedFrom(element, options);
    this.pagination = null;
  }

  KtSubTabTableHandler.prototype = new KtTableHandler();

  KtSubTabTableHandler.prototype._highlight_selected_tab = function(tab_str) {
    if (tab_str == undefined) {
      //pick the first one
      $($("#t" + this.table_id + " div.k-box-body a")[0]).addClass('active');
    } else {
      $("#t" + this.table_id + " a[subTab='" + tab_str + "']").addClass('active');
    }
  };

  KtSubTabTableHandler.prototype._bind_sub_tab_events = function() {
    var _this_obj = this;
    $("#t" + this.table_id + " div.k-box-body a").click(
      function() {
        var tab_str = $($(this).children()[0]).text();
        var url = np_get_table_url(_this_obj, _this_obj.category, _this_obj.tab, _this_obj.page, _this_obj.table_id) + '&table_sub_tab=' + escape(tab_str);
        var element = this;
        ktAjaxWrapper({
          type: 'GET',
          url: url,
          traditional: true,
          dataType: 'json',
          success: function(data, textStatus) {
            _this_obj.options['coln'] = data['__colns__'];
            $(_this_obj.element).ktTemplate('clear');
            _this_obj._construct_coln_header(true);
            _this_obj._bind_sub_tab_events(); // this is not a recursive call.
            _this_obj._setup_rows_template(data['__rows__']); //setup the table content template
            _this_obj._highlight_selected_tab(tab_str);
            _this_obj._setup_sorting();
            $(document).trigger('load_all_table_data', [_this_obj.table_id]);
          }
        });
        return false;
      });
  };

  KtSubTabTableHandler.prototype.init_impl = function() {
    // call parent's method
    KtTableHandler.prototype.init_impl.call(this);
    this._bind_sub_tab_events();
    this._highlight_selected_tab();

    var this_obj = this;
  };


  KtSubTabTableHandler.prototype._get_table_header = function(show_frame) {
    if (show_frame == true) {
      var template_str = "<div class='k-box'> \
	<div class='k-box-head'> \
	<div class='k-box-head-info'>\
	<h1>[=title]</h1> \
        <a href='#' index='[=index]' class='help' title='[=bubble_text]'>help</a> \
	<a href='#' title='Export to CSV' class='k-box-icon export_link' id='[=data_export_id]'>&nbsp;</a>\
      </div> \
	       </div>\
	       <div class='k-box-body'> \
                 <ul>\
		   [[for tab in subtab]]\
       	           <li><a href='#' subTab='[=tab]'><span>[=tab]</span></a></li>\
	           [[endfor]]\
	 	 </ul>\
 		 <table class='k-table' id='[=table_id]_table' \
			cellpadding=\"0\" cellspacing=\"0\" border=\"0\"  id=\"data\" style=\"width: 100%\"> \
		   <tr class=\"head-tr left-border\"> \
		     <td decimal='[=first_coln.coln_decimal]' class='lit first-coln [=first_coln.coln_type] [=first_coln.coln_class]' coln_id='[=first_coln.coln_id]'><small>[=first_coln.coln_name]</small></td>\
                     [[for coln in coln_list]] \
                     <td decimal='[=coln.coln_decimal]' class='lit [=coln.coln_type] [=coln.coln_class]' coln_id='[=coln.coln_id]'><small>[=coln.coln_name]</small></td>\
	             [[endfor]]\
		   </tr>\
		 </table>\
	       </div>\
	   </div>";
        } else {

        }
        return template_str;
    };

    function KtSubTabTable() {
        this.inheritedFrom = KtTable;
    };

    KtSubTabTable.prototype = new KtTable();
    KtSubTabTable.prototype._init = function() {
        this.handler = new KtSubTabTableHandler(this.element, this.options);
        this.handler.init_impl();
    };

    //////////////////////// KtSubTabTableRefactored ///////////////////////////


    function KtSubTabTableRefactoredHandler(element, options) {
        this.inheritedFrom = KtTableHandler;
        this.inheritedFrom(element, options);
    }
    KtSubTabTableRefactoredHandler.prototype = new KtTableHandler();

    KtSubTabTableRefactoredHandler.prototype._get_table_header = function(show_frame) {
        var template_str = "<div id='[=table_id]_secondary_data' class='k-box-secondary'></div>\
        <div class='k-box'> \
	       <div class='k-box-head'> \
	          <div class='k-box-head-info'>\
		      <h1>[=title]</h1> \
                      <a href='#' index='[=index]' class='help' title='[=bubble_text]'>help</a> \
		      <a href='#' title='Export to CSV' class='k-box-icon export_link' id='[=data_export_id]'>&nbsp;</a>\
		  </div> \
	       </div>\
	       <div class='k-box-body'> \
                 <ul>\
		   [[for tab in subtab]]\
       	           <li><a href='#' subTab='[=tab.tab_id]' class='subtab_btn'>[=tab.tab_str]</a><span>|</span></li>\
	           [[endfor]]\
	 	 </ul>\
               </div>\
       </div>";
        return template_str;
    };

    KtSubTabTableRefactoredHandler.prototype._load_all_table_data_handler = function() {
        //do nothing.
    };

    KtSubTabTableRefactoredHandler.prototype._export_handler = function() {
        var subtab_id = $("#t" + this.table_id + " a.active").attr('subtab');
        var data_export_url = np_get_table_export_url(this, this.category, this.tab, this.page, subtab_id);
        document.location = data_export_url;
        return false;
    };

    KtSubTabTableRefactoredHandler.prototype._push_secondary_data_to_parent = function(tab_id_str) {
        var $secondary_data_dom = $("#" + tab_id_str + "_secondary_data");
        if ($secondary_data_dom.length > 0) {
            $("#" + this.table_id + "_secondary_data").text($secondary_data_dom.text());
        }
    };

    KtSubTabTableRefactoredHandler.prototype._highlight_selected_tab = function(tab_id_str) {
        if (tab_id_str == undefined) {
            //pick the first one
            $($("#t" + this.table_id + " div.k-box-body a")[0]).addClass('active');
            tab_id_str = $($("#t" + this.table_id + " div.k-box-body a")[0]).attr('subtab');
        } else {
            $("#t" + this.table_id + " a[subTab='" + tab_id_str + "']").addClass('active');
        }

        var _this_obj = this;
        $(document).bind('onload_all_table_data', function(event, msg) {
            if (tab_id_str == msg) {
                _this_obj._push_secondary_data_to_parent(tab_id_str);
            }
        });
    };

    KtSubTabTableRefactoredHandler.prototype._unhighlight_selected_tab = function(tab_id_str) {
        $("#t" + this.table_id + " a[subTab='" + tab_id_str + "']").removeClass('active');
    };

    KtSubTabTableRefactoredHandler.prototype._bind_sub_tab_events = function() {
        var _this_obj = this;
        $("#t" + this.table_id + " div.k-box-body a").click(

        function() {
            var tab_table_index_list = _this_obj.options['table_widget_ids'];
            var tab_table_index_list_len = tab_table_index_list.length;
            for (var i = 0; i < tab_table_index_list_len; i++) {
                var sub_tab_index = tab_table_index_list[i]['index'];
                if (sub_tab_index == $(this).attr('subtab')) {
                    $("#t" + sub_tab_index).show();
                    _this_obj._highlight_selected_tab(sub_tab_index);
                    _this_obj._push_secondary_data_to_parent(sub_tab_index + "_tab");
                } else {
                    $("#t" + sub_tab_index).hide();
                    _this_obj._unhighlight_selected_tab(sub_tab_index);
                }
            }

            $.sparkline_display_visible();
            return false;
        });
    };

    KtSubTabTableRefactoredHandler.prototype.init_impl = function() {
        KtTableHandler.prototype.init_impl.call(this);

        var tab_table_index_list = this.options['table_widget_ids'];
        var tab_table_index_list_len = tab_table_index_list.length;
        for (var i = 0; i < tab_table_index_list_len; i++) {
            $("#t" + this.table_id + " div[class='k-box-body']").append($("#t" + tab_table_index_list[i]['index']));
        }
        this._bind_sub_tab_events();
        this._highlight_selected_tab();
        // unbind load_all_table_data
        // remove last divider
        $(".subtab_btn:last").next().remove();        
    };

    function KtSubTabTableRefactored() {
        //     this.handler = new KtSubTabTableHandler(this.element, this.options);
        this.inheritedFrom = KtTable;
    }


    KtSubTabTableRefactored.prototype._init = function() {
        this.handler = new KtSubTabTableRefactoredHandler(this.element, this.options);
        this.handler.init_impl();
    };


    //////////////////////// KtFiltersForDynTable ///////////////////////////


    function KtFilterForDynTableHandler(element, options) {
        this.inheritedFrom = KtTableHandler;
        this.inheritedFrom(element, options);
    };

    KtFilterForDynTableHandler.prototype = new KtTableHandler();

    KtFilterForDynTableHandler.prototype._delete_row_handler = function(dom) {
        var filter_id = $(dom).attr('filter_id');
        var _this_obj = this;
        ktAjaxWrapper({
            type: "GET",
            url: "/dashboard/filter/ajax_delete_filter/",
            data: {
                id: filter_id
            },
            success: function(msg) {
                _this_obj._trigger_load_table_data();
            }
        });
        return false;
    };

  KtFilterForDynTableHandler.prototype._bind_table_events = function() {
    var $remove_btns = $("#" + this.table_id + "_table a.remove_btn");
    var this_obj = this;
    if ($remove_btns.length > 0) {

      var idx = 0;

      $remove_btns.each(function() {
        $(this).click(function(event) {
          this_obj._delete_row_handler(event.target);
        });
        
        $(this).attr('filter_id', this_obj.data[idx]['filter_id']);
        idx++;
      });
    }
  };

    function KtFilterForDynTable() {
        this.inheritedFrom = KtTable;
    };
    KtFilterForDynTable.prototype = new KtTable();
    KtFilterForDynTable.prototype._init = function() {
        this.handler = new KtFilterForDynTableHandler(this.element, this.options);
        this.handler.init_impl();
    };


    ////////////////////////  ktFilterForSt1St2Table ///////////////////////////


    function KtFilterForSt1St2TableHandler(element, options) {
        this.inheritedFrom = KtFilterForDynTableHandler;
        this.inheritedFrom(element, options);
        this.initial_sorting = 'st1';
    }

    KtFilterForSt1St2TableHandler.prototype = new KtFilterForDynTableHandler();

    KtFilterForSt1St2TableHandler.prototype._delete_row_handler = function(dom) {
        var filter_id = $(dom).attr('filter_id');
        var _this_obj = this;
        ktAjaxWrapper({
            type: "GET",
            url: "/dashboard/filter/ajax_delete_filter/",
            data: {
                id: filter_id
            },
            success: function(msg) {
                var $st1_dom = $(dom).parent().next().next();
                var $st2_dom = $st1_dom.next();
                var $st3_dom = $st2_dom.next();
                var st1_text = $st1_dom.text();
                var st2_text = $st2_dom.text();
                var st3_text = $st3_dom.text();

                var table_id = '#t' + _this_obj.table_id.split("_")[0];
                var table_widget_ids = $(table_id).ktSubTabTableRefactored("option", "table_widget_ids");
                for (var i = 0; i < table_widget_ids.length; i++) {
                    $(document).trigger('delete_st2st3', [table_widget_ids[i]['index'], st1_text, st2_text, st3_text]);
                }
                _this_obj._trigger_load_table_data();
            } // success
        });
        return false;
    };

    function KtFilterForSt1St2Table() {
        this.inheritedFrom = KtFilterForDynTable;
    }
    KtFilterForSt1St2Table.prototype = new KtFilterForDynTable();
    KtFilterForSt1St2Table.prototype._init = function() {
        this.handler = new KtFilterForSt1St2TableHandler(this.element, this.options);
        this.handler.init_impl();
    };

    var kt_table = new KtTable();
    var kt_not_permitted_table = new KtNotPermittedTable();
    var kt_st1_st2_table = new KtSt1St2Table();
    var kt_paginated_table = new KtPaginatedTable();
    var kt_paginated_table_not_permitted = new KtPaginatedTableNotPermitted();
    var kt_sub_tab_table = new KtSubTabTable();
    var kt_sub_tab_table_refactored = new KtSubTabTableRefactored();
    var kt_filter_for_dyn_table = new KtFilterForDynTable();
    var kt_filter_for_st1_st2_table = new KtFilterForSt1St2Table();

    $.widget("kt.ktTable", kt_table);
    $.widget("kt.ktNotPermittedTable", kt_not_permitted_table);
    $.widget("kt.ktSt1St2Table", kt_st1_st2_table);
    $.widget("kt.ktPaginatedTable", kt_paginated_table);
    $.widget("kt.ktPaginatedTableNotPermitted", kt_paginated_table_not_permitted);
    $.widget("kt.ktSubTabTable", kt_sub_tab_table);
    $.widget("kt.ktSubTabTableRefactored", kt_sub_tab_table_refactored);
    $.widget("kt.ktFilterForDynTable", kt_filter_for_dyn_table);
    $.widget("kt.ktFilterForSt1St2Table", kt_filter_for_st1_st2_table);

    $.kt.ktTable.getter = ["get_handler"];
    $.kt.ktSt1St2Table.getter = ["get_handler"];
    $.kt.ktPaginatedTable.getter = ["get_handler"];
    $.kt.ktSubTabTable.getter = ["get_handler"];
    $.kt.ktSubTabTableRefactored.getter = ["get_handler"];
})(jQuery);

/*
 *   Depends:
 *	 num_formatter.js
 *	 jquery.sparkline.js
 */

var TableUtils = {

  numFormatter : new NumFormatter(),

  /*
   * Formats the given value based on its type and decimal precision
   */
  formatCell: function(value, type, decimals) {

    if(value == "N/A" || value == "--") {
      return value;
    }

    if(typeof value === "undefined") {
      // show blank for missing data
      return "";
    }

    if(type === 'cent') {
      value /= 100.0;
    }

    if(type === 'percentage') {
      value *= 100.0;
    }

    if(!(type === 'string' || type === 'time')) {
      value = parseFloat(value);
      if(decimals !== undefined) {
          value = value.toFixed(decimals);
      }
      value = this.numFormatter.comma_format(value);
    }

    switch(type) {
      case "dollar":
      case "cent":
        return value = KT_ENV_JS['currency'] + value;
      case "percentage":
      case "percentage_100_based":
        return value = value + "%";
      case "time":
        return this.formatSeconds(value);
      default:
        return value;
    }
  },

  /*
   * Converts an integer secs into a string of "hour:minute:seconds"
   */
  formatSeconds: function(secs) {
    var remaining_secs = Math.floor(secs);
    if (remaining_secs == 0) return "00:00:00";
    var hr = Math.floor(remaining_secs / 3600);
    remaining_secs -= hr * 3600;
    hr += "";
    if (hr.length == 1) hr = "0" + hr;

    var min = Math.floor(remaining_secs / 60);
    remaining_secs -= min * 60;
    min += "";
    if (min.length == 1) min = "0" + min;

    var sec = remaining_secs;
    sec += "";
    if (sec.length == 1) sec = "0" + sec;

    var r = hr + ":" + min + ":" + sec;
    return r;
  },

  /*
   * Finds all elements with sparkline_cell class
   * and uses their data attribute to populate
   * a sparkline chart
   */
  addSparklines: function(element) {
    var cells = element.find(".sparkline_cell");
    var sparklinesToAdd = $.makeArray(cells);
    sparklinesToAdd.reverse();

    var sparklinesPerIteration = 1;
    var delayBetweenIterations = 1;

    addSparklinesStaggered = function(remaining) {
      for(var i = 0; i < sparklinesPerIteration; i++) {
        var cell = remaining.pop();

        if(cell) {
          var data = $(cell).attr('data').split(",");

          $(cell).sparkline(data, {
            lineColor: '#057D9F',
            width: '50px',
            lineWidth: '2',
            spotColor: false,
            spotRadius: '0',
            fillColor: false
          });
        }
      }

      if(remaining.length > 0) {
        setTimeout(function() {
          addSparklinesStaggered(remaining)
        }, delayBetweenIterations);
      }
    };

    addSparklinesStaggered(sparklinesToAdd);
  },

  /*
   * When showing a tab that was previously hidden we need
   * to explicitly tell the sparklines show up
   */
  showSparklines: function() {
    $.sparkline_display_visible();
  },

  /*
   * Gives every row within the given table an alternating
   * class of 'odd' or 'even'
   */
  zebraStyleRows: function(tableBody) {
    var dataRows = tableBody.find('tr');

    dataRows.removeClass("even odd");
    dataRows.filter(":odd").addClass("odd")
    dataRows.filter(":even").addClass("even");
  },

  /*
   * Based on the given maximums computes a color for each cell in the given row
   */
  getHeatMapping: function(dataRow, maximums, cellName) {
    var colorValue = Math.round(255 - (((dataRow[cellName]/maximums[cellName]) * 255) / 2.0));
    return "background:rgb(" + colorValue + ", 255," + colorValue + ")";
  },

  /*
   * Determines the maximum value in data for each column given
   */
  computeColumnMaximums : function(data, columns) {
    var maxes = {};

    for(var c = 0, cLen = columns.length; c < cLen; c++) {
      for(var i = 0, len = data.length; i < len; i++) {

        if(columns[c].type === "string") continue;

        if(!maxes[columns[c].id] || maxes[columns[c].id] <= data[i][columns[c].id]) {
          maxes[columns[c].id] = data[i][columns[c].id];
        }
      }
    }

    return maxes;
  },

  /*
   * Returns a .notification row that will span across the entire table
   */
  buildNotificationRow: function(content, numColumns) {

    var cell = $('<td></td>')
      .html(content)
      .addClass('notification')
      .prop('colspan', Math.max(numColumns, 1));

    var row = $('<tr></tr>').append(cell);

    return row;
  },

  /*
   * Asks the server to echo back the given data triggering a download
   * with the given file name and type
   */
  triggerDownload: function(ele, filename, filetype, data) {
    var encodedData = encodeURIComponent(data);
    var url = KT_ENV_JS['root_url'] + "/echo_as_download";

    var form = $('<form method="post" action="' + url + '" style="display:none"></form>');

    form.append('<input type="hidden" name="filename" value="' + filename + '"/>')
    form.append('<input type="hidden" name="filetype" value="' + filetype + '"/>')
    form.append('<input type="hidden" name="data" value="' + encodedData + '"/>')

    ele.append(form);
    form.submit().remove();
  }

};

var RESTRICTED_DRILLDOWN_ORDER = ['day', 'week', 'month'];
var RESTRICTED_FOR_HIDING = {'month': true, 'week': true, 'day': true};

function TablePivotor(table, currentDrilldown) {
  this.table = table;
  this.currentDrilldown = currentDrilldown;
  this.pivots = this.table.element.find('.select-column');

  this.setup();
};

TablePivotor.prototype = {

  setup: function() {
    var that = this;

    // Select initial pivoting configuration
    for(var p = 0, len = this.currentDrilldown.length; p < len; p++) {
      this.setPivot($(this.pivots[p]), this.currentDrilldown[p]);
    }

    // If we click on the pivot selector don't send that event onto
    // its parent since we would treat this like clicking on the
    // column header and thus perform sorting on that column
    this.pivots.click(function(e) {
      e.stopPropagation();
    });

    this.pivots.change(function() {
      that.update($(this));
    });
  },

  update : function(changedPivot) {
    var selected = changedPivot.val();

    // Reset any other pivots with the same value selected
    var pivotsToReset = this.table.element.find('td[coln_id=' + selected + '] select');
    this.setPivot(pivotsToReset, '');

    // Also set the pivot value ourselves to manage bookkeping
    this.setPivot(changedPivot, selected);

    // Compute new list of selected pivots
    var selectedPivots = [];
    var earliestChange;
    for(var p = 0, len = this.pivots.length; p < len; p++) {
      var pivotId = $(this.pivots[p]).val();

      if (this.currentDrilldown[p] != pivotId && earliestChange === undefined) {
        earliestChange = p;
      }

      selectedPivots.push(pivotId);
    }

    this.currentDrilldown = selectedPivots;

    this.applyPivotRestrictions();

    this.checkHidingIsValid();

    // Need to let the sorter know since we may have changed the currently sorted column's value
    if(this.table.sorter) {
      this.table.sorter.pivotHeaderChanged(this.table.element.find('td[coln_id=' + selected + ']'));
    }

    if(!this.currentDrilldown[0]) {
      // Show warning if first pivot column is blank
      this.table.dataSection.html(this.table.getNotification('Please select first column'));
    } else if (earliestChange <= 1) {
      // Reload entire table if the 1st or 2nd pivot has changed
      this.table.fetchRootData();
    } else {
      //Only need to reload the column before the changed pivot to
      // figure out if those parent rows are expandable
      this.table.fetchDataAtDepth(earliestChange - 2);
    }
  },

  /*
   *
   * If one of the pivots is set to 'day' all dropdown boxes after it should have the options
   * 'week' and 'month' disabled
   *
   * If one of the pivots is set to 'week' all dropdown boxes after it should have the option
   * 'month' disabled, all dropdown boxes before it should have 'day' disabled
   *
   * If one of the pivots is set to 'month' all dropdown boxes before it should have 'day'
   * and 'week' disabled
   */
  applyPivotRestrictions: function() {

    this.pivots.find('option').prop('disabled', false);

    for(var pivot = 0, pLen = this.currentDrilldown.length; pivot < pLen; pivot++) {
      for(var restriction = 0, rLen = RESTRICTED_DRILLDOWN_ORDER.length; restriction < rLen; restriction++) {

        /*
         * As soon as we hit a pivot set with restricted value disable the values that
         * come after it in the restricted order on all subsequent pivots as well
         * as the values that come before it on previous pivots
         */
        if(this.currentDrilldown[pivot] === RESTRICTED_DRILLDOWN_ORDER[restriction]) {
          var valuesToDisableAfter = RESTRICTED_DRILLDOWN_ORDER.slice(restriction + 1);
          var valuesToDisableBefore = RESTRICTED_DRILLDOWN_ORDER.slice(0, restriction);

          for(var v = 0, vLen = valuesToDisableAfter.length; v < vLen; v++) {
            this.disableOption(this.pivots.slice(pivot + 1), valuesToDisableAfter[v]);
          }

          for(var v = 0, vLen = valuesToDisableBefore.length; v < vLen; v++) {
            this.disableOption(this.pivots.slice(0, pivot), valuesToDisableBefore[v]);
          }
        }

      }
    }
  },

  /*
   * We disable the ability for the user to hide a row if
   * any of the pivots are set to either 'day', 'week' or 'month'
   */
  checkHidingIsValid: function() {
    if(this.table.rowAction === "hide") {
      var hidingOn = true;

      for(var p = 0, pLen = this.currentDrilldown.length; p < pLen; p++) {
        if(this.currentDrilldown[p] in RESTRICTED_FOR_HIDING) {
          hidingOn = false;
          break;
        }
      }

      this.table.setHiding(hidingOn);
    }
  },

  /*
   * Sets the pivot's value in the dropdown as well as in the cell's attributes,
   * this is for consistency with the non-pivot columns
   */
  setPivot: function(pivot, val) {
    pivot.val(val);
    pivot.closest('td').attr('coln_id', val);
  },

  disableOption: function(pivots, value) {
    pivots.find('option[value=' + value + ']').prop('disabled', true);
  }
};

function TableSorter(table, initialSortColumn, initialSortOrder) {
  this.table = table;
  this.headerCells = this.table.element.find('thead tr').find('td[coln_id]');

  this.initialSortColumn = initialSortColumn;
  this.initialSortOrder = initialSortOrder;

  this.sortSet = false;

  this.setup();
};

/*
 * The sorter assumes the table is a TableWidget, use this helper to enable sorting a
 * any <table> element.
 *
 * Requires the table to have proper headers and body set:
 *
 * <thead>
 *  <tr> 
 *    <td coln_id=...><td coln_id=...>
 *  </tr>
 * <thead>
 *
 * <tbody>
 *  <tr> <td> <td> ... </tr>
 *  ...
 * </tbody>
 *
 *
 * initialSortOrder = "sort_ascending" | "sort_descending"
 *
 * intialSort = {id: "coln_id", type: "coln_type" }
 */
TableSorter.addSortingToStaticTable = function(element, initialSort, initialSortOrder) {
  var table = {
    element: element,
    root: { depth: 0 }
  };

  table.displayData = function() {
    sorter.sort();

    this.element.find('tbody').empty();
    for(var r = 0; r < this.root.children.length; r++) {
      this.element.find('tbody').append(this.root.children[r].ele);
    }
  };

  table.updateData = function() {
    this.setChildren();
    this.displayData();
  };

  table.setChildren = function() {
    this.root.children = [];

    var headers = [];

    this.element.find('thead tr td[coln_id]').each(function() {
      headers.push($(this).attr('coln_id'));
    });

    var rows = this.root.children;

    this.element.find('tbody tr').each(function() {
      var rawData = {};

      for(var h = 0; h < headers.length; h++) {
        rawData[headers[h]] = $($(this).find('td')[h]).attr('raw');
      }

      rows.push({
        ele: $(this),
        rawData: rawData
      });
    });
  };

  table.setChildren();

  sorter = new TableSorter(table, initialSort, initialSortOrder);

  return table;
};


TableSorter.prototype = {
  setup: function() {

    // Set initial sorting
    this.sortBy = this.initialSortColumn.id;
    this.sortType = this.initialSortColumn.type;
    this.sortOrder = this.initialSortOrder;

    if(this.initialSortColumn.drilldown) {
      this.sortDepth = 0;

      if(this.initialSortColumn.pivotable && this.table.pivotor) {
        this.sortBy = this.table.pivotor.currentDrilldown[0];
      } else {
        this.sortBy = this.sortBy[0];
      }
    }

    // Handles styling of sorted cells, set to an invalid column
    // to begin so that the initial sorted cells are not styled 
    this.sortedColumn = 0;

    var that = this;
    this.headerCells.click(function() {
      that.update($(this));
    });

  },

  /*
   * Responds to the event of a user clicking a sortable column header
   */
  update: function(columnHeader) {
    this.sortSet = true;

    this.sortType = columnHeader.attr('coln_type');
    this.sortDepth = columnHeader.attr('depth');
    this.sortBy = columnHeader.attr('coln_id');

    // On first click a column sorts in ascending order, then toggles back and forth
    this.sortOrder = columnHeader.hasClass("sort_descending") ? "sort_ascending" : "sort_descending";
    this.sortedColumn = columnHeader.index() + 1;

    // Remove sorting from other columns before apply this one
    this.headerCells.removeClass("sort_ascending sort_descending");
    columnHeader.addClass(this.sortOrder);

    this.table.displayData(true);
  },

  /*
   * If the pivots change on a column that we're sorting by
   * we need to update the values of the sorted column
   */
  pivotHeaderChanged: function(columnHeader) {

    // If the user hasn't explicitly set the sorting and the first column
    // is pivotable then we're sorting by the first pivot
    var initial = !this.sortSet && this.initialSortColumn.pivotable
      && columnHeader.attr('coln_id') === this.table.pivotor.currentDrilldown[0];

    // Check if the pivot was being sorted
    if((columnHeader.hasClass("sort_descending") || columnHeader.hasClass("sort_ascending"))
        || initial) {

      this.sortType = columnHeader.attr('coln_type');
      this.sortDepth = columnHeader.attr('depth');
      this.sortBy = columnHeader.attr('coln_id');
    }
  },

  sort: function() {
    this.sortRows(this.table.root.children, this.table.root.depth);
  },

  /*
   * Sorts the given rows, recursing on children
   */
  sortRows : function(rows, depth) {
    if(this.sortDepth === undefined || parseInt(this.sortDepth) === depth) {
      this.applySort(rows, this.sortBy, this.sortType, this.sortOrder);
    }

    for(var r = 0, len = rows.length; r < len; r++) {
      if(rows[r].children) {
        this.sortRows(rows[r].children, depth + 1);
      }
    }
  },

  /*
   * Sorts the given rows by the cell named in sortBy in the given order
   */
  applySort: function(rows, sortBy, type, order) {
    /*
     * rows.sort is repeated several times to avoid doing as much work
     * as possible within the actual comparision functions
     */
    if(order === "sort_ascending" && type === "string") {
      rows.sort(function(a, b) {
        return (a.rawData[sortBy] > b.rawData[sortBy]) ? 1 : -1;
      });
    }
    else if(order === "sort_descending" && type === "string") {
      rows.sort(function(b, a) {
        return (a.rawData[sortBy] > b.rawData[sortBy]) ? 1 : -1;
      });
    }
    else if (order === "sort_ascending") {
      rows.sort(function(a, b) {
        var a_v = a.rawData[sortBy];
        var b_v = b.rawData[sortBy];
        if (isNaN(a_v)) return -1;
        if (isNaN(b_v)) return 1;
        return a_v - b_v;
      });
    } else {
      rows.sort(function(b, a) {
        var a_v = a.rawData[sortBy];
        var b_v = b.rawData[sortBy];
        if (isNaN(a_v)) return -1;
        if (isNaN(b_v)) return 1;
        return a_v - b_v;
      });
    }
  },

  /*
   * Marks every td element under the sorted header in the given table as sorted
   */
  markSortedCells: function() {
    this.table.dataSection.find('td').removeClass("sorted");
    this.table.dataSection.find('td').filter(":nth-child(" + this.sortedColumn + ")").addClass("sorted");
  }


};

function TablePaginator(table, rowsPerPage) {
  this.table = table;

  this.prevPageElement = this.table.element.find('div.prev-page');
  this.nextPageElement = this.table.element.find('div.next-page');
  this.currPageElement = this.table.element.find('#curr-page');
  this.maxPageElement = this.table.element.find('#max-page');

  this.rowsPerPage = rowsPerPage;
  this.currentPage = 0;

  this.setup();
};

TablePaginator.prototype = {

  setup: function() {
      var that = this;

      // Go previous page
      this.prevPageElement.click(function() {
        if($(this).hasClass('disabled')) return;

        that.currentPage --;
        that.table.displayData(false, true);
      });

      // Go next page
      this.nextPageElement.click(function() {
        if($(this).hasClass('disabled')) return;

        that.currentPage ++;
        that.table.displayData(false, true);
      });
  },

  getStartIndex: function() {
    return this.currentPage * this.rowsPerPage;
  },

  getEndIndex: function() {
    return Math.min(this.rowsPerPage * (1 + this.currentPage), this.table.visibleRows.length);
  },

  /*
   * Updates the pagination UI based on current page and total number of rows
   */
  update : function() {
    /*
     * currentPage is 0-indexed, since pagesNeeded is the # of pages we need
     * in order to display all our rows it begins at 1
     */
    var pagesNeeded = Math.ceil(this.table.visibleRows.length / this.rowsPerPage);
    this.currPageElement.text(this.currentPage + 1);
    this.maxPageElement.text(pagesNeeded);

    if(this.currentPage === 0) {
      this.prevPageElement.addClass('disabled');
    } else {
      this.prevPageElement.removeClass('disabled');
    }

    if(this.currentPage === pagesNeeded - 1) {
      this.nextPageElement.addClass('disabled');
    } else {
      this.nextPageElement.removeClass('disabled');
    }

  }

};

function RootTableRow() {
  var row = new TableRow(this, '', {}, '');
  return row;
};

function TableRow(table, markup, rawData, name, hasDrilldownColumn, rowAction) {
  this.table = table;
  this.markup = markup;
  this.rawData = rawData;
  this.name = name;
  this.hasDrilldownColumn = hasDrilldownColumn;
  this.rowAction = rowAction;

  this.depth = 0;
  this.expandable = rawData.expandable || false;
  this.deleted = rawData.deleted || false;
  this.folded = false;
  this.isLoading = false;
  this.hierarchy = [];

  if(this.expandable) {
    this.setupExpanding();
  }

  if(this.rowAction) {
    this.setupRowAction();
  }

};

TableRow.prototype = {

  /*
   * Called by the table after the children have been fetched
   * and created
   */
  setChildren : function(children) {
    this.children = children;

    if(this.expandable) {
      this.setLoading(false);
    }

    for(var c = 0, len = children.length; c < len; c++)
    {
      var child = children[c];

      child.depth = this.depth + 1;

      if(child.hasDrilldownColumn) {
        child.markup.addClass("depth" + child.depth);
      }

      child.hierarchy = this.getHierarchy();
    };
  },

  getHierarchy: function() {
      return (this.name) ? this.hierarchy.concat(this.name) : this.hierarchy;
  },

  isVisible : function() {
    return !(this.folded || this.deleted);
  },

  hasChildren: function() {
    return this.children && this.children.length !== 0;
  },

  isExpanded: function() {
    return this.expandable && this.toggleImage.hasClass("unfolded");
  },

  setLoading : function(loading) {
    if(loading) {
      this.toggleImage.removeClass("folded");
      this.toggleImage.addClass("loading-children");
    } else {
      this.toggleImage.removeClass("loading-children folded");
      this.toggleImage.addClass("unfolded");
    }

    this.isLoading = loading;
  },

  loadFailed: function(response) {
    this.setLoading(false);
  },

  fetchData: function() {
    this.children = [];
    this.table.displayData(false);
    this.setLoading(true);
    this.table.fetchData(this);
  },

  /*
   * Adds the expand icon to this row and binds
   * a click handler to it
   */
  setupExpanding : function() {
    this.expandCell = this.markup.find('td.drilldown');
    this.toggleImage = $('<div class="folded">');

    this.expandCell.css('cursor', 'pointer');
    this.expandCell.find('p').closest('td').prepend(this.toggleImage)

    /*
     * Handle clicking on an expandable row
     */
    var that = this;
    this.expandCell.click(function() {
      if(that.isLoading) {
        return;
      }
      if(!that.hasChildren()) {
        that.fetchData();
      } else {
        that.toggleImage.toggleClass("unfolded");
        that.toggleImage.toggleClass("folded");

        /*
         * Whether or not children are visible depends on the current
         * state of the expand icon for this row
         */
        for(var c = 0, len = that.children.length; c < len; c++)
        {
          that.children[c].folded = that.toggleImage.hasClass("folded");
        }

        // Need to display data again after hide/show
        that.table.displayData();
      }

    });

  },

  /*
   * Handles actions that the user performs on a per row
   * basis
   */
  setupRowAction: function() {
    var that = this;

    this.markup.find('.has_button').click(function() {
      if(that.rowAction === "show") {
        ktAjaxWrapper({
          type: "GET",
          url: "/dashboard/filter/ajax_delete_filter/",
          data: {
              id: that.rawData.filter_id
          },
          success: function(msg) {
            // Need to trigger load since this filter could affect
            // other tables on the current page
            $(document).trigger('load_all_table_data');
          }
        });
      } else if(that.rowAction === "hide") {

        if(that.table.stopHiding) return;

        var hierarchy = that.getHierarchy();
        var filter = { 'channel_type': that.table.channelType }


        // Need to map each level of our hierarchy to the keys that
        // are expected by the subtype filter
        for(var depth = 0, len = hierarchy.length; depth < len; depth++) {
          key = that.table.subtypeFilterMapping[that.table.pivotor.currentDrilldown[depth]];
          filter[key] = hierarchy[depth];
        }

        ktAjaxWrapper({
          type: "GET",
          url: "/dashboard/filter/ajax_create_filter/",
          data: filter,
          success: function(data) {
            // Need to trigger load since this filter could affect
            // other tables on the current page
            $(document).trigger('load_all_table_data');
          }
        });
      }
    });
  }

};

/*
 *   Depends:
 *   table_utils.js
 *   table_sorter.js
 *   table_pivotor.js
 *   table_paginator.js
 *	 table_row.js
 */

(function($) {

  if(window.TEST_MODE) {
    var HEADER_TEMPLATE = new EJS({url: '../templates/_table_header.ejs'});
    var ROW_TEMPLATE = new EJS({url: '../templates/_table_row.ejs'});
  } else {
    var HEADER_TEMPLATE = new EJS({url: '/static/js/kt/table/templates/_table_header.ejs'});
    var ROW_TEMPLATE = new EJS({url: '/static/js/kt/table/templates/_table_row.ejs'});
  }

  //TODO should not be needed after QM calls consistent
  var DRILL_DOWN_QUERY_STRING = {
    'v1_traffic' : ['fcsst1', 'fcsst2', 'fcsst3'],
    'v1_revenue' : ['frsst1', 'frsst2', 'frsst3']
  };

  var ACTION_TOOLTIPS = {
    'show': 'Click to show.',
    'hide': 'Click to hide subtype.'
  };

  var NOTIFICATIONS = {
    noData: 'There is no data to display',

    tooMuchData: 'We have detected a large volume of data and are unable to render it at this time. Please <a href="http://support.kontagent.com/requests/new/">Contact Support</a> for assistance with this issue.',

    loadingData: 'Loading Data <img src="' + KT_ENV_JS['media_url'] + '/images/indicator.gif"></img>',

    allChildrenHidden: 'All subtypes hidden for this source'
  };

  var DATA_LENGTH_LIMIT = 3000; // for non paginated pages, this gets unruly
  var EXPORT_TIMEOUT = 40000;

  TableWidgetHandler = function(element, options) {
    this.element = element;

    this.dataUrl = options['data_url'];
    this.exportUrl = options['export_url'];
    this.exportFilename = options['export_filename'];

    this.table_id = options['slug'];
    this.title = options['title'];
    this.columns = options['columns'];
    this.bubble_text = options['bubble_text'];
    this.tableFrame = options['table_frame'];

    this.heatMap = options['heat'];
    this.paginate = options['paginate'];
    this.rowsPerPage = options['rows_per_page'];

    this.permitted = options['permitted'];

    this.initialSortColumn = options['sort_by'];
    this.initialSortOrder = options['sort_order'];

    this.channelType = options['channel_type'];
    this.rowAction = options['row_action'];
    this.initialDrilldown = options['initial_drilldown'];

    //TODO should not be needed after QM calls consistent
    this.qmVersion = options['qm_version'];
    this.subtypeFilterMapping = options['subtype_filter_mapping'];

    this.visibleRows = [];

    this.root = new RootTableRow();
  };

  TableWidgetHandler.prototype = {

    /*
     * Initiailize markup and event handlers for the table
     */
    Init: function() {
      /*
       * Generate HTML markup for this table
       */
      this.element.html(HEADER_TEMPLATE.render({
        tableFrame: this.tableFrame,
        title: this.title,
        columns: this.columns,
        drilldowns: this.initialDrilldown,
        rowAction: this.rowAction,
        table_id: this.table_id,
        bubble_text: this.bubble_text,
        secondary_data_style: (this.tableFrame) ? 'k-box-secondary' : 'tab_secondary_info',
        data_export_id: "data_export_" + this.table_id,
        paginate: this.paginate,
        permitted: this.permitted
      }));

      this.dataSection = this.element.find('tbody');

      if(this.permitted) {
        this.pivotor = new TablePivotor(this, this.initialDrilldown);
        this.sorter = new TableSorter(this, this.columns[this.initialSortColumn], this.initialSortOrder);

        if(this.paginate)
          this.paginator = new TablePaginator(this, this.rowsPerPage);

        this.setupDataExport();

        /*
         * Listen for the load table event
         */
        var that = this;

        //TODO this event should have a generic name to be triggered on charts and tables
        $(document).bind('load_all_table_data', function(event, msg) {
          if (msg === undefined || msg === that.table_id) {
            that.fetchRootData();
          }
        });
      }
    },

    /*
     * Fetches data for the entire table
     */
    fetchRootData: function() {
      this.dataSection.html(this.getNotification(NOTIFICATIONS.loadingData));
      this.fetchData(this.root);
    },

    /*
     * Refetches data for rows that are expanded at the given depth
     */
    fetchDataAtDepth: function(depth) {
      this.fetchDataAtDepthRec(this.root.children, 0, depth);
    },

    fetchDataAtDepthRec: function(rows, currentDepth, depthToApply) {
      for(var r = 0, len = rows.length; r < len; r++) {
        if(currentDepth === depthToApply) {
          if(rows[r].isExpanded()) {
            rows[r].fetchData();
          }
        } else {
          if(rows[r].children) {
            this.fetchDataAtDepthRec(rows[r].children, currentDepth + 1, depthToApply);
          }
        }
      }
    },

    /*
     * Fetches data from the server and passes it
     * to generateRows to be converted to JS objects
     *
     * This is triggered either by the 'load_all_table_data_event'
     * or when a user expands a row
     */
    fetchData: function(parentRow, fetchUrl) {
      var that = this;

      ktAjaxWrapper({
        type: 'GET',
        traditional: true,
        url: this.dataUrl,
        data: this.getFetchParameters(parentRow),
        dataType: 'json',
        success: function(data, textStatus) {
          if (!that.paginate && data.primary.length > DATA_LENGTH_LIMIT) {
            that.dataSection.html(that.getNotification(NOTIFICATIONS.tooMuchData));
            return;
          }

          // To apply a heat map we need to know the maximum values
          // in the top-level data to compare against
          if(that.heatMap && parentRow.depth === 0) {
            that.columnMaximums = TableUtils.computeColumnMaximums(data.primary, that.columns);
          }

          // Save and display the new set of rows
          parentRow.setChildren(that.generateRows(data.primary, parentRow.depth));
          that.displayData(true);

          // Display any secondary data given
          var secondaryDisplay = $("#" + that.table_id + "_secondary_data");

          var response = {};
          if (data.secondary) {
              secondaryDisplay.text(data.secondary);
              secondaryDisplay.css("display", "block");
          } else {
              secondaryDisplay.css("display", "none");
          }
        }, //success

        error: function(xhr) {
          var response;
          try {
            response = JSON.parse(xhr.responseText);
          } catch(e) {
            console && console.error("An error occurred while parsing error response.", e);
            response = {};
          }

          if(parentRow.depth == 0) {
            //TODO clean up
            $('#' + that.table_id + "_table .loading-row td").html(response.errorMessage ? response.errorMessage : "No data available");
          } else {
            parentRow.loadFailed(response);
         }

        } //error
      });
    },

    /*
     * If pivots are set need to append the url with the appropriate
     * parameters:
     *
     *    drilldown: A list of all the pivots set earlier in the hierachy, i.e. all
     *    the columns before the one we're retrieving data for
     *
     *    groupby:  The column to retreive data for
     *
     *    next_groupby: The pivot set for the blank column after data, used
     *    to determine if the rows are expandable further
     *
     * TODO remove once QM calls all use v2
     * For compatibility with old calls if qm_version is not v2 we send calls using:
     *    st1=name&st2=b&st3=c
     *
     */
    getFetchParameters: function(parentRow) {
      var data = {};

      if(this.pivotor.currentDrilldown.length > 0) {
        var hierarchy = parentRow.getHierarchy();

        if(this.qmVersion === 'v2') {
          // Append the row's ancestor list if it has one
          if(parentRow.depth > 0) {
            var drilldown = [];

            for(var p = 0; p < parentRow.depth; p++) {
              drilldown.push(this.pivotor.currentDrilldown[p] + ":" + hierarchy[p]);
            }

            data['drilldown'] = drilldown.join(',');
          }

          data['groupby'] = this.pivotor.currentDrilldown[parentRow.depth];

          var nextSelected = this.pivotor.currentDrilldown[parentRow.depth + 1];
          if(nextSelected) {
            data['next_groupby'] = nextSelected;
          }
        } else {
          for(var p = 0; p < parentRow.depth; p++) {
            data[DRILL_DOWN_QUERY_STRING[this.qmVersion][p]] = hierarchy[p];
          }
        }
      }

      return data;
    },

    /*
     * Translates each element of the JSON string into an object
     * representing a row on the table.
     */
    generateRows: function(data, depth) {
      var result = [];

      /*
       * Render HTML for each data row and create a new TableRow object
       */
      for(var i = 0, len = data.length; i < len; i++) {

        /*
        * Format each cell in the given data according to its type
        */
        var formattedRow = {};
        for(var c = 0, cLen = this.columns.length; c < cLen; c++) {
          var cellName = this.columns[c].id;
          var cellType = this.columns[c].type;
          var drilldown = this.columns[c].drilldown;

          // Value of drilldown cell depends on our current depth
          var dataKey = drilldown ? this.pivotor.currentDrilldown[depth] : cellName;

          // Consider the rows first cell value to be its name
          if(c === 0) {
            rowName = data[i][dataKey];
          }

          formattedRow[cellName] = {};

          formattedRow[cellName].data = TableUtils.formatCell(data[i][dataKey], cellType, this.columns[c].precision);

          // Add sparkline data
          if(this.columns[c].sparkline) {
            //TODO shouldn't have to hard-code '_by_day'
            formattedRow[cellName].sparklineData = data[i][cellName + "_by_day"];
          }

          // Apply heat map styling to numerical cells
          if(this.heatMap && cellType !== "string") {
            formattedRow[cellName].style = TableUtils.getHeatMapping(data[i], this.columnMaximums, cellName);
          }

        }

        var markup = ROW_TEMPLATE.render({
          numDrilldowns: this.pivotor.currentDrilldown.length,
          columns: this.columns,
          depth: depth,
          rowAction: this.rowAction,
          actionTooltip: ACTION_TOOLTIPS[this.rowAction],
          row : formattedRow
        });

        result.push(new TableRow(this, $(markup), data[i], rowName,
              this.pivotor.currentDrilldown.length !== 0, this.rowAction));
      }

      return result;
    },

    /*
     * Appends all currently visible rows to the table's html
     *
     * Can be triggered by a sorting change, a page change, when new
     * data has been fetched, or when a row's children are shown/hidden
     *
     */
    displayData: function(needToSort, pageChange) {

      if(this.root.children.length === 0) {
        this.dataSection.html(this.getNotification(NOTIFICATIONS.noData));
        return;
      }

      if(needToSort) {
        this.sorter.sort();
      }

      // Since a page is just a slice on the current visible rows we don't need to
      // recheck visibility when changing a page
      if(!pageChange) {
        this.visibleRows = this.getVisibleRows(this.root.children);
      }

      this.showCurrentPage();

      /*
       * Update various styling on the newly displayed rows
       */

      TableUtils.addSparklines(this.element);
      TableUtils.zebraStyleRows(this.dataSection);
      this.sorter.markSortedCells();

      // Need to call this every display since we might be showing a new
      // set of data that does not have the button turned off yet
      if(this.stopHiding) {
        this.setHiding(false);
      }
    },

    /*
     * Returns visible rows from the given list in order, recursing on children
     */
    getVisibleRows : function(rows) {
      var result = [];

      for(var r = 0, len = rows.length; r < len; r++) {
        if(rows[r].isVisible()) {
          result.push(rows[r]);

          // Recursively add any visible children this row might have
          if(rows[r].hasChildren()) {
            var visibleChildren = this.getVisibleRows(rows[r].children);

            if(visibleChildren.length === 0 && rows[r].isExpanded()) {
              // Currently we don't do anything in this case
              // the user will see the row icon as expanded but
              // nothing will be visible underneath
            } else {
              result = result.concat(visibleChildren);
            }
          }
        }
      }

      return result;
    },

    /*
     * Determines the slice of visible rows to display based
     * on the current page and appends it to the table
     */
    showCurrentPage: function() {
      var start, end;

      if(this.paginator) {
        start = this.paginator.getStartIndex();
        end = this.paginator.getEndIndex();
      } else {
        start = 0;
        end = this.visibleRows.length;
      }

      // Get rid of any old rows we might be displaying, need to call
      // detach instead of remove to preserve bound handlers
      this.dataSection.find('tr').detach();

      for(var r = start; r < end; r++) {
        this.dataSection.append(this.visibleRows[r].markup);
      }

      if(this.paginator) {
        this.paginator.update();
      }
    },

    /*
     * Binds the export link
     */
    setupDataExport : function() {
      var that = this;
      this.element.find('.export_link').click(function() {
        that.exportData();
      });
    },

    /*
     * We have two different ways that we tell the server we want
     * all the data for the given table for exporting
     *
     * V2
     * &export=A,B,C
     *
     * V1
     * &all_levels=1
     */
    getExportParameters: function() {
      var data = {};

      if(this.qmVersion === "v2") {
        // For QM v2 set the export parameter to a comma separated lists
        // of the drilldowns set up to the first blank

        if(this.pivotor.currentDrilldown.length > 0) {

          // Do this rather than indexOf, since IE8 does not support it
          for(var i = 0, len = this.pivotor.currentDrilldown.length; i < len; i++) {
            if(this.pivotor.currentDrilldown[i] === '') break
          }

          setDrilldowns = this.pivotor.currentDrilldown.slice(0, i);

          data['export'] = setDrilldowns.join(',');
        }
      } else {
        // QM v1

        data['all_levels'] = 1;
      }

      return data;
    },

    /*
     * Asks the server for all data for this table as a csv, then
     * echoes the data back so that a client-side download is triggered
     *
     * NOTE: The reason we just ask for a download directly is that we want
     * to show the user a "Please Wait" dialog while the data is being generated
     *
     */
    exportData: function() {
      var that = this;

      var loadingWin = new Boxy("<em>This may take a couple of moments. Please be patient as we export your data.</em>",
          {title: "Export in progress", modal: true, closeable: false});

      ktAjaxWrapper({
        type: 'GET',
        useFramework: false,
        traditional: true,
        timeout: EXPORT_TIMEOUT,
        url: this.exportUrl,
        data: this.getExportParameters(),
        dataType: 'text',
        success: function(data, textStatus) {
          // After data is received echo it back to the server to start a download
          loadingWin.hideAndUnload();
          TableUtils.triggerDownload(that.element, that.exportFilename, 'csv', data);
        },
        error: function(xhr) {
          loadingWin.hideAndUnload();
        }
      });

      return false;
    },

    /*
     * Builds a notification row with the given message
     */
    getNotification: function(msg) {
      return TableUtils.buildNotificationRow(msg, this.element.find('thead td').length);
    },

    /*
     * The pivotor wants to disable the ability to hide rows when time based pivots
     * are selected, i.e. day, week, month
     */
    setHiding: function(on) {
      var actionCell = this.element.find('td.has_button div');
      if(on) {
        actionCell
          .removeClass('disabled')
          .prop('title', ACTION_TOOLTIPS[this.rowAction]);
      } else {
        actionCell
          .addClass('disabled')
          .prop('title', 'Cannot hide when day, week or month is selected as a pivot.');
      }

      this.stopHiding = !on;
    }

  };

  /*
   * Register as a widget with JQuery
   *
   * Need an _init function which creates the handler
   * and a get_handler function which returns it
   */
  function TableWidget() {
    this.handler = null;
  }

  TableWidget.prototype = {
    _init: function() {
      this.handler = new TableWidgetHandler(this.element, this.options);
      this.handler.Init();
    },
    get_handler: function() {
      return this.handler;
    }
  };

  var tableWidget = new TableWidget();
  $.widget("kt.tableWidget", tableWidget);
  $.kt.tableWidget.getter = ["get_handler"];

})($);

(function($) {
  subtabTemplate = new EJS({url: '/static/js/kt/subtab/_subtab_widget.html'});

  /*
   * Register as a widget with JQuery
   *
   * Need an _init function which creates the handler
   * and a get_handler function which returns it
   */
  function SubtabWidget() {
    this.handler = null;
  }

  SubtabWidget.prototype = {
    _init: function() {
      this.handler = new SubtabWidgetHandler(this.element, this.options);
      this.handler.Init();
    },
    get_handler: function() {
      return this.handler;
    }
  };

  var subtabWidget = new SubtabWidget();
  $.widget("kt.subtabWidget", subtabWidget);
  $.kt.subtabWidget.getter = ["get_handler"];


  SubtabWidgetHandler = function(element, options) {
    this.element = element;

    this.title = options['title'];
    this.bubble_text = options['bubble_text'];
    this.index = options['index'];
    this.tabs = options['subtabs'];
  };

  SubtabWidgetHandler.prototype = {

    /*
     * Initiailize markup and event handlers for the widget
     */
    Init: function() {

      this.element.html(subtabTemplate.render({
        title: this.title,
        bubble_text: this.bubble_text,
        index: this.index,
        tabs: this.tabs
      }));

      this.tabContent = {};

      for(var t = 0, len = this.tabs.length; t < len; t++) {
        var id = this.tabs[t].id;

        this.tabContent[id] = $("#t" + id);

        // Take the tab from whenever it current is in the DOM and
        // put it within the subtab widget
        this.tabContent[id].detach();
        this.element.find('.k-box-body').append(this.tabContent[id]);
      }

      // Show the first tab initially
      this.showTab(this.tabs[0].id);

      var that = this;

      // Bind tab click
      this.element.find('.subtab_btn').click(function() {
        that.showTab($(this).attr('subtab'));
      });

      // Bind export click
      this.element.find('.export_link').click(function() {
        that.currentTab.tableWidget('get_handler').exportData();
      });

    },

    showTab: function(id) {

      // Hide content for all other tabs
      for(var t in this.tabContent) {
        this.tabContent[t].hide();
      }

      this.currentTab = this.tabContent[id];

      this.currentTab.show();
      TableUtils.addSparklines(this.currentTab);

      // Set selected styling for the current tab
      this.element.find('.subtab_btn').removeClass('active');
      this.element.find('[subtab=' + id + ']').addClass('active');
    }

  };

})($);

/*
 *   Depends:
 *	ui.core.js
 */

(function($) {

    TIME_MODE_NOUNS = { 
      'hourly' : 'Hour',
      'daily' : 'Day',
      'weekly' : 'Week',
      'monthly' : 'Month'
    }

    function KtSummaryTableHandler(element, options) {
        this.element = element;
        this.options = options;
        this.category = undefined;
        this.tab = undefined;
        this.page = undefined;
        this.table_id = undefined;
        this.root_url = undefined;
    }

    KtSummaryTableHandler.prototype = {

        init_impl: function() {
            this.category = this.options['category'];
            this.tab = this.options['tab'];
            this.page = this.options['page'];
            this.table_id = this.options['index'];
            this.root_url = this.options['root_url'];

            var summaryTableObj = this;

            $(document).bind('load_all_table_data', function(event, msg) {
                url = np_get_table_url(summaryTableObj, summaryTableObj.category, summaryTableObj.tab, summaryTableObj.page, summaryTableObj.table_id);
                
                // Blank out all of the cell data in the table
                // (All data cells have id's starting with "cell_")
                $(summaryTableObj.element).find('[id^=cell_]').text('---');
                summaryTableObj.update_time_strings();
                

                ktAjaxWrapper({
                    type: 'GET',
                    traditional: true,
                    caller: summaryTableObj.table_id,
                    url: url,
                    dataType: 'json',
                    success: function(data, textStatus) {
                        summaryTableObj.load_values_from_hash(data);
                    },
                    error: function() {
                    }
                });
            });

            $(this.element).parents(".k-box").find(".k-box-head-info").data("esc-title", escape(this.options['title']))

            var data_export_id = "data_export_" + this.table_id;
            $("#" + data_export_id).click(

            function() {
                var data_export_url = np_get_table_export_url(summaryTableObj, summaryTableObj.category, summaryTableObj.tab, summaryTableObj.page, summaryTableObj.table_id);
                document.location = data_export_url;
                return false;
            });

        },

        update_time_strings: function() {
          var time_mode = $('a.time_mode_button.active').data('time-mode');
          var time_adj = time_mode? time_mode.capitalize():"Daily";
          var time_noun = TIME_MODE_NOUNS[time_mode];

          this.element.find('time-string.adj').html(time_adj);
          this.element.find('time-string.noun').html(time_noun);
        },

        load_values_from_hash: function(hash) {
            for (h in hash) {
                var el = $('#' + h);
                el.empty();
                if (hash[h] != "undefined") {
                    el.append(hash[h]);
                }
            }
        }
    };

    function KtSummaryTable() {
        this.handler = null;

        this._init = function() {
            this.handler = new KtSummaryTableHandler(this.element, this.options);
            this.handler.init_impl();
        };
    }

    var kt_summary_table = new KtSummaryTable();
    $.widget("ui.ktSummaryTable", kt_summary_table);

})(jQuery);

(function($) {
  $.fn.tablePagination = function(handler) {
    var error = this.attr("tagName") != "TABLE" && console && console.error("This function only supports TABLE tag.");
    if(error !== false) {
      return;
    }
    var initialized = $("tfoot.pagination", this).length > 0;
    if(!initialized) {
      renderControls(this);
    }
    var table = this;
    this.bind("pagination-change", function() {
      var data = table.data("data");
      if(!data) {
        return;
      }
      var visibleData = $.grep(data, function(item) {
        return !item._hidden;
      });
      var rows = parseInt($(".pagination select[name=rows]", table).val());
      var total = visibleData.length;
      var start = parseInt($("input[name=start]", table).val()) - 1;
      if(start < 0) {
        start = 0;
        $("input[name=start]", table).val(1);
      }
      var sliced = visibleData.slice(start, start + rows)
      $(".pagination-total", table).text(total);
      $(".pagination-end", table).text(start + sliced.length);
      $(".pagination-start", table).text(start + 1);
      sliced.length > 0 && handler(sliced);
    });
    
    $("input[name=start]", this).val(1);
    this.trigger("pagination-change");
    return this;
  }
  var renderControls = function(table) {
    var html = '<tfoot class="pagination"><tr><td colspan="'+$("tr:eq(0)", table).children().length+'"><form>\
      Rows:\
        <select name="rows">\
          <option value="10">10</option>\
          <option value="25">25</option>\
          <option value="50" selected>50</option>\
          <option value="100">100</option>\
          <option value="1000">1000</option>\
        </select>\
      Jump To:\
        <input type="text" name="start" size="3" maxlength="6"/>\
      <span class="pagination-start">1</span> ~ <span class="pagination-end">-</span> of <span class="pagination-total">-</span>\
      <button class="pagination-prev">&lt;</button>\
      <button class="pagination-next">&gt;</button>\
    </form></td></tr></tfoot>';
    $("tbody", table).length > 0 ? $("tbody", table).after(html) : table.append(html);
    $(".pagination-next", table).click(function() {
      var rows = parseInt($(".pagination select[name=rows]", table).val());
      var total = $(".pagination-total", table).text(); 
      if(!isNaN(total)) {
        var val = parseInt($("input[name=start]", table).val()) + rows;
        if(val < total) {
          $("input[name=start]", table).val(val < 1 ? 1 : val);
          table.trigger("pagination-change");
        }
      }
      return false;
    });
    $(".pagination-prev", table).click(function() {
      var val = parseInt($("input[name=start]", table).val()) - parseInt($(".pagination select[name=rows]", table).val());
      $("input[name=start]", table).val(val < 1 ? 1 : val);
      table.trigger("pagination-change");
      return false;
    });
    $("select[name=rows], input[name=start]", table).change(function() {
      table.trigger("pagination-change"); 
    });
  }  
})(jQuery);

function populate_set_trends(id) {
  var ele = $('[name=trend_line_' + id + ']');
  var text = $("#trends_set_" + id).text();
  var trends;

  if(text) {
    trends = $("#trends_set_" + id).text().split(",");
  }

  for(idx in trends) {

    var name = trends[idx].match(/offset|moving/);
    var value = trends[idx].match(/\d+/)[0];
    var checkbox;

    //Preset values
    if(value == "30" || value == "7") {
      checkbox = ele.find('[name=' + name + '][value=' + value + ']');
    }
    else {
      checkbox = ele.find('[name=' + name + '][value=x]');
      custom_field = ele.find('[name=custom-' + name + ']');
      custom_field.val(value);
    }

    checkbox.prop('checked', true);
  }

  set_trend_form(id, false);
}

function set_trend_form(id, reset) {
  var ele = $('[name=trend_line_' + id + ']');

  ele.find('input:checkbox').each( function() {
    var from, to;

    if(reset) {
      from = 'saved';
      to = 'checked';
    } else {
      from = 'checked';
      to = 'saved';
    }

    value_to_set = $(this).attr(from);
    $(this).attr(to, value_to_set);
  });

  ele.find('input:text').each( function() {
    var from, to;

    if(reset) {
      from = 'saved';
      to = 'value';
    } else {
      from = 'value';
      to = 'saved';
    }

    value_to_set = $(this).attr(from);
    $(this).attr(to, value_to_set.toString() == 'true');
  });
}

function send_trend_options(id, boxy) {
  var trend_list = [];
  var valid = true;
  boxy = (typeof boxy == "undefined") ? true : boxy;
  var ele = $('[name=trend_line_'+id+']');

  $(ele).find('.trend_popup_form input:checkbox').each( function() {
    if($(this).is(':checked')) {
      var value = $(this).val();
      var name = $(this).attr('name');

     if(value == 'x') {
	var custom_value = $(ele).find('.trend_popup_form [name=custom-'+name+']').val();

	if(custom_value.match(/^[0-9]+$/) === null || parseInt(custom_value) < 1) {
          Boxy.alert("Custom value must be a whole number greater than 0.");
	  valid = false;
	  return false;
	}

	value = custom_value;
      }

      trend_list.push(name + value);

    }
  });

  if(valid) {
    /* Trend list data is expected as a hash */
    trend_list_param = {trend_list: 'none'};

    if( trend_list.length > 0) {
      trend_list_param = {trend_list: trend_list.join(",")};
    }

    $('#' + id).trigger('reload_chart', trend_list_param);

    if(boxy) {
      Boxy.get($(ele)).hide();
    }
    set_trend_form(id, false);
  }
}

(function($) {
  /*
   * Adds annotations to a KtHighCharts object
   *
   * Methods:
   *
   *  init
   *  redraw -- should be called whenever the HighChart is redrawn
   *  update -- stores the given list of annotation objects
   *
   */

  var methods = {
    init: function (options) {
      options = options || {};

      var settings = $.extend({
        use_application: true
      }, options);

      var chart_obj = this.data('chart_obj');

      chart_obj.current_annotations = {};
      chart_obj.annotation_images = {};
      chart_obj.date_annotations = {};
      chart_obj.use_annotation_application = options.use_application;

      // TODO don't need to bind this for each chart
      //
      $(document).bind('annotation_saved', function(event, msg) {
        var selected_chart_id = chart_obj._element.attr('custom_chart_id') || chart_obj._resource_id;
        var key = event.keyid;

        if (selected_chart_id === event.selected_chart_id
         || event.share_level === 'GLOBAL'||event.share_level === 'LIMITED'
         ||chart_obj.current_annotations[key]) {
          var annotation_obj = {
            'chart' : event.selected_chart_id,
            'creator' : event.creator,
            'date' : event.date,
            'epoch_date' : event.epochDate,
            'email' : event.email,
            'keyid' : event.keyid,
            'share_level' : event.share_level,
            'text' : event.text,
            'title' : event.title,
            'xid' : event.xid
          };

          if (event.submit_type === 'delete') {
            AnnotationHelpers.remove(chart_obj, key);
            AnnotationHelpers.erase(chart_obj, key);
          } else if (event.submit_type === 'submit') {
            var extremes = chart_obj.chart.xAxis[0].getExtremes();
            AnnotationHelpers.store(chart_obj, annotation_obj);
            AnnotationHelpers.drawAnnotation(chart_obj, key, annotation_obj, extremes);
          } else if (event.submit_type === 'edit') {
            var extremes = chart_obj.chart.xAxis[0].getExtremes();
            // calling store annotation because this can be used to make annotations global
            // this makes effectively new annotation objects in each chart
            if ((event.share_level === 'GLOBAL'|event.share_level === 'LIMITED')
               //If we changed to global, and this chart doesn't have this annotation
               &!chart_obj.current_annotations[key]){        //Save this annotation to this chart
               AnnotationHelpers.store(chart_obj, annotation_obj);
            }
            AnnotationHelpers.erase(chart_obj, key); //Remove the old image (automatically checks if it exists)

            if ((chart_obj.current_annotations[key]['share_level'] === 'GLOBAL'
               |chart_obj.current_annotations[key]['share_level'] === 'LIMITED')//If annotation was global
               &(event.share_level !== 'GLOBAL'&event.share_level!=='LIMITED')
                                                                      //And is no longer
               &selected_chart_id !== event.selected_chart_id){       //And this isn't the chart that took it
               AnnotationHelpers.remove(chart_obj, key);                      //Delete it
            } else{
               chart_obj.current_annotations[key] = annotation_obj;         //Otherwise, save the new annotation data and draw
               AnnotationHelpers.drawAnnotation(chart_obj, key, annotation_obj, extremes);
            }
          }
        }
      });
    },
    redraw: function() {
      AnnotationHelpers.draw(this.data('chart_obj'));
    },

    update: function(annotations) {
      var chart_obj = this.data('chart_obj');

      if (annotations !== undefined) {
        $.each(annotations, function(k,v) {
          AnnotationHelpers.setShareLevel(v); //convert share_level from private/shown_on
          AnnotationHelpers.store(chart_obj, v);
        });
      }
    }
  };

  $.fn.annotations = function(method) {
    // Method calling logic
    //
    // http://docs.jquery.com/Plugins/Authoring
    //
    if ( methods[method] ) {
      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof method === 'object' || ! method ) {
      return methods.init.apply( this, arguments );
    } else {
      $.error( 'Method ' +  method + ' does not exist on jQuery.tooltip' );
    }
  };

  var AnnotationHelpers = {
    draw: function(chart_obj) {
      var extremes = chart_obj.chart.xAxis[0].getExtremes();

      if(typeof chart_obj.base_extremes == "undefined") {
        chart_obj.base_extremes = chart_obj.chart.xAxis[0].getExtremes();
      }

      if(typeof extremes == "undefined") {
        extremes = chart_obj.base_extremes;
      }

      /* clear old annotations */
      this.clear(chart_obj);

      /* draw current ones */
      var _this = this;
      $.each(chart_obj.current_annotations, function(key, annotation) {
        _this.drawAnnotation(chart_obj, key, annotation, extremes);
      });
    },

    erase: function (chart_obj, key) {
      if (chart_obj.annotation_images[key]){ //if the image for this annnnotation is there to be removed
          var victim_img = chart_obj.annotation_images[key];
          victim_img.destroy();
          delete chart_obj.annotation_images[key];
      }
    },

    remove: function(chart_obj, key) {
      var victim = chart_obj.current_annotations[key];
      var date_key = victim['date'];
      var keyid = victim['keyid'];
      if (chart_obj.date_annotations[date_key]){
          var idx = chart_obj.date_annotations[date_key].indexOf(keyid);
          if (idx != -1) {
            chart_obj.date_annotations[date_key].splice(idx, 1);
          }
      }
      delete chart_obj.current_annotations[key];
    },

    clear: function(chart_obj) {

      $.each(chart_obj.annotation_images, function(k, image){
        image.renderer.alignedObjects = []; //TODO why is this needed?
        image.destroy();
      });
      chart_obj.annotation_images = {};
    },

    drawAnnotation: function (chart_obj, key, annotation_obj, extremes) {
      var annotation_date = annotation_obj['epoch_date'];

      var x = this.xToChartUnits(chart_obj.chart, annotation_date, extremes) - 5; /* -5 and -12 to align image correctly */
      var y_min = chart_obj.chart.yAxis[0].getExtremes().min //if left hand side is defined
      if (isNaN(y_min) && chart_obj.chart.yAxis[1]){
          y_min = chart_obj.chart.yAxis[1].getExtremes().min //otherwise get right hand side
      }
      var y = this.yToChartUnits(chart_obj.chart, y_min) - 14;
      if (!isNaN(x) & !isNaN(y)){
        var image = chart_obj.chart.renderer.image( KT_ENV_JS.media_url + '/images/annotation_icon.png', x, y, 13, 12);

        /* skip annotations not within the data */
        if (annotation_date < extremes.min || annotation_date > extremes.max) {
          return true; //same as continue
        }

        chart_obj.chart.xAxis[0].addPlotLine({
          color: "#E0E0E0",
          value: annotation_date,
          width: 2
        });

        image.attr({'zIndex': 15});
        image.css({'cursor': 'pointer'});

        var _this = this;
        image.on('click', function() {
          var a_lst = _this.getAnnotationsByDate(chart_obj, annotation_obj['date']);
          var el = chart_obj._element.closest('.kt-tab-chart');
          if(el.length === 0) {
            el = chart_obj._element;
          }
          handle_select_annotation(el.prop('id'), a_lst);
        });

        image.add();
        chart_obj.annotation_images[key] = image;
      }
    },

    getAnnotationsByDate: function(chart_obj, date_str) {
      var annotation_ids = chart_obj.date_annotations[date_str];
      var r = [];
      $.each(annotation_ids, function(i, keyid){
        r.push(chart_obj.current_annotations[keyid]);
      });
      return r;
    },

    setShareLevel: function(annotation) {
      annotation.share_level = AnnotationHelpers.privateShownOnToShareLevel(annotation.private, annotation.shown_on);
    },

    privateShownOnToShareLevel: function(private, shown_on) {
      var share_level;
      if (private){
        share_level = (shown_on==="global") ? "LIMITED" : "PRIVATE";
      } else {
        share_level = (shown_on==="global") ? "GLOBAL" : "PUBLIC";
      }
      return share_level;
    },

    store: function(chart_obj, anno_entry) {
      var anno_key = anno_entry['keyid'];
      if (!chart_obj.current_annotations[anno_key]) {
        chart_obj.current_annotations[anno_key] = anno_entry;
        var date_key  = anno_entry['date'];
        if (chart_obj.date_annotations[date_key] === undefined) {
          chart_obj.date_annotations[date_key] = [];
        }
        chart_obj.date_annotations[date_key].push(anno_key);
      }
    },

    /**
     * Converts x in chart units to distance from the left edge of the chart, in pixels.
     */
    xToChartUnits: function(chart, x, extremes) {
      var width = chart.plotWidth;

      if (typeof extremes == "undefined") {
        var extremes = chart.xAxis[0].getExtremes();
      }

      return chart.plotLeft + (x - extremes.min) / (extremes.max - extremes.min) * width;
    },

    /**
     * Converts y in chart units to distance from the top edge of the chart, in pixels.
     */
    yToChartUnits: function(chart, y, extremes) {
      var height = chart.plotHeight;

      if (typeof extremes == "undefined") { //checks left axis
        var extremes = chart.yAxis[0].getExtremes();
      }
      if (isNaN(extremes.max)|isNaN(extremes.min)) { //if that isn't defined, checks right axis
        if(chart.yAxis[1]) {
          var extremes = chart.yAxis[1].getExtremes();
        } else {
          return NaN;
        }
      }
      return chart.plotTop + (extremes.max - y) / (extremes.max - extremes.min) * height;
    }

  };

})(jQuery);

/**
 * HighChart handler for all chart types
 * @param element jQuery element
 * @param options hash of all options to the handler. options['highchart_options'] contains options passed to HighCharts.
 */

function AbstractHighChartHandler(element, options) {
  this.inheritedFrom = AbstractChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this._additional_highchart_options = {};
  this._default_highchart_options = {
    global: {
      useUTC: true
    },
    chart: {
      animation: false
    },

    title: {
      text: null
    },

    loading: {
      labelStyle: {
        top: '50%'
      }
    },

    plotOptions: {
      line: {
        marker: {
          enabled: false,
          symbol: 'circle'
        }
      },
      series: {
        animation: false,
        events: {
            legendItemClick: function (event) {
                this.visible? this.hide(): this.show();
                chart_obj.set_extreme();
                return false;
            }
        }
      }
    },

    yAxis: [
      {
        title: {
          text: null
        }
      },

      {
        title: {
          text: null
        },

        opposite: true
      }
    ],

    xAxis: {
      minPadding: 0.05,
      maxPadding: 0.05
    },

    credits: {
      enabled: false
    },

    legend: {
      borderWidth: 0
    },

    series: {
      allowPointSelect: true
    },

    exporting: {
      buttons: {
        exportButton: {
          enabled: false
        },

        printButton: {
          enabled: false
        }
      }
    },

    lang: {
      loading: "<span id='chart-loader-icon'></span><span id='chart-loader-text'>Loading...</span>"
    }
  };
}

/*
 * Convenience function to help with compatibility with
 * some of our plugins that expect these attributes
 *
 * Takes a regular HighCharts instance and adds some
 * properties to make it appear as a KtHighChart
 *
 */
AbstractHighChartHandler.AddKTAttributes = function(chart, resource_id) {
  var $element = $(chart.container).parent();

  var chart_obj = {
    _resource_id: resource_id,
    _element: $element,
    chart: chart
  };

  $element.data('chart_obj', chart_obj);
}

AbstractHighChartHandler.prototype = new AbstractChartHandler();

/**
 * These functions override AbstractChartHandler's methods
 * TODO: Remove $.extend()
 */
$.extend(AbstractHighChartHandler.prototype, {

  set_common_chart_options: function() {
    var chart_obj = this;

    this._additional_highchart_options = {
      yAxis: [
        {
          labels: {
            formatter: function () {
              return chart_obj.prefix + Highcharts.numberFormat(this.value, 0) + chart_obj.suffix;
            }
          },
          title: { text: chart_obj.y_axis_title }
        }
      ],
      xAxis: {
        title: {
          text: chart_obj.x_axis_title,
          margin: 15
        }
      },
      legend: {
        enabled: chart_obj.legend_enabled
      }
    }
  },

  _attach_header: function(template_str, params) {
    $(this._element).ktTemplate({
      template: template_str
    });
    $(this._element).ktTemplate('render', params);
  },

  _attach_footer: function() {
    if(this._options.filter_drawer) {
      var $footer = $('<div class="k-box-footer"></div>');
      this._element.find('.k-box').append($footer);

      var chart_filter = KtChartFilter.create({
        'chart_element': this._element,
        'filter_type': this._options.filter_drawer
      });

      $footer.append(chart_filter);
    }
  },


  _get_option: function(option, default_value) {
    var option_val = default_value;
    if (this._options[option] != undefined) {
      option_val = this._options[option];
    }
    return option_val;
  },

  _show_frame: function() {
    return this._get_option('show_frame', true);
  },

  /**
   * Option precidence (in ascending order):
   *     default_highchart_options -> additional_highchart_options -> options['highchart_options']
   */
  _merge_highchart_options: function() {
    this.highchart_options = this._default_highchart_options;
    $.extend(true, this.highchart_options, this._additional_highchart_options);
    if (this._options != undefined && 'highchart_options' in this._options) {
      $.extend(true, this.highchart_options, this._options['highchart_options']);
    }
  },

  bind_events: function() {
    this._bind_common_events();

    var so = this._so;
    var chart_obj = this;

    $(this._element).bind('trend_button_clicked', function(event) {
      if ($('a.time_mode_button.active').data('time-mode') == 'daily'){
        chart_obj._load_trend_popup(chart_obj._id);
      }
    });

    $(this._element).bind('reload_chart', function(event, extra_query_params) { /* merge queries parameters into _ajax object */
      $.extend(chart_obj._ajax.csv_query_params, extra_query_params);
      chart_obj.load_agnostic_data();
    });

    $(document).bind('clear_all_chart', function(event, msg) {
      chart_obj.clear_data();
    });

    $(document).bind('load_all_chart', function(event, msg) {
      chart_obj.load_data();
    });

    $(document).bind('load_all_charts_multi', function(event, msg){
      var saved_filter_id_list = event['saved_filters'];
      chart_obj._ajax.data_query_params['f_ids'] = saved_filter_id_list;
      chart_obj.load_multi_data();
    });

    $("#" + this._id).bind("redraw_chart", function(event) {
      chart_obj.draw(chart_obj._ajax.last_fetched_data);
    });

    if (this._show_trend_option()) {
      $("#" + this._trend_id).click(function() {
        $("#" + chart_obj._id).trigger("trend_button_clicked");
      });
    }

    $(document).bind('line_chart_dropdown_selected', function(event, msg) {
      if (msg == chart_obj._id) {
        chart_obj._ajax.csv_query_params['dropdown_v'] = event.dropdown_v;
        chart_obj.load_data();
      }
    });

    $(this._element).find('.advanced_link').attr('href', chart_obj.advanced_link());
    $(this._element).find('.print_link').click(function() {
      chart_obj.chart.print();
      return false;
    });

    this._bind_export(this);
  },

  init_impl: function() { /* Settings in abstract_chart_handler.js run first */

    this._common_assignments();
    this._merge_highchart_options();
    this.highchart_options['chart']['renderTo'] = 'so_' + this._id;
    this._enable_print_link = true;
    var chart_type = this._options['type'];
    var chart_obj = this;
    var $this = $(this);

    if (chart_type == "simple") {
      var template_str = this._get_simple_header();

      var params = {
        title: this._options['title'],
        chart_index: this._options['chart_index'],
        resource_id: this._options['resource_id'],
        id: this._id,
        height: this._height,
        half_height: this._int_height,
        bubble_text: this._options['bubble'],
        data_export_id: this._data_export_id
      };

      this._attach_header(template_str, params);
      this._attach_footer();

      $this = $(this);

    } else if (chart_type == "dropdown") {
      var dropdown_chart_id = this._id + "_dropdown";
      var header_html_str = this._get_dropdown_header();

      $(this._element).append(header_html_str);
      $(this._element).find(".k-box-head-info").data("esc-title", escape(this._options['title']));
      chart_obj._ajax.csv_query_params['dropdown_v'] = "1"; /* Default dropdown position */

      //TODO: bind the event handler
      $("#" + dropdown_chart_id).change(function() {
        var sel_id = $(this).prop('id');
        var sel_v = $("#" + sel_id + " option:selected").val();
        $(document).trigger({
          type: 'line_chart_dropdown_selected',
          dropdown_v: sel_v
        }, [chart_obj._id]);
      });
    }

    this.chart = new Highcharts.Chart(this.highchart_options);


    this.bind_events();
  },

  load_agnostic_data: function() {
    /* choose load_data() or load_multi_data() */
    if(this._ajax.data_query_params['f_ids']) {
      this.load_multi_data();
    } else {
      this.load_data();
    }
  },

  load_data: function() {
    this.perform_data_load(false);
  },

  load_multi_data: function() {
    this.perform_data_load(true);
  },

  perform_data_load: function(multi) {
    var chart_obj = this;
    this.chart.showLoading(); /* show loading before ajax finishes */
    //chart_obj.highchart_options.xAxis.maxZoom = get_zoom();

    var successHandler = function(data) {
      if (data.errorType === "ErrorRetrievingDataNewApplication") {
        // KT-5117
	    // PageMessage.addMessageToPage({
	    //   type: PageMessage.INFO,
	    //   content: 'Welcome to the Kontagent dashboard. To get started, visit our <a href="' + $('#documentation-link').attr('href') + '">documentation site</a>.' ,
	    //   hidable: true,
	    //   id: "page-level-chart-error"
        // });
      } else if (data.errorMessage) { // under np_ajax, some responses have HttpResponses without actual data but provide an error message
      	chart_obj.hide_chart_icons(chart_obj);
      } else {
   	  	chart_obj.show_chart_icons(chart_obj);
   	  }
      chart_obj.draw(data);
      chart_obj.set_extreme();
    };

    var errorHandler = function(jqXHR, textStatus, errorThrown) {
      /* Unexpected error has occured. Overlay the chart with a message. */
      chart_obj.hide_chart_icons(chart_obj);
      var dataError = $.parseJSON(jqXHR.responseText);
      chart_obj.chart.showLoading('This chart is experiencing technical difficulties.');
      if (dataError.responseCode){
        chart_obj.chart.showLoading(dataError.errorMessage);
      }
    };

    chart_obj.showing_popup = false;

    if(multi) {
      this._ajax.load_multi_chart_data(successHandler, errorHandler);
    } else {
      this._ajax.load_chart_data(successHandler, errorHandler);
    }
  },

  clear_data: function() {
    while (this.chart.series.length > 0) {
      this.chart.series[0].remove();
    }
  }
});

AbstractHighChartHandler.prototype.set_extreme = function () {
  /*
   * When Highcharts is given a single flat line it renders it in the center of the chart and omits
   * the y-axis. To avoid that behavior we pick an arbitrary cutoff of numThreshold and call setExtremes to force
   * the axis to be shown
   */

  var chart_obj = this;
  var numThreshold = 3;
  for (var axis = 0; axis < 2; axis++) {
    var yAxis = chart_obj.chart.yAxis[axis];
    var dataMax = yAxis.getExtremes().dataMax;
    var dataMin = yAxis.getExtremes().dataMin;

    if (!chart_obj.all_series_hidden() && dataMax === 0 && dataMax === dataMin) {
      yAxis.setExtremes(0, numThreshold);
    }
  }
}

// this function checks to see if all of the series are hidden
AbstractHighChartHandler.prototype.all_series_hidden = function () {
    var series = this.chart.series;
    for (index in series)
       if (series[index].visible)
           return false;
    return true;
}

/**
 * Setting up a highcharts object while the chart container is hidden
 * sets the width incorrectly. Reinstantiating the chart solves this.
 */
AbstractHighChartHandler.prototype.recreate_highchart = function() {
  this.chart.destroy();
  this.chart = new Highcharts.Chart(this.highchart_options);
};

/**
 * High Line Chart Handler, with line chart specific options
 */

function y_axis_zoom_handler(evt){
    var chart = evt.target,
        dataMax = []
        dataMin = []
        series = chart.series,
        xAxis = evt.xAxis !== undefined? evt.xAxis[0] : undefined,
        xMin = xAxis !== undefined? xAxis.min : undefined,
        xMax = xAxis !== undefined? xAxis.max : undefined,
        xExtremes = chart.series[0].xAxis.getExtremes(),
        xSmallestInterval = chart.smallestInterval,
        loop_count = 0;

        while ((xMax - xMin)/xSmallestInterval < 5 && loop_count < 5){
            if((xMin-xSmallestInterval) > xExtremes.dataMin && loop_count < 3){
                xMin-=xSmallestInterval;
            } else if ((xMax+xSmallestInterval) <= xExtremes.dataMax ) {
                xMax+=xSmallestInterval;
            }
            loop_count++;
        }

    if (xAxis === undefined){
        return true;
    }

    for (index in series){
        var curr_series = series[index],
            yAxisSide = curr_series.options.yAxis;

        if (curr_series.visible === true){
            $.map(curr_series.data, function (elementOfArray,indexInArray) {
                if (elementOfArray.x >= xMin && elementOfArray.x <=xMax){
                    if (dataMax[yAxisSide] === undefined && dataMin[yAxisSide] === undefined){
                        dataMax[yAxisSide] = elementOfArray.y;
                        dataMin[yAxisSide] = elementOfArray.y;
                    }
                    dataMax[yAxisSide] =  Math.max(elementOfArray.y , dataMax[yAxisSide]);
                    dataMin[yAxisSide] =  Math.min(elementOfArray.y , dataMin[yAxisSide]);
                }
            });
        }
    }

    for (index in dataMax){
        // An example yMax is 1700 and yMin is 100, yMax stays as 1700, and yMin becomes 0
        var yMax = Math.max(dataMax[index],0),
            yMin = Math.min(dataMax[index],0),
            // The line below is ultimately to find the right number of digits for the divisor, for both decimals and whole numbers.
            // Math.log(Math.abs(yMax))/Math.log(10) --> to convert to log base 10. abs is needed because log doesnt work with - numbers;
            // Math.floor so that you will get the correct number of digits you want.
            // With our example, yMaxNumDigits is going to be 3, and yMinNumDigits becomes 1
            yMaxNumDigits = yMax === 0? 0 : Math.floor(Math.log(Math.abs(yMax))/Math.log(10)),
            yMinNumDigits = yMin === 0? 0 : Math.floor(Math.log(Math.abs(yMin))/Math.log(10)),
            // With our example, maxDivisor becomes 1000, and minDivisor becomes 1
            maxDivisor = Math.pow(10,yMaxNumDigits),
            minDivisor = Math.pow(10,yMinNumDigits);

        // What happens here is, we divide the max value by 10^(number of digits -1), ceil it, then multiply back the 10^(number of digits -1)
        // With our example, yMax becomes 2000, and yMin is 0
        yMax = (Math.ceil(yMax/maxDivisor))*maxDivisor;
        yMin = (Math.floor(yMin/minDivisor))*minDivisor;

        evt.yAxis[index].axis.setExtremes(yMin,yMax,false);
    }
}

/*function get_zoom(){
    // This returns the max zoom of a chart based on the time-mode selected. montly is set to *31 days because in a monthly scale, one single day will not be noticed
    var zoom = {'hourly':14400000, 'daily':14400000*24,'weekly': 14400000*24*7,'monthly': 14400000*24*31};
    return zoom[$('a.time_mode_button.active').data('time-mode')];
}*/

function HighLineChartHandler(element, options) {
  this.inheritedFrom = AbstractHighChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this.area_marker_radius = 3;
  this.area_marker_no_radius = 0;
  var dateTimeLabelFormat = null;
  var format_precision = [0, 0];

  /* Munge options into a per-axis basis -- we need precision for left/right axis */
  for(var i = 0; i < chart_obj._options.axes.length; i++) {
    var side = chart_obj._options.axes[i] == "left" ? 0 : 1;
    var new_precision = chart_obj._options.series_precision[i];
    if(format_precision[side] < new_precision) {
      format_precision[side] = new_precision;
    }
  }

  this.format_precision = format_precision;

  this.set_common_chart_options();

  element.annotations();

  this._additional_highchart_options = $.extend(this._additional_highchart_options, {
    chart: {
      defaultSeriesType: 'line',
      zoomType: 'x',
      marginTop: '40',
      events: {
        redraw: function(event) {
          element.annotations('redraw');
        },
        selection: y_axis_zoom_handler
      }
    },
    plotOptions: {
      line: {
        marker: {
          enabled: false,
          states: {
            hover: {
              enabled: true,
              radius: 3,
              lineWidth: 1
            }
          }
        },
        events: {
          click: function(event) {}
        }
      },

      area: {
        marker: {
          enabled: true,
          lineColor: '#FFFFFF',
          lineWidth: 1,
          symbol: 'circle',
          radius: chart_obj.area_marker_radius,
          states: {
            hover: {
              radius: 5,
              lineWidth: 1
            }
          }
        },
        events: {
          click: function(event) {}
        }
      }
    },

    yAxis: [
      {
        labels: {
          formatter: function() {
            return chart_obj.prefix + Highcharts.numberFormat(this.value, format_precision[0]) + chart_obj.suffix;
          }
        },
        title: {
          text: chart_obj.y_axis_title
        }
      },

      {
        labels: {
          formatter: function() {
            return chart_obj.prefix + Highcharts.numberFormat(this.value, format_precision[1]) + chart_obj.suffix;
          }
        }
      }
    ],

    xAxis: {
      maxPadding: 0,
      dateTimeLabelFormats: {
        second: '%H:%M:%S',
        minute: '%H:%M',
        hour: '%H:%M',
        day: '%b %e',
        week: '%b %e, %Y',
        month: '%b %e, %Y',
        year: '%Y'
      }
    },

    tooltip: {
      formatter: function() {
        var trend_multiplier = (chart_obj._ajax.last_fetched_data.names.length //number of trendlines on chart + 1
                               /chart_obj._options.series_precision.length);
        var series_precision_index = (this.series.index - (this.series.index % trend_multiplier))/trend_multiplier
        //series_precision has n elements, but with trendlines, indices are multiplied. So we divide our indices
        var precision = chart_obj._options.series_precision[series_precision_index];
        return '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + chart_obj.prefix + Highcharts.numberFormat(this.y, precision) + chart_obj.suffix;
      }
    }
  });

  if(this._options.highchart_options.xAxis.type == "datetime") {
    $.extend(true, this._additional_highchart_options, {
      xAxis: {
        //maxZoom:get_zoom(),
        labels: {
          formatter: function() {
            //Set the date time format, if only one data entry exists (same start/end point) force it to be 'Month day, year'
            dateTimeLabelFormat = (chart_obj._ajax.last_fetched_data.data.length > 1) ? this.dateTimeLabelFormat : chart_obj._additional_highchart_options.xAxis.dateTimeLabelFormats.month;
            return Highcharts.dateFormat(dateTimeLabelFormat, this.value);
          }
        }
      },
      tooltip: {
        formatter: function() {
        var trend_multiplier = (chart_obj._ajax.last_fetched_data.names.length //number of trendlines on chart + 1
                               /chart_obj._options.series_precision.length);
        var series_precision_index = (this.series.index - (this.series.index % trend_multiplier))/trend_multiplier
        //series_precision has n elements, but with trendlines, indices are multiplied. So we divide our indices
        var precision = chart_obj._options.series_precision[series_precision_index];

          var dateTimeFormatToUse = '%b %e, %Y';
          if($('a.time_mode_button.active').data('time-mode') == 'hourly') {
            dateTimeFormatToUse += ' %H:%M';
          }
          else if(dateTimeLabelFormat.indexOf('H') > -1) {
            dateTimeFormatToUse += ' ' + dateTimeLabelFormat;
          }

          return '<b>' + Highcharts.dateFormat(dateTimeFormatToUse, this.x) + '</b><br/>' + this.series.name + ': ' + chart_obj.prefix + Highcharts.numberFormat(this.y, precision) + chart_obj.suffix;
        }
      }
    });
  }

  if(typeof this._options.y_max != "undefined") {
    this._additional_highchart_options.yAxis[0].max = this._options.y_max;
  }

  if(typeof this._options.y_min != "undefined") {
    this._additional_highchart_options.yAxis[0].min = this._options.y_min;
  }
}
HighLineChartHandler.prototype = new AbstractHighChartHandler();

HighLineChartHandler.prototype.draw = function(data) {
  var chart_obj = this;
  var chart_data = data['data'];
  var epoch_dates = data['epoch_dates'];
  var names = data['names'];
  var colors = data['colors'];
  var xaxis_type = this._options['highchart_options']['xAxis']['type'];

  this._element.annotations('update', data['annotations']);

  if(chart_data) {
    // For line charts if we're showing a single point of data, enable drawing of points
    chart_obj.highchart_options.plotOptions.line.marker.enabled = (data.data && data.data.length === 1);

    // If there are more than 2 primary lines (not trend lines) we turn off area filling
    var data_lines = _.filter(colors, function(color) { return !color.is_trend; });
    if(data_lines.length > 2) {
      for(var c = 0; c < data_lines.length; c++) {
        data_lines[c]['fill_alpha'] = "0";
      }
    }


    if (chart_obj.highchart_options['plotOptions']['area'] != undefined) {
      /* if len(data) > 50, don't show the dots. Show lines only. */
      var proper_radius = (chart_data.length > 50) ? chart_obj.area_marker_no_radius : chart_obj.area_marker_radius;
      if (chart_obj.highchart_options['plotOptions']['area']['marker']['radius'] != proper_radius) {
        chart_obj.highchart_options['plotOptions']['area']['marker']['radius'] = proper_radius;
        chart_obj.chart = new Highcharts.Chart(chart_obj.highchart_options);
      }
      if (chart_data.length === 1) {
        //Padding adjusted to move the single point to the middle of the plot
        //0.1 is the default padding, 50% of this is used to move the point to the center
        chart_obj.highchart_options['xAxis']['maxPadding'] = 0.05;
        chart_obj.chart = new Highcharts.Chart(chart_obj.highchart_options);
      }
    }
  }

  if(this._element.is(":hidden")) {
    return;
  }

  this.recreate_highchart();
  var chart = this.chart;
  chart.showLoading();
  this.clear_data();

  /* Errors */
  if ('errorMessage' in data) {
    chart.showLoading(data['errorMessage']);
    return;
  }

    //When going from non Trendline to Trendline matching the axes type to name
    var counter = 0,
        inner_counter = 0,
        length = chart_obj._options.axes.length, // length is used because chart_obj._options.axes.length is being changed in the for loop before
        axes = chart_obj._options.axes.slice(0), // axes needs to be copied because chart_obj._options.axes is being changed
        multiplier = 1; // Multiplier is the ratio between the number of total series and the series that arent trendlines.

    for(counter = 0; counter < length; counter++){
        //When trends are added, chart_obj._options.axes are not updated, so there will be less axes then there are names.
        if(chart_obj._options.axes.length < names.length) {
            //multiplier is set this way because the number of series are the number of names, and length is the number of series that arent trendlines (this is set at the very end)
            multiplier = names.length/length;
            //this sets a series and its corresponding trendlines to the same side
            for(inner_counter = 0; inner_counter < multiplier; inner_counter++)
                chart_obj._options.axes[(counter*multiplier)+inner_counter] = axes[counter];
        }
    }

  /* Data */
  $.each(colors, function(i, color) {
    var series = {
      name: names[i],
      data: $.map(chart_data, function(dataPoint) {
        // The string date is stored at the beginning of the data array
        // Equivalent epoch dates are stored in epoch_dates as { string date: epoch date, ... }
        var date = xaxis_type === 'datetime' ? epoch_dates[dataPoint[0]] : dataPoint[0];
        return [[date, dataPoint[1 + i]]];
      }),
      color: color.color
    };
    series.dashStyle = color.dashStyle;

    if(color.fill_alpha != "0") {
      series.type = 'area';
      series.fillOpacity = color.fill_alpha / 100.0;
    }

    if(chart_obj._options.axes.length == names.length) {
      series.yAxis = chart_obj._options.axes[i] == "right" ? 1 : 0;
    }

    chart.addSeries(series);
  });

  // setting the chart_obj axes back to the way it was before trendlines are added. This is resetted so that other trendlines can be added or removed even if there was a previously existing trendline
   for(counter = 0; counter < names.length/multiplier; counter++)
      chart_obj._options.axes[counter] = chart_obj._options.axes[counter*multiplier];
   for(counter = chart_obj._options.axes.length; counter > names.length/multiplier; counter--)
      chart_obj._options.axes.pop();

  chart.hideLoading();
};


/**
 * High Bar Chart Handler, with bar chart specific options
 */

function HighBarChartHandler(element, options) {
  this.inheritedFrom = AbstractHighChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this._additional_highchart_options = {
    chart: {
      type: 'bar',
      inverted: chart_obj._get_option('inverted'),
      marginTop: '40'
    },
    plotOptions: {
      bar: {
        shadow: false,
        borderWidth: 0,
        dataLabels: {
          enabled: true,
          formatter: function () {
            return chart_obj.prefix + Highcharts.numberFormat(this.y, 2) + chart_obj.suffix;
          }
        }
      }
    },
    yAxis: [
      {
        labels: {
          formatter: function () {
            return chart_obj.prefix + Highcharts.numberFormat(this.value, 0) + chart_obj.suffix;
          }
        }
      }
    ],
    tooltip: {
      formatter: function () {
        return '<b>' + this.x + '</b><br/>' + this.series.name + ': ' + chart_obj.prefix + Highcharts.numberFormat(this.y, 2) + chart_obj.suffix;
      }
    }
  };
}
HighBarChartHandler.prototype = new AbstractHighChartHandler();

HighBarChartHandler.prototype.draw = function(data) {
  var chart_data = data['data'];
  var names = data['names'];
  var colors = data['colors'];

  if(this._element.is(":hidden")) {
    return;
  }

  this.recreate_highchart();
  var chart = this.chart;
  chart.showLoading();
  this.clear_data();

  /* Errors */
  if ('errorMessage' in data) {
    chart.showLoading(data['errorMessage']);
    return;
  }

  /* Data */
  var categories = $.map(chart_data, function(item) {
    return item[0];
  });

  chart.xAxis[0].setCategories(categories);
  var color = colors[0];

  series_data = $.map(chart_data, function(item) {
    return item[0];
  });

  var series = {
    type: 'bar',
    name: names[0],
    data: chart_data,
    color: color['color']
  };

  chart.addSeries(series);
  chart.hideLoading();
}

/**
 * High Stacked Column chart
 */

function HighColumnStackedChartHandler(element, options) {
  this.inheritedFrom = AbstractHighChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this.set_common_chart_options();

  this._additional_highchart_options = $.extend(this._additional_highchart_options, {
    chart: {
      defaultSeriesType: 'column'
    },
    plotOptions: {
      column: {
        borderWidth: 0,
        shadow: false,
        dataLabels: true,
        stacking: 'normal'
      }
    },

    xAxis: {
      labels: {
        rotation: -45,
        align: 'right',
        style: {
          font: 'bold #000 13px Verdana, sans-serif'
        }
      },
      title: {
        text: chart_obj.x_axis_title,
        margin: 15
      }
    },

    tooltip: {
      shared: true,
      formatter: function() {
        var s = '<b>' + (this.x).escapeHTML() + '</b>';
        $.each(this.points, function(i, point) {
          s += '<br/>' + point.series.name + ': ' + chart_obj.prefix + Highcharts.numberFormat(this.y, chart_obj._precision) + chart_obj.suffix;
        });

        return s;
      }
    }
  });

  if(options && options.y_max !== undefined) {
    this._default_highchart_options.yAxis[0].max = options.y_max;
  }

  if(options && options.y_min !== undefined) {
    this._default_highchart_options.yAxis[0].min = options.y_min;
  }

}

HighColumnStackedChartHandler.prototype = new AbstractHighChartHandler();

HighColumnStackedChartHandler.prototype.draw = function(data) {
  var chart_data = data['data'];
  var names = data['names'];
  var colors = data['colors'];

  if(this._element.is(":hidden")) {
    return;
  }

  this.recreate_highchart();
  var chart = this.chart;
  chart.showLoading();
  this.clear_data();

  /* Errors */
  if ('errorMessage' in data) {
    chart.showLoading(data['errorMessage']);
    return;
  }

  /* Data */
  var categories = $.map(chart_data, function(item) {
    var category_str = item[0];
    if (category_str.split('-').length == 3) {
      // Does the string has - in it?
      // If so, pass it into Dateparse
      // Assumption: the date string coming  back from QM is always
      // going to be in YYYY-MM-DD format.
      var dt = Date.parse(category_str); // Date.parse returns ms since 1/1/1970
      if (dt !== null) {
        var dateTimeFormatToUse = '%b %e';
        return Highcharts.dateFormat(dateTimeFormatToUse, dt);
      } else {
        return category_str;
      }
    }
    return category_str;
  });

  chart.xAxis[0].setCategories(categories);

  for (var i = 0; i < names.length; i++) {
    var color = colors[i];

    var series_data = $.map(chart_data, function(item) {
      return [item[1 + i]];
    });

    var series = {
      name: names[i],
      data: series_data,
      color: color['color']
    };

    chart.addSeries(series);
  }

  chart.hideLoading();
};

/**
 * High Stacked Column chart (percentage)
 */

function HighColumn100StackedChartHandler(element, options) {
  this.inheritedFrom = HighColumnStackedChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this._additional_highchart_options = {
    chart: {
      defaultSeriesType: 'column'
    },
    plotOptions: {
      column: {
        borderWidth: 0,
        shadow: false,
        dataLabels: true,
        stacking: 'percent'
      }
    },

    xAxis: {
      labels: {
        rotation: -45,
        align: 'right',
        style: {
          font: 'bold #000 13px Verdana, sans-serif'
        }
      }
    },

    tooltip: {
      shared: true,
      formatter: function() {
        var s = '<b>'+ (this.x).escapeHTML()+ '</b>';
        $.each(this.points, function(i, point) {
          s += '<br/>' + point.series.name + ': ' + chart_obj.prefix + Highcharts.numberFormat(this.percentage, 2) + chart_obj.suffix;
        });

        return s;
      }
    }

  };
}

HighColumn100StackedChartHandler.prototype = new HighColumnStackedChartHandler();

/**
 * High Pie Chart Handler, with pie chart specific options
 */

function HighPieChartHandler(element, options) {
  this.inheritedFrom = AbstractHighChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this._additional_highchart_options = {
    chart: {
      defaultSeriesType: 'pie',
      marginRight: 150
    },
    plotOptions: {
      pie: {
        allowPointSelect: true,
        cursor: 'pointer',
        fillOpacity: 0.7,
        showInLegend: true,
        borderWidth: 0,
        shadow: false,
        dataLabels: {
          enabled: true,
          color: '#555555',
          connectorColor: '#E5E5E5',
          formatter: function() {
            return this.point.name + ': ' + Highcharts.numberFormat(this.percentage, 1) + ' %';
          }
        }
      }
    },

    legend: {
      align: 'right',
      layout: 'vertical',
      verticalAlign: 'middle',
      labelFormatter: function() {
        return this.name + ": " + Highcharts.numberFormat(this.y, chart_obj._precision);
      }
    },

    tooltip: {
        formatter: function() {
            return '<b>'+ this.point.tooltip_name +'</b>: ' + Highcharts.numberFormat(this.y, 2);
        }
    }

  };
}

HighPieChartHandler.prototype = new AbstractHighChartHandler();

function limitStrLength(s,maxlen) {
    if (s.length <= maxlen) {
        return s;
    } else {
        return s.slice(0,maxlen) + '...';
    }
}

HighPieChartHandler.prototype.draw = function(data) {
  var chart_data = data['data'];
  var names = data['names'];
  var colors = data['colors'];
  var series_data = [];

  if(this._element.is(":hidden")) {
    return;
  }

  this.recreate_highchart();
  var chart = this.chart;
  chart.showLoading();
  this.clear_data();

  /* Errors */
  if ('errorMessage' in data) {
    chart.showLoading(data['errorMessage']);
    return;
  }

  /* Data */
  for (var i = 0; i < names.length; i++) {

    series_data[i] = {
      tooltip_name: names[i],
      name: limitStrLength(names[i],25),
      color: colors[i]['color'],
      y: chart_data[i]
    };
  }

  //Color order is based on size of each series
  series_data.sort(function(a, b) { return b.y - a.y; });

  for (var i = 0; i < series_data.length; i++) {
    series_data[i].color = colors[i].color;
  }

  var series = {
    data: series_data
  };

  chart.addSeries(series);
  chart.hideLoading();
};

/**
 * High Scatter Plot
 */

function HighScatterPlotHandler(element, options) {
  this.inheritedFrom = AbstractHighChartHandler;
  this.inheritedFrom(element, options);
  var chart_obj = this;

  this._additional_highchart_options = {
    chart: {
      defaultSeriesType: 'scatter',
      zoomType: 'xy'
    },

    xAxis: {
      title: {
        text: 'x'
      }
    },

    yAxis: [{
      title: {
        text: 'y'
      }
    }],

    tooltip: {
        formatter: function() {
            return '<b>'+ this.point.tooltip_name +'</b><br />x: ' + Highcharts.numberFormat(this.x, 2) + '<br />y: ' + Highcharts.numberFormat(this.y, 2);
        }
    }
  };
}

HighScatterPlotHandler.prototype = new AbstractHighChartHandler();

HighScatterPlotHandler.prototype._load_trend_popup = function(id, resource_id_to_use) {
  //toggle the regression line
  if (!this.best_fit_series.visible) {
    this.best_fit_series.show();
  } else {
    this.best_fit_series.hide();
  }
}

HighScatterPlotHandler.prototype.draw = function(data) {
  var chart_data = data['data'];
  var names = data['names'];
  var annotations = data['annotations'];
  var colors = data['colors'];
  var series_data = [];

  if(this._element.is(":hidden")) {
    return;
  }

  this.recreate_highchart();
  var chart = this.chart;
  chart.showLoading();
  this.clear_data();

  /* Errors */
  if ('errorMessage' in data) {
    chart.showLoading(data['errorMessage']);
    return;
  }
  
  /* generate color gradient */
  var starting_color = hexColorToRgbArray(colors[0]['color']);
  var ending_color = hexColorToRgbArray(colors[1]['color']);
  
  /* determine darker color and have it be the starting color */
  var sum = 0;
  $(starting_color).each(function() { sum += this;});
  $(ending_color).each(function() { sum -= this;});
  if (sum > 0) {
    // switch
    var temp_color = starting_color;
    starting_color = ending_color;
    ending_color = temp_color;
    
    temp_color = colors[0]; // totally abuse variables
    colors[0] = colors[1];
    colors[1] = temp_color;
  }
  
  var color_gradient = $(generateColorGradient(starting_color, ending_color, chart_data.length)).map( function(index, colorArray) {
    return 'rgba(' + colorArray.join(', ') + ', .75)'; // add alpha so you can visualize overlaps
  });

  /* Data */
  var x_y_chart_data = [];
  for (var i = 0, chart_data_length = chart_data.length; i < chart_data_length; i++) {
    var chart_point = chart_data[i];
    series_data[i] = {
      tooltip_name: chart_point[0], //date
      name: limitStrLength(chart_point[0],25),
      x: chart_point[1],
      y: chart_point[2],
      color: color_gradient[i],
      marker: {
        fillColor: color_gradient[i],
        states: {
          hover: {
            fillColor: color_gradient[i],
            lineWidth: 2
          }
        }
      }
    };
    x_y_chart_data.push([chart_point[1], chart_point[2]]);
  }
  
  var scatter_plot_label_text = 'older newer';
  var scatter_plot_label = $(generateColorGradient(starting_color, ending_color, scatter_plot_label_text.length)).map( function(index, colorArray) {
    return '<span style="color:rgba(' + colorArray.join(', ') + ', .75)' +';">' + scatter_plot_label_text[index] + '</span>';
  }).get().join("");
  
  var series = {
    name: scatter_plot_label,
    color: 'rgba(255,255,255,0)', // hide the bullet point
    data: series_data
  };
  
  var best_squares = findLineByLeastSquares(x_y_chart_data);
  var best_squares_line = [
    [best_squares.min_x, best_squares.fn(best_squares.min_x)],
    [best_squares.max_x, best_squares.fn(best_squares.max_x)]
  ];
  
  var best_fit_series = {
    color: 'rgba(100, 100, 100, .5)', // light gray
    type: 'line',
    shadow: false,
    name: 'Regression Line',
    data: best_fit = best_squares_line,
    enableMouseTracking: false,
    showInLegend: false
  }

  chart.addSeries(series);
  this.best_fit_series = chart.addSeries(best_fit_series);
  this.best_fit_series.hide();
  $(chart.xAxis[0].axisTitle.element).text(names[0]);
  $(chart.yAxis[0].axisTitle.element).text(names[1]);
  
  chart.hideLoading();
};

/**
 * kt jQuery extension for High Charts.
 */
(function($) {
  function HighLineChart(options) {
    if($(this).length > 0) {
      this.handler = new HighLineChartHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.HighLineChart = HighLineChart;


  function HighPieChart(options) {
    if($(this).length > 0) {
      this.handler = new HighPieChartHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.HighPieChart = HighPieChart;
  
  function HighScatterPlot(options) {
    if($(this).length > 0) {
      this.handler = new HighScatterPlotHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.HighScatterPlot = HighScatterPlot;

  function HighBarChart(options) {
    if($(this).length > 0) {
      this.handler = new HighBarChartHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.HighBarChart = HighBarChart;

  function HighColumnStackedChart(options) {
    if($(this).length > 0) {
      this.handler = new HighColumnStackedChartHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.HighColumnStackedChart = HighColumnStackedChart;

  function HighColumn100StackedChart(options) {
    if($(this).length > 0) {
      this.handler = new HighColumn100StackedChartHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.HighColumn100StackedChart = HighColumn100StackedChart;
})(jQuery);

/////////////////////// FunnelChartHandler ///////////////////////
function FunnelChartHandler(element, options) {
    this.inheritedFrom = AbstractChartHandler;
    this.inheritedFrom(element, options);
}

FunnelChartHandler.prototype = new AbstractChartHandler();

$.extend(FunnelChartHandler.prototype, {
  bind_events: function() {
    this._bind_common_events();

    var chart_obj = this;

    $(this._element).bind('reload_chart', function(event, extra_query_params) {
      chart_obj.load_data();
    });

    // When a simple filter is applied
    $(document).bind('load_all_chart', function(event, msg) {
      chart_obj.load_data();
    });

    $(document).bind('load_all_charts_multi', function(event, msg) {
      chart_obj.load_data();
    });

    this._bind_export(this);
  },

  init_impl: function() { /* Settings in abstract_chart_handler.js run first */
    this._common_assignments();
    this._enforced = this._options['enforced'];
    this._force_funnel_graph = this._options['force_funnel_graph'];

    this._render_simple_header();
    this.bind_events();

    var $ele = $(this._element);
    $ele.find('.k-box').addClass('funnel');

    if (this._options['show_funnel_type_toggle']) {
      $ele.find('.k-box-body').append($('<div id="select-chart-type"><input type="radio" name="chart-type" value="tree" checked>Tree</input><input type="radio" name="chart-type" value="funnel">Funnel</input></div>'));
    }

    $ele.find('.k-box-body').append($('<div class="funnel-chart"></div>'));

  },

  draw: function(data) {
    var graphEnforced = this._force_funnel_graph || this._enforced;
    FunnelGraph.graph(graphEnforced, data.data, data.names, '#' + this._id);
  },

  showLoading: function(msg) {
    var loadingBlock = $('<span class="loading-block"></span>');

    if(!msg) {
      // If no message is given assume we want to show the loading gif
      loadingBlock.append($('<span class="loader"></span>'));
      msg = 'Loading...';
    }

    loadingBlock.append($('<span class="loading-text">' + msg + '</span>'));

    $('#' + this._id + ' .funnel-chart').html(loadingBlock);
  }

});

/**
 * kt jQuery extension for charts.
 */
(function($) {
  function FunnelChart(options) {
    if($(this).length > 0) {
      this.handler = new FunnelChartHandler($(this), options);
      this.handler.init_impl();
      this.handler.load_data();
    }
  }
  $.fn.FunnelChart = FunnelChart;
})(jQuery);

var KtChartFilter = (function() {

  //This path must be from /static/ see KT-3116
  var TEMPLATE_PATH = '/static/js/kt/templates/'; //TODO better place for this?

  var EVENT_EXPLORER_DETAILS = 'event_explorer_details';
  var EVENT_EXPLORER_TIMELINE = 'event_explorer_timeline';

  var TEMPLATES = {};

  TEMPLATES[EVENT_EXPLORER_DETAILS] =  new EJS({url: TEMPLATE_PATH + '_event_explorer_details_filter.ejs'});
  TEMPLATES[EVENT_EXPLORER_TIMELINE] =  new EJS({url: TEMPLATE_PATH + '_event_explorer_timeline_filter.ejs'});

  function create(args) {

    var defaults = $.extend({
      //Set any default opetions
    }, args);

    var ktFilter = {};

    var chart_element = args['chart_element'];
    var filter_type = args['filter_type'];

    var template = TEMPLATES[filter_type];

    var context = {}
    $element = $(template.render(context));

    ktFilter.element = $element;
    ktFilter.chart_element = chart_element;

    _setup_y_axis_selector(ktFilter);
    _setup_x_axis_selector(ktFilter);

    $element.find('.type_select, .grouping_select').change(function(evt) {
      _apply_filters(ktFilter);
    });

    return $element;
  };

  function _apply_filters(ktFilter) {
    var args = {};

    args['y_axis'] = ktFilter.y_axis_grouping.val();

    if(ktFilter.x_axis_grouping) {
      args['x_axis'] = ktFilter.x_axis_grouping.val();

      var x_group_min = ktFilter.group_slider_x_min_input.val();
      if(x_group_min !== ktFilter.group_slider_min_value)
          args['x_axis_min'] = x_group_min;

      var x_group_max = ktFilter.group_slider_x_max_input.val();
      if(x_group_max !== ktFilter.group_slider_max_value)
          args['x_axis_max'] = x_group_max;
    }

    ktFilter.chart_element.trigger('reload_chart', args);

  }

  function _setup_y_axis_selector(ktFilter) {
    ktFilter.y_axis_grouping = $element.find('.type_select');
    ktFilter.y_axis_grouping.select2({minimumResultsForSearch:5, width: '125px'});
  }

  function _setup_x_axis_selector(ktFilter) {
    ktFilter.x_axis_grouping = $element.find(".grouping_select");
    if(ktFilter.x_axis_grouping.length > 0) {

        // Timeline grouping slider, labels, and inputs
        ktFilter.group_slider = $element.find(".grouping_slider_container");
        ktFilter.group_slider_x_min_label = $element.find(".x_axis_min");
        ktFilter.group_slider_x_max_label = $element.find(".x_axis_max");
        ktFilter.group_slider_x_min_input = $element.find(".x_axis_min_input");
        ktFilter.group_slider_x_max_input = $element.find(".x_axis_max_input");

        // Timeline x axis grouping slider
        _populate_x_axis_group_slider(ktFilter);
        ktFilter.x_axis_grouping.change(function() {
          _populate_x_axis_group_slider(ktFilter);
        });
        ktFilter.x_axis_grouping.select2({minimumResultsForSearch:5,width:'125px'});
    }
    else
        ktFilter.x_axis_grouping = false;
  }

  function _populate_x_axis_group_slider(ktFilter) {
        if(!ktFilter.x_axis_grouping)
            return;
        var _this_obj = ktFilter;
        var dimension_type_val = _this_obj.x_axis_grouping.val();
        $.ajax(
        {
            type : "POST",
            url  : '/event_filter/ajax_get_x_axis/',
            dataType : 'json',
            data : { dimension_type : dimension_type_val },
            success: function(data){
                var axis_data = data['axis'];
                var new_min, new_max = null;
                var dimension_info = {};

                $.each(axis_data,
                function (i, d) {
                    if (new_min == null || d['id'] < new_min)
                        new_min = d['id'];
                    if (new_max == null || d['id'] > new_max)
                        new_max = d['id'];
                    dimension_info[d['id']] = d['description'];
                });

                _this_obj.group_slider_min_value = new_min;
                _this_obj.group_slider_max_value = new_max;
                var selected_new_max = new_max;
                if (data['timeline_axis'] == dimension_type_val) {
                    if (data['x_axis_min'] != undefined)
                        _this_obj.group_slider_min_value = data['x_axis_min'];
                    if (data['x_axis_max'] != undefined)
                        _this_obj.group_slider_max_value = data['x_axis_max'];
                }

                var _set_values = function (min, max) {
                    _this_obj.group_slider_x_min_label.text(dimension_info[min]);
                    _this_obj.group_slider_x_max_label.text(dimension_info[max]);
                    _this_obj.group_slider_x_min_input.prop('value', min);
                    _this_obj.group_slider_x_max_input.prop('value', max);
                };

                var new_slider = $('<div class="ui-slider grouping_slider"></div>');
                _this_obj.group_slider.empty().append(new_slider);

                new_slider.slider('values', 0, _this_obj.group_slider_min_value);
                new_slider.slider('values', 1, _this_obj.group_slider_max_value);
                _set_values(_this_obj.group_slider_min_value, _this_obj.group_slider_max_value);


                // Add the new slider
                new_slider.slider({
                    range:true,
                    min:new_min,
                    max:new_max,
                    values:[new_min, new_max],
                    slide:function (event, ui) {
                        var x_axis_min = ui.values[0];
                        var x_axis_max = ui.values[1];
                        _set_values(x_axis_min, x_axis_max);
                    },
                    change:function(event, ui) {
                      _apply_filters(_this_obj);
                    },
                });
            }
        }
        );
    };


  return {
    create: create,
    EVENT_EXPLORER_DETAILS: EVENT_EXPLORER_DETAILS,
    EVENT_EXPLORER_TIMELINE: EVENT_EXPLORER_TIMELINE
  };
})();

// wrapper functions to jquery.sparkline

// template for histogram creation
// expects data to come in [[key, value], [key, value], ... ]
function appendHistogram(element, data, options) {
  var defaultOptions = {
    id: '',
    overlay: false,
    labels: false,
    width: element.width()
  };
  options = $.extend({}, defaultOptions, options || {});
  
  var totalBarWidth = options.width/data.length;
  var defaultSparklineOptions = {
    type: 'bar',
    height: '32',
    barWidth: totalBarWidth - 1, // -1 for bar spacing
    barColor: '#bdbdbd'
  };
  var sparklineOptions = $.extend({}, defaultSparklineOptions, options.sparklineOptions);

  var defaultOverlayOptions = {
    id: '',
    start: '',
    end: '',
    onChange: function(event, data, options) {},
    drag: false,
    resize: false,
    header: false,
    color: 'rgb(35,195,255)'
  };
  
  var idText = (options.id === '') ? '' : '-' + options.id;
  
  // remove existing histogram, if it exists
  var $histogram = $('#histogram' + idText);
  if ($histogram) { $histogram.remove(); }

  // create histogram  
  element.append('<div id="histogram' + idText + '" class="histogram"><div id="histogram-wrapper' + idText + '" class="histogram-wrapper"></div></div>');
  var $histogram = $('#histogram' + idText);
  $histogram.data('data', data);
  $histogram.data('totalBarWidth', totalBarWidth)
  
  var $histogramWrapper = $('#histogram-wrapper' + idText);
  $histogramWrapper.sparkline(
    $.map(data, function(dataPoint) { return dataPoint[1]; }), // collect data points, disregard dates
    sparklineOptions
  );

  if (options.overlay) {
    for (overlayOptionsIndex in options.overlay) {
      var overlayOptions = options.overlay[overlayOptionsIndex];
      overlayOptions = $.extend({}, defaultOverlayOptions, overlayOptions);

      // append overlay
      var overlayID = (overlayOptions.id) ? overlayOptions.id : overlayOptionsIndex;
      $histogramWrapper.append('<div id="histogram-overlay' + idText + '-' + overlayID + '" class="histogram-overlay" style="background-color:' + overlayOptions.color + ';"></div>');
      
      // position overlay
      refreshHistogramOverlay(options.id, overlayID, overlayOptions.start, overlayOptions.end);

      var $histogramSlider = $('#histogram-overlay' + idText + '-' + overlayID);
      $histogramSlider.change(function(event, additionalParams) {
        overlayOptions.onChange(event, data, options, additionalParams); 
      });
  
      if (overlayOptions.header) {
        $histogram.prepend('<div id="histogram-header' + idText + '" class="histogram-header"></div>');
      }
      
      if (overlayOptions.drag) {
        $histogramSlider.draggable({
          axis: "x",
          containment: "parent",
          drag: function(event, ui) {
            overlayOptions.onChange(event, data, options);
          }
        });
      }
      
      if (overlayOptions.resize) {
        $histogramSlider.resizable({
          handles: 'e, w',
          containment: "parent",
          resize: function(event, ui) {
            overlayOptions.onChange(event, data, options);
          }
        });
      }
    }
  }

  if (options.labels) {
    // append text for keys
    // for { key: label } ...
    $histogram.append('<div id="histogram-labels' + idText + '" class="histogram-labels"></div>');
    $histogramLabels = $('#histogram-labels' + idText);
    var labels = options.labels($histogram, data);
    for (labelKey in labels) {
      var label = labels[labelKey];
      var positionData = getHistogramPositionData(options.id, labelKey, labelKey); // use same key for start and end to just get position
      $histogramLabels.append('<span class="histogram-label" id="histogram-label' + idText + '-' + labelKey + '">|<br />' + label + '</span>');
      var $histogramLabel = $('#histogram-label' + idText + '-' + labelKey);
      $histogramLabel.css('left', positionData.left - ($histogramLabel.width()/2) + 'px'); // center the label on the spot
    }
  }
}

// takes in start and end keys of the histogram and shifts the overlay to overlap those
function refreshHistogramOverlay(histogramID, overlayID, start, end) {
  var positionData = getHistogramPositionData(histogramID, start, end); 
  
  var $histogramSlider = $('#histogram-overlay-' + histogramID + '-' + overlayID);
  if (positionData) {
    $histogramSlider.width(positionData.size).css('left', positionData.left + 'px');
  } else {
    $histogramSlider.width(0);
  }

  $histogramSlider.trigger('change', {updateCohortLabels: false});
}

// template ajax call
// default histogram creation from ajax call
function appendHistogramAjax(element, data, url, options) {
  var defaultOptions = {
    dataFormatFunction: function(data) { return data; },
    histogramOptions: {
      id: '',
      overlay: false
    },
    afterSuccess: function(element, data, options) { },
    error: function() { $('#histogram-' + options.id).remove(); }
  };
  options = $.extend({}, defaultOptions, options || {});

  if(!data.api_key) {
    return;
  }

  $.ajax({
    type: "POST",
    data: data,
    url: url,
    dataType: 'json',
    success: function(data) {
      data = options.dataFormatFunction(data);
      appendHistogram(element, data, options.histogramOptions);
      options.afterSuccess(element, data, options)
    },
    error: options.error
  });
}

// utility functions

// expecting data in [[key, value], [key, value]]
// this takes in data and based on the start position and size in pixels, returns the slice that the overlay would cover
// (reverse of getHistogramPositionData)
function getHistogramSliceData(histogramID, barWidth, start, size) {
  var $datepickerHistogram = $('#histogram-' + histogramID);
  if (!$datepickerHistogram) { return false; }

  var data = $datepickerHistogram.data('data');

  // I hate using round here, but since I'm not using integer values for width/start/size, this is the best I could do.
  var startSlice = Math.round(start/barWidth);
  var endSlice = Math.round((start+size)/barWidth);
  
  var histogramSlice = data.slice(startSlice, endSlice)
  var sliceLength = histogramSlice.length;
  
  if (sliceLength === 0) {
    return {
      "sum": 0,
      "startKey": -1,
      "endKey": -1,
      "length": 0
    }
  }

  var sum = 0;
  $.each(histogramSlice, function() { sum += this[1]; });
  
  var startKey = histogramSlice[0][0];
  var endKey = histogramSlice[sliceLength-1][0]
  
  return {
    "sum": sum,
    "startKey": startKey,
    "endKey": endKey,
    "length": sliceLength
  };
}

// takes in start and end keys of the histogram and returns left/size info
// (reverse of getHistogramSliceData)
function getHistogramPositionData(histogramID, start, end) {
  var $histogram = $('#histogram-' + histogramID);
  if (!$histogram) { return false; }

  // calculate overlay positioning, size
  var startIndex = -1;
  var endIndex = -1;

  var data = $histogram.data('data');
  for (datumIndex in data) {
    datum = data[datumIndex];
    if (start === datum[0]) {
      startIndex = datumIndex;
    }
    if (end === datum[0]) {
      endIndex = datumIndex;
    }
    if (startIndex !== -1 && endIndex !== -1) { break; }
  }
  
  // if start/end not found, leave as is
  if (startIndex === -1 || endIndex === -1) {
    return false;
  }

  var totalBarWidth = $histogram.data('totalBarWidth');
  return {
    size: totalBarWidth*(endIndex-startIndex+1) - 1, //-1 for bar width space
    left: startIndex*totalBarWidth
  }
}

// for data like [[timestamp, value], [timestamp, value]]
function convertDataFromTimestampToNumberDateFormat(data) {
  return $.map(data, function(datum) { return [[unixTimestampToNumberDateFormat(datum[0]), datum[1]]]; });
}

// for data like [[dateString, value], [dateString, value]]
function generateDateLabelsByIndex(data, startIndex, endIndex, interval, labelFormatter) {
  var labels = {};
  for (var i = startIndex; i < endIndex; i += interval) {
    var tempDateString = data[i][0];
    labels[tempDateString] = labelFormatter(tempDateString)
  }
  return labels;
}

function generateDateLabels(histogramElement, intervalPixels, edgePixels) {
  var barWidth = histogramElement.data('totalBarWidth');
  var data = histogramElement.data('data');

  var interval = Math.ceil(intervalPixels/barWidth);
  var start = Math.ceil(edgePixels/barWidth);
  var end = data.length - start;

  return generateDateLabelsByIndex(data, start, end, interval, function(dateString) {
    var tempDate = new Date(dateString);
    return Highcharts.dateFormat('%b %e', tempDate.getTime());
  });
}

google.load("visualization", "1", {packages: ["geochart"]});

$.ui.widget.subclass("kt.ktGeoChart", {
  div: null,
  DEFAULT_OPTIONS: {width: 820, height: 380, colors: ["#d8e8ec","#44bdd8","#18A7C7","#00a0c4"], "backgroundColor.stroke": "#c1b3b6"},
  _init: function() {
    var self = this;
    $(this.element).addClass("k-box");
    $(document).bind("load_all_chart", function(event, msg) {
      self.draw();
    });
    $(document).bind("load_all_charts_multi", function(event, msg) {
      self.draw();
    });
    self.draw();
  },
  draw: function() {
    var self = this;
    var div = $(this.getDiv()).prependTo(this.element);
    if(this.div) {
      this.div.remove();
    }
    this.div = div;
    ktAjaxWrapper({
      type: "GET",
      traditional: true,
      url: this.getUrl(),
      dataType: "json",
      success: function(json, textStatus) {
        var data = new google.visualization.DataTable();
        data.addRows(json.data.length);
        data.addColumn("string", "Country");
        data.addColumn("number", "Users");
        $.each(json.data, function(i, item) {
          data.setValue(i, 0, item[0]);
          data.setFormattedValue(i, 0, item[1]);
          data.setValue(i, 1, item[2]);
        });
        new google.visualization.NumberFormat({fractionDigits: 0}).format(data, 1); // Apply formatter to second column
        var chart = new google.visualization.GeoChart(div[1]);
        chart.draw(data, self.DEFAULT_OPTIONS);
        
        google.visualization.events.addListener(chart, "error", function() {
          $(".loading-message", self.element).text("This chart is experiencing technical difficulties.");
        });
        
        self.initAdvancedView(data, json.data);
      }, 
      error: function(xhr) {
        try {
          response = JSON.parse(xhr.responseText);
          $(".loading-message", self.element).text(response.errorMessage);
        } catch(e) {
          console && console.error("An error occurred while parsing error response.", e);
          $(".loading-message", self.element).text("This chart is experiencing technical difficulties.");
        }
      }
    });    
  },
  getDiv: function() {
    var html = '<div class="k-box-head"><div class="k-box-head-info"><h1>' + this.options.header_txt + '</h1><a href="#" class="help" index="'+this.options.chart_index+'" title="' + this.options.bubble_txt + '">help</a>' + this.getAdvancedLink() + '<ul class="icons"><li><a href="#"><img src="' + KT_ENV_JS.media_url + '/images/ico6.jpg" width="19" height="24" alt="" /></a></li><li><a href="#"><img src="' + KT_ENV_JS.media_url + '/images/ico3.jpg" width="19" height="24" alt="" /></a></li><li><a href="#"><img src="' + KT_ENV_JS.media_url + '/images/ico9.jpg" width="16" height="24" alt="" /></a></li></ul></div></div>';
    html += '<div class="k-box-body geochart" style="text-align:center;background-color:#eaf7fe;overflow:visible"><div style="font-weight: bold; font-family: \'Lucida Grande\', \'Lucida Sans Unicode\', Verdana, Arial, Helvetica, sans-serif; font-size: 12px; color:#888;margin:50px" class="loading-message">Loading...</span></div>';
    return html;
  },
  getAdvancedLink: function() {
    return '<a href=javascript:void(0) class="k-box-icon advanced_link" title="Advanced Graph View" style="display:none"> </a>';
  },
  getUrl: function() {
    return np_get_table_url(this.options, this.options.category, this.options.tab, this.options.page, this.element.prop("id").substring(1));
  },
  initAdvancedView: function(data, jsonData) {
    var self = this;
    $(".advanced_link", this.element).click(function() {
      var div = $('<div class="k-box kt-left" style="overflow:visible;height:100%;position:absolute;left:0"><div class="button_holder"><button class="kt-button kt-secondary exit-geochart-advanced-view">Exit Advanced View</button></div>' + self.getDiv() + '</div>');
      var content = $("#content");
      div.css("top", content.offset().top);
      content.append(div);
      $(".content-holder", content).hide();
      var options = $.extend({}, self.DEFAULT_OPTIONS);
      options.width = content.innerWidth() - 24;
      options.height = (self.DEFAULT_OPTIONS.height / self.DEFAULT_OPTIONS.width) * options.width;
      var chart = new google.visualization.GeoChart(div.find(".geochart")[0]);
      chart.draw(data, options);
      $(".exit-geochart-advanced-view", div).click(function() {
        div.remove();
        $(".content-holder", content).show();
      });
    }).show();
  }
});

// Define our own htmlEncode function for use within _.template()
function htmlEncode(value){
  return $('<div/>').text(value).html();
}
// Javascript/JQuery HTML Encoding - Stack Overflow
// http://stackoverflow.com/questions/1219860/javascript-jquery-html-encoding



var AnnotationHandler = {
    init_impl: function() {
        this.annotation_template = _.template($('#annotation_template').html());
        this.annotation_comment_template = _.template($('#annotation_comment_template').html());
    },

    show_loading: function() {
        $('.annotation_loading').show();
    },

    hide_loading: function() {
        $('.annotation_loading').hide();
    },

    default_comment_text: "Write a comment...",
    visible_comments: 2,

    bind_events: function() {
        var ann_handler = this;

        $('.annotation-comment-form form').live('submit', function() {
            var txtarea = $(this).find('textarea');
            var comment = txtarea.val();

            if(comment.match(/^\s*$/) || comment.match(ann_handler.default_comment_text)) {
                return false;
            }

            var annotation_item = $(this).closest('.annotation-item');
            var annotation_comment_number = annotation_item.find('.annotation-comment-number');
            var annotation_id = annotation_item.prop('id').match(/\d+$/)[0];
            var comment_list = $(this).closest('.annotation-comments').find('.annotation-comment-list');

            $.post('/dashboard/annotation_comment/add/', {
                    'annotation_id': annotation_id,
                    'comment': comment
                },
                function(data, textStatus) {
                    var comment_node = ann_handler.annotation_comment_template(data);
                    comment_list.append(comment_node);
                    txtarea.val(ann_handler.default_comment_text);
                    txtarea.addClass('blurred');
                    txtarea.val(ann_handler.default_comment_text);

                    var x = annotation_comment_number.html();
                    annotation_comment_number.html(Number(x) + 1);
                },
                'json'
            );

            return false;
        });

        $('.annotation-item').live('click', function() {
            /*$('.annotation-comments').hide();*/
            $(this).find('.annotation-comments').show();
        });

        $('.annotation-comment-delete').live('click', function() {
            var comment_dom = $(this).closest('.annotation-comment');
            var comment_id = comment_dom.prop('id').match(/\d+$/)[0];
            var annotation_item = $(this).closest('.annotation-item');
            var annotation_comment_number = annotation_item.find('.annotation-comment-number');

            $.post('/dashboard/annotation_comment/delete/', {
                    'comment_id': comment_id
                },
                function(data, textStatus) {
                    comment_dom.fadeOut(300, function() {
                        $(this).remove();
                    });
                    var x = annotation_comment_number.html();
                    annotation_comment_number.html(Number(x) - 1);
                }
            );
        });

        $(document).bind('annotation_saved', function(event, msg) {
            event['default_comment_text'] = ann_handler.default_comment_text;
            event['visible_comments'] = ann_handler.visible_comments;

            var box = ann_handler.annotation_to_string(event);
            $('#annotation-box').prepend(box);
            $('.annotation-none').hide();
        });

        $('.annotation-comment-form textarea').live('focus', function() {
            $(this).removeClass('blurred');
            if($(this).val() == ann_handler.default_comment_text) {
                $(this).val('');
            }
        });

        $('.annotation-comment-form textarea').live('blur', function() {
            var comment = $(this).val();
            if(comment.match(/^\s*$/) || comment.match(ann_handler.default_comment_text)) {
                $(this).addClass('blurred');
                $(this).val(ann_handler.default_comment_text);
            }
        });

        $('.annotation-view-all-comments').live('click', function() {
            $(this).hide();
            var comments = $(this).closest('.annotation-comments');
            comments.find('.annotation-comment-hidden').show();
            comments.find('.annotation-comment-form').show();
        });

    }, /* end bind_events */

    draw: function(annotations) {
        var ann_handler = this;
        $.each(annotations, function(i, annotation) {
            annotation['default_comment_text'] = ann_handler.default_comment_text;
            annotation['visible_comments'] = ann_handler.visible_comments;

            var annotation_string = ann_handler.annotation_to_string(annotation);
            $('#annotation-box').append(annotation_string);
        });

        if(annotations.length < 1) {
            $('.annotation-none').show();
        }
    },

    annotation_to_string: function(annotation) {
        var ann_handler = this;
        /* render comment templates */
        annotation.comments = $.map(annotation.comments, function(comment, j) {
            return ann_handler.annotation_comment_template(comment);
        });

        return this.annotation_template(annotation);
    }
};

/*
 *   Depends:
 *	ui.core.js
 */
 var applied_bundle_lst = [];

(function($) {
    function AbstractFiltersHandler(element, options) {

        this._element = element;
        this._options = options;
        if (this._element != undefined) this._id = element.prop('id');
    };

    function set_new_bundle_lst (new_bundle_lst){
        var selected_bundle_dom = $("#bundled_event_filters_list input:checked");
        if(new_bundle_lst && new_bundle_lst.length){
            selected_bundle_dom = new_bundle_lst;
        }
         return selected_bundle_dom;
    }

  AbstractFiltersHandler.prototype = {
    _get_ui_template: function() {
      var template_str = "<div>\
        <div class='k-box-head'>\
        <div class='k-box-head-info'>\
	<h1>[=title]</h1>\
      </div>\
      </div>\
      </div>\
	<div class='block-bg'>\
        <div id='filter_list'></div>\
        <ul class='options'>\
        <li class='first'>\
        <a id='apply_filters' href='#'>Apply</a>\
      </li>\
      </ul>\
      </div>";
      return template_str;
    },

    _init_ui_element: function() {
      $("#" + this._id).ktTemplate({
        template: this._get_ui_template()
      });
      $("#" + this._id).ktTemplate("render", {
        title: this.title,
        purgatory_title: this.purgatory_title,
        selected_title: this.selected_title,
        subtype_tree_title: this._options['subtype_tree_title'],
        bundled_title: this._options['bundled_title'],
        pural_noun: this._options['pural_noun'],
        singular_noun: this._options['singular_noun']
      });
      if (this._options['accnt_type'] != 'enterprise') {
        $("#manage_active_events_btn").hide();
      }

      $('.pivot-selector-link').click(function() {
        $('#event_subtype_filters').hide();
        $('.event-explorer.pivot').show();

        $.ajax({
          type: 'GET',
          url: '/dashboard/dashboard_instrumentation_ajax_event/',
          data: {
            st1: 'EventSelector',
            name: 'ToggleToPivot'
          }
        });

      });

      if(this._options['help_text']) {
        var $helpLink = $('<a class="help" title="' + this._options['help_text'] + '" href="#"></a>');
        $("#" + this._id).find('.k-box-head-info').append($helpLink);

        $helpLink.cluetip({splitTitle: '|', arrows: true, showTitle: false});
      }

    }
  };

    //////////////////// GenericSubtypeFilters ////////////////////


    function GenericSubtypeFiltersHandler(element, options) {
        this.inheritedFrom = AbstractFiltersHandler;
        this.inheritedFrom(element, options);
        this.title = "Provide a title";
        this.cached_tree_available_events = {}; // cached data to help toggling between the tree and search tab
        this.cached_search_available_events = {}; // cached data to help toggling between the tree and search tab
        this.m_tree = null;
        this.separator = ' / ';

        this.highlighting_purgatory_list_state = false;
        this.highlighting_saved_list_state = false;
        this.highlight_purgatory_y_dict = {};
        this.highlight_purgatory_y_stack = [];

        this.ctrl_key_down = false;
        // When a selected region is in the process of being created, selectable should ignore ctrl keypress event
        this.ignore_ctrl_key = false;

        // To be overridden
        this.ajax_create_saved_entry_url = null;
        this.ajax_remove_saved_entry_url = null;
        this.ajax_get_purgatory_url = null;
        this.ajax_get_saved_entry_url = null;
        this.ajax_get_subtype_tree_url = null;
        this.ajax_get_one_bundled_entry_url = null;
        this.ajax_bundle_saved_entry_url = null;
        this.ajax_handle_st_filter_url = null;
        this.ajax_forced_handle_st_filter_url = null;
        this.ajax_remove_bundle_url = null;
        this.ajax_apply_bundle_url = null;
        this.ajax_get_bundled_entries_url = null;
        this.ajax_search_subtype_tree_url = null;
    };
    GenericSubtypeFiltersHandler.prototype = new AbstractFiltersHandler();


    GenericSubtypeFiltersHandler.prototype._get_ui_template = function() {
        var template_str = "<div>\
          <div class='k-box-head'>\
            <div class='k-box-head-info'>\
	      <h1>[=title]</h1>\
            </div>\
          </div>\
	  <div class='block-bg' style='-moz-border-radius: 0 0 5px 5px; -webkit-border-radius: 0 0 5px 5px;'>\
      <div class='event-selector-toggle'>\
        <a class='hierachy-selector-link selected' href='javascript:void(0)'>Hierarchy</a>\
        <span>|</span>\
        <a class='pivot-selector-link' href='javascript:void(0)'>Pivot</a></div>\
	    <div id='event_filter_triangular_btn' class='event_filter_collapsed'><a href='#'>[=subtype_tree_title]</a>&nbsp;&nbsp;&nbsp;&nbsp;<span id='event_select_snippet'></span></div>\
	    <div id='event_filter' style='display:none;'>\
              <div class='event_filter_tab'>\
                <ul>\
                  <li class='first'><a id='event_subtype_tree_view' href='#' class='active'><span>Tree</span></a></li>\
                  <li><a id='event_subtype_search_view' href='#'><span>Search</span></a></li>\
                </ul>\
              </div>\
	      <div id='event_tree_view_box'>\
		<div class='kt-left' style='width:31%; margin: 0 10px;'>Subtype Navigator\
		  <div id='filter_list' class='event_tree_container'></div>\
		</div>\
		<div class='kt-left' style='width:30%'>[=purgatory_title]\
		  <span style='margin: 0 5px 0 20px'>Select:</span><a id='purgatory_select_all' class='event_filter_link' href='#'>All</a>&nbsp;&nbsp;<a id='purgatory_select_none' class='event_filter_link' href='#'>None</a>\
		  <br/>\
		  <div id='event_purgatory_list' class='event_list_container'>\
		    <ul>\
		    </ul>\
		  </div>\
		</div>\
		<div style='height:100px; margin:100px 5px 0;' class='kt-left'>\
		  <input id='save_event_names_btn' type='button' value='&gt;&gt;'/>\
		  <br/><br/>\
		  <input id='remove_saved_event_names_btn' type='button' value='&lt;&lt;' />\
		</div>\
		<div id='saved_event_name_list_box' class='kt-left' style='width:30%'>[=selected_title]\
		  <span style='margin: 0 5px 0 20px'>Select:</span><a id='event_select_all' class='event_filter_link' href='#'>All</a>&nbsp;&nbsp;<a id='event_select_none' class='event_filter_link' href='#'>None</a>\
		  <br/>\
		  <div id='saved_event_name_list' class='event_list_container'>\
		    <ul>\
		    </ul>\
		  </div>\
		  <div style='margin-top:10px; margin-bottom: 20px;' class='kt-right'>\
                    <a id='manage_active_events_btn' href='#' value='' class='help'\
                     title='Manage your active events' \>Manage Active Events</a>\
                    <a id='bundle_saved_event_names_btn' href='#' value='Save' class='kt-button kt-primary'\
		     title='Create a bundle of selected [=pural_noun] that you often want to view together.'>Save</a>\
		    <a id='apply_event_names_btn' href='#' value='Apply' class='kt-button kt-primary'\
		    title='Apply the selected [=pural_noun] to be viewed'>Apply</a>\
		  </div>\
		</div>\
	    </div>\
	    \
	    \
       	    <div id='event_search_view_box' style='display:none;'>\
	      <div style='width:31%; margin: 0 10px 0 10px;' class='kt-left'>Search\
              <div>\
                <form id='event_search_form'>\
                  <input id='event_search_text' type='text'/><input id='event_search_button' type='submit' value='search'/>\
                </form>\
              </div>\
          </div>\
          <div style='width:30%' class='kt-left'>[=purgatory_title]\
		  <span style='margin: 0 5px 0 20px'>Select:</span><a id='search_result_select_all' class='event_filter_link' href='#'>All</a>&nbsp;&nbsp;<a id='search_result_select_none' class='event_filter_link' href='#'>None</a>\
		  <br/>\
		  <div id='search_result_list' class='event_list_container'>\
		    <ul>\
		    </ul>\
		  </div>\
		</div>\
		<div style='height:100px; margin:100px 5px 0;' class='kt-left'>\
		  <input id='save_search_result_btn' type='button' value='&gt;&gt;'/>\
		    <br/><br/>\
		  <input id='remove_search_result_btn' type='button' value='&lt;&lt;' />\
		</div>\
            \
	    </div>\
	    </div>\<!---event_tree_view_box-->\
	    \
	    <div class='clear'>\
	    <!-- bundled saved events -->\
       	    <div id='bundled_event_filter_triangular_btn' class='event_filter_collapsed'><a href='#'>[=bundled_title]</a>&nbsp;&nbsp;&nbsp;&nbsp;<span id='bundle_select_snippet'></span></div>\
	    <div id='bundled_event_filters' style='display:none'>\
	      <ul id='bundled_event_filters_list' class='event_filter_cb'>\
	      </ul>\
	      <div style='margin-left:20px'>\
       	  <a href='javascript:void(0)' class='kt-button kt-primary' id='apply_bundle_btn' title='Apply the selected bundled [=pural_noun]'>Apply</a>\
	        <a href='javascript:void(0)' class='kt-button kt-secondary' id='remove_bundle_btn' title='Remove the selected bundled [=pural_noun]'>Remove</a>\
	      </div>\
	    </div>\
	    <ul>\
	    </ul>\
	  </div>\
        </div>";
        return template_str;
    };


    GenericSubtypeFiltersHandler.prototype.recursive_uncheck_parents_siblings = function(dom) {
        var siblings = $($($(dom).parent()).parent()).siblings();
        var len = siblings.length;
        var curr_dom = null;
        for (var i = 0; i < len; i++) {
            curr_dom = siblings[i];
            $.tree.plugins.checkbox.uncheck(curr_dom);
        } // for
        if (curr_dom == null) {
            // this could be case when its parent has no sibling.
            // However, we still need to recurse one level higher.
            // Need to uncheck grandparent's siblings if there's any.
            var tmp_dom = $($(dom).parent()).parent();
            if (tmp_dom.length == 1) curr_dom = tmp_dom[0];
        }

        if (curr_dom != null) {
            // only need to recurse once. Since all sibling nodes can have only one parent.
            var subtype_str = $(curr_dom).attr('subtype');
            if (subtype_str != undefined && subtype_str != "1") {
                this.recursive_uncheck_parents_siblings(curr_dom);
            }
        }
    };

    GenericSubtypeFiltersHandler.prototype._grey_out_apply_if_necessary = function() {
        var len = $("#bundled_event_filters_list input:checked").length;
        if (len == 0) {
            // disable apply and leave remove enabled if more than one checkbox is checked.
            $("#apply_bundle_btn").addClass('disabled');
            $("#apply_bundle_btn").removeAttr('href');
        } else {
            $("#apply_bundle_btn").removeClass('disabled');
            $("#apply_bundle_btn").attr('href', 'javascript:void(0)');
        }
    };

    // setup the bundle related buttons, like apply and save.
    GenericSubtypeFiltersHandler.prototype._enable_bundle_related_btns = function() {
        this._grey_out_apply_if_necessary();
    };

    GenericSubtypeFiltersHandler.prototype._event_filter_slidedown = function() {
        $("#event_filter_triangular_btn").removeClass('event_filter_collapsed');
        $("#event_filter_triangular_btn").addClass('event_filter_expanded');
        $("#event_filter").slideDown();
    };

    GenericSubtypeFiltersHandler.prototype._event_filter_slideup = function() {
        $("#event_filter_triangular_btn").removeClass('event_filter_expanded');
        $("#event_filter_triangular_btn").addClass('event_filter_collapsed');
        $("#event_filter").slideUp();
        if ($("#event_filter_triangular_btn").hasClass('event_filter_collapsed') && $("#bundled_event_filter_triangular_btn").hasClass('event_filter_collapsed')) {}
    };

    GenericSubtypeFiltersHandler.prototype._bundle_filter_slidedown = function() {
        $("#bundled_event_filter_triangular_btn").removeClass('event_filter_collapsed');
        $("#bundled_event_filter_triangular_btn").addClass('event_filter_expanded');
        $("#bundled_event_filters").slideDown();
        this._enable_bundle_related_btns();
    };

    GenericSubtypeFiltersHandler.prototype._bundle_filter_slideup = function() {
        $("#bundled_event_filter_triangular_btn").removeClass('event_filter_expanded');
        $("#bundled_event_filter_triangular_btn").addClass('event_filter_collapsed');
        $("#bundled_event_filters").slideUp();
        if ($("#event_filter_triangular_btn").hasClass('event_filter_collapsed') && $("#bundled_event_filter_triangular_btn").hasClass('event_filter_collapsed')) {}
    };

    GenericSubtypeFiltersHandler.prototype._handle_subtree = function(dom) {
        //
        // check to see if any of the siblings are checked.
        // If so, uncheck them.
        //
        var siblings = $(dom).siblings();
        var need_to_check_myself = false;
        for (var i = 0; i < siblings.length; i++) {
            var curr_dom = siblings[i];
            if (!$(curr_dom).hasClass('checked')) {
                $.tree.plugins.checkbox.uncheck(curr_dom);
                need_to_check_myself = true;
            }
        } // for
        //
        // Make sure that you check this node, namely dom.
        //
        if (need_to_check_myself) {
            $.tree.plugins.checkbox.check(dom);
        }

        // uncheck older relatives
        this.recursive_uncheck_parents_siblings(dom);
    };

    GenericSubtypeFiltersHandler.prototype._set_height = function() {
        var children = $('#filter_list ul.ltr').children();
        var height_accum = 0;
        for (var i = 0; i < children.length; i++) {
            height_accum += $(children[i]).height();
        }
        $('#filter_list ul.ltr').css('height', height_accum + "px");
    };


    GenericSubtypeFiltersHandler.prototype._get_fst0_fst1_fst2_fst3 = function(subtype_level) {
        var st0_lst = [];
        var st1_lst = [];
        var st2_lst = [];
        var st3_lst = [];

        var st0_is_checked = false; // if st0_is_checked is true, no need to include st1, st2, and st3. undetermined means unchecked
        var st1_is_checked = false; // if st1_is_checked is true, no need to include st2 and st3. undetermined means unchecked
        var st2_is_checked = false; // if st2_is_checked is true, no need to include st3. undetermined means unchecked
        var list_of_checked_items = $.tree.plugins.checkbox.get_checked();
        var list_of_undetermined_items = $.tree.plugins.checkbox.get_undeterminded();
        for (var i = 0; i < list_of_undetermined_items.length; i++) {
            list_of_checked_items.push(list_of_undetermined_items[i]);
        }

        var len = list_of_checked_items.length;

        for (i = 0; i < len; i++) {
            var curr_checked_item = list_of_checked_items[i];
            var is_checked = $($(curr_checked_item).children()[0]).hasClass('checked');
            var subtype_category = $(curr_checked_item).attr('subtype');
            var subtype_text = $.trim($($(curr_checked_item).children()[0]).text()).replace('\xa0', ''); //IE prepends \xa0 for no good reasonw
            if (subtype_category == "0") {
                if (is_checked) st0_is_checked = true;
                st0_lst.push(subtype_text);
            }
            if (subtype_category == "1") {
                if (is_checked) st1_is_checked = true;
                st1_lst.push(subtype_text);
            } else if (subtype_category == "2") {
                if (is_checked) st2_is_checked = true;
                st2_lst.push(subtype_text);
            } else if (subtype_category == "3") {
                st3_lst.push(subtype_text);
            }
        } // for
        var r = {};

        if (subtype_level >= 0 && st0_lst.length > 0) {
            r[this._options['qm_arg_prefix'] + '0'] = st0_lst;
        }
        if (subtype_level >= 1 && st1_lst.length > 0) {
            r[this._options['qm_arg_prefix'] + '1'] = st1_lst;
        }
        if (subtype_level >= 2 && st2_lst.length > 0) {
            r[this._options['qm_arg_prefix'] + '2'] = st2_lst;
        }
        if (subtype_level >= 3 && st3_lst.length > 0) {
            r[this._options['qm_arg_prefix'] + '3'] = st3_lst;
        }

        return r;
    }; // GenericSubtypeFiltersHandler.prototype._get_fst0_fst1_fst2_fst3 = function()

    // being used by _get_to_be_saved_event_helper and _Get_highlighted_saved_event_helper
    GenericSubtypeFiltersHandler.prototype._get_event_helper_helper = function($input_list) {
        var arg = {};
        var count = 0;

        $.each($input_list, function(i, input_dom) {
            var k = $(input_dom).prop('value');
            arg[k] = $(input_dom).hasClass('event_name_entry') ? 'is_a_name' : 'not_a_name';
            count++;
        });

        var r = {
            arg: arg,
            selected_labels_dom: $input_list,
            count: count
        };
        return r;
    };

    GenericSubtypeFiltersHandler.prototype._get_to_be_saved_event_helper = function() {
        var $input_list = $('#saved_event_name_list ul li input');
        return this._get_event_helper_helper($input_list);
    };

    GenericSubtypeFiltersHandler.prototype._get_highlighted_saved_event_helper = function() {
        var $input_list = $('#saved_event_name_list  .event_entry_label_selected').prev();
        return this._get_event_helper_helper($input_list);
    };

    GenericSubtypeFiltersHandler.prototype._get_all_saved_event_helper = function() {
        var $selected_labels = $('#saved_event_name_list label').prev();
        var arg = {};
        $.each($selected_labels, function(i, input_dom) {
            var k = $(input_dom).prop('value');
            arg[k] = $(input_dom).hasClass('event_name_entry') ? 'is_a_name' : 'not_a_name';
        });
        var r = {
            arg: arg,
            selected_labels_dom: $selected_labels
        };
        return r;
    };


    GenericSubtypeFiltersHandler.prototype._high_light_click_handler = function(dom) {
        var $label = $($(dom).children()[1]);
        if (!$label.hasClass('event_entry_label_disabled')) {
            $($(dom).children()[1]).removeClass('event_entry_label');
            $($(dom).children()[1]).addClass('event_entry_label_selected');
        }

    };

    GenericSubtypeFiltersHandler.prototype._unhigh_light_click_handler = function(dom) {
        var $label = $($(dom).children()[1]);
        if (!$label.hasClass('event_entry_label_disabled')) {
            $($(dom).children()[1]).removeClass('event_entry_label_selected');
            $($(dom).children()[1]).addClass('event_entry_label');
        }
    };

    GenericSubtypeFiltersHandler.prototype._unhigh_light_all = function(top_level_dom) {
        var _this_obj = this;

        var selector = "";
        if (top_level_dom[0] != "#") {
            selector = "#";
        }
        selector = selector + top_level_dom + " li";

        $.each($(selector), function(i, d) {
            _this_obj._unhigh_light_click_handler(d);
        });
    };

    GenericSubtypeFiltersHandler.prototype._toggle_high_light_click_handler = function(dom) {
        // highlight it
        var $label = $($(dom).children()[1]);
        if ($label.hasClass('event_entry_label')) {
            $($(dom).children()[1]).removeClass('event_entry_label');
            $($(dom).children()[1]).addClass('event_entry_label_selected');
        } else {
            $($(dom).children()[1]).removeClass('event_entry_label_selected');
            $($(dom).children()[1]).addClass('event_entry_label');
        }
    };

    GenericSubtypeFiltersHandler.prototype._bind_high_light_click_helper = function($dom) {
        var _this_obj = this;
        $dom.unbind('click'); // cleanup
        $dom.click(function(event) {
            _this_obj._toggle_high_light_click_handler(this);
        });
    };

    GenericSubtypeFiltersHandler.prototype._find_tree_node = function(parent_level_node, value) {
        var subtype_list = value.split(this.separator);
        for (var i = 0; i < subtype_list.length; i++) {
            var st_text = subtype_list[i];
            var st_li_list = parent_level_node.find("li[subtype=" + (i + 1) + "]");
            for (var j = 0; j < st_li_list.length; j++) {
                var li = st_li_list[j];
                if ($($(li).children()[0]).text().replace(/^\s+|\s+$/g, "") == st_text) {
                    parent_level_node = $(li);
                    break;
                }
            }
        }
        return parent_level_node;
    };

    // double_or_single_click should be either dblclick or click
    GenericSubtypeFiltersHandler.prototype._bind_click_helper = function($dom, double_or_single_click) {
        var _this_obj = this;
        $dom.unbind(double_or_single_click);
        $dom.bind(
        double_or_single_click, function(event) {
            var curr_val = $($(this).children()[0]).prop('value');
            var st_li = _this_obj._find_tree_node($("#filter_list"), curr_val);
            _this_obj.m_tree.load_datastore($(st_li), null, true /* do_not_open_branch */ );
            var st_lst = curr_val.split(_this_obj.separator);
            var arg = {};
            if (curr_val.length > 0) {
                for (var i = 0; i < st_lst.length; i++) {
                    arg[_this_obj._options['qm_arg_prefix'] + (i + 1)] = st_lst[i];
                }
            } else {
                arg['top_level'] = true;
            }
            // arg looks like
            // example: {fevst1:'', fevst2:'', fevst3: ''}
            _this_obj._load_purgatory_impl(arg);
            return false;
        });
    };

    // subtype_str : 'subtype1', 'subtype2', 'subtype3'
    GenericSubtypeFiltersHandler.prototype._common_ancestory_helper = function(common_ancestory, subtype_str, curr_item) {
        var next_subtypes = {'subtype1':'subtype2', 'subtype2':'subtype3'};
        if (common_ancestory[subtype_str] === undefined) {
            common_ancestory[subtype_str] = curr_item[subtype_str];
        }
        //if we're past the bottom of the selected heirarchy
        //(curr_item has no next subtype and isn't an event)
        if ((!curr_item[next_subtypes[subtype_str]]) && (!curr_item['name'])){
            common_ancestory[subtype_str] = false;
        }
    };

    GenericSubtypeFiltersHandler.prototype._display_num_of_selected_events = function(cnt) {
        var str = null;
        if (cnt > 0) {
            if (cnt == 1) str = cnt + " selected " + this._options['singular_noun'] + ".";
            else str = cnt + " selected " + this._options['pural_noun'] + ".";
        } else {
            str = "No selected " + this._options['pural_noun'] + ".";
        }
        $("#event_select_snippet").text(str);
        $("#bundle_select_snippet").empty();
    };

    GenericSubtypeFiltersHandler.prototype._display_bundled_events = function() {

        var selected_bundle_dom = set_new_bundle_lst();
        var bundled_event_name_lst = [];
        $.each(selected_bundle_dom, function(i, d) {
            bundled_event_name_lst.push(' ' + $(d).next().text());
        });
        $("#bundle_select_snippet").text(bundled_event_name_lst + " is being applied.");
        $("#event_select_snippet").empty();
    };

    GenericSubtypeFiltersHandler.prototype._ajax_create_saved_event_names = function(dom_list_id) {
        var _this_obj = this;
        var $candidate_list = $("#" + dom_list_id + " .event_entry_label_selected");
        var the_other_guy_id = null;
        var the_other_guy_cache = null;
        if (dom_list_id == 'event_purgatory_list') {
            the_other_guy_id = 'search_result_list';
            the_other_guy_cache = _this_obj.cached_search_available_events;
        } else {
            the_other_guy_id = 'event_purgatory_list';
            the_other_guy_cache = _this_obj.cached_tree_available_events;
        }

        var selected_val = {};
        $.each($candidate_list, function(i, dom) {
            var is_name_entry = $(dom).prev().hasClass('event_name_entry') ? 'is_a_name' : 'not_a_name';
            selected_val[$(dom).prev().prop('value')] = is_name_entry;
        });

        if (_this_obj.ajax_create_saved_entry_url != null) {
            ktAjaxWrapper({
                type: 'POST',
                url: _this_obj.ajax_create_saved_entry_url,
                data: {
                    'selected_events': JSON.stringify(selected_val)
                },
                dataType: 'json',
                success: function(data) {
                    $.each($candidate_list, function(i, dom) {
                        // make the corresponding purgatory item unclickable.
                        $(dom).removeClass('event_entry_label_selected').addClass('event_entry_label_disabled');

                        // update the current candidate
                        if ($(dom).children().length > 0) {
                            if (selected_val[$(dom).prev().prop('value')] == 'is_a_name') {
                                $($(dom).children()[0]).removeClass('event_entry_file_icon').addClass('event_entry_file_icon_disabled');
                            } else if (selected_val[$(dom).prev().prop('value')] == 'not_a_name') {
                                $($(dom).children()[0]).removeClass('event_entry_folder_icon').addClass('event_entry_folder_icon_disabled');
                            }
                        }

                        // update the other guy if necessary
                        var path_str = $(dom).prev().prop('value');
                        if (the_other_guy_cache[path_str]) {
                            var $the_other_dom = $("#" + the_other_guy_id + " input[value='" + path_str + "']");
                            $the_other_dom.next().removeClass('event_entry_label_selected').addClass('event_entry_label_disabled');
                            if ($($the_other_dom.next().children()[0]).hasClass('event_entry_file_icon')) $($the_other_dom.next().children()[0]).removeClass('event_entry_file_icon').addClass('event_entry_file_icon_disabled');
                            else if ($($the_other_dom.next().children()[0]).hasClass('event_entry_folder_icon')) $($the_other_dom.next().children()[0]).removeClass('event_entry_folder_icon').addClass('event_entry_folder_icon_disabled');
                        }
                    });
                    // populate saved_event_names with the new entry
                    _this_obj._add_to_list_impl($("#saved_event_name_list ul"), data.events, true /*render_full_path*/ );

                    var cnt = $('#saved_event_name_list li').length;
                    _this_obj._display_num_of_selected_events(cnt);
                },
                error: function(data, textStatus) {},
                complete: function(textStatus, xhr) {}
            });
        } // if(_this_obj.ajax_create_saved_entry_url != null){
    };

    GenericSubtypeFiltersHandler.prototype._ajax_remove_saved_event_names = function(target_list) {
        var _this_obj = this;
        var the_other_guy_id = null;
        var the_other_guy_cache = null;
        if (target_list == 'event_purgatory_list') {
            the_other_guy_id = 'search_result_list';
            the_other_guy_cache = _this_obj.cached_search_available_events;
        } else {
            the_other_guy_id = 'event_purgatory_list';
            the_other_guy_cache = _this_obj.cached_tree_available_events;
        }

        var r = _this_obj._get_highlighted_saved_event_helper();
        var arg = JSON.stringify(r['arg']);
        var $dom_list = r['selected_labels_dom'];
        if (_this_obj.ajax_remove_saved_entry_url != null) {
            ktAjaxWrapper({
                type: "POST",
                url: _this_obj.ajax_remove_saved_entry_url,
                data: {
                    'selected_events': arg
                },
                success: function(data) {
                    $dom_list.parent().remove();
                    $.each($dom_list, function(i, d) {
                        var $val = $(d).prop('value');
                        // update current
                        var $purgatory_item = $("#" + target_list + " input.event_entry_list[value='" + $val + "']");
                        if ($purgatory_item.length != 0) {
                            $purgatory_item.next().removeClass('event_entry_label_disabled').addClass('event_entry_label');
                            if ($($purgatory_item.next().children()[0]).hasClass('event_entry_folder_icon_disabled')) $($purgatory_item.next().children()[0]).removeClass('event_entry_folder_icon_disabled').addClass('event_entry_folder_icon');
                            else if ($($purgatory_item.next().children()[0]).hasClass('event_entry_file_icon_disabled')) $($purgatory_item.next().children()[0]).removeClass('event_entry_file_icon_disabled').addClass('event_entry_file_icon');

                            //rebind the click event handler
                            _this_obj._bind_high_light_click_helper($purgatory_item.parent());
                        }

                        var $the_other_item = $("#" + the_other_guy_id + " input.event_entry_list[value='" + $val + "']");
                        if ($the_other_item.length != 0) {
                            $the_other_item.next().removeClass('event_entry_label_disabled').addClass('event_entry_label');
                            if ($($the_other_item.next().children()[0]).hasClass('event_entry_folder_icon_disabled')) $($the_other_item.next().children()[0]).removeClass('event_entry_folder_icon_disabled').addClass('event_entry_folder_icon');
                            else if ($($the_other_item.next().children()[0]).hasClass('event_entry_file_icon_disabled')) $($the_other_item.next().children()[0]).removeClass('event_entry_file_icon_disabled').addClass('event_entry_file_icon');

                            //rebind the click event handler
                            _this_obj._bind_high_light_click_helper($the_other_item.parent());
                        }
                    });

                    var cnt = $('#saved_event_name_list li').length;
                    _this_obj._display_num_of_selected_events(cnt);
                },
                error: function(data, textStatus) {},
                complete: function(textStatus, xhr) {}
            }); // ktAjaxWrapper
        } //if(_this_obj.ajax_remove_saved_entry_url!=null)
    };

    GenericSubtypeFiltersHandler.prototype._add_to_search_result_list = function(keys, dict) {
        var _this_obj = this;
        _this_obj.cached_search_available_events = dict;
        $.each(keys, function(i, k) {
            var val = k;
            var label = k;
            var graduated = dict[k]['graduated'];
            var event_name_entry_str = '';

            if (dict[k]['name'] != undefined && dict[k]['name'].length > 0) {
                if (graduated == undefined) {
                    var label_class = 'event_entry_label';
                    var icon_class = 'event_entry_file_icon';
                } else {
                    var label_class = 'event_entry_label_disabled';
                    var icon_class = 'event_entry_file_icon_disabled';
                }
                event_name_entry_str = 'event_name_entry';
            } else {
                if (graduated == undefined) {
                    var label_class = 'event_entry_label';
                    var icon_class = 'event_entry_folder_icon';
                } else {
                    var label_class = 'event_entry_label_disabled';
                    var icon_class = 'event_entry_folder_icon_disabled';
                }
            }

            var html_str = "<li style='clear:both;'><input type='hidden' value='" + val + "' class='event_entry_list " + event_name_entry_str + "' /><label class='" + label_class + "'><span class='" + icon_class + "'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + label + "</label></li>";
            var $new_dom = $(html_str);
            if (graduated == undefined) {
                // grey out entries are not clickable
                _this_obj._bind_high_light_click_helper($new_dom);
            }
            $("#search_result_list ul").append($new_dom);
            _this_obj._init_selectable("#search_result_list ul");
        });
    };



    GenericSubtypeFiltersHandler.prototype._add_to_list_impl = function(target, data, render_full_path) {
        var _this_obj = this;

        var common_ancestory = {};
        _this_obj.cached_tree_available_events = {};
        $.each(data, function(i, d) {
            var str_buff = [];
            var k = d[0];
            var curr_item = d[1];
            if (curr_item['subtype1'] != undefined) {
                if (curr_item['subtype1'].length != 0) str_buff.push(curr_item['subtype1']);
                _this_obj._common_ancestory_helper(common_ancestory, 'subtype1', curr_item);
            }
            if (curr_item['subtype2'] != undefined) {
                if (curr_item['subtype2'].length != 0) str_buff.push(curr_item['subtype2']);
                _this_obj._common_ancestory_helper(common_ancestory, 'subtype2', curr_item);
            }
            if (curr_item['subtype3'] != undefined) {
                if (curr_item['subtype3'].length != 0) str_buff.push(curr_item['subtype3']);
                _this_obj._common_ancestory_helper(common_ancestory, 'subtype3', curr_item);
            }
            if (curr_item['name'] != undefined) {
                if (curr_item['name'].length != 0) str_buff.push(curr_item['name']);
            }

            if (str_buff.length > 0) {
                var val = str_buff.join(_this_obj.separator);
                if (render_full_path) {
                    var label = val;
                } else {
                    var label = k;
                }

                var graduated = curr_item['graduated'];
                _this_obj.cached_tree_available_events[val] = curr_item;

                if (graduated == undefined) {
                    var label_class = 'event_entry_label';
                    var icon_class = null;
                    if (curr_item['name'] != undefined) icon_class = 'event_entry_file_icon';
                    else icon_class = 'event_entry_folder_icon';
                } else {
                    var label_class = 'event_entry_label_disabled';
                    var icon_class = null;
                    if (curr_item['name'] != undefined) icon_class = 'event_entry_file_icon_disabled';
                    else icon_class = 'event_entry_folder_icon_disabled';
                }

                if (curr_item['name'] != undefined) {
                    var html_entry_str = "<li style='clear:both;'><input type='hidden' value='" + val + "' class='event_entry_list event_name_entry' /><label class='" + label_class + "'><span class='" + icon_class + "'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + label + "</label></li>";
                } else {
                    var html_entry_str = "<li style='clear:both;'><input type='hidden' value='" + val + "' class='event_entry_list' /><label class='" + label_class + "'><span class='" + icon_class + "'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + label + "</label></li>";
                }

                var $new_dom = $(html_entry_str);
                if (graduated == undefined) {
                    // grey out entries are not clickable
                    _this_obj._bind_high_light_click_helper($new_dom);
                }
                if (target == '#event_purgatory_list ul') if (!$new_dom.find('input').hasClass('event_name_entry')) _this_obj._bind_click_helper($new_dom, 'dblclick');

                $(target).append($new_dom);
            } //if(str_buff.length > 0)
        }); // for
        _this_obj._init_selectable(target);

        if (common_ancestory['subtype3'] == false || common_ancestory['subtype2'] == false || common_ancestory['subtype1'] == false) {
            if (common_ancestory['subtype3'] == false) {
                delete common_ancestory['subtype3'];
            }
            if (common_ancestory['subtype2'] == false) {
                delete common_ancestory['subtype2'];
            }
            if (common_ancestory['subtype1'] == false) {
                delete common_ancestory['subtype1'];
            }
        } else {
            // delete the bottom most subtype level. We will get this this case if the bottom most subtype level has only one member.
            /*
             *
             * NOTE: The following code was uncommented to fix KT-970
             * https://kontagent.jira.com/browse/KT-970
             *
             * The comment above (delete the bottom most subtype level...) says one thing
             * and the code does another.  Since commenting this code doesn't appear to change anything,
             * I think the condition it tries to fix must've been fixed in parallel somehow.
             * Nevertheless, I'm leaving this here in case I'm incorrect.
             *
             * -Dave Paola, 9/9/2011
            */
            /*if (common_ancestory['subtype3'] != undefined) {
                delete common_ancestory['subtype3'];
            } else if (common_ancestory['subtype2'] != undefined) {
                delete common_ancestory['subtype2'];
            } else if (common_ancestory['subtype1'] != undefined) {
                delete common_ancestory['subtype1'];
            }*/
            /* END COMMENTED CODE FOR 9/9/2011 COMMENT */
        }

        var common_ancestory_buf = [];
        var common_ancestory_len = 0;
        $.each(common_ancestory, function(i, d) {
            common_ancestory_buf.push(d);
            common_ancestory_len++;
        });
        common_ancestory_buf.pop(); // need to get rid one level in order to traverse one level up.
        if (target == '#event_purgatory_list ul' && common_ancestory_len > 0) {
            // up button
            var val = common_ancestory_buf.join(_this_obj.separator);
            var up_html_str = "<li style='clear:both;'><input type='hidden' value='" + val + "'/><label class='event_entry_label'><span class='event_entry_up_arrow_icon'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>..</label></li>";
            var $up_dom = $(up_html_str);
            $(target).prepend($up_dom);
            _this_obj._bind_click_helper($up_dom, 'click');
        }; //if(target == '#event_entry_up_arrow_icon')
    };

    GenericSubtypeFiltersHandler.prototype._render_list_impl = function(target, data, render_full_path) {
        // event example {u'subtype2': u'build', u'subtype3': u'Food_Storehouse', u'subtype1': u'finishBuilding', u'name': u'finishBuilding'}
        //
        $(target).empty();
        this._add_to_list_impl(target, data, render_full_path);
    };


    GenericSubtypeFiltersHandler.prototype._render_purgatory = function(purgatory_event_data) {
        this._render_list_impl("#event_purgatory_list ul", purgatory_event_data, false /*render_full_path*/ );
    };

    GenericSubtypeFiltersHandler.prototype._render_saved_event_name = function(saved_event_data) {
        this._render_list_impl("#saved_event_name_list ul", saved_event_data, true /*render_full_path*/ );
    };

    GenericSubtypeFiltersHandler.prototype._load_purgatory = function(subtype_level) {
        var arg = {};
        var _this_obj = this;
        if (subtype_level == 0) {
            arg['top_level'] = true;
        } else {
            arg = this._get_fst0_fst1_fst2_fst3(subtype_level);
        }

        this._load_purgatory_impl(arg);
    };


    GenericSubtypeFiltersHandler.prototype._load_purgatory_impl = function(ajax_arg) {
        var _this_obj = this;
        if (_this_obj.ajax_get_purgatory_url != null) {
            ktAjaxWrapper({
                type: "POST",
                traditional: true,
                url: _this_obj.ajax_get_purgatory_url,
                data: ajax_arg,
                dataType: 'json',
                success: function(data) {
                    _this_obj._render_purgatory(data.events);
                    // If there are no events selected, slide down the menu
                    if ($('#saved_event_name_list li').length == 0) {
                        _this_obj._event_filter_slidedown();
                        $(document).trigger('chart.no_events');
                    }
                }
            });
        } // if(_this_obj.ajax_get_purgatory_url != null)
    };

    GenericSubtypeFiltersHandler.prototype._build_saved_event_names = function(load_data) {

      if(load_data == undefined) load_data = true; //defaults to true
        //
        // setup the saved_event_name_list
        //
        var _this_obj = this;
        if (_this_obj.ajax_get_saved_entry_url != null) {
            ktAjaxWrapper({
                type: "POST",
                data: {},
                url: _this_obj.ajax_get_saved_entry_url,
                dataType: 'json',
                success: function(data) {
                    var d = data.events;
                    _this_obj._render_saved_event_name(d);


                    if (d.length > 0 && load_data) _this_obj._load_default_event_data();
                    if (data.applied_type == 'default') {
                        _this_obj._display_num_of_selected_events(d.length);
                    }
                }
            }); // ktAjaxWrapper
        } // if(_this_obj.ajax_get_saved_entry_url !=null)
    };

    GenericSubtypeFiltersHandler.prototype._onchange_handler = function(n, t, _this_obj) {
        if ($($(n).children()[0]).hasClass('clicked')) {
            // one item is always checked.
            $.tree.plugins.checkbox.check(n);
        }
        if ($(n).attr('subtype') == '1') {
            if ($($(n).children()[0]).hasClass('checked')) {
                var lst_of_st1 = $("li[subtype='1']");
                for (var i = 0; i < lst_of_st1.length; i++) {
                    var curr_dom = lst_of_st1[i];
                    if (curr_dom != n) {
                        $.tree.plugins.checkbox.uncheck(curr_dom);
                    }
                }
            }
        } else if ($(n).attr('subtype') == '2' || $(n).attr('subtype') == '3') {
            _this_obj._handle_subtree(n);
        }

        return true;
    };

    GenericSubtypeFiltersHandler.prototype._build_st_tree_helper = function() {
        $("#" + this._id + " div[id='filter_list']").empty();
        var _this_obj = this;
        var st_tree = $("#" + this._id + " div[id='filter_list']").tree({
            data: {
                type: "json",
                async: true,
                opts: {
                    method: 'post',
                    url: _this_obj.ajax_get_subtype_tree_url
                }
            },
            // data
            ui: {
                theme_name: "classic",
                theme_path: "/static/js/third-party/jsTree/themes/classic/style.css"
            },
            types: {
                "default": {
                    draggable: false
                }
            },
            plugins: {
                "checkbox": {

                }
            },
            //plugins
            callback: {
                onchange: function(n, t) {
                    _this_obj._onchange_handler(n, t, _this_obj);
                },
                onclose: function(n, t) {
                    _this_obj._set_height();
                },
                onopen: function(n, t) {
                    _this_obj._set_height();
                    t.callback('onsingleclk', [n, t]); //treat selecing a branching as a single click event
                },
                onload: function(t) {
                    _this_obj.m_tree = t;
                    _this_obj._set_height();
                    $(document).trigger('event_subtype_filter_done');
                    _this_obj._load_purgatory(0);
                },
                onsingleclk: function(n, t) {
                    t.load_datastore(t.get_node(n), null, true /* do_not_open_branch */ );
                    var clicked_n = $("a.clicked");
                    if (clicked_n.length == 1 && clicked_n.parent()[0] == n) {
                        // only reload purgatory if the clicked node is highlighted.
                        _this_obj._load_purgatory($(n).attr('subtype'));
                    }
                },
                beforedata: function(n, t) {
                    var r = {};
                    if (n) {
                        var curr_subtype = $(n).attr('subtype');
                        var curr_text = $.trim($($(n).children()[0]).text());
                        if (curr_subtype == 2) {
                            r[_this_obj._options['qm_arg_prefix'] + '2'] = curr_text;
                            var my_parent = $(n).parent().parent();
                            r[_this_obj._options['qm_arg_prefix'] + '1'] = $.trim($(n).parent().prev().text());
                            r[_this_obj._options['qm_arg_prefix'] + '0'] = $.trim(my_parent.parent().prev().text());
                        } else if (curr_subtype == 1) {
                            r[_this_obj._options['qm_arg_prefix'] + '1'] = curr_text;
                            r[_this_obj._options['qm_arg_prefix'] + '0'] = $.trim($(n).parent().prev().text());
                        } else if (curr_subtype == 0) {
                            r[_this_obj._options['qm_arg_prefix'] + '0'] = curr_text;
                        }
                    } else {
                        r['top_level'] = true;
                    }
                    return r;
                }
            }
        }); // tree
    };

    GenericSubtypeFiltersHandler.prototype._gen_modal_bundle_saved_event_names = function(arg) {
        // arg looks it this:
        // { 'virality / invite' : 'not_a_name', ...}
        var html_str = "Bundle Name:<input type='text' name='bundle_name' id='bundle_name'/><br/>";
        html_str += "<span id='ajax_url_string' style='display:none'>" + this.ajax_bundle_saved_entry_url + "</span>";
        var len = arg.length;
        $.each(arg, function(k, v) {
            html_str += "<input name='to_be_bundled_event_name' type='checkbox' is_a_name='" + v + "' value='" + k + "' checked/>" + k + "<br/>";
        });
        return html_str;
    };

    GenericSubtypeFiltersHandler.prototype._gen_modal_bundle_event_details = function(arg) {
        //arg : [{'subtype1':'', 'subtype2':'', 'name' : ''},...]
        var display_name = [];
        var display_name_type = [];
        var _this_obj = this;
        $.each(arg, function(i, item) {
            var str_buff = [];
            if (item['subtype1'] != undefined) str_buff.push(item['subtype1']);
            if (item['subtype2'] != undefined) str_buff.push(item['subtype2']);
            if (item['subtype3'] != undefined) str_buff.push(item['subtype3']);
            if (item['name'] != undefined) str_buff.push(item['name']);

            if (str_buff.length > 0) {
                var str_val = str_buff.join(_this_obj.separator);
                display_name.push(str_val);
                if (item['name'] != undefined) display_name_type[str_val] = 'is_a_name';
                else display_name_type[str_val] = 'not_a_name';
            }
        });

        display_name.sort();
        var html_str = '';
        $.each(display_name, function(i, name) {
            if (display_name_type[name] == 'is_a_name') html_str += "<label class='event_entry_label'><span class='event_entry_file_icon'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + name + "</label><br/>";
            else html_str += "<label class='event_entry_label'><span class='event_entry_folder_icon'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + name + "</label><br/>";
        });
        return html_str;
    };

    GenericSubtypeFiltersHandler.prototype._populate_bundle_entries = function(data) {
        var _this_obj = this;
        $.each(data, function(k, pk) {
            if (k == 'applied_bundle_pk') return;
            var html_str = null;
            applied_bundles = data['applied_bundle_pk'];
            var add_bundle = false;

            // if there are bundles
            if (applied_bundles != undefined) {
                if (pk == applied_bundles) {
                    // original single case
                    var add_bundle = true;
                } else {
                    // new multiple events
                    for (var i = 0; i < applied_bundles.length; i++) {
                        if (pk == applied_bundles[i]) {
                            var add_bundle = true;
                        }
                    }
                }

                if (add_bundle) {
                    html_str = "<li style='width:300px;'><input type='checkbox' value='" + pk + "' checked/><label><a href='#'>" + k.escapeHTML() + "</a></label><li/>";
                } else {
                    html_str = "<li style='width:300px;'><input type='checkbox' value='" + pk + "'/><label><a href='#'>" + k.escapeHTML() + "</a></label><li/>";
                }
            } else {
                // no bundles
                html_str = "<li style='width:300px;'><input type='checkbox' value='" + pk + "'/><label><a href='#'>" + k.escapeHTML() + "</a></label><li/>";
            }

            var $new_dom_entry = $(html_str);
            $("#bundled_event_filters_list").append($new_dom_entry);

            // add text for bundles
            if (add_bundle) {
                _this_obj._display_bundled_events();
            }

            // click handler for individual bundles.
            $new_dom_entry.find('a').click(

            function() {
                var bundle_label = $(this).text();
                var val = $(this).parent().prev().prop('value');
                if (_this_obj.ajax_get_one_bundled_entry_url != null) {
                    $.ajax({
                        type: "POST",
                        url: _this_obj.ajax_get_one_bundled_entry_url,
                        dataType: 'json',
                        data: {
                            pk: val
                        },
                        success: function(data) {
                          _this_obj._build_st_tree_helper();
                          _this_obj._build_saved_event_names(false);
                        }
                    }); // $.ajax
                } // if(_this_obj.ajax_get_one_bundled_entry_url != null)
                return false;
            }); //click
            $new_dom_entry.find('input').click(
            _this_obj._grey_out_apply_if_necessary); //click
        }); //$.each
    };

    GenericSubtypeFiltersHandler.prototype._handle_bundle_saved_event_names = function(e) {
        //TODO: error handling
        var duplicate_index = 0,
            bundle_lst = [],
            bundle_name = $("#bundle_name").prop('value'),
            $checked_event_names = $("input[name='to_be_bundled_event_name']:checked"),
            ajax_bundle_saved_entry_url = $("#ajax_url_string").text(),
            event_name_values = {},
            _this_obj = this,
            arg;

        applied_bundle_lst = $checked_event_names;

        $.each($checked_event_names, function(i, dom) {
            var $this = $(this),
                name_key = $(dom).prop('value'),
                is_a_name = $(dom).attr('is_a_name');
            event_name_values[name_key] = is_a_name;
        });
        $.each($('#bundled_event_filters_list input'), function(i, d) {
          var $this = $(this);
          bundle_lst.push([$this.next().text(),$this.parent().next(),$this.parent()]);
        });

        arg = event_name_values;
        arg['__bundle_name__'] = bundle_name;

        function save_bundle () {
            $.ajax({
                type: 'POST',
                url: ajax_bundle_saved_entry_url,
                data: arg,
                dataType: 'json',
                success: function(data) {
                    //data : {'TEST1' : pk}
                    if (duplicate_index){
                        bundle_lst[duplicate_index][1].remove();
                        bundle_lst[duplicate_index][2].remove();
                    }
                    $(document).trigger({
                        type: 'populate_bundle_entries',
                        new_entry: data
                    });
                },
                error: function(data){
                    if (data)
			        Boxy.alert($.parseJSON(data.response).errorMessage);
                    else
                       Boxy.alert("Unexpected error");
                }
           }); //$.ajax
        }

        for (index in bundle_lst){
            if(bundle_lst[index][0] === bundle_name){
                duplicate_index = index;
                break;
            }
        }

        if(!duplicate_index ){
            save_bundle();
        } else {
            Boxy.confirm('This saved bundle event already exists. Would you like to overwrite this saved bundle?', save_bundle);
        };
    };

    GenericSubtypeFiltersHandler.prototype._load_default_event_data = function() {
        var _this_obj = this;
        var r = _this_obj._get_all_saved_event_helper();
        var arg = r['arg'];
        if (_this_obj.ajax_handle_st_filter_url) {
            ktAjaxWrapper({
                type: "POST",
                url: _this_obj.ajax_handle_st_filter_url,
                data: arg,
                success: function(data) {
                    $(document).trigger('load_all_chart');
                    $(document).trigger('load_all_table_data');
                }
            }); // ktAjaxWrapper
        } // if(_this_obj.ajax_handle_st_filter_url)
    };

    GenericSubtypeFiltersHandler.prototype._forced_load_default_event_data = function() {
        var _this_obj = this;
        var r = _this_obj._get_all_saved_event_helper();
        var arg = r['arg'];
        if (_this_obj.ajax_forced_handle_st_filter_url) {
            $.ajax({
                type: "POST",
                url: _this_obj.ajax_forced_handle_st_filter_url,
                data: arg,
                success: function(data) {
                    $(document).trigger('load_all_chart');
                    $(document).trigger('load_all_table_data');
                    var cnt = $('#saved_event_name_list li').length;
                    _this_obj._display_num_of_selected_events(cnt);
                }
            }); //$.ajax
        }
    };

    GenericSubtypeFiltersHandler.prototype._handle_event_subtype_filter_done = function() {
        // After the tree is done loading, it will fire off an event_subtype_filter_done.
        // In certain cases, we might want to populate another level immediately (see events).
        // In some other cases, we don't want to do anything (see monetization).
        alert("need to override _handle_event_subtype_filter_done");
    };

    GenericSubtypeFiltersHandler.prototype._init_selectable = function(target) {
        if (!$(target).hasClass('ui-selectable')) {
            //
            // Only initialize selectable once
            //
            var _this_obj = this;
            $(target).selectable({
                start: function() {
                    if (!_this_obj.ctrl_key_down) {
                        _this_obj._unhigh_light_all(target);
                        _this_obj.ignore_ctrl_key = true;
                    }
                },
                stop: function() {
                    $.each($(target + " label.ui-selected"), function(i, dom) {
                        $(dom).removeClass('ui-selected');
                        if (!$($(dom).children()[0]).hasClass('event_entry_up_arrow_icon')) {
                            _this_obj._high_light_click_handler($(dom).parent());
                        }
                    });
                    _this_obj.ignore_ctrl_key = false;
                }
            }); // $(target).selectable
        }
    };



    GenericSubtypeFiltersHandler.prototype._init_ui_element = function() {
        var _this_obj = this;
        //
        // call parent's _init_ui_element
        //
        AbstractFiltersHandler.prototype._init_ui_element.call(this);

        //
        // Ctrl key down/up
        //
        $(document).keydown(function(e) {
            if (e.which == 17) {
                if (!_this_obj.ignore_ctrl_key) {
                    _this_obj.ctrl_key_down = true;
                }
            }
        });
        $(document).keyup(function(e) {
            if (e.which == 17) {
                _this_obj.ctrl_key_down = false;
            }
        });

        //
        // Turn of highlighting
        //
        $.fn.extend({
            disableSelection: function() {
                return this.each(function() {
                    this.onselectstart = function() {
                        return false;
                    };
                    this.unselectable = "on";
                    jQuery(this).css('user-select', 'none');
                    jQuery(this).css('-o-user-select', 'none');
                    jQuery(this).css('-moz-user-select', 'none');
                    jQuery(this).css('-khtml-user-select', 'none');
                    jQuery(this).css('-webkit-user-select', 'none');
                });
            }
        });

        $('.event_tree_container').disableSelection();
        $('.event_list_container').disableSelection();

        //
        // setup the tree
        //
        var root_url = (this._options['root_url']);
        _this_obj._build_st_tree_helper();
        _this_obj._build_saved_event_names(false);

        // repopulate the subtype1 level
        $(document).bind('event_subtype_filter_done', function() {
            _this_obj._handle_event_subtype_filter_done();
        });

      var $manage_active_events_btn = $("#manage_active_events_btn");

      var mgmt_active_event_dialog_loaded = function(){
        //$("#change-white-list-button").click(_this.white_list_btn_handler);
        if ($("#active_event_filter").length != 0) {
          $("#active_event_filter").manageActiveEventFilters( {
	    root_url : KT_ENV_JS['root_url']
          });
        }

        $('#active_event_save_button').click( function() {
          Boxy.confirm('You are about to change the set of active events. This could affect other users on the site, are you sure?',
                       function() {
                         //save active list
                         save_hidden_list();
                       },
                       {title: 'Warning'});
        });

        $('#num_listed').text($('#selected_count').text());
        $manage_active_events_btn.bind('click', manage_active_events_btn_click);
      };

      //
      // setup the "Management Your Active Events" button
      var manage_active_events_btn_click = function(){
            $manage_active_events_btn.unbind('click');
            Boxy.load("/dashboard/event_active_management",
                      {title:'Active Events Management',
                       unloadOnHide: true,
	               modal: true,
                       afterShow: mgmt_active_event_dialog_loaded,
	               closeText: "",
                       closeable:true,
	               center:true});
      };

      $manage_active_events_btn.bind('click', manage_active_events_btn_click);


        //
        // setup the save bundle button
        $("#bundle_saved_event_names_btn").click(
        function() {
            var r = _this_obj._get_to_be_saved_event_helper();
            var arg = r['arg'];

            if (r['count'] > 0) {
                var form_str = _this_obj._gen_modal_bundle_saved_event_names(arg);
                BoxyConfirm(form_str, _this_obj._handle_bundle_saved_event_names, {
                    title: "Create a new event bundle",
                    draggable: true,
                    afterShow: function() { $('#bundle_name').focus(); }
                });
            } else {
                Boxy.alert("You must select one or more events in the \"" + _this_obj.selected_events + "\" window above to create a bundle.");
            }

            return false;
        });

        //
        // setup the apply default button
        //
        $("#apply_event_names_btn").click(

        function() {
            _this_obj._forced_load_default_event_data();
            return false;
        });

        //
        // setup the remove button for bundle
        //
        $('#remove_bundle_btn').click(

        function() {

            var selected_bundle_dom = $("#bundled_event_filters_list input:checked");
            var bundle_name_lst_to_rmv = [];
            var to_be_removed_pk_lst = [];

            $.each(selected_bundle_dom, function(i, d) {
                to_be_removed_pk_lst.push($(d).prop('value'));
                bundle_name_lst_to_rmv.push($(this).next().text() );
            });

            if (_this_obj.ajax_remove_saved_entry_url) {
                $.ajax({
                    type: 'POST',
                    url: _this_obj.ajax_remove_bundle_url,
                    data: {
                        to_be_removed_pk_lst: to_be_removed_pk_lst
                    },
                    success: function(data) {
                        selected_bundle_dom.parent().remove();
                        var index = 0,
                            bundle_name_lst_length = bundle_name_lst_to_rmv.length,
                            new_bundle_lst = [];

                        $.each(applied_bundle_lst, function(i, d){
                            var to_delete = false;
                            for (index = 0; index < bundle_name_lst_length; index++) {
                                if($(d).next().text() === bundle_name_lst_to_rmv[index]){
                                    to_delete = true;
                                    break;
                                }
                            }
                            if (!to_delete){
                               new_bundle_lst.push(d);
                            }
                        });

                        applied_bundle_lst = $(new_bundle_lst);

                        if (!applied_bundle_lst.length) {
                            _this_obj._forced_load_default_event_data();
                        }
                        else{
                            apply_bundled_events(applied_bundle_lst);
                        }
                    }
                });
            } // if(_this_obj.ajax_remove_saved_entry_url){
        });

        //
        // setup the apply button for bundle
        //
        function apply_bundled_events(new_bundle_lst) {
            var selected_bundle_dom = set_new_bundle_lst(new_bundle_lst);
            applied_bundle_lst = selected_bundle_dom;

            var to_be_applied_pk = selected_bundle_dom.prop('value');
            var to_be_applied_pk_lst = [];
            $.each(selected_bundle_dom, function(i, d) {
                to_be_applied_pk_lst.push($(d).prop('value'));
            });

            if (to_be_applied_pk_lst.length > 0) {
                $.ajax({
                    type: 'POST',
                    url: _this_obj.ajax_apply_bundle_url,
                    data: {
                        to_be_applied_pk: to_be_applied_pk,
                        to_be_applied_pk_lst: to_be_applied_pk_lst
                    },
                    success: function(data) {
                        if (new_bundle_lst && new_bundle_lst.length){
                            new_bundle_lst.each(function () {
                                $(this).prop('checked',true);
                            });
                        }
                        $(document).trigger('load_all_chart');
                        $(document).trigger('load_all_table_data');
                        _this_obj._display_bundled_events();
                    }
                });
            } //endif length
        }

        $('#apply_bundle_btn').click(function(){
            apply_bundled_events();
        });

        //
        // setup the >> button for subtype tree
        //
        $("#save_event_names_btn").click(

        function(e) {
            _this_obj._ajax_create_saved_event_names("event_purgatory_list");
            return false;
        });

        //
        // setup the remove  << btn for subtype tree
        //
        $('#remove_saved_event_names_btn').click(

        function() {
            _this_obj._ajax_remove_saved_event_names("event_purgatory_list");
            return false;
        });

        //setup the >> button for search result
        $("#save_search_result_btn").click(

        function(e) {
            _this_obj._ajax_create_saved_event_names("search_result_list");
            return false;
        });

        //setup the << button for search result
        $("#remove_search_result_btn").click(

        function(e) {
            _this_obj._ajax_remove_saved_event_names("search_result_list");
            return false;
        });

        //setup app_handle_update event
        $(document).bind('app_handle_updated', function() {
            _this_obj._build_st_tree_helper();
            _this_obj._build_saved_event_names();
        });

        //setup populate_bundle_entries event
        $(document).bind('populate_bundle_entries', function(e) {
            _this_obj._populate_bundle_entries(e.new_entry);
        });

        //setup purgatory_select_all
        $('#purgatory_select_all').click(

        function() {
            $.each($('#event_purgatory_list li'), function(i, li) {
                // don't high light the arrow
                if ($($(li).children()[0]).hasClass('event_entry_list')) _this_obj._high_light_click_handler(li);
            });
            return false;
        });
        //setup purgatory_select_none
        $('#purgatory_select_none').click(

        function() {
            $.each($('#event_purgatory_list li'), function(i, li) {
                _this_obj._unhigh_light_click_handler(li);
            });
            return false;
        });

        //setup search_result_select_all
        $('#search_result_select_all').click(

        function() {
            $.each($('#search_result_list li'), function(i, li) {
                _this_obj._high_light_click_handler(li);
            });
            return false;
        });
        //setup search_result_select_none
        $('#search_result_select_none').click(

        function() {
            $.each($('#search_result_list li'), function(i, li) {
                _this_obj._unhigh_light_click_handler(li);
            });
            return false;
        });

        // populate bundled_event_filter
        if (_this_obj.ajax_get_bundled_entries_url != null) {
            $.ajax({
                type: "POST",
                url: _this_obj.ajax_get_bundled_entries_url,
                dataType: 'json',
                success: function(data) {
                    //data : {'TESTA' : 1, 'TESTB' : 2} , where 1 and 2 are pk.
                    _this_obj._populate_bundle_entries(data);
                } //success
            }); //$.ajax
        }

        //setup event_select_all
        $('#event_select_all').click(

        function() {
            $.each($('#saved_event_name_list li'), function(i, li) {
                _this_obj._high_light_click_handler(li);
            });
            return false;
        });

        //setup event_select_none
        $('#event_select_none').click(

        function() {
            $.each($('#saved_event_name_list li'), function(i, li) {
                _this_obj._unhigh_light_click_handler(li);
            });
            return false;
        });

        //setup the triangular dropdown button for default filters
        $('#event_filter_triangular_btn').click(

        function(e) {
            if ($(this).hasClass('event_filter_collapsed')) {
                _this_obj._event_filter_slidedown();
                //_this_obj._bundle_filter_slideup();
            } else if ($(this).hasClass('event_filter_expanded')) {
                _this_obj._event_filter_slideup();
            }
            return false;
        });

        //setup the triangular dropdown button for Bundled Events
        $('#bundled_event_filter_triangular_btn').click(

        function() {
            if ($(this).hasClass('event_filter_collapsed')) {
                _this_obj._bundle_filter_slidedown();
                //_this_obj._event_filter_slideup();
            } else if ($(this).hasClass('event_filter_expanded')) {
                _this_obj._bundle_filter_slideup();
            }
            return false;
        });

        //setup the tree tab button
        $("#event_subtype_tree_view").click(

        function() {
            $(this).addClass('active');
            $('#event_subtype_search_view').removeClass('active');
            $('#event_search_view_box').hide();
            $('#save_search_result_btn').hide();
            $('#remove_search_result_btn').hide();
            $('#event_tree_view_box').show();
            $('#save_event_names_btn').show();
            $('#remove_saved_event_names_btn').show();
            $('#event_tree_view_box').append($('#saved_event_name_list_box'));
            return false;
        });


        //setup the search tab button
        $("#event_subtype_search_view").click(

        function() {
            $(this).addClass('active');
            $('#event_subtype_tree_view').removeClass('active');
            $('#event_tree_view_box').hide();
            $('#save_event_names_btn').hide();
            $('#remove_saved_event_names_btn').hide();
            $('#event_search_view_box').show();
            $('#save_search_result_btn').show();
            $('#remove_search_result_btn').show();
            $('#event_search_view_box').append($('#saved_event_name_list_box'));
            return false;
        });

        $("#event_search_form").submit(

        function() {
            $("#search_result_list ul").empty();
            var val = $("#event_search_text").prop('value');
            var arg = {
                search_text: val
            };
            if (_this_obj.ajax_search_subtype_tree_url) {
                ktAjaxWrapper({
                    type: "POST",
                    url: _this_obj.ajax_search_subtype_tree_url,
                    data: arg,
                    dataType: 'json',
                    success: function(data) {
                        var r_key = [];
                        var r_dict = {};
                        _this_obj._handle_ajax_search(_this_obj, data, r_key, r_dict);
                        r_key.sort();
                        _this_obj._add_to_search_result_list(r_key, r_dict);
                    }
                }); //ktAjaxWrapper
            } // if(_this_obj.ajax_search_subtype_tree_url)
            return false;
        }); //click
    }; //GenericSubtypeFiltersHandler.prototype._init_ui_element = function()
    GenericSubtypeFiltersHandler.prototype._handle_ajax_search = function(_this_obj, data, r_key, r_dict) {
        $.each(data.events, function(i, d) {
            var st1 = d['subtype1'];
            var st2 = d['subtype2'];
            var st3 = d['subtype3'];
            var name = d['name'];
            var str_buf = [];
            var has_st1, has_st2, has_st3 = false;
            if (st1.length > 0) {
                has_st1 = true;
                str_buf.push(st1);
            }
            if (has_st1 && st2.length > 0) {
                has_st2 = true;
                str_buf.push(st2);
            }
            if (has_st1 && has_st2 && st3.length > 0) {
                str_buf.push(st3);
            }
            if (name.length > 0) {
                str_buf.push(name);
            }
            var s = str_buf.join(_this_obj.separator);
            r_key.push(s);
            r_dict[s] = d;
        });
    };

    //////////////////// EventSubtypeFilters ////////////////////


    function EventSubtypeFiltersHandler(element, options) {
        this.inheritedFrom = GenericSubtypeFiltersHandler;
        this.inheritedFrom(element, options);
        this.title = "Event Explorer";
        this.purgatory_title = "Available Events";
        this.selected_title = "Selected Events";

        this.ajax_create_saved_entry_url = '/event_filter/ajax_create_saved_event_names/';
        this.ajax_remove_saved_entry_url = '/event_filter/ajax_remove_saved_event_names/';
        this.ajax_get_purgatory_url = '/event_filter/ajax_get_purgatory/';
        this.ajax_get_saved_entry_url = '/event_filter/ajax_get_saved_event_names/';
        this.ajax_get_subtype_tree_url = '/event_filter/ajax_get_subtype_tree/';
        this.ajax_get_one_bundled_entry_url = '/event_filter/ajax_get_one_bundled_event/';
        this.ajax_bundle_saved_entry_url = '/event_filter/ajax_bundle_saved_event_names/';
        this.ajax_handle_st_filter_url = '/event_filter/ajax_handle_event_st_filter/';
        this.ajax_forced_handle_st_filter_url = '/event_filter/ajax_forced_handle_event_st_filter/';
        this.ajax_remove_bundle_url = '/event_filter/ajax_remove_bundle/';
        this.ajax_apply_bundle_url = '/event_filter/ajax_apply_bundle/';
        this.ajax_get_bundled_entries_url = '/event_filter/ajax_get_bundled_events/';
        this.ajax_search_subtype_tree_url = '/event_filter/ajax_search_subtype_tree/';

        $(document).bind('chart.no_events', function() {
            if ($('#saved_event_name_list li').length == 0) {
                $('.kt-chart .k-box-body').hide();
                if ($('.no_chart_display').length > 0) {
                    $('.no_chart_display').show();
                } else {
                    $('.kt-chart .k-box-body').before($('<div/>', {
                        'class': 'no_chart_display'
                    }).
                    text('Please select one or more events.').
                    css({
                        'height': '297px',
                        'background-color': '#FFF',
                        'line-height': '297px',
                        'text-align': 'center',
                        'color': '#000',
                        'border': '1px solid #989898'
                    }));
                }
            }
        });

        $(document).bind('load_all_chart', function() {
            $('.kt-chart .k-box-body').show();
            $('.no_chart_display').hide();
        });
    };

    EventSubtypeFiltersHandler.prototype = new GenericSubtypeFiltersHandler();
    EventSubtypeFiltersHandler.prototype._handle_event_subtype_filter_done = function() {
        this.m_tree.load_datastore($("li[subtype=0]"), null, true /* do_not_open_branch */ );
    };

    function EventSubtypeFilters() {
        this.handler = null;
        this._init = function() {
            this.handler = new EventSubtypeFiltersHandler(this.element, this.options);
            this.handler._init_ui_element();
        };
    };

    //////////////////// MonetizationSubtypeFilters ////////////////////


    function MonetizationSubtypeFiltersHandler(element, options) {
        this.inheritedFrom = GenericSubtypeFiltersHandler;
        this.inheritedFrom(element, options);
        this.title = "Monetization";
        this.purgatory_title = "Available Sources";
        this.selected_title = "Selected Sources";

        this.ajax_create_saved_entry_url = '/revenue_filter/ajax_create_saved_revenue_names/';
        this.ajax_remove_saved_entry_url = '/revenue_filter/ajax_remove_saved_revenue_names/';
        this.ajax_get_purgatory_url = '/revenue_filter/ajax_get_purgatory/';
        this.ajax_get_saved_entry_url = '/revenue_filter/ajax_get_saved_revenue_names/';
        this.ajax_get_subtype_tree_url = '/revenue_filter/ajax_get_subtype_tree/';
        this.ajax_get_one_bundled_entry_url = '/revenue_filter/ajax_get_one_bundled_revenue/';
        this.ajax_bundle_saved_entry_url = '/revenue_filter/ajax_bundle_saved_revenue_names/';
        this.ajax_handle_st_filter_url = '/revenue_filter/ajax_handle_revenue_st_filter/';
        this.ajax_forced_handle_st_filter_url = '/revenue_filter/ajax_forced_handle_revenue_st_filter/';
        this.ajax_remove_bundle_url = '/revenue_filter/ajax_remove_bundle/';
        this.ajax_apply_bundle_url = '/revenue_filter/ajax_apply_bundle/';
        this.ajax_get_bundled_entries_url = '/revenue_filter/ajax_get_bundled_revenues/';

        this.ajax_search_subtype_tree_url = '/revenue_filter/ajax_search_subtype_tree/';


        var section_body_selector = '.k-box-body:has(.kt-chart), .kt_dyn_table .k-box-body';
        $(document).bind('chart.no_events', function() {
            var $targs = $(section_body_selector);

            $targs.hide();
            if ($('.no_chart_display').length > 0) {
                $('.no_chart_display').show();
            } else {
                $targs.before($('<div/>', {
                    'class': 'no_chart_display k-box-body'
                }).
                text('Select one or more monetization events to display').
                css({
                    'height': '297px',
                    'background-color': '#FFF',
                    'line-height': '297px',
                    'text-align': 'center',
                    'color': '#000'
                }));
            }

        });

        $(document).bind('load_all_chart', function() {
            $(section_body_selector).show();
            $('.no_chart_display').hide();
        });
    };
    MonetizationSubtypeFiltersHandler.prototype = new GenericSubtypeFiltersHandler();
    MonetizationSubtypeFiltersHandler.prototype._handle_event_subtype_filter_done = function() {
        return; //do nothing.
    };

    MonetizationSubtypeFiltersHandler.prototype._gen_modal_bundle_event_details = function(arg) {
        //arg : [{'subtype1':'', 'subtype2':'', 'name' : ''},...]
        var display_name = [];
        var display_name_type = [];
        var _this_obj = this;
        $.each(arg, function(i, item) {
            var str_buff = [];
            if (item['rev_type'] != undefined) str_buff.push(item['rev_type']);
            if (item['subtype1'] != undefined) str_buff.push(item['subtype1']);
            if (item['subtype2'] != undefined) str_buff.push(item['subtype2']);
            if (item['subtype3'] != undefined) str_buff.push(item['subtype3']);
            if (item['name'] != undefined) str_buff.push(item['name']);

            if (str_buff.length > 0) {
                var str_val = str_buff.join(_this_obj.separator);
                display_name.push(str_val);
                if (item['name'] != undefined) display_name_type[str_val] = 'is_a_name';
                else display_name_type[str_val] = 'not_a_name';
            }
        });

        display_name.sort();
        var html_str = '';
        $.each(display_name, function(i, name) {
            if (display_name_type[name] == 'is_a_name') html_str += "<label class='event_entry_label'><span class='event_entry_file_icon'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + name + "</label><br/>";
            else html_str += "<label class='event_entry_label'><span class='event_entry_folder_icon'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + name + "</label><br/>";
        });
        return html_str;
    };

    // double_or_single_click should be either dblclick or click
    MonetizationSubtypeFiltersHandler.prototype._bind_click_helper = function($dom, double_or_single_click) {
        var _this_obj = this;
        $dom.unbind(double_or_single_click);
        $dom.bind(
        double_or_single_click, function(event) {
            var curr_val = $($(this).children()[0]).prop('value');
            var st_li = _this_obj._find_tree_node($("#filter_list"), curr_val);
            _this_obj.m_tree.load_datastore($(st_li), null, true /* do_not_open_branch */ );
            var st_lst = curr_val.split(_this_obj.separator);
            var arg = {};
            if (curr_val.length > 0) {
                for (var i = 0; i < st_lst.length; i++) {
                    arg[_this_obj._options['qm_arg_prefix'] + i] = st_lst[i];
                }
            } else {
                arg['top_level'] = true;
            }

            // arg looks like
            // example: {fevst1:'', fevst2:'', fevst3: ''}
            _this_obj._load_purgatory_impl(arg);
            return false;
        });
    };

    MonetizationSubtypeFiltersHandler.prototype._add_to_list_impl = function(target, data, render_full_path) {
        var _this_obj = this;
        var common_ancestory = {};

        _this_obj.cached_tree_available_events = {};
        $.each(data, function(i, d) {
            var str_buff = [];
            var k = d[0];
            var curr_item = d[1];
            if (curr_item['rev_type'] != undefined) {
                if (curr_item['rev_type'].length != 0) str_buff.push(curr_item['rev_type']);
                _this_obj._common_ancestory_helper(common_ancestory, 'rev_type', curr_item);
            }
            if (curr_item['subtype1'] != undefined) {
                if (curr_item['subtype1'].length != 0) str_buff.push(curr_item['subtype1']);
                _this_obj._common_ancestory_helper(common_ancestory, 'subtype1', curr_item);
            }
            if (curr_item['subtype2'] != undefined) {
                if (curr_item['subtype2'].length != 0) str_buff.push(curr_item['subtype2']);
                _this_obj._common_ancestory_helper(common_ancestory, 'subtype2', curr_item);
            }
            if (curr_item['subtype3'] != undefined) {
                if (curr_item['subtype3'].length != 0) str_buff.push(curr_item['subtype3']);
            }

            if (str_buff.length > 0) {
                var val = str_buff.join(_this_obj.separator);
                if (render_full_path) {
                    var label = val;
                } else {
                    var label = k;
                }

                var graduated = curr_item['graduated'];
                _this_obj.cached_tree_available_events[val] = curr_item;

                if (graduated == undefined) {
                    var label_class = 'event_entry_label';
                    var icon_class = null;
                    if (curr_item['is_terminal'] != undefined) {
                        icon_class = 'event_entry_file_icon';
                    } else {
                        icon_class = 'event_entry_folder_icon';
                    }
                } else {
                    var label_class = 'event_entry_label_disabled';
                    var icon_class = null;
                    if (curr_item['is_terminal'] != undefined) {
                        icon_class = 'event_entry_file_icon_disabled';
                    } else {
                        icon_class = 'event_entry_folder_icon_disabled';
                    }
                }

                if (curr_item['is_terminal'] != undefined) {
                    var html_entry_str = "<li style='clear:both;'><input type='hidden' value='" + val + "' class='event_entry_list event_name_entry' /><label class='" + label_class + "'><span class='" + icon_class + "'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + label + "</label></li>";
                } else {
                    var html_entry_str = "<li style='clear:both;'><input type='hidden' value='" + val + "' class='event_entry_list' /><label class='" + label_class + "'><span class='" + icon_class + "'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + label + "</label></li>";
                }

                var $new_dom = $(html_entry_str);
                if (graduated == undefined) {
                    // grey out entries are not clickable
                    _this_obj._bind_high_light_click_helper($new_dom);
                }
                if (target == '#event_purgatory_list ul') if (!$new_dom.find('input').hasClass('event_name_entry')) _this_obj._bind_click_helper($new_dom, 'dblclick');

                $(target).append($new_dom);
            } //if(str_buff.length > 0)
        }); // for
        _this_obj._init_selectable(target);

        if (common_ancestory['rev_type'] == undefined || common_ancestory['rev_type'] == false || common_ancestory['rev_type'].length == 0) {
            delete common_ancestory['rev_type'];
        }
        if (common_ancestory['subtype2'] == undefined || common_ancestory['subtype2'] == false || common_ancestory['subtype2'].length == 0) {
            delete common_ancestory['subtype2'];
        }
        if (common_ancestory['subtype1'] == undefined || common_ancestory['subtype1'] == false || common_ancestory['subtype1'].length == 0) {
            delete common_ancestory['subtype1'];
        }

        var common_ancestory_buf = [];
        var common_ancestory_len = 0;
        $.each(common_ancestory, function(i, d) {
            common_ancestory_buf.push(d);
            common_ancestory_len++;
        });
        common_ancestory_buf.pop(); // need to get rid one level in order to traverse one level up.
        if (target == '#event_purgatory_list ul') {
            // if this level doesn't have anything.
            var free_pass = false;
            if (data.length == 0) {
                var clicked = $("a.clicked").parent();
                if (clicked.length > 0) {
                    common_ancestory_buf = [];

                    while (true) {
                        var st = clicked.attr('subtype');
                        common_ancestory_buf.push($.trim($($(clicked).children()[0]).text()));
                        if (st == 0) break;
                        else clicked = clicked.parent().parent();
                    }
                    common_ancestory_buf.reverse();
                    common_ancestory_buf.pop();
                    common_ancestory_len = common_ancestory_buf.length;
                    free_pass = true;
                }
            }

            if (common_ancestory_len > 0 || free_pass) {
                // up button
                var val = common_ancestory_buf.join(_this_obj.separator);
                var up_html_str = "<li style='clear:both;'><input type='hidden' value='" + val + "'/><label class='event_entry_label'><span class='event_entry_up_arrow_icon'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>..</label></li>";
                var $up_dom = $(up_html_str);
                $(target).prepend($up_dom);
                _this_obj._bind_click_helper($up_dom, 'click');
            }
        } // if(target == '#event_purgatory_list ul'){
    };

    MonetizationSubtypeFiltersHandler.prototype._add_to_search_result_list = function(keys, dict) {
        var _this_obj = this;
        _this_obj.cached_search_available_events = dict;
        $.each(keys, function(i, k) {
            var val = k;
            var label = k;
            var graduated = dict[k]['graduated'];
            var event_name_entry_str = '';

            if (graduated == undefined) {
                var label_class = 'event_entry_label';
                var icon_class = 'event_entry_file_icon';
            } else {
                var label_class = 'event_entry_label_disabled';
                var icon_class = 'event_entry_file_icon_disabled';
            }
            event_name_entry_str = 'event_name_entry';

            var html_str = "<li style='clear:both;'><input type='hidden' value='" + val + "' class='event_entry_list " + event_name_entry_str + "' /><label class='" + label_class + "'><span class='" + icon_class + "'>&nbsp;&nbsp;&nbsp;&nbsp;</span>" + label + "</label></li>";
            var $new_dom = $(html_str);
            if (graduated == undefined) {
                // grey out entries are not clickable
                _this_obj._bind_high_light_click_helper($new_dom);
            }
            $("#search_result_list ul").append($new_dom);
            _this_obj._init_selectable("#search_result_list ul");
        });
    };

    MonetizationSubtypeFiltersHandler.prototype._load_purgatory = function(subtype_level) {
        var arg = {};
        var _this_obj = this;
        // _get_fst0_fst1_fst2_fst3 returns {} it nothing is clicked on. This happens when
        // the tree is first loaded
        arg = this._get_fst0_fst1_fst2_fst3(subtype_level);
        var len = 0;
        for (var k in arg) {
            len++;
        }
        if (len == 0) {
            arg['top_level'] = true;
        }

        this._load_purgatory_impl(arg);
    };

    MonetizationSubtypeFiltersHandler.prototype._onchange_handler = function(n, t, _this_obj) {
        if ($($(n).children()[0]).hasClass('clicked')) {
            // one item is always checked.
            $.tree.plugins.checkbox.check(n);
        }
        if ($(n).attr('subtype') == '0') {
            if ($($(n).children()[0]).hasClass('checked')) {
                var lst_of_st1 = $("li[subtype='0']");
                for (var i = 0; i < lst_of_st1.length; i++) {
                    var curr_dom = lst_of_st1[i];
                    if (curr_dom != n) {
                        $.tree.plugins.checkbox.uncheck(curr_dom);
                    }
                }
            }
        } else if ($(n).attr('subtype') == '1' || $(n).attr('subtype') == '2' || $(n).attr('subtype') == '3') {
            _this_obj._handle_subtree(n);
        }

        return true;
    };

    MonetizationSubtypeFiltersHandler.prototype._handle_ajax_search = function(_this_obj, data, r_key, r_dict) {
        $.each(data.events, function(i, d) {
            var st1 = d['subtype1'];
            var st2 = d['subtype2'];
            var st3 = d['subtype3'];
            var rev_type = d['type'];
            var str_buf = [];
            var has_rev_type, has_st1, has_st2, has_st3 = false;
            if (rev_type.length > 0) {
                has_rev_type = true;
                str_buf.push(rev_type);
            }
            if (has_rev_type && st1.length > 0) {
                has_st1 = true;
                str_buf.push(st1);
            }
            if (has_st1 && st2.length > 0) {
                has_st2 = true;
                str_buf.push(st2);
            }
            if (has_st1 && has_st2 && st3.length > 0) {
                str_buf.push(st3);
            }
            var s = str_buf.join(_this_obj.separator);
            r_key.push(s);
            r_dict[s] = d;
        });
    };

    function MonetizationSubtypeFilters() {
        this.handler = null;
        this._init = function() {
            this.handler = new MonetizationSubtypeFiltersHandler(this.element, this.options);
            this.handler._init_ui_element();

            // Monetization selector does not support pivoting
            $("#" + this.handler._id).find('.event-selector-toggle').hide();
        };
    };

    /////////////////////// Widget Construction ///////////////////////
    var eventSubtypeFilters = new EventSubtypeFilters();
    $.widget("ui.eventSubtypeFilters", eventSubtypeFilters);

    var monetizationSubtypeFilters = new MonetizationSubtypeFilters();
    $.widget("ui.monetizationSubtypeFilters", monetizationSubtypeFilters);


})(jQuery);

var CREATE_EVENT_WHITE_LIST_URL = '/event_filter/ajax_create_event_white_list/';
var CREATE_EVENT_HIDDEN_LIST_URL = '/event_filter/ajax_create_event_hidden_list/';


function build_list_impl(ele, master_list, unchanged_list, parent_list, subtype_level, get_checked_entries){
  //Copy current hiearchical list
  var cur_list = $.extend({}, parent_list);

  var entry_selector_func = null;
  if (get_checked_entries) {
    entry_selector_func = is_checked;
  } else {
    entry_selector_func = is_unchecked;    
  }
  
  //Append the proper name to the list
  if(is_leaf(ele)) {	
    cur_list['event_name'] = get_leaf_text(ele);
  } else {
    cur_list['fevst' + subtype_level] = get_node_text(ele);
  }

  //If checked we want everything included in this path
  if (entry_selector_func(ele)) {

    if(ele.attr('count')) {
      cur_list['count'] = ele.attr('count');
    } else {
      cur_list['count'] = 1;
    }

    master_list.push(cur_list);
    //If undetermined we need to recurse and figure out what else we want in the path
  } else if (is_undetermined(ele)) {
    var st = get_checkbox_subtree(ele);
    if (st.length == 0) {
      unchanged_list.push(cur_list);
    } else {    
      st.each( function() {
        build_list_impl($(this), master_list, unchanged_list, cur_list, subtype_level+1, get_checked_entries);
      });
    }    
  }  
}

function build_hidden_list(ele, master_list, unchanged_list, parent_list, subtype_level) {
  build_list_impl(ele, master_list, unchanged_list, parent_list, subtype_level, false);  
}

function build_selected_list(ele, master_list, unchanged_list, parent_list, subtype_level) {
  build_list_impl(ele, master_list, unchanged_list, parent_list, subtype_level, true);
}

function save_list_impl(build_list_func, ajax_url, $save_button, $cancel_button, $list_filter, get_checked_entries) {
  var root = get_root();
  var entry_selector_func = null;
  if (get_checked_entries) {
    entry_selector_func = is_checked;
  } else {
    entry_selector_func = is_unchecked;    
  }
  
  var master_list = new Array();
  var unchanged_list = new Array();
  var parent_list = {};
  
  if(entry_selector_func(root)) {
    master_list = "all";
  }
  else if (is_undetermined(root)) {
    var st = get_checkbox_subtree(root);
    // we don't have a subtree, which means it was never loaded, so we need to note that nothing there could have changed
    if (st.length == 0) {
      unchanged_list.push('all');
    } else {
      st.each( function() {
	build_list_func($(this), master_list, unchanged_list, parent_list, 1);
      });
    }    
  }
  
  var arg = {};
  arg['master_list'] = JSON.stringify(master_list);
  arg['unchanged_list'] = JSON.stringify(unchanged_list);
  if (ajax_url == CREATE_EVENT_WHITE_LIST_URL)
    arg['unadulterated_list'] = 1;

  //Disable anything actionable in the dialog while we process the save
  $save_button.unbind('click');
  $cancel_button.removeClass('close');
  var loading_indicator = $("<ul class='ltr' style='direction:ltr;'>\
			    <li class='last'>\
			    <a class='loading' href='#'><ins>&nbsp;</ins>Saving ...</a>\
			    </li>\
			    </ul>");
  $list_filter.html(loading_indicator);

  ktAjaxWrapper(
    {
      type: "POST",
      url : ajax_url,
      data: arg,
      success: function(data){
	if(_refresh_on_save) {
	  location.reload();
	} else {
	  $cancel_button.addClass('close').trigger('click');
	  if(_on_save){
	    _on_save.call();
	  }
	}
      },
      error: function(XMLHttpRequest, textStatus, errorThrown) {
	console.log(errorThrown);
      }
    });// ktAjaxWrapper  
}

function save_white_list() {
  save_list_impl(build_selected_list, CREATE_EVENT_WHITE_LIST_URL, 
                 $('#white_list_save_button'),
                 $('#white_list_cancel_button'),
                 $('#white_list_filter'),
                 true
                );
}

function save_hidden_list() {
  save_list_impl(build_hidden_list, CREATE_EVENT_HIDDEN_LIST_URL,
                 $('#active_event_save_button'),
                 $('#active_event_cancel_button'),
                 $('#active_event_filter'),
                 false
                );
}

function get_fevst1_fevst2_fevst3_name_helper(n, r) {
  var curr_event_name = $(n).attr('event_name');
  if (curr_event_name != undefined) {
    var curr_text = $.trim($(n).attr('event_name'));
    r['event_name'] = curr_text;
    n = $(n).parent().parent();
    get_whitelist_fevst1_fevst2_fevst3_helper(n, r);
  } else {
    get_whitelist_fevst1_fevst2_fevst3_helper(n, r);

  }
}

function get_whitelist_fevst1_fevst2_fevst3_helper(n, r) {
  var curr_subtype = $(n).attr('subtype');
  var curr_text = $(n).attr('subtype_name');
  if (curr_subtype != undefined) if (curr_subtype == 3) {
    r['fevst3'] = curr_text;
    r['fevst2'] = $(n).parent().prev().parent().attr('subtype_name');
    r['fevst1'] = $(n).parent().parent().parent().prev().parent().attr('subtype_name');
  } else if (curr_subtype == 2) {
    r['fevst2'] = curr_text;
    r['fevst1'] = $(n).parent().prev().parent().attr('subtype_name');
  } else if (curr_subtype == 1) {
    r['fevst1'] = curr_text;
  } else if (curr_subtype == 0) {
    r['fevst0'] = curr_text;
  }
}

function get_leaf_text(ele) {
  return $.trim(ele.attr('event_name'));
}

function get_node_text(ele) {
  return $.trim(ele.attr('subtype_name'));
}

function is_undetermined(ele) {
  return $(ele.children("a")).is('.undetermined');
}

function is_checked(ele) {
  return $(ele.children("a")).is('.checked');
}

function is_unchecked(ele) {
  return $(ele.children("a")).is('.unchecked');
}

function is_leaf(ele) {
  return ele.is('.leaf');
}

function get_root() {
  return get_checkbox_subtree($('#white_list_filter'));
}

function get_checkbox_subtree(ele) {
  return ele.children("ul").children();
}

function replace_counts(ele, selected_count, count) {
  if (!is_leaf($(ele))) {
    var str = ele.children("a").text();
    var new_text = str.substring(0, str.indexOf("(", 0)) + "(" + selected_count + " / " + count + ")";
    ele.children("a").html("<ins>&nbsp;</ins>" + $.trim(new_text));
  }
}

function update_selected_total(new_count) {
  var max = parseInt($('#num_remaining').text());

  if (new_count > max) {
    return false;
  } else {
    $('#num_listed').text(new_count);
    return true;
  }
}

function set_child_counts(ele, type) {

  $(ele).children("ul").children().each(function() {
    var new_count;
    var count = $(this).attr('count');

    if (type == "full") {
      new_count = count;
    } else {
      new_count = 0;
    }

    $(this).attr('selected_count', new_count);
    replace_counts($(this), new_count, count);

    set_child_counts($(this), type);
  });
}

(function($) {
  function AbstractEventManageHandler(element, options) {
    this._element = element;
    this._options = options;
    this.m_tree = null;
    if (this._element != undefined) this._id = element.prop('id');
    this.gen_subtype_url = null;
  }

  AbstractEventManageHandler.prototype = {
    _get_ui_template: function() {
      var template_str = "<div>\
	<div id='white_list_filter'></div>\
      </div>";
      return template_str;
    },

    _init_ui_element: function() {
      var _this_obj = this;
      $("#" + this._id).ktTemplate({
        template: this._get_ui_template()
      });
      $("#" + this._id).ktTemplate("render", {});
      _this_obj._build_white_list_tree_helper();
    },

    _build_white_list_tree_helper: function() {
      $("#" + this._id + " div[id='white_list_filter']").empty();
      var _this_obj = this;
      var st_tree = $("#" + this._id + " div[id='white_list_filter']").tree({
        data: {
          type: "json",
          async: true,
          opts: {
            method: 'post',
            url: _this_obj.gen_subtype_url
          }
        },
        ui: {
          theme_name: "checkbox"
        },
        types: {
          "default": {
            draggable: false
          }
        },
        plugins: {
          "checkbox": {}
        },
        //plugins
        callback: {
          onload: function(n, t) {
            var root = get_root();
            $('#num_listed').text(root.attr('selected_count'));
          },
          onchange: function(n, t) {},
          onselect: function(n, t) {

            var count = $(n).attr('count');

            var old_selected_count = $(n).attr('selected_count');

            var child_action;

            if (is_checked($(n))) {
              //Means we are UNchecking
              $(n).attr('selected_count', 0);
              child_action = "reset";
            } else {
              //Means we're checking
              $(n).attr('selected_count', count);
              child_action = "full";
            }

            var selected_count = $(n).attr('selected_count');

            var parent_adjustment;

            selected_count = parseInt(selected_count);
            if (is_checked($(n))) {
              //Means we are UNchecking
              parent_adjustment = -old_selected_count;
            } else {
              //Means we're checking
              parent_adjustment = (selected_count - old_selected_count);
            }


            //TODO clean up
            var curr_event_name = $(n).attr('event_name');

            //Adjust root numbers
            var root = get_root();

            var root_selected_count;

            if ($(n).attr('subtype_name') != "All Events") {
              root_selected_count = parseInt(root.attr('selected_count')) + parent_adjustment;
            } else {
              root_selected_count = selected_count;
            }

            if (!update_selected_total(root_selected_count)) {
              $(n).attr('selected_count', old_selected_count);

              $(n).addClass("cancel");

              Boxy.ask("Maximum number of white listed events exceeded. Would you like to upgrade your account?", ["Yes", "No"], function(val) {
                if (val == "Yes") {
                  window.location.replace('/dashboard/account_type');
                }
              });
              return;
            }

            set_child_counts($(n), child_action);


            replace_counts($(n), selected_count, count);


            var root_count = root.attr('count');

            //Update running total, check for exceeding
            root.attr('selected_count', root_selected_count);

            $('#num_listed').text(root.attr('selected_count'));

            replace_counts(root, root_selected_count, root_count);

            if (curr_event_name != undefined) {
              n = $(n).parent().parent();

              if ($(n).attr('subtype_name') != "All Events") {
                var parent_selected_count = parseInt($(n).attr('selected_count')) + parent_adjustment;
                var parent_count = $(n).attr('count');
                n.attr('selected_count', parent_selected_count);
                replace_counts(n, parent_selected_count, parent_count);
              }
            }

            var curr_subtype = $(n).attr('subtype');

            if (curr_subtype == 3) {
              var parent = $($(n).parent().prev().parent());
              var parent_selected_count = parseInt(parent.attr('selected_count')) + parent_adjustment;
              parent.attr('selected_count', parent_selected_count);
              var parent_count = parent.attr('count');
              replace_counts(parent, parent_selected_count, parent_count);

              var grand_parent = $($(n).parent().parent().parent().prev().parent());
              var grand_parent_selected_count = parseInt(grand_parent.attr('selected_count')) + parent_adjustment;
              grand_parent.attr('selected_count', grand_parent_selected_count);
              var grand_parent_count = grand_parent.attr('count');
              replace_counts(grand_parent, grand_parent_selected_count, grand_parent_count);

            } else if (curr_subtype == 2) {
              var parent = $($(n).parent().prev().parent());
              var parent_selected_count = parseInt(parent.attr('selected_count')) + parent_adjustment;
              parent.attr('selected_count', parent_selected_count);
              var parent_count = parent.attr('count');
              replace_counts(parent, parent_selected_count, parent_count);
            }




          },
          onload: function(t) {
            _this_obj.m_tree = t;
            _this_obj.m_tree.load_datastore($("#white_list_filter li[subtype=0]"), null, true /* do_not_open_branch */ );
          },
          beforedata: function(n, t) {
            var r = {};

            if (n) {
              if (is_checked(n)) {
                r['parent_state'] = 'checked';
              } else if (is_undetermined(n)) {
                r['parent_state'] = 'undetermined';
              } else {
                r['parent_state'] = 'unchecked';
              }
              get_whitelist_fevst1_fevst2_fevst3_helper(n, r);
            } else {
              r['top_level'] = true;
            }
            r['unadulterated_list'] = 1;
            r['counts'] = 1;

            return r;
          }
        }
      }); //tree
    }
  };

  
  /////////////////////// EventWhiteListFiltersHandler  ///////////////////////
  function EventWhiteListFiltersHandler(element, options) {
    this.inheritedFrom = AbstractEventManageHandler;
    this.inheritedFrom(element, options);
    this.gen_subtype_url = '/event_filter/ajax_get_subtype_tree_4_whitelist/';
  };

  EventWhiteListFiltersHandler.prototype = new AbstractEventManageHandler();
  
  function EventWhiteListFilters() {
    this.handler = null;
    this._init = function() {
      this.handler = new EventWhiteListFiltersHandler(this.element, this.options);
      this.handler._init_ui_element();
    };
  };
  
  /////////////////////// ManageActiveEventFiltersHandler  ///////////////////////  
  function ManageActiveEventFiltersHandler(element, options) {
    this.inheritedFrom = AbstractEventManageHandler;
    this.inheritedFrom(element, options);
    this.gen_subtype_url = '/event_filter/ajax_get_subtype_tree_4_manage/';
  };
  ManageActiveEventFiltersHandler.prototype = new AbstractEventManageHandler();

  function ManageActiveEventFilters() {
    this.handler = null;    
    this._init = function() {
      this.handler = new ManageActiveEventFiltersHandler(this.element, this.options);
      this.handler._init_ui_element();
    };
  };

  /////////////////////// Widget Construction ///////////////////////
  var eventWhiteListFilters = new EventWhiteListFilters();
  $.widget("ui.eventWhiteListFilters", eventWhiteListFilters);

  var manageActiveEventFilters = new ManageActiveEventFilters();
  $.widget("ui.manageActiveEventFilters", manageActiveEventFilters);

})(jQuery);

/*
 *   Depends:
 *	ui.core.js
 */

function get_fevst1_fevst2_fevst3_name_helper(n, r) {
    var curr_event_name = $(n).attr('event_name');
    if (curr_event_name != undefined) {
        var curr_text = $.trim($(n).attr('event_name'));
        r['event_name'] = curr_text;
        n = $(n).parent().parent();
        get_fevst1_fevst2_fevst3_helper(n, r);
    } else {
        get_fevst1_fevst2_fevst3_helper(n, r);

    }
}

function get_fevst1_fevst2_fevst3_helper(n, r) {
    var curr_subtype = $(n).attr('subtype');
    var curr_text = $.trim($($(n).children()[0]).text());
    if (curr_subtype != undefined) if (curr_subtype == 3) {
        r['fevst3'] = curr_text;
        r['fevst2'] = $.trim($(n).parent().prev().text());
        r['fevst1'] = $.trim($(n).parent().parent().parent().prev().text());
    } else if (curr_subtype == 2) {
        r['fevst2'] = curr_text;
        r['fevst1'] = $.trim($(n).parent().prev().text());
    } else if (curr_subtype == 1) {
        r['fevst1'] = curr_text;
    } else if (curr_subtype == 0) {
        r['fevst0'] = curr_text;
    }
}

function find_clicked_leaf() {
    var clicked = $('#filter_list').find('.clicked');

    if (clicked.length && clicked.parent().is('.leaf')) {
        return clicked.parent();
    } else {
        return false;
    }
}

function set_selected_text(ele) {

    if ($(ele).is('.leaf')) {
        r = {}
        get_fevst1_fevst2_fevst3_name_helper(ele, r);

        var str = ""

        if (r['fevst1']) {
            str += r['fevst1'] + "/";
        }
        if (r['fevst2']) {
            str += r['fevst2'] + "/";
        }
        if (r['fevst3']) {
            str += r['fevst3'] + "/";
        }

        str += r['event_name'];

        $("#selected_event").text(str);
    } else {
        $("#selected_event").text("--");
    }
}

(function($) {
    function AbstractFiltersHandler(element, options) {

        this._element = element;
        this._options = options;
        if (this._element != undefined) this._id = element.prop('id');
    };


    AbstractFiltersHandler.prototype = {
        _get_ui_template: function() {
            var template_str = "<div>\
           <div class='k-box-head'>\
             <div class='k-box-head-info'>\
	       <h1>[=title]</h1>\
             </div>\
           </div>\
          </div>\
	  <div class='block-bg'>\
           <div id='filter_list'></div>\
         <ul class='options'>\
               <li class='first'>\
                 <a id='apply_filters' href='#'>Apply</a>\
               </li>\
       	     </ul>\
	   </div>";
            return template_str;
        },

        _init_ui_element: function() {
            $("#" + this._id).ktTemplate({
                template: this._get_ui_template()
            });
            $("#" + this._id).ktTemplate("render", {
                title: this.title
            });

        }
    };

    //////////////////// EventSelector ////////////////////


    function EventSelectorHandler(element, options) {
        this.inheritedFrom = AbstractFiltersHandler;
        this.inheritedFrom(element, options);
        this.title = "Event";
        this.cached_tree_available_events = {}; // cached data to help toggling between the tree and search tab
        this.cached_search_available_events = {}; // cached data to help toggling between the tree and search tab
        this.m_tree = null;
        this.separator = ' / ';
    };
    EventSelectorHandler.prototype = new AbstractFiltersHandler();


    function EventSelector() {
        this.handler = null;
        this._init = function() {
            this.handler = new EventSelectorHandler(this.element, this.options);
            this.handler._init_ui_element();
        };
    };

    EventSelectorHandler.prototype._get_ui_template = function() {
        var template_str = "<div id='event_tree_view_box'>\
			<div class='kt-left' style='width:100%;'>Select Event\
			  <div id='filter_list' class='event_tree_container'></div>\
			</div>\
	    </div><!---event_tree_view_box-->\
		";
        return template_str;
    };

    EventSelectorHandler.prototype.recursive_uncheck_parents_siblings = function(dom) {
        var siblings = $($($(dom).parent()).parent()).siblings();
        var len = siblings.length;
        var curr_dom = null;
        for (var i = 0; i < len; i++) {
            curr_dom = siblings[i];
            $.tree.plugins.checkbox.uncheck(curr_dom);
        } // for
        if (curr_dom == null) {
            // this could be case when its parent has no sibling.
            // However, we still need to recurse one level higher.
            // Need to uncheck grandparent's siblings if there's any.
            var tmp_dom = $($(dom).parent()).parent();
            if (tmp_dom.length == 1) curr_dom = tmp_dom[0];
        }

        if (curr_dom != null) {
            // only need to recurse once. Since all sibling nodes can have only one parent.
            var subtype_str = $(curr_dom).attr('subtype');
            if (subtype_str != undefined && subtype_str != "1") {
                this.recursive_uncheck_parents_siblings(curr_dom);
            }
        }
    };


    EventSelectorHandler.prototype._handle_subtree = function(dom) {
        //
        // check to see if any of the siblings are checked.
        // If so, uncheck them.
        //
        var siblings = $(dom).siblings();
        var need_to_check_myself = false;
        for (var i = 0; i < siblings.length; i++) {
            var curr_dom = siblings[i];
            if (!$(curr_dom).hasClass('checked')) {
                $.tree.plugins.checkbox.uncheck(curr_dom);
                need_to_check_myself = true;
            }
        } // for
        //
        // Make sure that you check this node, namely dom.
        //
        if (need_to_check_myself) {
            $.tree.plugins.checkbox.check(dom);
        }

        // uncheck older relatives
        this.recursive_uncheck_parents_siblings(dom);
    };

    EventSelectorHandler.prototype._set_height = function() {
        var children = $('#filter_list ul.ltr').children();
        var height_accum = 0;
        for (var i = 0; i < children.length; i++) {
            height_accum += $(children[i]).height();
        }
        $('#filter_list ul.ltr').css('height', height_accum + "px");
    };



    EventSelectorHandler.prototype._find_tree_node = function(parent_level_node, value) {
        var subtype_list = value.split(this.separator);
        for (var i = 0; i < subtype_list.length; i++) {
            var st_text = subtype_list[i];
            var st_li_list = parent_level_node.find("li[subtype=" + (i + 1) + "]");
            for (var j = 0; j < st_li_list.length; j++) {
                var li = st_li_list[j];
                if ($($(li).children()[0]).text().replace(/^\s+|\s+$/g, "") == st_text) {
                    parent_level_node = $(li);
                    break;
                }
            }
        }
        return parent_level_node;
    };

    EventSelectorHandler.prototype._bind_double_click_helper = function($dom) {
        var _this_obj = this;
        $dom.unbind('dblclick');
        $dom.dblclick(function(event) {
            var curr_val = $($(this).children()[0]).prop('value');
            var st_li = _this_obj._find_tree_node($("#filter_list"), curr_val);
            _this_obj.m_tree.load_datastore($(st_li), null, true /* do_not_open_branch */ );
            var st_lst = curr_val.split(_this_obj.separator);
            var arg = {};
            if (curr_val.length > 0) {
                for (var i = 0; i < st_lst.length; i++) {
                    arg['fevst' + (i + 1)] = st_lst[i];
                }
            } else {
                arg['top_level'] = true;
            }

            // arg looks like
            // {fevst1:'', fevst2:'', fevst3: ''}
            _this_obj._load_purgatory_impl(arg);
            return false;
        });
    };

    EventSelectorHandler.prototype._build_st_tree_helper = function() {
        $("#" + this._id + " div[id='filter_list']").empty();
        var _this_obj = this;
        var st_tree = $("#" + this._id + " div[id='filter_list']").tree({
            data: {
                type: "json",
                async: true,
                opts: {
                    method: 'post',
                    url: '/event_filter/ajax_get_subtype_tree/'
                }
            },
            // data
            ui: {
                theme_name: "classic",
                theme_path: "/static/js/third-party/jsTree/themes/classic/style.css"
            },
            types: {
                "default": {
                    draggable: false
                }
            },
            plugins: {
                "checkbox": {

                }
            },
            //plugins
            callback: {
                onchange: function(n, t) {
                    if ($($(n).children()[0]).hasClass('clicked')) {
                        // one item is always checked.
                        $.tree.plugins.checkbox.check(n);
                    }
                    if ($(n).attr('subtype') == '1') {
                        if ($($(n).children()[0]).hasClass('checked')) {
                            var lst_of_st1 = $("li[subtype='1']");
                            for (var i = 0; i < lst_of_st1.length; i++) {
                                var curr_dom = lst_of_st1[i];
                                if (curr_dom != n) {
                                    $.tree.plugins.checkbox.uncheck(curr_dom);
                                }
                            }
                        }
                    } else if ($(n).attr('subtype') == '2' || $(n).attr('subtype') == '3') {
                        _this_obj._handle_subtree(n);
                    }


                    set_selected_text(n);
                    return true;
                },
                onclose: function(n, t) {
                    _this_obj._set_height();
                },
                onopen: function(n, t) {
                    _this_obj._set_height();
                    //t.callback('onsingleclk', [n, t]); //treat selecing a branching as a single click event
                },
                onload: function(t) {
                    _this_obj.m_tree = t;
                    _this_obj._set_height();
                    $(document).trigger('event_subtype_filter_done');
                },
                onsingleclk: function(n, t) {
                  var $addButton = $('#start-tracking');
                  var isLeaf = $(n).hasClass('leaf');
                  isLeaf ? $addButton.removeClass('kt-disabled') : $addButton.addClass('kt-disabled');
                    //t.load_datastore(t.get_node(n), null, true /* do_not_open_branch */);
                },
                ondblclk: function(n, t) {
                  ManageSteps.addStep();
                },
                beforedata: function(n, t) {
                    var r = {};
                    if (n) {
                        var curr_subtype = $(n).attr('subtype');
                        var curr_text = $.trim($($(n).children()[0]).text());
                        if (curr_subtype == 3) {
                            r['fevst3'] = curr_text;
                            r['fevst2'] = $.trim($(n).parent().prev().text());
                            r['fevst1'] = $.trim($(n).parent().prev().parent().parent().prev().text());
                        } else if (curr_subtype == 2) {
                            r['fevst2'] = curr_text;
                            r['fevst1'] = $.trim($(n).parent().prev().text());
                        } else if (curr_subtype == 1) {
                            r['fevst1'] = curr_text;
                        } else if (curr_subtype == 0) {
                            r['fevst0'] = curr_text;
                        }
                    } else {
                        r['top_level'] = true;
                    }

                    r['show_files'] = true;
                    return r;
                }
            }
        }); // tree
    };


    EventSelectorHandler.prototype._init_ui_element = function() {
        //
        // call parent's _init_ui_element
        //
        AbstractFiltersHandler.prototype._init_ui_element.call(this);

        //
        // setup the tree
        //
        var _this_obj = this;
        var root_url = (this._options['root_url']);
        _this_obj._build_st_tree_helper();

        // repopulate the subtype1 level
        $(document).bind('event_subtype_filter_done', function() {
            _this_obj.m_tree.load_datastore($("li[subtype=0]"), null, true /* do_not_open_branch */ );
        });

        //setup app_handle_update event
        $(document).bind('app_handle_updated', function() {
            _this_obj._build_st_tree_helper();
        });

        //Allow us to refresh the selector
        $(document).bind('refresh_event_selector', function() {
            _this_obj._build_st_tree_helper();
        });



    }; //EventSelectorHandler.prototype._init_ui_element = function()

    /////////////////////// Widget Construction ///////////////////////
    var eventSelector = new EventSelector();
    $.widget("ui.eventSelector", eventSelector);

})(jQuery);


function detect_textinput_change($root_dom) {
  var $input_title_text = $root_dom.find('input.title:text');
  var content = $input_title_text.val();
  //var content = $('input.title:text').val();
  $input_title_text.keyup(function() {
    var $this = $(this);
    if ($this.val() !== content) {
      if ($this.val() === "") {
        $this.parents('tr').parent().find('.an_submit').addClass('kt-disabled');
      } else {
        content = $this.val();
        $this.parents('tr').parent().find('.an_submit').removeClass('kt-disabled');
      }
    }
  });

  var $text_input  = $root_dom.find('.text_input');
  var text = $text_input.val();
  // use keydown() because it appears that webkit browsers don't understand the keypress event
  $text_input.keydown(function() {
    var $this = $(this);
    if ($this.val() !== text) {
      content = $this.val();

	  // check to see if title is not blank even if the description button has content before enabling the submit button
	  if($this.parents('.annotation-wrapper').find('input.title:text').val() !== "") {
		  $this.parents('tr').parent().find('.an_submit').removeClass('kt-disabled');
	  }
    }
  });

  $root_dom.find('input[type=radio]').change(function() {
        var $this = $(this);
  	if($this.parents('.annotation-wrapper').find('input.title:text').val() !== "") {
    	$this.parents('.annotation-wrapper').find('.an_submit').removeClass('kt-disabled');
	}
  });
}

/*
 Binding Calendar.js with all date input fields on the
 page requires unique ids. Ids of the date fields all have
 their respective chart index with it.
*/
function bind_date_input() {
  $("input[id^='date_']").each(function() {
     $('.date').datepicker({dateFormat: 'yy-mm-dd'});
  });
}
$(document).ready(bind_date_input);

function fill_annotation_data(tbody, a_lst) {
  function html_escape(str) {
    // Filter the input for display
    return $("<div/>").text(str).html();
  }

  tbody.empty();
  for (var a in a_lst) {
    var text = (a_lst[a].text && a_lst[a].text !== "null") ? html_escape(a_lst[a].text) : "";
    var creator = (a_lst[a].creator && a_lst[a].creator !== " ") ? html_escape(a_lst[a].creator) : "unknown";
    text = text.replace(/\n/g, '<br />');
    var template_str = Template.render('annotation_display_row', {
      key_id      : a_lst[a].keyid,
      date        : a_lst[a].date,
      title       : html_escape(a_lst[a].title),
      share_level : a_lst[a].share_level.toLowerCase(),
      text        : text,
      action      : a,
      creator     : creator
    });

    tbody.append(template_str);
    tbody.find('tr').filter(':last').addClass(a % 2 ? "even" : "odd");
    var $annotation_content = tbody.parents('.Annotation_content');
    // check the correct visibility
    if (a_lst[a].share_level === 'GLOBAL') {
      $annotation_content.find('#global-visibility').prop('checked', true);
      $annotation_content.find('#private-visibility').prop('checked', false);
      $annotation_content.find('#public-visibility').prop('checked', false);
      $annotation_content.find('#limited-visibility').prop('checked', false);
    } else if (a_lst[a].share_level === 'PRIVATE') {
      $annotation_content.find('#private-visibility').prop('checked', true);
      $annotation_content.find('#public-visibility').prop('checked', false);
      $annotation_content.find('#global-visibility').prop('checked', false);
      $annotation_content.find('#limited-visibility').prop('checked', false);
    } else if (a_lst[a].share_level === 'PUBLIC') {
      $annotation_content.find('#public-visibility').prop('checked', true);
      $annotation_content.find('#private-visibility').prop('checked', false);
      $annotation_content.find('#global-visibility').prop('checked', false);
      $annotation_content.find('#limited-visibility').prop('checked', false);
    } else if (a_lst[a].share_level === 'LIMITED') {
      $annotation_content.find('#limited-visibility').prop('checked', true);
      $annotation_content.find('#private-visibility').prop('checked', false);
      $annotation_content.find('#public-visibility').prop('checked', false);
      $annotation_content.find('#global-visibility').prop('checked', false);
    }
    bind_edit_annotation();
  }
  tbody.parents('.Annotation_content').show();
  tbody.parents('.Annotation_content').find('.annotation-table-wrapper').hide();
  tbody.parents('.Annotation_content').find('.annotation-visibility-wrapper').hide();
}

function get_chart_annotation_info($ele) {
  var chart_type, uuid;
  var chart_box = $ele.parents('div.annotation').siblings('.kt-chart, .kt-tab-chart');

  var custom_id = chart_box.attr('custom_chart_id');
  var chart_obj = chart_box.data('chart_obj');

  if (custom_id) {
    chart_type = "custom";
    uuid = custom_id;
  } else {
    chart_type = "static";

    if(chart_box.hasClass('kt-tab-chart')) {
      chart_box = chart_box.find('.kt-chart:visible')
    }

    uuid = chart_obj._resource_id;
  }

  return {
    type: chart_type,
    id: uuid,
    use_application: chart_obj.use_annotation_application
  };
}

function bind_submit_annotation($root_dom) {
  var $an_submit = $root_dom.find('.an_submit');
  $an_submit.addClass('kt-disabled');
  $an_submit.unbind('click').click(function() {
    var $this = $(this);
    if (!$this.hasClass('kt-disabled')) {

      var chart_info = get_chart_annotation_info($this);

      var share_level = $this.parents('.annotation-wrapper').find('input[type=radio]:checked').val();
      var private_shown_on = share_level_chart_type_to_private_shown_on(share_level, chart_info.type);
      var data = {
        submit_type: (editable) ? 'edit' : 'submit',
        keyid: point_data.keyid,
        selected_chart_id: chart_info.id,
        share_level: share_level,
        text: $this.parents('.annotation-wrapper').find('tr textarea').val(),
        title: $this.parents('.annotation-wrapper').find('tr input.title:text').val(),
        date: $this.parents('.annotation-wrapper').find('tr input.date:text').val(),
        private: private_shown_on[0],
        shown_on: private_shown_on[1],
        time_mode: $('a.time_mode_button.active').data('time-mode') || 'daily',
        start_day: $('#start_day').val(),
        end_day: $('#end_day').val(),
        use_application: chart_info.use_application
      };

      var time_mode = $('a.time_mode_button.active').data('time-mode') || 'daily';
      data['time_segment'] = time_mode[0];
      if (time_mode === 'daily') {
          data['start_day'] = $('#start_day').val();
          data['end_day'] = $('#end_day').val();
      } else if (time_mode === 'monthly') {
          data['start_day'] = $('#start_month').val();
          data['end_day'] = $('#end_month').val();
      } else if (time_mode === 'weekly') {
          data['start_day'] = $('#start_week').val();
          data['end_day'] = $('#end_week').val();
      } else if (time_mode === 'hourly') {
          data['start_hour'] = $('#start_hour').val();
          data['end_hour'] = $('#end_hour').val();
      }

      if (data['title'] !== "") {
        handle_submit_annotation(data);
        $this.siblings('.an_cancel').click();
      } else {
        Boxy.alert("Annotation title cannot be empty.");
      }
    }
    return false;
  });
} // submit annotation function
var old_html;
var old_class;

function annotation_edit_template(tbody) {
  var $annotation_by_id = $('#au_' + point_data.keyid)
  $annotation_by_id.addClass("annotation_edit highlighted");
  tbody.find('input.date:text').prop('disabled', true);
  $annotation_by_id.find('input.date:text').prop('disabled', true);

  bind_date_input();
}

function cancel_edit_annotation(tr) {

  tr.removeClass();
  tr.empty();
  tr.addClass(old_class);

  tr.append(old_html);

  bind_edit_annotation();
}

var curr_custom_chart_id;

function bind_edit_annotation() {
  var $an_edit = $('.an_edit');
  $an_edit.die('click');
  $an_edit.live('click', function() {
    var $this = $(this),
        $annotation_by_keyid = $("#au_" + point_data.keyid)
    $this.closest('table').hide();
    $this.parents('.annotation-wrapper').find('.annotation-table-wrapper, .annotation-visibility-wrapper').show();
    $('tbody:data(selected)').removeData("selected");
    // add active-cancel class so when closing the annotation form, we can click just the cancel link with this class
    $this.parents('.annotation-wrapper').find('.annotation-table-wrapper .an_cancel').addClass('active-cancel');
    if ($annotation_by_keyid.hasClass('annotation_edit highlighted')) {
      cancel_edit_annotation($annotation_by_keyid);
    }

    var a_obj = point_data = point_data_lst[$this.attr('index')];
    var tbody = $('.annotation-wrapper tbody');

    if (tbody.prev().is(":visible")) {
      tbody.prev().find('.an_cancel').click();
    }

    if ($this.parents('div.annotation').prev().attr('custom_chart_id')) {
      curr_custom_chart_id = $this.parents().prev('div[custom_chart_id]').attr('custom_chart_id');
    }

    tbody.data("selected", true);
    annotation_edit_template(tbody);

    // counter
    var $anno_counter = $('.anno_counter').filter(':visible').find('span');
    var $first = $anno_counter.filter(':first'),
        $last = $anno_counter.filter(':last');
    $first.text(a_obj.index !== undefined ? a_obj.index - (-1) : "0");
    $last.text(" / " + (a_obj.total ? a_obj.total : "0"));

    // fill in the blanks.
    tbody.find('input.title:text').val(a_obj.title ? a_obj.title : "");
    tbody.find('input.date:text').val(a_obj.date);
    // depending on title is empty or not..
    if (a_obj.title) {
      tbody.parents().find('.an_delete').show();
    } else {
      $('.an_delete', '.form_fnc', tbody).hide();
    }
    editable = (a_obj.title) ? true : false;

    tbody.find('.text_input').val(a_obj.text !== "null" ? a_obj.text : "");
    if (a_obj.share_level) tbody.find("." + a_obj.share_level.toLowerCase() + " input").prop('checked', true);

    return false;
  });
}

function bind_delete_annotation($root_dom) {
  $root_dom.find('.an_delete').click(function() {
    var $this = $(this);
    if ($this.is(":visible")) {
      var chart_info = get_chart_annotation_info($this);

      var private_shown_on = share_level_chart_type_to_private_shown_on(point_data.share_level, chart_info.type);
      var data = {
        submit_type: 'delete',
        keyid: point_data.keyid,
        private: private_shown_on[0],
        shown_on: private_shown_on[1],
        share_level: point_data.share_level,
        selected_chart_id: chart_info.id
      };

      handle_submit_annotation(data);
      $this.siblings('.an_cancel').click();
    }
    return false;
  });
}

function new_anno_timestamp() {
  var d = new Date();
  var curr_date = d.getDate().toString();
  if (curr_date.toString().length === 1) curr_date = "0" + curr_date;
  var curr_month = d.getMonth();
  curr_month++;
  if (curr_month.toString().length === 1) curr_month = "0" + curr_month;
  var curr_year = d.getFullYear();

  curr_timestamp = curr_year + "-" + curr_month + "-" + curr_date;
}

function bind_create_new_annotation($root_dom) {
  var $createnew = $root_dom.find('.createnew');
  $createnew.unbind('click');
  $createnew.click(function() {
    var $this = $(this),
        $annotation_by_keyid = $("#au_" + point_data.keyid),
        $annotation_content = $this.parent().next('.Annotation_content');
    editable = false;
    $(".annotation-wrapper > table").hide();
    if ($annotation_content.find('tbody').filter(':first').filter(':hidden').length > 0) {

	  // click active cancel links to cancel all other forms
      $('.an_cancel.active-cancel').click();

	  // change annotation title
      $this.text('- Create New Annotation');

	  // show form
	  $annotation_content.find('.annotation-table-wrapper, .annotation-visibility-wrapper').show();
      if ($annotation_by_keyid.hasClass('annotation_edit highlighted')) {
        cancel_edit_annotation($annotation_by_keyid);
      }

	  // add active-cancel class to the visible cancel link
	  $this.parent().next().find('.annotation-table-wrapper .an_cancel').addClass('active-cancel');

      $annotation_content.show();

      var cdiv_id = "#" + $annotation_content.prop('id');
      $('.Annotation_content').not(cdiv_id).hide()
      $('.Annotation_content').not(cdiv_id).find(".annotation-wrapper > table").empty();

	  // reset form input values
      $annotation_content.find('textarea').val('');
      $annotation_content.find('input:text').val('');
      $annotation_content.find('.private input').prop('checked', true);
      $annotation_content.find('input.date:text').prop('disabled', false);
      $annotation_content.find('.an_submit').addClass('kt-disabled');
      $annotation_content.find('.an_delete').hide();
    } else {
      $this.text('+ Create New Annotation');
	  $this.parent().next().find('.annotation-table-wrapper .an_cancel').removeClass('active-cancel');

      if ($annotation_content.find(".annotation-wrapper > table tbody").children().length === 0) {
        $annotation_content.hide();
		$annotation_content.find('.annotation-wrapper > table').hide();
      } else {
        $annotation_content.find(".annotation-table-wrapper, .annotation-visibility-wrapper").hide();
      }

      $annotation_content.find('textarea').val('');
      $annotation_content.find('input:text').val('');
      $annotation_content.find('.private input').prop('checked', true);
      $annotation_content.find('input.date:text').prop('disabled', false);
      $annotation_content.find('.an_submit').addClass('kt-disabled');
      $annotation_content.find('.an_delete').hide();
    }
    $annotation_content.find('input.date:text').val(curr_timestamp);
    return false;
  });
}

function bind_cancel_annotation($root_dom) {
  var $an_cancel = $root_dom.find('.an_cancel');
  $an_cancel.click(function() {
    var $this = $(this),
        $annotation_by_keyid = $("#au_" + point_data.keyid);
    $this.removeClass('active-cancel');
    $annotation_by_keyid.show();
    if ($this.parents('tbody').next().children().length === 0) {
      $($this.parents('.annotation').children()[1]).hide();
      //$this.parents().find('.Annotation_content').hide();
    }

    $this.parents().siblings().closest('.Annotation_wrapper').find('.createnew').text('+ Create New Annotation').removeClass('disabled');

    var $prev_tr = $this.closest('tr').prev();
    $prev_tr.find('textarea').val('');
    $prev_tr.find('input.title:text').val('');
    $prev_tr.find('div.private input').prop('checked', true);
    $prev_tr.find('input.date:text').prop('disabled', false);

    $this.siblings('.an_submit').addClass('kt-disabled');
    $this.siblings('.an_delete').hide();

    $this.parents('.Annotation_content').find('.annotation-wrapper > table').hide();

    if ($annotation_by_keyid.hasClass('annotation_edit highlighted')) {
      cancel_edit_annotation($annotation_by_keyid);
    } else if ($this.closest('.annotation_edit').length > 0) {
      $this.closest('.annotation_edit').closest('tbody').hide();
    }

    return false;
  });
}

function handle_submit_annotation(data) {
  var arg = data;
  ktAjaxWrapper({
    type: "POST",
    url: KT_ENV_JS['root_url'] + "/annotations/ajax_handle_annotation/",
    data: arg,
    dataType: "json",
    success: function(dataObj, textStatus) {
      var xid = 'xid' in dataObj ? dataObj.xid : point_data.xid;
      var keyid = 'keyid' in dataObj ? dataObj.keyid : point_data.keyid;
      var creator = 'creator' in dataObj ? dataObj.creator : point_data.creator;
      var epochDate = 'epoch_date' in dataObj ? dataObj.epoch_date : point_data.epoch_date;

      $(document).trigger({
        type: 'annotation_saved',
        selected_chart_id: data['selected_chart_id'],
        submit_type: data['submit_type'],
        title: data['title'],
        text: data['text'],
        share_level: data['share_level'],
        creator: creator,
        xid: xid,
        keyid: keyid,
        date: data['date'],
        epochDate: epochDate,
        email: dataObj['email'],
        comments: []
      });
    },
    errorMessage: "An error occured while trying to " + arg['submit_type'] + " an annotation."
  });
}

/**
 * Displays annotations, given a chart_id (i.e. c0) and a list of annotations
 */
function handle_select_annotation(chart_id, a_lst) {
    if ($('.createnew').length > 0) {
        var cdiv_id = "#" + chart_id + "_cdiv";
        if (a_lst.length !== null) point_data_lst = a_lst;

        $('.an_cancel:visible').click();
        // hide deselected annotations.
        $('.Annotation_content').filter(':visible').not(cdiv_id).hide();
        $('.Annotation_content').not(cdiv_id).find('.annotation-wrapper > table tbody').empty();

        // selecting the correct tbody when editing annotation
        var tbody = $(".annotation-wrapper > table", cdiv_id);
        var tbody_date = $.trim($(".annotation-wrapper > table td.date:first-child", cdiv_id).html());
        //strip the whitespace off the ends of the date text in the field. If the field isn't filled, trim returns ""
        if (tbody_date === a_lst[0]['date']){
	    tbody.toggle();
        } else {
            tbody.show();
        }
        // test if EDITING && last chart is binded
        if (!$(cdiv_id).find('.an_submit').hasClass('kt-disabled') && $(cdiv_id).parents('.annotation').is(":visible")) {
            Boxy.confirm("Are you sure you want to discard change?", function() {
                fill_annotation_data(tbody, a_lst);
                $(cdiv_id).find('.an_submit').addClass('kt-disabled');
            });
        } else {
            fill_annotation_data(tbody, a_lst);
        }
    }
}

function bind_annotation($root_dom) {
  $root_dom.find('.annotation').show();
  //$('.annotation').show();
  detect_textinput_change($root_dom);
  bind_submit_annotation($root_dom);
  new_anno_timestamp();
  bind_create_new_annotation($root_dom);
  bind_cancel_annotation($root_dom);
  bind_delete_annotation($root_dom);
}

function share_level_chart_type_to_private_shown_on(share_level, chart_type) {
  var private, shown_on;
  if ((share_level === "GLOBAL") || (share_level === "LIMITED")){
    shown_on = "global";
  } else {
    shown_on = chart_type;
  }
  if ((share_level === "GLOBAL") || (share_level === "PUBLIC")){
    private = false;
  } else {
    private = true;
  }
  return [private, shown_on];
}


$(document).ready(function() {
  bind_annotation($('body'));
});

$(document).ready(function() {

  $('#sortable').on('click', '.see-applied-filters', function() {
    var $this = $(this);

    $this.find('.selector').toggleClass('right-arrow').toggleClass('down-arrow');
    $this.parents('.chart-footer-wrapper').find('.chart-footer-content').toggle();
  });

});

var TimeFilterApp = (function(my){
  my.Models = my.Models || {};

  my.Models.HOURLY = 'hour';
  my.Models.DAILY = 'day';
  my.Models.WEEKLY = 'week';
  my.Models.MONTHLY = 'month';

  my.Models.get_readable_time_segment = function(model_time_segment){
    var r_str = null;
    switch (model_time_segment) {
      case my.Models.HOURLY: {
        r_str = 'Hourly';
        break;
      }
      case my.Models.DAILY: {
        r_str = 'Daily';
        break;
      }
      case my.Models.WEEKLY: {
        r_str = 'Weekly';
        break;
      }
      case my.Models.MONTHLY : {
        r_str = 'Monthly';
        break;
      }
    }
    return r_str;
  },

  // Attributes: start and end
  // start and end are stored as Date objects

  my.Models.AbstractTimeFilter = Backbone.Model.extend({
    toJSON: function() {
      var json = {};
      json["start"] = $.datepicker.formatDate('mm/dd/yy', this.attributes['start']);
      json["end"] = $.datepicker.formatDate('mm/dd/yy', this.attributes['end']);
      return json;
    }    
  });

  // HourlyTimeFilter takes in one extra parameter : 24 hour format.
  my.Models.HourlyTimeFilter = my.Models.AbstractTimeFilter.extend({
    toJSON: function() {
      var json = my.Models.AbstractTimeFilter.prototype.toJSON.call(this);
      json['start_hour'] = this.attributes['start_hour'];
      json['end_hour'] = this.attributes['end_hour'];
      return json;
    }
  });

  my.Models.DailyTimeFilter = my.Models.AbstractTimeFilter.extend({

  });

  my.Models.WeeklyTimeFilter = my.Models.AbstractTimeFilter.extend({
    // If d is sunday, d isn't changed.
    _get_last_sunday: function(d) {
      var day = d.getDay();
      var delta = d.getDate() - day;
      return new Date(d.setDate(delta));
    },

    // If an attribute is of instance Date, it will automatically be
    // reset to the beginning of the week, which as far as Kontagent is
    // concerned is Sunday.
    set: function(attributes, options) {
      var _this_obj = this;

      $.each(attributes, function(attr_k, attr_v) {
        if (attr_v instanceof Date) {
          attributes[attr_k] = _this_obj._get_last_sunday(attr_v);
        }
      });
      Backbone.Model.prototype.set.call(this, attributes, options);
    }
  });

  my.Models.MonthlyTimeFilter = my.Models.AbstractTimeFilter.extend({
    // If d is already first day of the month, d shouldn't be changed.
    _get_first_day_of_the_month: function(d) {
      var days = d.getDate();
      var delta = d.getDate() - days + 1;
      return new Date(d.setDate(delta));
    },

    // Automatically reset date objects to the beginning of the month.
    set: function(attributes, options) {
      var _this_obj = this;

      $.each(attributes, function(attr_k, attr_v) {
        if (attr_v instanceof Date) {
          attributes[attr_k] = _this_obj._get_first_day_of_the_month(attr_v);
        }
      });
      Backbone.Model.prototype.set.call(this, attributes, options);
    }
  });

  my.Models.TimeFilter = Backbone.Model.extend({

    initialize : function () {
      this.hourly_model = new my.Models.HourlyTimeFilter();
      this.daily_model = new my.Models.DailyTimeFilter();
      this.weekly_model = new my.Models.WeeklyTimeFilter();
      this.monthly_model = new my.Models.MonthlyTimeFilter();
      _.bindAll(this, 'on_change');
    },

    bind_children : function() {
      /**
       TimeFilter is a model of models, namely hourly_model,
       daily_model, weekly_model, monthly_model, etc. If one of its
       submodels got changed, the change event will not get propgated
       to all the way back up. Therefore, we need to manually trigger
       a change event, whenever any of the children gets changed.
       */
      // TODO: bind_children gets called from views.js. Ideally, it
      // should be called automatically by model's initialize().
      this.hourly_model.bind('change', this.on_change);
      this.daily_model.bind('change', this.on_change);
      this.weekly_model.bind('change', this.on_change);
      this.monthly_model.bind('change', this.on_change);
    },

    on_change: function () {
      this.change(); //trigger a change event.
    },

    defaults : {
      'selected_time_segment' : my.Models.DAILY
    },

    curr_model : function() {
      var r_model = null;
      switch(this.get('selected_time_segment')) {
      case my.Models.HOURLY : {
        r_model = this.hourly_model;
        break;
      }
      case my.Models.DAILY: {
        r_model = this.daily_model;
        break;
      }
      case my.Models.WEEKLY: {
        r_model = this.weekly_model;
        break;
      }
      case my.Models.MONTHLY: {
        r_model = this.monthly_model;
        break;
      }
      }
      return r_model;
    },

    toJSON : function () {
      var json = {};
      json[ my.Models.HOURLY ] = this.hourly_model.toJSON();
      json[ my.Models.DAILY ]  = this.daily_model.toJSON();
      json[ my.Models.WEEKLY ]  = this.weekly_model.toJSON();
      json[ my.Models.MONTHLY ]  = this.monthly_model.toJSON();
      json[ 'selected_time_segment'] = this.attributes['selected_time_segment'];
      return json;
    }

  });

  return my;
}(TimeFilterApp || {}));
var TimeFilterApp = (function(my){
  my.Views = my.Views || {};

  my.Views.DateControlCalendar = Backbone.View.extend({
    // id: optional. <div id='view_kt_datecontrol></div> is created by
    // backbone. It wrapes around the new html content.
    id: 'view_kt_datecontrol',
    default_hourly_span : 1, // 1 day or 24 hours
    default_daily_span : 30, // 30 days
    default_weekly_span : 84, //12 weeks
    default_monthly_span : 30*6, //6 months
    datepicker_selecting_range : false,
    CUSTOM_RANGE_SELECT_VAL : "custom",

    events: {
      "focus #start": "start_editing_field",
      "focus #end": "start_editing_field",
      "keyup #start" : "editing_start_field",
      "keyup #end" : "editing_end_field",
      "blur #start" : "end_editing_field",
      "blur #end" : "end_editing_field",
      "click #time_filter_button" : "apply",
      "click .kt_datecontrol_cancel" : "cancel",
      "click #kt_datecontrol_arrow" : "toggle_datecontrol_display",
      "click .kt_time_segment_button" : "set_time_segment",
      "change #start_hr" : "set_start_hr",
      "change #end_hr" : "set_end_hr",
      "change .kt_datecontrol_select": "select_preset_dropdown"
    },

    initialize : function () {
      _.bindAll(this,
                'render',
                'update_entire_datecontrol',
                'update_input_fields',
                'update_time_segment');
      this.time_filter_model = new my.Models.TimeFilter();
      this.time_filter_model.bind('change', this.update_entire_datecontrol);
      this.time_filter_model.bind('change:selected_time_segment', this.update_time_segment);

      // The following unfortunate complexitiy is in place to get EJS working
      // under quint.
      var ejs_file_name = 'time_filter.ejs';

      if (window.QUNIT_TEST_MODE != undefined && window.QUNIT_TEST_MODE == true) {
        var ejs_url_path = ejs_file_name;
      } else {
        var ejs_url_path = '/js/kt/time_filter_app/templates/' + ejs_file_name;
      }
      this.template = new EJS({url: KT_ENV_JS['media_url'] + ejs_url_path});
    },

    update_input_fields: function () {
      var start_date_obj = this.time_filter_model.curr_model().get('start');
      var end_date_obj = this.time_filter_model.curr_model().get('end');

      if (!$("#start").hasClass("kt_datecontrol_input_picked")) {
        $("#start").val(this.to_mmddyy_date_string(start_date_obj));
      }

      if (!$("#end").hasClass("kt_datecontrol_input_picked")) {
        $("#end").val(this.to_mmddyy_date_string(end_date_obj));
      }

      if (this.time_filter_model.get('selected_time_segment') == my.Models.HOURLY) {
        var start_hr = this.time_filter_model.curr_model().get('start_hour');
        var end_hr = this.time_filter_model.curr_model().get('end_hour');
        $("#start_hr").val(this.to_24_hr_format(start_hr));
        $("#end_hr").val(this.to_24_hr_format(end_hr));
      }
    },

    update_datecontrol_txt : function () {
      // Change the kt_datecontrol_txt
      var start_date_obj = this.time_filter_model.curr_model().get('start');
      var end_date_obj = this.time_filter_model.curr_model().get('end');
      var selected_time_segment = this.time_filter_model.get('selected_time_segment');
      var readable_time_segment = my.Models.get_readable_time_segment(selected_time_segment);

      var datecontrol_text = null;
      var datecontrol_start_date_str = this.to_ddMyy_date_string(start_date_obj);
      var datecontrol_end_date_str = this.to_ddMyy_date_string(end_date_obj);
      if (selected_time_segment != my.Models.HOURLY) {
        datecontrol_text = datecontrol_start_date_str + " ~ " + datecontrol_end_date_str;
      } else {
        // hourly
        var datecontrol_start_hr_str = this.time_filter_model.curr_model().get('start_hour');
        var datecontrol_end_hr_str = this.time_filter_model.curr_model().get('end_hour');
        datecontrol_text = datecontrol_start_date_str + " " + datecontrol_start_hr_str + ":00 ~ " +
          datecontrol_end_date_str + " " + datecontrol_end_hr_str + ":00";
      }
      datecontrol_text += " (" + readable_time_segment +")" ;

      $(".kt_datecontrol_txt").text(datecontrol_text);

      // realign kt_datecontrol_menu
      $(".kt_datecontrol_menu").css('left', $("#kt_datecontrol_slot").width() - 888);
    },

    update_entire_datecontrol: function () {
      this.update_input_fields();
      $("#kt_calendar").datepicker("refresh");
      $("#time_filter_button").prop('disabled', false);
    },

    update_time_segment: function() {
      var selected_time_segment = this.time_filter_model.get('selected_time_segment') ;
      $("a.kt_time_segment_button").removeClass("active");
      $("a.kt_time_segment_button[data='"+ selected_time_segment +"']").addClass("active");

      $("select.kt_datecontrol_select").hide();
      $("select.kt_datecontrol_select[data='"+ selected_time_segment +"']").show();

      if (selected_time_segment == my.Models.HOURLY) {
        $("#time_select").show();
      } else {
        $("#time_select").hide();
      }
    },

    set_time_segment: function(event) {
      this.time_filter_model.set({
        'selected_time_segment' : $(event.target).prop('data')
      });
    },

    _set_hr_helper : function(selector_id, model_attr_name) {
      if (this.time_filter_model.get('selected_time_segment') == my.Models.HOURLY) {
        var hr_val = $(selector_id).val().split(":")[0];
        var old_hr_val = this.time_filter_model.curr_model().get(model_attr_name);
        if (hr_val != old_hr_val) {
          // make sure that selected_time_segment is, in fact, hour.
          var key_val_params = {};
          key_val_params[model_attr_name] = hr_val;
          this.time_filter_model.curr_model().set(key_val_params);
        }
      }
    },

    set_start_hr: function() {
      this._set_hr_helper('#start_hr', 'start_hour');
      return false;
    },

    set_end_hr: function() {
      this._set_hr_helper('#end_hr', 'end_hour');
      return false;
    },

    select_preset_dropdown: function(event) {
      var day_span = $(event.target).val();
      if (day_span != this.CUSTOM_RANGE_SELECT_VAL) {
        var end_date_obj = new Date();
        var start_date_obj = this.get_k_days_from_curr_day(day_span);

        var update_param_date = {
          start: start_date_obj,
          end: end_date_obj
        };

        if (this.time_filter_model.get('selected_time_segment') == my.Models.HOURLY) {
          update_param_date['start_hour'] =  end_date_obj.getHours();
          update_param_date['end_hour'] = end_date_obj.getHours();
        }
        this.time_filter_model.curr_model().set(update_param_date);
      }
    },

    // Return a javascript date object. If the user input field has a
    // valid date string in mm/dd/yy format.
    // Otherwise, return null
    _editing_field_helper : function(event) {
      var date_obj = null;
      try {
        date_obj = $.datepicker.parseDate('mm/dd/yy', $(event.target).val());
        $(event.target).removeClass("kt_datecontrol_input_error");
        $(event.target).addClass("kt_datecontrol_input_picked");
      } catch (e) {
        $(event.target).removeClass("kt_datecontrol_input_picked");
        $(event.target).addClass("kt_datecontrol_input_error");
      }
      return date_obj;
    },

    editing_start_field: function (event) {
      var date_obj = this._editing_field_helper(event);
      if (date_obj != null) {
        this.time_filter_model.curr_model().set({
          start: date_obj
        });
      }
    },

    editing_end_field: function (event) {
      var date_obj = this._editing_field_helper(event);
      if (date_obj != null) {
        this.time_filter_model.curr_model().set({
          end: date_obj
        });
      }
    },

    start_editing_field: function (event) {
      $(event.target).removeClass("kt_datecontrol_input");
      $(event.target).addClass("kt_datecontrol_input_picked");
    },

    end_editing_field : function (event) {
      $(event.target).removeClass("kt_datecontrol_input_picked");
      $(event.target).addClass("kt_datecontrol_input");
    },

    apply : function (event) {
      $("#time_filter_button").prop('disabled', true);
      Backbone.history.navigate(JSON.stringify(this.time_filter_model.toJSON()));
      this.update_datecontrol_txt();
      this.update_input_fields(); // Might need to reformat the dates to have the leading zeros.
      $(document).trigger('load_all_table_data');
      return false;
    },

    cancel : function() {
      //reset model according to the url fragment.
      //reset the model back to its original state according to the url fragment.
      if (window.location.hash != '' && window.location.hash != undefined) {
        this.init_time_filter_model_from_url_fragment(window.location.hash.substring(1)); // get rid of the first # character
      }
      //reset the ui to reflect the original model state.
      this.update_entire_datecontrol();
      $("#time_filter_button").prop('disabled', true);
      return false;
    },

    toggle_datecontrol_display: function() {
      var $arrow = $("#kt_datecontrol_arrow");
      if ($arrow.hasClass('kt_datecontrol_arrow_down')) {
        // show the control panel
        $arrow.removeClass('kt_datecontrol_arrow_down');
        $arrow.addClass('kt_datecontrol_arrow_up');
        $(".kt_datecontrol_menu").show();
      } else {
        // hide the control panel
        $arrow.removeClass('kt_datecontrol_arrow_up');
        $arrow.addClass('kt_datecontrol_arrow_down');
        $(".kt_datecontrol_menu").hide();
      }
      return false;
    },

    get_k_days_from_curr_day : function (num_of_days_to_subtract) {
      return new Date(new Date().setDate((new Date()).getDate() - num_of_days_to_subtract));
    },

    to_mmddyy_date_string: function (date_obj) {
      //mm/dd/yy
      return $.datepicker.formatDate('mm/dd/yy', date_obj);
    },

    to_ddMyy_date_string: function (date_obj) {
      //M dd, yy
      return $.datepicker.formatDate('M dd, yy', date_obj);
    },

    to_24_hr_format: function (hour_num) {
      // @param{hour_num} : 1-24
      // returns  05:00 12:00, 15:00
      var buf = [];
      var hour_num_str = hour_num+"";
      if (hour_num_str.length == 1) {
        buf.push("0");
      }
      buf.push(hour_num_str);
      buf.push(":");
      buf.push("00");
      return buf.join("");
    },

    init_time_filter_model_default : function () {
      //Set daily only for now.
      // TODO: set hourly, weekly, month

      // Daily
      var end_date_obj = new Date();
      var start_date_obj = this.get_k_days_from_curr_day(this.default_daily_span);
      this.time_filter_model.daily_model.set({
        start: start_date_obj,
        end: end_date_obj
      },{
        silent: true
      });

      // Weekly
      start_date_obj = this.get_k_days_from_curr_day(this.default_weekly_span);
      // need to recreate end date because model's set function might
      // snap the date to the beginning of the week or the beginning of
      // the month.
      end_date_obj = new Date();
      this.time_filter_model.weekly_model.set({
        start: start_date_obj,
        end: end_date_obj
      },{
        silent: true
      });

      // Monthly
      start_date_obj = this.get_k_days_from_curr_day(this.default_monthly_span);
      end_date_obj = new Date();
      this.time_filter_model.monthly_model.set({
        start: start_date_obj,
        end: end_date_obj
      },{
        silent: true
      });

      // Hourly
      start_date_obj = this.get_k_days_from_curr_day(this.default_hourly_span);
      end_date_obj = new Date();
      this.time_filter_model.hourly_model.set({
        start : start_date_obj,
        end: end_date_obj,
        start_hour: end_date_obj.getHours(), //getHours() returns 0 thru 23
        end_hour: end_date_obj.getHours()
      },{
        silent: true
      });

      Backbone.history.navigate(JSON.stringify(this.time_filter_model.toJSON()));
    },

    init_time_filter_model_from_url_fragment : function(filter_json_str) {
      var filter_json = eval("(" + filter_json_str + ")");
      var hourly_const = my.Models.HOURLY;
      var daily_const = my.Models.DAILY;
      var weekly_const = my.Models.WEEKLY;
      var monthly_const = my.Models.MONTHLY;

      function initialize_time_model_helper( time_segment_type , model ) {
        if (filter_json[ time_segment_type ] &&
            filter_json[ time_segment_type ][ 'start' ] != undefined &&
            filter_json[ time_segment_type ][ 'end' ] != undefined) {

          var start_date_obj = $.datepicker.parseDate('mm/dd/yy', filter_json[ time_segment_type ][ 'start' ]);
          var end_date_obj = $.datepicker.parseDate('mm/dd/yy', filter_json[ time_segment_type ][ 'end' ]);

          model.set({
            start: start_date_obj,
            end : end_date_obj
          }, {
            silent: true
          });
        }
      }
      initialize_time_model_helper(daily_const, this.time_filter_model.daily_model);
      initialize_time_model_helper(weekly_const, this.time_filter_model.weekly_model);
      initialize_time_model_helper(monthly_const, this.time_filter_model.monthly_model);
      initialize_time_model_helper(hourly_const, this.time_filter_model.hourly_model);

      // Special case for hourly only.
      if (filter_json[ hourly_const ] &&
          filter_json[ hourly_const ]['start_hour'] != undefined &&
          filter_json[ hourly_const ]['end_hour'] != undefined ) {
            this.time_filter_model.hourly_model.set({
              'start_hour' : filter_json[ hourly_const ]['start_hour'],
              'end_hour' : filter_json[ hourly_const ]['end_hour']
            }, {
              silent: true
            });
      }

      this.time_filter_model.set({
        'selected_time_segment': filter_json['selected_time_segment']
      });
    },

    render : function (filter_json_str) {
      if (filter_json_str == null || filter_json_str == undefined || filter_json_str == '') {
        this.init_time_filter_model_default();
      } else {
        this.init_time_filter_model_from_url_fragment(filter_json_str);
      }

      this.time_filter_model.bind_children();

      $(this.el).html(this.template.render({
        'hr' : my.Models.HOURLY,
        'dy' : my.Models.DAILY,
        'wk' : my.Models.WEEKLY,
        'mo' : my.Models.MONTHLY,
        'custom' : this.CUSTOM_RANGE_SELECT_VAL
      }));

      $("#kt_datecontrol_slot").html(this.el);
      this.update_input_fields();
      this.update_datecontrol_txt();
      this.update_time_segment();

      var that = this;
      $("#kt_calendar").datepicker({
        numberOfMonths: 3,
        showCurrentAtPos: 0,
        beforeShowDay: function (date) {
          var start_date_obj = that.time_filter_model.curr_model().get('start');
          var end_date_obj = that.time_filter_model.curr_model().get('end');

          if(!that.datepicker_selecting_range){
            // Only highligh the date range when the user is done
            // selecting.
            if (date >= start_date_obj && date <= end_date_obj) {
              // Highlight the cell if the current date we are dealing
              // with is within range.
              return [true, 'kt_date_selected'];
            } else {
              return [true];
            }
          } else {
            if (date.getTime() == start_date_obj.getTime()) {
              return [true, 'kt_date_selecting'];
            } else if (date < start_date_obj) {
              // Make the days before the newly selected start date unselectable.
              return [false];
            } else {
              return [true];
            }
          }
        },
        onSelect: function (selectedDate, inst) {
          var date_obj = $.datepicker.parseDate('mm/dd/yy', selectedDate);
          if (!that.datepicker_selecting_range) {
            // Disable selecting the end day range prior to this
            // selected day.
            that.time_filter_model.curr_model().set({
              start: date_obj
            }, {
              silent: true
            });
            that.datepicker_selecting_range = true;

          } else {
            that.time_filter_model.curr_model().set({
              end: date_obj
            });

            that.datepicker_selecting_range = false;
          }

          var selected_time_segment = that.time_filter_model.get('selected_time_segment');
          $(".kt_datecontrol_select[data='" + selected_time_segment + "']").val(that.CUSTOM_RANGE_SELECT_VAL);
        }
      }); //$("#kt_calendar").datepicker({

      $("#start_hr").timePicker({
        step: 60
      });
      $("#end_hr").timePicker({
        step: 60
      });

      $(document).trigger('load_all_table_data');
    }// render : function (filter_json_str) {

  });

  return my;

}(TimeFilterApp || {}));
var TimeFilterApp = (function(my){
  my.Routers = my.Routers || {}; 
  my.Routers.Apply = Backbone.Router.extend({
    routes : {
      "*filter_json_str" : "index"
    },

    time_filter_view: null,

    initialize: function(options) {
      _.bindAll(this, 'index');
      this.time_filter_view = new my.Views.DateControlCalendar();
    },

    index : function(filter_json_str) {
      if (filter_json_str == "") {
         if (window.KT_ENV_JS['filter_json_str'] != undefined) {
           filter_json_str = window.KT_ENV_JS['filter_json_str'];
           Backbone.history.navigate(filter_json_str, false);
         }
      }

      this.time_filter_view.render(filter_json_str);
    }

  });
  
  return my;

}(TimeFilterApp || {}));
var TimeFilterApp = (function(my) {
  my.init = function() {
    new TimeFilterApp.Routers.Apply();

    Backbone.history.start();
  };
  
  return my;
}(TimeFilterApp || {}));


$(document).ready(function(){
  //TimeFilterApp.init(); //Temporarily disable the new time filter.
});

var FunnelGraph = (function() {

  var numFormatter = new NumFormatter();

  function graph(enforced, data, labels, selector_str) {
    var selector_str = selector_str || '';

    $(selector_str + ' .funnel-chart').empty();

    if(!data){
      $(selector_str + ' .funnel-chart').append('<div class="no-data">Currently no data to be displayed for this funnel</div>');
      $('#select-chart-type').hide();
      $('.k-box-head-info h1').text('');
    } else {
      if(enforced) {
        graphEnforced(data, labels, selector_str);
      } else {
        graphUnenforced(data, labels, selector_str);
      }
    }
  }

  function arrayToTree(data, labels) {
    var treeData = {name: data[0], label: labels[0]};
    var children = [];

    // The first data point is considered the tree root, loop
    // through the remainder to grab the children
    _.each(_.rest(data), function(value, i) {
      children.push({name: value, label: labels[i+1]});
    });

    children.sort(function(a,b) {
      return b.name - a.name;
    });

    treeData["children"] = children;

    return treeData;
  };

  function graphUnenforced(data, labels, selector_str) {

    var chartHeight = $(selector_str + ' .funnel-chart').height();
    var chartWidth = $(selector_str + ' .funnel-chart').width(); //950;
    var treeWidth = chartWidth / 2; //400;

    var maxWidth = 20;
    var maxData = _.max(data);

    var treeData = arrayToTree(data, labels);

    var translation = (treeWidth - 100) / 2;

    // Create a svg canvas
    var vis = d3.select(selector_str + ' .funnel-chart')
      .append("div")
        .attr('id', 'unenforced-chart')
        .attr('style', 'width:' + chartWidth + 'px')
        .style("width", chartWidth)
      .append("svg:svg")
        .attr("width", chartWidth) //2000 //hack to avoid cutting anything off
        .attr("height", chartHeight)
        .append("svg:g")
        .attr("transform", "translate(" + translation + ", 0)"); // was 200 // shift everything to the right

    // Create a tree "canvas"
    var tree = d3.layout.tree().size([chartHeight, treeWidth]);

    var diagonal = d3.svg.diagonal()
      // change x and y (for the left to right tree)
      .projection(function(d) { return [d.y, d.x]; });

    // Preparing the data for the tree layout, convert data into an array of nodes
    var nodes = tree.nodes(treeData);
    // Create an array with all the links
    var links = tree.links(nodes);

    // Make sure we update the labels with any sorting performed on the data
    labels = _.map(nodes, function(n) { return n.label; });

    var link = vis.selectAll("pathlink")
      .data(links)
      .enter().append("svg:path")
      .attr("stroke-width", function(d, i) {
        var width = data[i+1] / maxData * maxWidth;
        if (width < 2) {
          width = 2
        }
        return width })
      .attr("class", "link")
      .attr("d", diagonal)
      .text(function(d, i) { return data[i+1]; } );

    link.append("svg:title")
      .text(function(d, i) {
        return labels[i+1] + '\n' + numFormatter.comma_format(data[i+1]) + ' Users';
    });

    var node = vis.selectAll("g.node")
      .data(nodes)
      .enter().append("svg:g")
      .attr("transform", function(d) {
        var y = d.children ? d.y - 10 : d.y + 5;
        return "translate(" + y + "," + d.x + ")";
      });

    // place the name atribute left or right depending if children
    var counts = node.append("svg:text")
      .attr("dy", 3)
      .attr("text-anchor", function(d) { return d.children ? "end" : "start"; });

    counts.append("svg:tspan")
      .text(function(d, i) {
        return numFormatter.comma_format(d.name);
      });

    counts.append("svg:tspan")
      .attr("style", "font-weight:bold")
      .text(function(d, i) {
        var result;
        if (i !== 0) {
          var percentage = data[0] === 0 ? 0 : ((parseFloat(d.name) / data[0]) * 100).toFixed(2);
          result = "  (" + percentage + "%)";
        } else {
          result = "";
        }
        return (result);
      });

    // If there are 9 or more data points, the labels will overlap
    // Make the label 1 line instead of 2 when this happens
    if (data.length < 9) {
      node.append("svg:text")
        .attr("dy", 20)
        .attr("text-anchor", function(d) { return d.children ? "end" : "start"; })
        .attr("style", "font-size:11px")
        .text(function(d, i) {
          return (labels[i]);
      });
    } else {
      counts.append("svg:tspan")
        .text(function(d, i) {
          return (' ' + labels[i]);
      });
    }
  }

  function graphEnforced(data, labels, selector_str) {
    var chartHeight = $(selector_str + ' .funnel-chart').height();
    var maxHeight = chartHeight - 30;
    var width = 100;
    var labelWidth = 90;
    var maxData = _.max(data);
    var spacing = 45;

    var chart = d3.select(selector_str + ' .funnel-chart');

    var bars = chart.selectAll('.bar').data(data);

    var newBars = bars.enter().append("div");
    newBars.attr("class","bar");

    bars.exit().remove();

    var drawBars = function(selection) {
      selection
        .style("height", function(d) { return d / maxData * maxHeight + "px"; })
        .style("left", function(d, i) { return i * width + "px"; })
	.attr("title", function(d, i) { return labels[i] + '\n' + numFormatter.comma_format(d) + ' Users'; })
    };

    drawBars(bars);
    drawBars(newBars);

    var labelText = chart.selectAll('.label').data(data);

    var newLabel = labelText.enter().append("div");
    newLabel.attr("class","label");

    labelText.exit().remove();

    var writeLabels = function(selection) {
      selection
        .attr("class","label")
        .style("left", function(d, i) { return ((i * width)) - 30 + "px"; })
        .style("top", function() { return chartHeight + 5 + 'px'; })
        .style("width", function() { return labelWidth + 'px'; })
        .text(function(d, i) { return labels[i]; });
    };

    writeLabels(labelText);
    writeLabels(newLabel);

    var arrows = chart.selectAll('.arrow').data(data.slice(0, data.length - 1));

    var newArrows = arrows.enter().append("div");
    newArrows.attr("class","arrow");

    arrows.exit().remove();

    var drawArrows = function(selection) {
      var minFittableChars = 7;
      var longNumbers = {};

      selection.text(function(d, i) {
        var percentage = d === 0 ? 0 : ((parseFloat(data[i+1]) / d) * 100).toFixed(2);
        var percentageLength = (percentage + "%").length;

        if (percentageLength > minFittableChars) {
          var extraChars = percentageLength - minFittableChars;
          longNumbers[i] = extraChars;
        }

        return percentage + "%";
      });

      selection.style("left", function(d, i) {
        var extraChars = longNumbers[i] ? longNumbers[i] : 0;
        var extraSpacing = extraChars * 5; // each extra char requires the left offset to decrease by 5px to keep the widened arrow centered

        return ((i * width) + (spacing - extraSpacing)) + "px";
      });

      if (Object.getOwnPropertyNames(longNumbers).length !== 0) {
        selection.style("background-size", function(d, i) {
          var extraChars = longNumbers[i] ? longNumbers[i] : 0;
          var extraWidth = extraChars * 10; // each extra char requires the arrow to widen by 10px

          return (50 + extraWidth) + "px 50px";
        });
        selection.style("width", function(d, i) {
          var extraChars = longNumbers[i] ? longNumbers[i] : 0;
          var extraWidth = extraChars * 10; // each extra char requires the arrow to widen by 10px
          return (50 + extraWidth) + "px";
        });
      }
    };

    drawArrows(arrows);
    drawArrows(newArrows);

    _.each($(selector_str + ' .bar'), function(bar, i) {
      bar.innerHTML = '<div class="num-label">' + numFormatter.comma_format(Math.round(data[i])) + '</div>';
    });

    var percentage = data[0] === 0 ? 0 : ((parseFloat(data[data.length - 1]) / data[0]) * 100).toFixed(2);

    chart.append('div').attr('class','overall-conversion');

    $(selector_str + ' .overall-conversion')
      .css("margin-left", data.length * width)
      .append('<p class="conversion-text">Funnel Conversion</p>')
      .append('<p class="conversion-text">Rate</p>')
      .append('<p class="conversion-text">' +	percentage + "%" + '</p>');
  }

  return {
    graph: graph
  };
})();

var FilterHelper = (function() {
  var KtFilter = function() {
    // location
    this.$countryInput = [];
    this.$locationArray = [];
    this.$locationNameArray = [];

    // device
    this.$deviceInput = [];
    this.$deviceList = [];
    this.deviceArray = [];

    // os version
    this.$osNameArray = [];
    this.osValueArray = [];

    // app version
    this.$appNameArray = [];
    this.appValueArray = [];

    this.savedFiltersReady = false;
    this.savedFiltersButtonActivated = '';
    this.blankDemoFilter = {gender: ['A'], filter_name: 'filters'};
    this.demoFilters = {};
    this.savedFilters = [];
  };

  /*
   *  Initializes properties and load all saved filters
   *
   */
  KtFilter.prototype.init = function() {
    this.savedFiltersButtonActivated = false;
    this.$locationArray = $('input[name="location"]');
    this.$locationNameArray = $('label[name="location_str"]');
    this.$countryInput = $('#country-input');
    this.$deviceInput = $('#device-input');
    this.$deviceList = $('input[name="device"]');
    this.deviceArray = this.extractValue(this.$deviceList);
    this.$osNameArray = $('input[name="os_version"]');
    this.osValueArray = this.extractValue(this.$osNameArray);
    this.$appNameArray = $('input[name="app_version"]');
    this.appValueArray = this.extractValue(this.$appNameArray);

    this.loadSavedFilters();
  };

  KtFilter.prototype.recordCurrentFilters = function() {
    this.demoFilters = this.constructArgArray("filter_input");
    this.savedFilters = this.getCheckedFilterInfo();
  };

  KtFilter.prototype.areDemoFiltersApplied = function() {
    return (!_.isEqual(this.demoFilters, this.blankDemoFilter) || this.savedFilters.length > 0);
  };

  /*
   *  Construct an array that is used in save and apply
   *    on normal and cohort filters
   *
   */
  KtFilter.prototype.constructArgArray = function(attrName) {
    var $filterArray = $("input[" + attrName + "='true']");
    var arg = {};

    $filterArray.each(function(i, filter) {
      var $inputObj = $(filter);
      var isCheckboxOrRadio = $inputObj.is(':checkbox') || $inputObj.is(':radio');
      var isTextOrHidden = $inputObj.is(':text') || $inputObj.prop('type') === 'hidden';
      var isChecked = $inputObj.is(':checked');
      var inputName = $inputObj.attr('name');
      var inputValue = $inputObj.val();

      if (isCheckboxOrRadio && isChecked) {
        if (!arg[inputName]) {
          arg[inputName] = [inputValue];
        } else {
          arg[inputName][arg[inputName].length] = inputValue;
        }
      } else if (isTextOrHidden) {
        if (inputValue.length > 0) {
          arg[inputName] = inputValue;
        }
      }
    });

    var $selectionFilterArray = $("select[" + attrName + "='true']");
    $selectionFilterArray.each(function(i, filter) {
      var $selectObj = $(filter);
      arg[$selectObj.attr('name')] = $selectObj.val();
    });

    arg.filter_name = $('#filter-panel input[name="filter_name"]').val();
    return arg;
  };

  /*
   *  Extracts the value from a list of input elements
   *    and return them in an array
   *
   */
  KtFilter.prototype.extractValue = function(list) {
    var array = [];
    var inputValue = '';

    $.each(list, function(i, listItem) {
      inputValue = $(listItem).val();
      array.push(inputValue);
    });

    return array;
  };

  /*
   *  Sort a trimmed list object
   *
   */
  KtFilter.prototype.sortList = function(list) {
    return _.sortBy(list, function(list) {
      return $.trim($(list).text());
    });
  };

  /*
   *  Checks to see if a property of an object is defined
   *
   */
  KtFilter.prototype.isDefined = function(object, property) {
    return typeof object[property] !== 'undefined';
  };

  /*
   *  Saves the selected country to database
   *  The ajax call returns the iso for the country that then used
   *    to add the country to the location list
   *
   */
  KtFilter.prototype.saveCountryGetIso = function(countryName) {
    var _this = this;

    ktAjaxWrapper({
      type: 'POST',
      traditional: true,
      data: {
        'country': countryName
      },
      url: KT_ENV_JS['root_url'] + "/countries/ajax_store_added_country_and_get_iso/",
      dataType: 'json',
      success: function(data, textStatus){
        if(data.iso !== 'Invalid') {
          _this.addCountryToLocationList(countryName, data.iso);
        } else {
          _this.$countryInput.val('').blur();
        }
      },
      error: function(xhr, textStatus, errorThrown ) {
        _this.$countryInput.val("").blur();
      }
    });
  };

  /*
   *  Adds a new location to the location list on the Filter UI
   *
   */
  KtFilter.prototype.addCountryToLocationList = function(countryName, countryIso) {
    var $countryList = $('#country-list');

    $countryList.append("<li><label name='location_str' v='" + countryIso + "'><input type='checkbox' filter_input='true' name='location' value='" + countryIso + "'/> " + countryName + "</label><a href='#' class='remove-list del-icon'>del</a></li>");

    //Sort the new list by the value of the label
    $countryList.html(this.sortList($("#country-list li")));

    this.$countryInput.val("").blur();
    this.$locationArray = $("input[name='location']");
    this.$locationNameArray = $("label[name='location_str']");
  };

  /*
   *  Removes a location from the location list on the Filter UI
   *
   */
  KtFilter.prototype.removeCountryFromLocationList = function($el) {
    $el.remove();
    this.$locationArray = $("input[name='location']");
    this.$locationNameArray = $("label[name='location_str']");
  };

  /*
   *  Given a list of isos, return an object of country names
   *
   */
  KtFilter.prototype.getCountryListFromIso = function(isoList) {
    var countryList;

    ktAjaxWrapper({
      type: 'POST',
      traditional: true,
      data: {
        'iso': isoList
      },
      url: KT_ENV_JS['root_url'] + "/countries/ajax_country_name_from_iso/",
      dataType: 'json',
      async: false,
      success: function(data, textStatus) {
        countryList = data['country_list'];
      },
      error: function(xhr, textStatus, errorThrown) {
        countryList = isoList;
      }
    });

    return countryList;
  };

  /*
   *  Returns the country name or iso in an array
   *
   */
  KtFilter.prototype.generateLocationArrays = function(typestr) {
    var locationArray = [];

    //Copying current country list
    if (typestr === "countries") {
      this.$locationNameArray.each(function(i, locationName) {
        locationArray.push($.trim($(locationName).text()));
      });
    }
    //Copying current iso list
    else if (typestr === "isos") {
      this.$locationArray.each(function(i, locationIso) {
        locationArray.push($(locationIso).val());
      });
    }

    return locationArray;
  };

  // BEGIN: device list functions
  KtFilter.prototype.ajaxAddDeviceToSelectables = function(deviceStr) {
    var _this = this;

    ktAjaxWrapper({
      type: 'POST',
      traditional: true,
      data: {
        'device': deviceStr
      },
      url: KT_ENV_JS['root_url'] + "/devices/ajax_add_device_to_selectables/",
      dataType: 'json',
      success: function(data, textStatus) {
        var devices = $("input[name='device']").map(function() {
          return this.value;
        });
        var deviceNotInList = $.inArray(data.device, devices) < 0;

        if(data.device && deviceNotInList) {
          _this.addDeviceToDeviceList(deviceStr, data.device);
        } else {
          _this.$deviceInput.val("").blur();
        }
      },
      error: function(xhr, textStatus, errorThrown ) {
        _this.$deviceInput.val("").blur();
      }
    });
  };

  /*
   *  Adds a new device to the device list on the Filter UI
   *
   */
  KtFilter.prototype.addDeviceToDeviceList = function(deviceName, deviceValue) {
    var $deviceList = $('#device-list');

    $deviceList.append("<li><label><input filter_input='true' name='device' type='checkbox' value='" + deviceValue + "'/> " + deviceName + "</label><a href='#' class='remove-list del-icon'>del</a></li>");
    $deviceList.html(this.sortList($("#device-list li")));
    this.$deviceInput.val("").blur();
    this.$deviceList = $("input[name='device']");
    this.deviceArray = this.extractValue(this.$deviceList);
  };

  /*
   *  Removes a device from the devicelist on the Filter UI
   *
   */
  KtFilter.prototype.removeDeviceFromDeviceList = function($el) {
    $el.remove();
    this.$deviceList = $("input[name='device']");
    this.deviceArray = this.extractValue(this.$deviceList);
  }

  /*
   *  Adds a saved filter to the saved filter list
   *
   */
  KtFilter.prototype.addToSavedFiltersList = function(filterId, filterName, isChecked) {
    var filterName = $('<div></div>').text(filterName).html();
    var item;
    var checked = isChecked ? 'checked' : '';

    var htmlStr ='<li><label><input type="checkbox" class="saved_filters" ' + checked + ' value="' + filterId + '"/><a href="#" id="filter_link_' + filterId + '" data-filter-id="' + filterId  + '" class="saved-filter-name">' + filterName + '</a></label><a href="#" class="remove-list del-icon">del</a></li>';

    item = $(htmlStr);
    item.find("input").data('fname',filterName);
    $("#filter-list").prepend(item);
  };

  /*
   *  Called in the init method, this method made a call to the database
   *    to get all saved filters
   *
   */
  KtFilter.prototype.loadSavedFilters = function() {
    var _this = this;

    ktAjaxWrapper({
      type: 'POST',
      url: KT_ENV_JS['root_url'] + '/ajax_get_saved_filters/',
      data: {},
      dataType: 'json',
      traditional: true,
      success: function(data, textStatus) {
        if (data.filters.length > 0) {
          $("#filter-list-block > p").hide();
          $("#saved-filter, #apply-saved-filters").show();
          $.each(data.filters, function(i, data) {
            var f = data;
            if(f.checked)
              _this.addToSavedFiltersList(f.id, f.fname, true);
            else
              _this.addToSavedFiltersList(f.id, f.fname);
          });
        } else {
          $("#filter-list-block > p").show();
          $("#saved-filter, #apply-saved-filters").hide();
        }

        _this.savedFiltersReady = true;

        $(document).trigger('saved_filter_done');
      },
      error: function(request, textStatus, errorThrown) {
        _this.savedFiltersReady = true;
      }
    });
  };

  /*
   * Saves a new filter after hitting Save on Boxy confirmation
   *
   */
  KtFilter.prototype.saveFilter = function() {
    var _this = this;
    var filterName = $("#f_name").val();
    var arg = _this.constructArgArray("save_filter_input");
    arg['submit_type'] = 'save';
    arg['f_name'] = filterName;

    ktAjaxWrapper({
      type: "POST",
      url: KT_ENV_JS['root_url'] + "/ajax_handle_filter/",
      traditional: true,
      data: arg,
      success: function(data){
        // msg is simply an id for the filter object.
        if ($("#filter-list").children().length === 0) {
          $("#filter-list-block p").hide();
          $("#saved-filter, #apply-saved-filters").show();
        }
        _this.addToSavedFiltersList(data.filter_id, filterName);
      },
      error: function(data){
      }
    });

    return filterName;
  };

  /*
   *  Saves an update on an existing filter
   *
   */
  KtFilter.prototype.saveExistingFilter = function() {
    var filterName = $("#f_name").val();
    var arg = ktFilterHelper.constructArgArray("save_filter_input");

    arg['submit_type'] = 'edit';
    arg['f_name'] = filterName;

    ktAjaxWrapper({
      type: "POST",
      url: KT_ENV_JS['root_url'] + "/ajax_handle_filter/",
      traditional: true,
      data: arg,
      success: function(msg) {
        $("#filter_link_" + arg['f_id']).text(filterName);
        ktFilterHelper.applySavedFilters();
      }
    });

    return filterName;
  };

  /*
   *  Apply checked saved filters and (re)load charts
   *
   */
  KtFilter.prototype.reloadCharts = function(applySaved) {
    var savedFilters = this.getCheckedFilterInfo();
    var savedFilterNames = this.getCheckedFilterInfo('name');

    if (savedFilters.length > 0 && applySaved) {
      $(document).trigger({
        type: 'load_all_charts_multi',
        saved_filters: savedFilters,
        saved_filter_names: savedFilterNames
      });

      $(document).trigger('load_all_table_data');

    } else {
      $(document).trigger('load_all_chart');
      $(document).trigger('load_all_table_data');
    }
    this.recordCurrentFilters();
  };


  /*
   *  Apply checked saved filters and (re)load charts
   *
   */
  KtFilter.prototype.applySavedFilters = function() {
    var _this = this;
    var savedFilters = _this.getCheckedFilterInfo();

    if (savedFilters.length === 0) {
      ktAjaxWrapper({
        type: "POST",
        url: KT_ENV_JS['root_url'] + "/ajax_handle_filter/",
        data: {
          'submit_type': 'apply',
          'gender': ['A']
        },
        traditional: true,
        success: function() {
          _this.reloadCharts(false);
        }
      });
    } else {
      var arg = {
        f_ids: savedFilters.join(",")
      };

      ktAjaxWrapper({
        type: "POST",
        url: KT_ENV_JS['root_url'] + "/ajax_handle_saved_filters/",
        data: arg,
        traditional: true,
        success: function(msg) {
          _this.reloadCharts(true);
        }
      });
    }
  };

  /*
   *  Loads default charts/graphs without filter
   *
   */
  KtFilter.prototype._handleFilterHelper = function(commandStr, searchFilterStr, urlStr, successFunction) {
    var searchFilterStr = searchFilterStr || 'filter_input';
    var arg = this.constructArgArray(searchFilterStr);
    arg['submit_type'] = commandStr || '';

    ktAjaxWrapper({
      type: "POST",
      url : urlStr,
      data : arg,
      traditional: true,
      success : successFunction
    });
  }
  
  KtFilter.prototype.handleFilter = function(commandStr, searchFilterStr) {
    var _this = this;
    this._handleFilterHelper(commandStr, searchFilterStr, KT_ENV_JS['root_url'] + '/ajax_handle_filter/', function() { _this.reloadCharts(false); });
  };
  
  /*
   * Apply an extended filter, then the regular filters
   */
  KtFilter.prototype.handleExtendedFilter = function(commandStr, searchFilterStr, urlStr) {
    var _this = this;
    this._handleFilterHelper(commandStr, searchFilterStr, urlStr, function() { _this.handleFilter("apply"); });
  };

  /*
   *  Removes a saved filter from the database
   *
   */
  KtFilter.prototype.removeFilter = function(filterName, $el) {
    var _this = this;
    var arg = {};
    arg['remove_fids'] = filterName;

    ktAjaxWrapper({
      type: "POST",
      url: KT_ENV_JS['root_url'] + "/ajax_remove_filters/",
      traditional: true,
      data: arg,
      dataType: 'json',
      success: function(data) {
        // update the filter list.
        _this.removeFromSavedFilterList($el);
        if(data.num_filters === 0) {
          _this.handleFilter('apply');
        } else {
          _this.applySavedFilters();
        }
      }
    });
  };

  /*
   *  Removes a saved filter from the saved filter list on the Filter UI
   *
   */
  KtFilter.prototype.removeFromSavedFilterList = function($el) {
    $el.remove();

    if($("#filter-list").children().length === 0) {
      $("#filter-list-block > p").show();
      $("#saved-filter, #apply-saved-filters").hide();
    }
  };

  /*
   *  Return an array of data-fname or value for the checked filter(s)
   *    on the saved filter list
   *
   */
  KtFilter.prototype.getCheckedFilterInfo = function(type) {
    var $savedFilters = $('.saved_filters');
    var checkedFilters = [];

    $savedFilters.each(function(i, savedFilter) {
      if (savedFilter.checked) {
        if (type === 'name') {
          checkedFilters.push($(savedFilter).data('fname'));
        } else {
          checkedFilters.push(savedFilter.value);
        }
      }
    });

    return checkedFilters;
  };

  /*
   *  Initialize amchart if it's ready
   *
   */
  KtFilter.prototype.triggerInitializeAmchartEventIfReady = function() {
    var ready = true;

    for(var key in joinEventDict) {
      if(joinEventDict[key] === false) {
        ready = false;
        break;
      }
    }

    if(ready) {
      $(document).trigger('initialize_amchart');
    }
  };

  /*
   *  Gets a saved filter data to be edited
   *
   */
  KtFilter.prototype.editFilter = function(filterId) {
    var _this = this;
    ktAjaxWrapper({
      type: 'POST',
      data: {
        'f_id': filterId
      },
      url: KT_ENV_JS['root_url'] + "/ajax_get_filter_info/",
      traditional: true,
      dataType: 'json',
      success: function(data, textStatus) {
        _this.editFilterModal(data.filter);
      }
    });
    return false;
  };

  /*
   *  Generates the HTML for Boxy modal popup
   *
   */
  KtFilter.prototype.generateModalHtml = function(argArray) {
    /*
     * argArray looks like:
     * {	"age": ["0","50"],
     * 		"filter_name": "filters",
     * 		"friend_cnt": ["0","21"],
     * 		"gender": ["F"],
     * 		"location": ["US"]
     * }
     */

    var _this = this;
    var filterNameHtml = '<link href="' + KT_ENV_JS['media_url'] + '/css/save_filter_dialog.css" rel="stylesheet" type="text/css" media="all"/><form id="modal-form" method="post" action="#" onsubmit="return false"><table border="0" cellpadding="0" cellspacing="0"><tr><td colspan="6"></td></tr><tr><td colspan="2"><h4>Filter Name:</h4></td><td colspan="4"><input id="f_name" type="input" maxlength="32" name="f_name"';
    var ageArray = [0, 13, 18, 25, 30, 35, 40, 50, 65, -100];
    var ageStrArray = ['0-12', '13-17', '18-24', '25-29', '30-34', '35-39', '40-49', '50-64', '65+', 'unknown'];
    var friendCountArray = [0, 11, 21, 41, 61, 81, 126, 250, -1];
    var friendCountStrArray = ['1-10', '11-20', '21-40', '41-60', '61-80', '81-125', '126-250', '250+', 'unknown'];
    var genderArray = ['M', 'F', 'U', 'A'];
    var genderStrArray = ['Male', 'Female', 'Unknown', 'All'];
    var modalFormHtml;
    var isExistingFilter = _this.isDefined(argArray, 'fname');
    var modalLocationStrings = _this.generateLocationArrays("countries");
    var modalLocationIsos = _this.generateLocationArrays("isos");

    // Filter Name
    if (isExistingFilter) {
      var allIsosInList = [];
      var unlistedSavedCountries = [];
      var unlistedSavedIsos = [];

      modalFormHtml = filterNameHtml + ' value="' + argArray['fname'] + '"/></td></tr></table>';

      // Find out if there are countries in the saved filter that are not currently displayed in the location list
      $.each(_this.$locationArray, function(locationInputIndex, locationInput) {
        allIsosInList.push(locationInput.value);
      });

      if (argArray['location']) {
        $.each(argArray['location'], function(locationIsoIndex, locationIso) {
          if ($.inArray(locationIso, allIsosInList) === -1) {
            unlistedSavedIsos.push(locationIso);
          }
        });
      }

      // Concatenate unlisted countries to the modal lists
      if (unlistedSavedIsos.length > 0) {
        unlistedSavedCountries = _this.getCountryListFromIso(unlistedSavedIsos);
        modalLocationStrings.concat(unlistedSavedCountries);
        modalLocationIsos.concat(unlistedSavedIsos);
      }
    } else {
      modalFormHtml = filterNameHtml + '/></td></tr></table>';
    }

    // Filter Id
    if (argArray['f_id']) {
      modalFormHtml += '<input save_filter_input="true" name="f_id" type="hidden" value="' + argArray['f_id'] + '"/>';
    }

    // Define which filers to display
    var filtersToDisplay;
    if ($('#demo-filter').length > 0 ) {
      filtersToDisplay = [
        {
          'name': 'age',
          'text_array': ageStrArray,
          'value_array': ageArray,
          'title': 'Age'
        },
        {
          'name': 'gender',
          'text_array': genderStrArray,
          'value_array': genderArray,
          'title': 'Gender'
        },
        {
          'name': 'friend_cnt',
          'text_array': friendCountStrArray,
          'value_array': friendCountArray,
          'title': 'Number of Friends'
        },
        {
          'name': 'location',
          'text_array': modalLocationStrings,
          'value_array': modalLocationIsos,
          'title': 'Locations'
        }
      ];
    } else {
      filtersToDisplay = [
        {	'title': 'Devices',
          'name': 'device',
          'text_array': _this.deviceArray,
          'value_array': _this.deviceArray
        },
        {	'title': 'App Versions',
          'name': 'app_version',
          'text_array': _this.appValueArray,
          'value_array': _this.appValueArray
        },
        {	'title': 'OS Versions',
          'name': 'os_version',
          'text_array': _this.osValueArray,
          'value_array': _this.osValueArray
        },
        {	'title': 'Locations',
          'name': 'location',
          'text_array': modalLocationStrings,
          'value_array': modalLocationIsos
        }
      ];
    }

    // Populate the lists
    $.each(filtersToDisplay, function(filterIndex, filterData) {
      var title = filterData['title'];
      var type = filterData['name'];
      var text = filterData['text_array'];
      var values = filterData['value_array'];
      var inputType = type === 'gender' ? "radio" : "checkbox";

      if (text.length > 0) {
        modalFormHtml += '<div class="modal-filter-type kt-left"><h5>' + title + ':</h5>';
        modalFormHtml += _this.generateModalHtmlList(text, values, argArray[type], type, inputType);
        modalFormHtml += '</div>';
      }
    });

    modalFormHtml += "</form>";

    return modalFormHtml;
  };

  /*
   *  Generates the HTML for selected filters on the Boxy modal popup
   *
   */
  KtFilter.prototype.generateModalHtmlList = function(textArray, valueArray, appliedFilters, filterType, inputType) {
    var listHtml = '<ul>';

    $.each(valueArray, function(i, value) {
      var text = textArray[i];
      var inputId = filterType + '_' + value + '_input';
      var inFiltersToApply = appliedFilters? $.inArray(value.toString(), appliedFilters) : -1;
      var checkedText = inFiltersToApply > -1 ? "checked" : "";

      listHtml += '<li><label><input save_filter_input="true" alt="' + text + '" name="' + filterType + '" id="' + inputId + '" type="' + inputType + '" value="' + value + '" ' + checkedText + '/>' + text + '</label></li>';
    });

    listHtml += '</ul>';

    return listHtml;
  };

  /*
   *  Handler to trigger a Boxy modal popup to save a new filter
   *
   */
  KtFilter.prototype.saveFilterModal = function() {
    var argArray = this.constructArgArray("filter_input");
    var formHtml = this.generateModalHtml(argArray);

    BoxyConfirm(formHtml, this.modalSaveNewFilter, {
      title: "Save Filter",
      draggable: true,
      fixed: true,
      afterShow: function() {
        $('#f_name').focus();
      }
    });
  };

  /*
   *  Handler to trigger a Boxy modal popup to edit a new filter
   *
   */
  KtFilter.prototype.editFilterModal = function(jsonObject) {
    var formHtml = this.generateModalHtml(jsonObject);
    Boxy.confirm(formHtml, this.saveExistingFilter, {
      title: "Edit Filter",
      draggable: true,
      fixed: true,
      afterShow: function() {
        $('#f_name').focus();
      }
    });
  };

  /*
   *  Checks to see if a filter name has been provided when saving a filter
   *
   */
  KtFilter.prototype.modalSanityCheck = function() {
    var filterName = $("#f_name").prop("value");
    var hasFilterName = filterName.length > 0;

    return hasFilterName;
  };

  /*
   *  Handler to save a new filter
   *
   */
  KtFilter.prototype.modalSaveNewFilter = function() {
    if (ktFilterHelper.modalSanityCheck()) {
      var filter_name = ktFilterHelper.saveFilter();
      return false;
    } else {
      Boxy.alert("You must provide a filter name.");
      return false;
    }
  };

  return function() {
    return new KtFilter();
  }
})();
